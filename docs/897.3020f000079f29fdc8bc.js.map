{"version":3,"file":"897.3020f000079f29fdc8bc.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAsC;AAC/B;AACP,WAAW,4BAAQ;AACnB;AACA;;;;;;ACJmD;AACP;AACd;AACvB;AACP;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA,WAAW,SAAS,GAAG,oBAAI,OAAO,kCAAY;AAC9C;AACA;;;;;ACViD;AAC2B;AACa;AAC1C;AACV;AACQ;AACH;AAC1C,2BAA2B,+BAAc;AACzC,eAAe,oGAAe;AAC9B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,gDAAgD,gCAAiB;AACjE;AACA,oCAAoC,sBAAO;AAC3C;AACA,4BAA4B,gCAAiB;AAC7C;AACA,wBAAwB,uCAAoB;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA,4BAA4B,gCAAiB;AAC7C;AACA,wBAAwB,uCAAoB;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,2BAA2B,yBAAS;AAC3C;AACA;AACA;AACA,2BAA2B,uCAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM,CAAC,oBAAI,2BAA2B,4BAAQ,cAAc,oBAAI;AAC/E;AACA;AACA,yBAAyB,uCAAoB;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,wBAAwB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAG,eAAe,QAAQ;AAC1C,mEAAmE,kCAAkC;AACrG,kCAAkC,MAAM;AACxC,gBAAgB,mBAAG,eAAe,UAAU;AAC5C;AACA;AACA;AACA;AACA;AACA,8BAA8B,+CAAiC;AAC/D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AAC8B;AACA;AAC9B","sources":["webpack://mytonwallet/./node_modules/rxjs/dist/esm5/internal/operators/concatAll.js","webpack://mytonwallet/./node_modules/rxjs/dist/esm5/internal/observable/concat.js","webpack://mytonwallet/./node_modules/@mytonwallet/capacitor-usb-hid/dist/esm/index.js"],"sourcesContent":["import { mergeAll } from './mergeAll';\nexport function concatAll() {\n    return mergeAll(1);\n}\n//# sourceMappingURL=concatAll.js.map","import { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\nexport function concat() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return concatAll()(from(args, popScheduler(args)));\n}\n//# sourceMappingURL=concat.js.map","import { registerPlugin } from '@capacitor/core';\nimport { identifyUSBProductId, ledgerUSBVendorId } from '@ledgerhq/devices';\nimport { DisconnectedDevice, DisconnectedDeviceDuringOperation } from '@ledgerhq/errors';\nimport Transport from '@ledgerhq/hw-transport';\nimport { log } from '@ledgerhq/logs';\nimport { concat, from, Subject } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nconst CapacitorUSBPlugin = registerPlugin('CapacitorUSBPlugin', {\n    web: () => import('./web').then(m => new m.CapacitorUSBPluginWeb()),\n});\nconst disconnectedErrors = [\n    'I/O error',\n    \"Attempt to invoke virtual method 'int android.hardware.usb.UsbDevice.getDeviceClass()' on a null object reference\",\n    'Invalid channel',\n    'Permission denied by user for device',\n];\nexport async function listLedgerDevices() {\n    const devices = (await CapacitorUSBPlugin.getDeviceList()).devices;\n    return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\nconst liveDeviceEventsSubject = new Subject();\nCapacitorUSBPlugin.addListener('onDeviceConnect', (device) => {\n    if (device.vendorId !== ledgerUSBVendorId)\n        return;\n    const deviceModel = identifyUSBProductId(device.productId);\n    liveDeviceEventsSubject.next({\n        type: 'add',\n        descriptor: device,\n        deviceModel,\n    });\n});\nCapacitorUSBPlugin.addListener('onDeviceDisconnect', (device) => {\n    if (device.vendorId !== ledgerUSBVendorId)\n        return;\n    const deviceModel = identifyUSBProductId(device.productId);\n    liveDeviceEventsSubject.next({\n        type: 'remove',\n        descriptor: device,\n        deviceModel,\n    });\n});\nconst liveDeviceEvents = liveDeviceEventsSubject;\n/**\n * Ledger's React Native HID Transport implementation\n * @example\n * import TransportHID from \"@ledgerhq/react-native-hid\";\n * ...\n * TransportHID.create().then(transport => ...)\n */\nexport class HIDTransport extends Transport {\n    constructor(deviceId, productId) {\n        super();\n        this.deviceId = deviceId;\n        this.deviceModel = identifyUSBProductId(productId);\n    }\n    /**\n     * List currently connected devices.\n     * @returns Promise of devices\n     */\n    static async list() {\n        if (!this.isSupported)\n            return Promise.resolve([]);\n        return listLedgerDevices();\n    }\n    /**\n     * Listen to ledger devices events\n     */\n    static listen(observer) {\n        if (!this.isSupported) {\n            return {};\n        }\n        return concat(from(listLedgerDevices()).pipe(mergeMap((devices) => from(devices.map((device) => ({\n            type: 'add',\n            descriptor: device,\n            deviceModel: identifyUSBProductId(device.productId),\n        }))))), liveDeviceEvents).subscribe(observer);\n    }\n    /**\n     * Open a the transport with a Ledger device\n     */\n    static async open(deviceObj) {\n        try {\n            const result = await CapacitorUSBPlugin.openDevice({ deviceId: deviceObj.id });\n            if (result.success) {\n                return new HIDTransport(deviceObj.id, deviceObj.productId);\n            }\n            else {\n                throw new Error();\n            }\n        }\n        catch (error) {\n            if (disconnectedErrors.includes(error.message)) {\n                throw new DisconnectedDevice(error.message);\n            }\n            throw error;\n        }\n    }\n    /**\n     * @param {*} apdu input value\n     * @returns Promise of apdu response\n     */\n    async exchange(apdu) {\n        return this.exchangeAtomicImpl(async () => {\n            try {\n                const apduHex = apdu.toString('hex');\n                log('apdu', `=> ${apduHex}`);\n                const result = await CapacitorUSBPlugin.exchange({ deviceId: this.deviceId, apduHex });\n                const resultHex = Buffer.from(result.response, 'hex');\n                log('apdu', `<= ${resultHex}`);\n                return resultHex;\n            }\n            catch (error) {\n                if (disconnectedErrors.includes(error.message)) {\n                    this.emit('disconnect', error);\n                    throw new DisconnectedDeviceDuringOperation(error.message);\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Close the transport\n     * @returns Promise\n     */\n    async close() {\n        await this.exchangeBusyPromise;\n        void CapacitorUSBPlugin.closeDevice({ deviceId: this.deviceId });\n    }\n}\n/**\n * Check if the transport is supported (basically true on Android)\n */\nHIDTransport.isSupported = () => Promise.resolve(true);\nexport * from './definitions';\nexport { CapacitorUSBPlugin };\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}