/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 51:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gi: () => (/* binding */ BarcodeFormat),
/* harmony export */   Nn: () => (/* binding */ LensFacing),
/* harmony export */   gH: () => (/* binding */ BarcodeValueType)
/* harmony export */ });
/* unused harmony exports Resolution, GoogleBarcodeScannerModuleInstallState, AddressType, EmailFormatType, PhoneFormatType, WifiEncryptionType */
/**
 * @since 0.0.1
 */
var BarcodeFormat;
(function (BarcodeFormat) {
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Aztec"] = "AZTEC";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Codabar"] = "CODABAR";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Code39"] = "CODE_39";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Code93"] = "CODE_93";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Code128"] = "CODE_128";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["DataMatrix"] = "DATA_MATRIX";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Ean8"] = "EAN_8";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Ean13"] = "EAN_13";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Itf"] = "ITF";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["Pdf417"] = "PDF_417";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["QrCode"] = "QR_CODE";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["UpcA"] = "UPC_A";
    /**
     * Only available on Android and iOS.
     *
     * @since 0.0.1
     */
    BarcodeFormat["UpcE"] = "UPC_E";
})(BarcodeFormat || (BarcodeFormat = {}));
/**
 * @since 0.0.1
 */
var BarcodeValueType;
(function (BarcodeValueType) {
    /**
     * @since 0.0.1
     */
    BarcodeValueType["CalendarEvent"] = "CALENDAR_EVENT";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["ContactInfo"] = "CONTACT_INFO";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["DriversLicense"] = "DRIVERS_LICENSE";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Email"] = "EMAIL";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Geo"] = "GEO";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Isbn"] = "ISBN";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Phone"] = "PHONE";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Product"] = "PRODUCT";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Sms"] = "SMS";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Text"] = "TEXT";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Url"] = "URL";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Wifi"] = "WIFI";
    /**
     * @since 0.0.1
     */
    BarcodeValueType["Unknown"] = "UNKNOWN";
})(BarcodeValueType || (BarcodeValueType = {}));
/**
 * @since 7.0.0
 */
var Resolution;
(function (Resolution) {
    /**
     * @since 7.0.0
     */
    Resolution[Resolution["640x480"] = 0] = "640x480";
    /**
     * @since 7.0.0
     */
    Resolution[Resolution["1280x720"] = 1] = "1280x720";
    /**
     * @since 7.0.0
     */
    Resolution[Resolution["1920x1080"] = 2] = "1920x1080";
    /**
     * @since 7.2.0
     */
    Resolution[Resolution["3840x2160"] = 3] = "3840x2160";
})(Resolution || (Resolution = {}));
/**
 * @since 0.0.1
 */
var LensFacing;
(function (LensFacing) {
    /**
     * @since 0.0.1
     */
    LensFacing["Front"] = "FRONT";
    /**
     * @since 0.0.1
     */
    LensFacing["Back"] = "BACK";
})(LensFacing || (LensFacing = {}));
/**
 * @since 5.1.0
 */
var GoogleBarcodeScannerModuleInstallState;
(function (GoogleBarcodeScannerModuleInstallState) {
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["PENDING"] = 1] = "PENDING";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["DOWNLOADING"] = 2] = "DOWNLOADING";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["CANCELED"] = 3] = "CANCELED";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["COMPLETED"] = 4] = "COMPLETED";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["FAILED"] = 5] = "FAILED";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["INSTALLING"] = 6] = "INSTALLING";
    /**
     * @since 5.1.0
     */
    GoogleBarcodeScannerModuleInstallState[GoogleBarcodeScannerModuleInstallState["DOWNLOAD_PAUSED"] = 7] = "DOWNLOAD_PAUSED";
})(GoogleBarcodeScannerModuleInstallState || (GoogleBarcodeScannerModuleInstallState = {}));
/**
 * @since 7.0.0
 */
var AddressType;
(function (AddressType) {
    /**
     * @since 7.0.0
     */
    AddressType[AddressType["HOME"] = 0] = "HOME";
    /**
     * @since 7.0.0
     */
    AddressType[AddressType["UNKNOWN"] = 1] = "UNKNOWN";
    /**
     * @since 7.0.0
     */
    AddressType[AddressType["WORK"] = 2] = "WORK";
})(AddressType || (AddressType = {}));
/**
 * @since 7.0.0
 */
var EmailFormatType;
(function (EmailFormatType) {
    /**
     * @since 7.0.0
     */
    EmailFormatType[EmailFormatType["HOME"] = 0] = "HOME";
    /**
     * @since 7.0.0
     */
    EmailFormatType[EmailFormatType["UNKNOWN"] = 1] = "UNKNOWN";
    /**
     * @since 7.0.0
     */
    EmailFormatType[EmailFormatType["WORK"] = 2] = "WORK";
})(EmailFormatType || (EmailFormatType = {}));
/**
 * @since 7.0.0
 */
var PhoneFormatType;
(function (PhoneFormatType) {
    /**
     * @since 7.0.0
     */
    PhoneFormatType[PhoneFormatType["FAX"] = 0] = "FAX";
    /**
     * @since 7.0.0
     */
    PhoneFormatType[PhoneFormatType["HOME"] = 1] = "HOME";
    /**
     * @since 7.0.0
     */
    PhoneFormatType[PhoneFormatType["MOBILE"] = 2] = "MOBILE";
    /**
     * @since 7.0.0
     */
    PhoneFormatType[PhoneFormatType["UNKNOWN"] = 3] = "UNKNOWN";
    /**
     * @since 7.0.0
     */
    PhoneFormatType[PhoneFormatType["WORK"] = 4] = "WORK";
})(PhoneFormatType || (PhoneFormatType = {}));
/**
 * @since 7.0.0
 */
var WifiEncryptionType;
(function (WifiEncryptionType) {
    /**
     * @since 7.0.0
     */
    WifiEncryptionType[WifiEncryptionType["OPEN"] = 1] = "OPEN";
    /**
     * @since 7.0.0
     */
    WifiEncryptionType[WifiEncryptionType["WEP"] = 2] = "WEP";
    /**
     * @since 7.0.0
     */
    WifiEncryptionType[WifiEncryptionType["WPA"] = 3] = "WPA";
})(WifiEncryptionType || (WifiEncryptionType = {}));
//# sourceMappingURL=definitions.js.map

/***/ }),

/***/ 251:
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ 398:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CF: () => (/* binding */ toBig),
/* harmony export */   QQ: () => (/* binding */ roundDecimal),
/* harmony export */   UH: () => (/* binding */ fromDecimal),
/* harmony export */   nI: () => (/* binding */ toDecimal)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31481);
/* harmony import */ var _lib_big_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48805);


_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z.RM = 0; // RoundDown
_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z.NE = -100000; // Disable exponential form
_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z.PE = 100000; // Disable exponential form

const ten = (0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z)(10);
function fromDecimal(value, decimals) {
  return BigInt((0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z)(value).mul(ten.pow(decimals ?? _config__WEBPACK_IMPORTED_MODULE_0__/* .TONCOIN */ .Tu9.decimals)).round().toString());
}
function toDecimal(value, decimals) {
  let noFloor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return toBig(value, decimals ?? _config__WEBPACK_IMPORTED_MODULE_0__/* .TONCOIN */ .Tu9.decimals, noFloor).toString();
}
function toBig(value) {
  let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _config__WEBPACK_IMPORTED_MODULE_0__/* .TONCOIN */ .Tu9.decimals;
  let noFloor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return (0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z)(value.toString()).div(ten.pow(decimals)).round(decimals, noFloor ? _lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z.roundHalfUp : undefined);
}
function roundDecimal(value, decimals) {
  return (0,_lib_big_js__WEBPACK_IMPORTED_MODULE_1__/* .Big */ .z)(value).round(decimals).toString();
}

/***/ }),

/***/ 809:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UA: () => (/* binding */ bigintMin),
/* harmony export */   _O: () => (/* binding */ bigintMax),
/* harmony export */   bk: () => (/* binding */ bigintReviver),
/* harmony export */   fC: () => (/* binding */ bigintDivideToNumber),
/* harmony export */   m1: () => (/* binding */ bigintMultiplyToNumber),
/* harmony export */   tH: () => (/* binding */ BIGINT_PREFIX),
/* harmony export */   wg: () => (/* binding */ bigintAbs)
/* harmony export */ });
/* unused harmony exports bigintSum, bigintRandom, bigintCountBits, bigintMultiplePercent */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31481);
/* harmony import */ var _decimals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(398);
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(59121);



const BIGINT_PREFIX = 'bigint:';
function bigintReviver(key, value) {
  if (typeof value === 'string' && value.startsWith(BIGINT_PREFIX)) {
    return BigInt(value.slice(7));
  }
  return value;
}
function bigintAbs(value) {
  return value === -0n || value < 0n ? -value : value;
}
function bigintSum(values) {
  let result = 0n;
  for (const value of values) result += value;
  return result;
}
function bigintDivideToNumber(value, num) {
  return value * _config__WEBPACK_IMPORTED_MODULE_0__/* .ONE_TON */ .X1K / (0,_decimals__WEBPACK_IMPORTED_MODULE_1__/* .fromDecimal */ .UH)(num);
}
function bigintMultiplyToNumber(value, num) {
  return value * (0,_decimals__WEBPACK_IMPORTED_MODULE_1__/* .fromDecimal */ .UH)(num) / _config__WEBPACK_IMPORTED_MODULE_0__/* .ONE_TON */ .X1K;
}
function bigintRandom(bytes) {
  let value = BigInt(0);
  for (const randomNumber of randomBytes(bytes)) {
    const randomBigInt = BigInt(randomNumber);
    value = (value << BigInt(8)) + randomBigInt;
  }
  return value;
}
function bigintCountBits(value) {
  const binaryString = value.toString(2);
  return binaryString.length;
}
function bigintMax(value0, value1) {
  return value0 > value1 ? value0 : value1;
}
function bigintMin(value0, value1) {
  return value0 < value1 ? value0 : value1;
}
function bigintMultiplePercent(value, percent) {
  return value * fromDecimal(percent / 100) / ONE_TON;
}

/***/ }),

/***/ 3476:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bm: () => (/* binding */ W5_MAX_MESSAGES),
/* harmony export */   EV: () => (/* binding */ DEFAULT_MAX_MESSAGES),
/* harmony export */   Zm: () => (/* binding */ WORKCHAIN),
/* harmony export */   eL: () => (/* binding */ WALLET_IS_BOUNCEABLE),
/* harmony export */   fI: () => (/* binding */ DEFAULT_DECIMALS),
/* harmony export */   fv: () => (/* binding */ TON_GAS_REAL),
/* harmony export */   li: () => (/* binding */ Workchain),
/* harmony export */   qP: () => (/* binding */ LEDGER_MAX_MESSAGES),
/* harmony export */   sl: () => (/* binding */ TON_GAS)
/* harmony export */ });
/* unused harmony exports TON_BIP39_PATH, ONE_TON, TOKEN_TRANSFER_AMOUNT, TINY_TOKEN_TRANSFER_AMOUNT, TOKEN_TRANSFER_REAL_AMOUNT, TINY_TOKEN_TRANSFER_REAL_AMOUNT, TINIEST_TOKEN_TRANSFER_REAL_AMOUNT, TOKEN_TRANSFER_FORWARD_AMOUNT, CLAIM_MINTLESS_AMOUNT, NFT_TRANSFER_AMOUNT, NFT_TRANSFER_REAL_AMOUNT, NFT_TRANSFER_FORWARD_AMOUNT, NFT_PAYLOAD_SAFE_MARGIN, STAKE_COMMENT, UNSTAKE_COMMENT, ATTEMPTS, DEFAULT_IS_BOUNCEABLE, FEE_FACTOR, ALL_WALLET_VERSIONS, OUR_FEE_PAYLOAD_BOC, RAW_ADDRESS_LENGTH, TRANSFER_TIMEOUT_SEC, LEDGER_VESTING_SUBWALLET_ID, OpCode, JettonOpCode, NftOpCode, LiquidStakingOpCode, JettonStakingOpCode, VestingV1OpCode, SingleNominatorOpCode, DnsOpCode, TeleitemOpCode, OtherOpCode, ContractType, DnsCategory, EXCESS_OP_CODES, DNS_CATEGORY_HASH_MAP, KnownContracts */
/* harmony import */ var _contracts_JettonStaking_imports_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61995);

const TON_BIP39_PATH = 'm/44\'/607\'/0\'';
const ONE_TON = 1_000_000_000n;
const TOKEN_TRANSFER_AMOUNT = 2000000000n; // 0.05 TON
const TINY_TOKEN_TRANSFER_AMOUNT = 18000000n; // 0.018 TON
const TOKEN_TRANSFER_REAL_AMOUNT = 32100000n; // 0.0321 TON
const TINY_TOKEN_TRANSFER_REAL_AMOUNT = 8000000n; // 0.008 TON
const TINIEST_TOKEN_TRANSFER_REAL_AMOUNT = 3000000n; // 0.003 TON
const TOKEN_TRANSFER_FORWARD_AMOUNT = 1n; // 0.000000001 TON
const CLAIM_MINTLESS_AMOUNT = 20000000n; // 0.02 TON

/** The amount that MyTonWallet attaches to NFT transfers */
const NFT_TRANSFER_AMOUNT = 100000000n; // 0.1 TON
const NFT_TRANSFER_REAL_AMOUNT = 5000000n; // 0.005 TON
const NFT_TRANSFER_FORWARD_AMOUNT = 1n; // 0.000000001 TON
/**
 * When the NFT contract handles the payload we send, it simply adds its data to the payload. If the resulting payload
 * size becomes greater than the cell capacity, the contract fails to send the NFT. To avoid that, we keep some free
 * space in the payload cell we send. This constant is the size of the free space in bits.
 */
const NFT_PAYLOAD_SAFE_MARGIN = (/* unused pure expression or super */ null && (14 * 8));
const TON_GAS = {
  stakeNominators: ONE_TON,
  unstakeNominators: ONE_TON,
  stakeLiquid: ONE_TON,
  unstakeLiquid: ONE_TON,
  stakeJettonsForward: _contracts_JettonStaking_imports_constants__WEBPACK_IMPORTED_MODULE_0__/* .JettonStakingGas */ .xT.STAKE_JETTONS,
  stakeJettons: _contracts_JettonStaking_imports_constants__WEBPACK_IMPORTED_MODULE_0__/* .JettonStakingGas */ .xT.STAKE_JETTONS + TOKEN_TRANSFER_AMOUNT,
  unstakeJettons: _contracts_JettonStaking_imports_constants__WEBPACK_IMPORTED_MODULE_0__/* .JettonStakingGas */ .xT.UNSTAKE_JETTONS,
  claimJettons: _contracts_JettonStaking_imports_constants__WEBPACK_IMPORTED_MODULE_0__/* .JettonStakingGas */ .xT.JETTON_TRANSFER + _contracts_JettonStaking_imports_constants__WEBPACK_IMPORTED_MODULE_0__/* .JettonStakingGas */ .xT.SIMPLE_UPDATE_REQUEST,
  changeDns: 15_000_000n,
  // 0.015 TON
  stakeEthena: TOKEN_TRANSFER_AMOUNT + 100_000_000n,
  // 0.15 TON
  stakeEthenaForward: 100_000_000n,
  // 0.1 TON
  unstakeEthena: TOKEN_TRANSFER_AMOUNT + 100_000_000n,
  // 0.15 TON
  unstakeEthenaForward: 100_000_000n,
  // 0.1 TON
  unstakeEthenaLocked: 150_000_000n,
  // 0.15 TON
  unstakeEthenaLockedForward: 70_000_000n // 0.07 TON
};
const TON_GAS_REAL = {
  stakeNominators: 1_000_052_853n,
  unstakeNominators: 148_337_433n,
  stakeLiquid: 20_251_387n,
  unstakeLiquid: 18_625_604n,
  stakeJettons: 74_879_996n,
  unstakeJettons: 59_971_662n,
  claimJettons: 57_053_859n,
  stakeEthena: 116_690_790n,
  unstakeEthena: 113_210_330n,
  unstakeEthenaLocked: 37_612_000n
};
const STAKE_COMMENT = 'd';
const UNSTAKE_COMMENT = 'w';
const ATTEMPTS = 5;
const DEFAULT_DECIMALS = 9;
const DEFAULT_IS_BOUNCEABLE = true;
const WALLET_IS_BOUNCEABLE = false;

// Fee may change, so we add 5% for more reliability. This is only safe for low-fee blockchains such as TON.
const FEE_FACTOR = 1.05;
const ALL_WALLET_VERSIONS = (/* unused pure expression or super */ null && (['simpleR1', 'simpleR2', 'simpleR3', 'v2R1', 'v2R2', 'v3R1', 'v3R2', 'v4R2', 'W5']));
const OUR_FEE_PAYLOAD_BOC = 'te6cckEBAQEABgAACE0jhUPUcYAL';
const RAW_ADDRESS_LENGTH = 66;
let Workchain = /*#__PURE__*/function (Workchain) {
  Workchain[Workchain["MasterChain"] = -1] = "MasterChain";
  Workchain[Workchain["BaseChain"] = 0] = "BaseChain";
  return Workchain;
}({});
const WORKCHAIN = Workchain.BaseChain;
const TRANSFER_TIMEOUT_SEC = 600; // 10 min.

const DEFAULT_MAX_MESSAGES = 4;
const LEDGER_MAX_MESSAGES = 1;
const W5_MAX_MESSAGES = 255;
const LEDGER_VESTING_SUBWALLET_ID = 0x10C;
let OpCode = /*#__PURE__*/function (OpCode) {
  OpCode[OpCode["Comment"] = 0] = "Comment";
  OpCode[OpCode["Encrypted"] = 560454219] = "Encrypted";
  OpCode[OpCode["OurFee"] = 1294173507] = "OurFee";
  OpCode[OpCode["Bounced"] = 4294967295] = "Bounced";
  return OpCode;
}({});
let JettonOpCode = /*#__PURE__*/function (JettonOpCode) {
  JettonOpCode[JettonOpCode["Transfer"] = 260734629] = "Transfer";
  JettonOpCode[JettonOpCode["TransferNotification"] = 1935855772] = "TransferNotification";
  JettonOpCode[JettonOpCode["InternalTransfer"] = 395134233] = "InternalTransfer";
  JettonOpCode[JettonOpCode["Excesses"] = 3576854235] = "Excesses";
  JettonOpCode[JettonOpCode["Burn"] = 1499400124] = "Burn";
  JettonOpCode[JettonOpCode["BurnNotification"] = 2078119902] = "BurnNotification";
  return JettonOpCode;
}({});
let NftOpCode = /*#__PURE__*/function (NftOpCode) {
  NftOpCode[NftOpCode["TransferOwnership"] = 1607220500] = "TransferOwnership";
  NftOpCode[NftOpCode["OwnershipAssigned"] = 85167505] = "OwnershipAssigned";
  NftOpCode[NftOpCode["Excesses"] = 3576854235] = "Excesses";
  return NftOpCode;
}({});
let LiquidStakingOpCode = /*#__PURE__*/function (LiquidStakingOpCode) {
  // Pool
  LiquidStakingOpCode[LiquidStakingOpCode["RequestLoan"] = 3863136613] = "RequestLoan";
  LiquidStakingOpCode[LiquidStakingOpCode["LoanRepayment"] = 3755778683] = "LoanRepayment";
  LiquidStakingOpCode[LiquidStakingOpCode["Deposit"] = 1205158801] = "Deposit";
  LiquidStakingOpCode[LiquidStakingOpCode["Withdraw"] = 832244956] = "Withdraw";
  LiquidStakingOpCode[LiquidStakingOpCode["Withdrawal"] = 175592284] = "Withdrawal";
  LiquidStakingOpCode[LiquidStakingOpCode["DeployController"] = 2994658477] = "DeployController";
  LiquidStakingOpCode[LiquidStakingOpCode["Touch"] = 1271382751] = "Touch";
  LiquidStakingOpCode[LiquidStakingOpCode["Donate"] = 1940913697] = "Donate";
  // NFT
  LiquidStakingOpCode[LiquidStakingOpCode["DistributedAsset"] = 3678112445] = "DistributedAsset";
  // Jetton
  LiquidStakingOpCode[LiquidStakingOpCode["Vote"] = 1778069612] = "Vote";
  return LiquidStakingOpCode;
}({});
let JettonStakingOpCode = /*#__PURE__*/function (JettonStakingOpCode) {
  JettonStakingOpCode[JettonStakingOpCode["UnstakeRequest"] = 1234866786] = "UnstakeRequest";
  JettonStakingOpCode[JettonStakingOpCode["ClaimRewards"] = 2027548937] = "ClaimRewards";
  return JettonStakingOpCode;
}({});
let VestingV1OpCode = /*#__PURE__*/function (VestingV1OpCode) {
  VestingV1OpCode[VestingV1OpCode["AddWhitelist"] = 1918412443] = "AddWhitelist";
  return VestingV1OpCode;
}({});
let SingleNominatorOpCode = /*#__PURE__*/function (SingleNominatorOpCode) {
  SingleNominatorOpCode[SingleNominatorOpCode["Withdraw"] = 4096] = "Withdraw";
  SingleNominatorOpCode[SingleNominatorOpCode["ChangeValidator"] = 4097] = "ChangeValidator";
  return SingleNominatorOpCode;
}({});
let DnsOpCode = /*#__PURE__*/function (DnsOpCode) {
  DnsOpCode[DnsOpCode["ChangeRecord"] = 1320284409] = "ChangeRecord";
  return DnsOpCode;
}({});
let TeleitemOpCode = /*#__PURE__*/function (TeleitemOpCode) {
  TeleitemOpCode[TeleitemOpCode["Ok"] = 2742684035] = "Ok";
  return TeleitemOpCode;
}({});
let OtherOpCode = /*#__PURE__*/function (OtherOpCode) {
  OtherOpCode[OtherOpCode["TokenBridgePaySwap"] = 8] = "TokenBridgePaySwap";
  return OtherOpCode;
}({});
let ContractType = /*#__PURE__*/function (ContractType) {
  ContractType["Wallet"] = "wallet";
  ContractType["Staking"] = "staking";
  return ContractType;
}({});
let DnsCategory = /*#__PURE__*/function (DnsCategory) {
  DnsCategory["DnsNextResolver"] = "dns_next_resolver";
  DnsCategory["Wallet"] = "wallet";
  DnsCategory["Site"] = "site";
  DnsCategory["BagId"] = "storage";
  DnsCategory["Unknown"] = "unknown";
  return DnsCategory;
}({});
const EXCESS_OP_CODES = [JettonOpCode.Excesses, TeleitemOpCode.Ok];
const DNS_CATEGORY_HASH_MAP = {
  dns_next_resolver: '19f02441ee588fdb26ee24b2568dd035c3c9206e11ab979be62e55558a1d17ff',
  wallet: 'e8d44050873dba865aa7c170ab4cce64d90839a34dcfd6cf71d14e0205443b1b',
  site: 'fbae041b02c41ed0fd8a4efb039bc780dd6af4a1f0c420f42561ae705dda43fe',
  storage: '49a25f9feefaffecad0fcd30c50dc9331cff8b55ece53def6285c09e17e6f5d7'
};
const KnownContracts = {
  simpleR1: {
    name: 'simpleR1',
    hash: '3232dc55b02b3d2a9485adc151cf29c50b94c374d3571cb59390d761b87af8bd',
    type: ContractType.Wallet
  },
  simpleR2: {
    name: 'simpleR2',
    hash: '672ce2b01d2fd487a5e0528611e7e4fc11867148cc13ff772bd773b72fb368df',
    type: ContractType.Wallet
  },
  simpleR3: {
    name: 'simpleR3',
    hash: 'd95417233f66ae218317f533630cbbddc677d6d893d5722be6947c8fad8e9d52',
    type: ContractType.Wallet
  },
  v2R1: {
    name: 'v2R1',
    hash: 'fb3bd539b7e50166f1cfdc0bbd298b1c88f6b261fe5ee61343ea47ab4b256029',
    type: ContractType.Wallet
  },
  v2R2: {
    name: 'v2R2',
    hash: 'b584b6106753b7f34709df505be603e463a44ff6a85adf7fec4e26453c325983',
    type: ContractType.Wallet
  },
  v3R1: {
    name: 'v3R1',
    hash: '11d123ed5c2055128e75a9ef4cf1e837e6d14a9c079c39939885c78dc13626e6',
    type: ContractType.Wallet
  },
  v3R2: {
    name: 'v3R2',
    hash: 'df7bf014ee7ac0c38da19ef1b7fa054e2cc7a4513df1f1aa295109cf3606ac14',
    type: ContractType.Wallet
  },
  v4R1: {
    name: 'v4R1',
    hash: '1bc0dfa40956c911616f8a5db09ecc217601bae48d7d3f9311562c5afcb66dcf',
    type: ContractType.Wallet
  },
  v4R2: {
    name: 'v4R2',
    hash: '5659ce2300f4a09a37b0bdee41246ded52474f032c1d6ffce0d7d31b18b7b2b1',
    type: ContractType.Wallet
  },
  W5: {
    name: 'W5',
    hash: '7e94eaaeaaa423b9396e79747038c42edc4fe98dce65094071f0e0ad2df22fd5',
    type: ContractType.Wallet
  },
  highloadV2: {
    name: 'highloadV2',
    hash: 'fcd7d1f3b3847f0b9bd44bc64a2256c03450979dd1646a24fbc874b075392d6e',
    type: ContractType.Wallet
  },
  nominatorPool: {
    name: 'nominatorPool',
    hash: '26faa2d0fd2a8197ea36ded8dc50ad081cce5244207e9b05c08c1bb655527bff',
    type: ContractType.Staking
  },
  multisig: {
    name: 'multisig',
    hash: '45d890485cdd6b152bcbbe3fb2e16d2df82f6da840440a5b9f34ea13cb0b92d2',
    type: ContractType.Wallet
  },
  multisigV2: {
    name: 'multisigV2',
    hash: 'eb1323c5544d5bf26248dc427d108d722d5c2922dd97dd0bdf903c4cea73ca97',
    type: ContractType.Wallet
  },
  vesting: {
    name: 'vesting',
    hash: '69dc931958f7aa203c4a7bfcf263d25d2d828d573184b542a65dd55c8398ad83',
    type: ContractType.Wallet
  },
  multisigNew: {
    name: 'multisigNew',
    hash: '7cb3678880388acff45d74b2e7e7544caa8039d20b49f57c75b53c051b6fa30f',
    type: ContractType.Wallet
  },
  dedustPool: {
    name: 'dedustPool',
    hash: 'f216ded2b43d32e2d487db6fa6e4d2387f0ef1d7b53ec1ad85f0b4feb8e4ed62',
    isSwapAllowed: true
  },
  dedustVaultNative: {
    name: 'dedustVaultNative',
    hash: '64a42ad66688097422901ae6188670f0d6292ad3bdb4139289666f24187e86cb',
    isSwapAllowed: true
  },
  // Example: https://tonscan.org/address/EQAYqo4u7VF0fa4DPAebk4g9lBytj2VFny7pzXR0trjtXQaO
  dedustVaultJetton: {
    name: 'dedustVaultJetton',
    hash: '5bc82f0c5972ccc6732e98cbe31ea4795da818f9e06c991331568182a8362307',
    isSwapAllowed: true
  },
  stonPtonWallet: {
    name: 'stonPtonWallet',
    hash: '6ccbf71a3ed9c7355f84a698a44a7406574bfb8aa34d4bbd86ab75ee9c994880',
    isSwapAllowed: true
  },
  stonRouter: {
    name: 'stonRouter',
    hash: '14ce618a0e9a94adc99fa6e975219ddd675425b30dfa9728f98714c8dc55f9da',
    isSwapAllowed: true
  },
  stonRouterV2_1: {
    name: 'stonRouterV2_1',
    hash: 'd61cb7fb7bee0cc414286a482fccdec53c3f8717e4aae4fc362d98ab6254e6cd',
    isSwapAllowed: true
  },
  stonPoolV2_1: {
    name: 'stonPoolV2_1',
    hash: '16cc513c380e329f45d54f294787e2030e289799eca138961c1cd7e26e882c7c',
    isSwapAllowed: true
  },
  // Example: https://tonscan.org/address/EQCS4UEa5UaJLzOyyKieqQOQ2P9M-7kXpkO5HnP3Bv250cN3
  stonRouterV2_2: {
    name: 'stonRouterV2_2',
    hash: '094b5084111addda1b6fac7007c8a8f85ff4ccc63475815ab3dfa3b5b4c6b102',
    isSwapAllowed: true
  },
  // Example: https://tonscan.org/address/EQBSNX_5mSikBVttWhIaIb0f8jJU7fL6kvyyFVppd7dWRO6M
  stonRouterV2_2_alt: {
    name: 'stonRouterV2_2_alt',
    hash: 'd41e7563afa05ee008655e190920d3f53de9cab4c2d4e10ee1d0f158e95e52e5',
    isSwapAllowed: true
  },
  stonPoolV2_2: {
    name: 'stonPoolV2_2',
    hash: '11eaf6db706e63adf9327897aaa845c77a631856abfc14375837f19b617cacb4',
    isSwapAllowed: true
  },
  // Example: https://tonscan.org/address/EQBiLHuQjDj4fNyCD7Ch5HwpNGldlb5g-LMwQ1kStQ4NM5kv
  stonPtonWalletV2: {
    name: 'stonPtonWalletV2',
    hash: '2761042202032258de9eb1b672e1ec2e4f13b2af00700195801ada33f7ced1b6',
    isSwapAllowed: true
  },
  // Example: https://tonscan.org/address/EQC_-t0nCnOFMdp7E7qPxAOCbCWGFz-e3pwxb6tTvFmshjt5
  toncoRouter: {
    name: 'toncoRouter',
    hash: '9b9891eaa7db7becc6ccdda1bd9a8d25dc3df2817d57e4b27ec003daf81a4439',
    isSwapAllowed: true
  }
};

/***/ }),

/***/ 5130:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   U$: () => (/* binding */ createConnector)
/* harmony export */ });
/* unused harmony exports createExtensionConnector, createReverseExtensionConnector */
/* harmony import */ var _extensionMessageSerializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24082);
/* harmony import */ var _generateUniqueId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14235);
/* harmony import */ var _logs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55029);




// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents

class ConnectorClass {
  requestStates = new Map();
  requestStatesByCallback = new Map();
  constructor(target, onUpdate, channel, shouldUseJson) {
    let targetOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '*';
    this.target = target;
    this.onUpdate = onUpdate;
    this.channel = channel;
    this.shouldUseJson = shouldUseJson;
    this.targetOrigin = targetOrigin;
  }
  destroy() {}
  init() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.postMessage({
      type: 'init',
      args
    });
  }
  request(messageData) {
    const {
      requestStates,
      requestStatesByCallback
    } = this;
    const messageId = (0,_generateUniqueId__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)();
    const payload = {
      type: 'callMethod',
      messageId,
      ...messageData
    };
    const requestState = {
      messageId
    };

    // Re-wrap type because of `postMessage`
    const promise = new Promise((resolve, reject) => {
      Object.assign(requestState, {
        resolve,
        reject
      });
    });
    if (typeof payload.args[payload.args.length - 1] === 'function') {
      payload.withCallback = true;
      const callback = payload.args.pop();
      requestState.callback = callback;
      requestStatesByCallback.set(callback, requestState);
    }
    requestStates.set(messageId, requestState);
    promise.catch(() => undefined).finally(() => {
      requestStates.delete(messageId);
      if (requestState.callback) {
        requestStatesByCallback.delete(requestState.callback);
      }
    });
    this.postMessage(payload);
    return promise;
  }
  cancelCallback(progressCallback) {
    progressCallback.isCanceled = true;
    const {
      messageId
    } = this.requestStatesByCallback.get(progressCallback) || {};
    if (!messageId) {
      return;
    }
    this.postMessage({
      type: 'cancelProgress',
      messageId
    });
  }
  onMessage(data) {
    try {
      data = (0,_extensionMessageSerializer__WEBPACK_IMPORTED_MODULE_0__/* .decodeExtensionMessage */ .d$)(data);
    } catch (err) {
      (0,_logs__WEBPACK_IMPORTED_MODULE_1__/* .logDebugError */ .SJ)('PostMessageConnector: Failed to parse message', err);
      return;
    }
    const {
      requestStates,
      channel
    } = this;
    if (data.channel !== channel) {
      return;
    }
    if (data.type === 'update' && this.onUpdate) {
      this.onUpdate(data.update);
    }
    if (data.type === 'methodResponse') {
      const requestState = requestStates.get(data.messageId);
      if (requestState) {
        if (data.error) {
          requestState.reject(data.error);
        } else {
          requestState.resolve(data.response);
        }
      }
    } else if (data.type === 'methodCallback') {
      var _requestState$callbac;
      const requestState = requestStates.get(data.messageId);
      requestState === null || requestState === void 0 || (_requestState$callbac = requestState.callback) === null || _requestState$callbac === void 0 || _requestState$callbac.call(requestState, ...data.callbackArgs);
    } else if (data.type === 'unhandledError') {
      var _data$error, _data$error2;
      const error = new Error((_data$error = data.error) === null || _data$error === void 0 ? void 0 : _data$error.message);
      if ((_data$error2 = data.error) !== null && _data$error2 !== void 0 && _data$error2.stack) {
        error.stack = data.error.stack;
      }
      throw error;
    }
  }
  postMessage(data) {
    data.channel = this.channel;
    let rawData = data;
    if (this.shouldUseJson) {
      rawData = (0,_extensionMessageSerializer__WEBPACK_IMPORTED_MODULE_0__/* .encodeExtensionMessage */ .HE)(data);
    }
    if ('open' in this.target) {
      // Is Window
      this.target.postMessage(rawData, this.targetOrigin);
    } else {
      this.target.postMessage(rawData);
    }
  }
}

/**
 * Allows to call functions, provided by another messenger (a window, a worker), in this messenger.
 * The other messenger must provide the functions using `createPostMessageInterface`.
 */
function createConnector(worker, onUpdate, channel, targetOrigin) {
  const connector = new ConnectorClass(worker, onUpdate, channel, undefined, targetOrigin);
  function handleMessage(_ref) {
    let {
      data
    } = _ref;
    connector.onMessage(data);
  }
  worker.addEventListener('message', handleMessage); // TS weirdly complains here

  connector.destroy = () => {
    worker.removeEventListener('message', handleMessage);
  };
  return connector;
}

/**
 * Allows to call functions, provided by the extension service worker, in this window.
 * The service worker must provide the functions using `createExtensionInterface`.
 */
function createExtensionConnector(name, onUpdate, getInitArgs, channel) {
  const connector = new ConnectorClass(connect(), onUpdate, channel, true);
  function connect() {
    const port = self.chrome.runtime.connect({
      name
    });
    port.onMessage.addListener(data => {
      connector.onMessage(data);
    });

    // For some reason port can suddenly get disconnected
    port.onDisconnect.addListener(() => {
      connector.target = connect();
      connector.init(getInitArgs === null || getInitArgs === void 0 ? void 0 : getInitArgs());
    });
    return port;
  }
  connector.init(getInitArgs === null || getInitArgs === void 0 ? void 0 : getInitArgs());
  return connector;
}

/**
 * Allows to call functions, provided by a window, in this service worker.
 * The window must provide the functions using `createReverseExtensionInterface`.
 *
 * Warning: the connector is able to send messages only when the popup window is open.
 */
function createReverseExtensionConnector(portName) {
  const nullWorker = {
    postMessage() {
      throw new Error('The popup window is not connected');
    }
  };
  const connector = new ConnectorClass(nullWorker, undefined, undefined, true);
  chrome.runtime.onConnect.addListener(port => {
    if (port.name !== portName) {
      return;
    }
    connector.target = port;
    port.onMessage.addListener(data => {
      connector.onMessage(data);
    });
    port.onDisconnect.addListener(() => {
      connector.target = nullWorker;
    });
  });
  return connector;
}

/***/ }),

/***/ 9705:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ Deferred)
/* harmony export */ });
class Deferred {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
    });
  }
  static resolved(value) {
    const deferred = new Deferred();
    deferred.resolve(value);
    return deferred;
  }
}

/***/ }),

/***/ 10309:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CS: () => (/* binding */ getDayStartAt),
/* harmony export */   GS: () => (/* binding */ getCountDaysToDate),
/* harmony export */   N5: () => (/* binding */ formatHumanDay),
/* harmony export */   TK: () => (/* binding */ formatFullDay),
/* harmony export */   UX: () => (/* binding */ YEAR),
/* harmony export */   YG: () => (/* binding */ formatRelativeHumanDateTime),
/* harmony export */   Z2: () => (/* binding */ SECOND),
/* harmony export */   d_: () => (/* binding */ DAY),
/* harmony export */   fU: () => (/* binding */ formatTime),
/* harmony export */   mf: () => (/* binding */ formatShortDay),
/* harmony export */   pY: () => (/* binding */ MINUTE)
/* harmony export */ });
/* unused harmony exports HOUR, getDayStart, getMinuteStart */
/* harmony import */ var _withCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19314);

const SECOND = 1000;
const MINUTE = SECOND * 60;
const HOUR = MINUTE * 60;
const DAY = HOUR * 24;
const YEAR = 365 * DAY;
const formatDayToStringWithCache = (0,_withCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(function (langCode, dayStartAt, noYear) {
  let monthFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'short';
  let noDay = arguments.length > 4 ? arguments[4] : undefined;
  let withTime = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  return new Date(dayStartAt).toLocaleString(langCode, {
    year: noYear ? undefined : 'numeric',
    month: monthFormat || undefined,
    day: noDay ? undefined : 'numeric',
    hour: withTime ? 'numeric' : undefined,
    minute: withTime ? 'numeric' : undefined,
    hourCycle: 'h23'
  });
});
function formatRelativeHumanDateTime() {
  let langCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'en';
  let time = arguments.length > 1 ? arguments[1] : undefined;
  const total = time - Date.now();
  const minutes = Math.floor(total / 1000 / 60 % 60);
  const hours = Math.floor(total / (1000 * 3600) % 24);
  const days = Math.floor(total / 1000 / 3600 / 24);
  const rtf = new Intl.RelativeTimeFormat(langCode, {
    localeMatcher: 'best fit',
    numeric: 'always',
    style: 'long'
  });
  const result = [];
  if (days > 0) {
    const [daysPlural, daysValue] = rtf.formatToParts(days, 'day').reverse();
    result.push(`${daysValue.value}${daysPlural.value}`.replace(' ', '\u00A0'));
  }
  if (hours > 0) {
    const [hoursPlural, hoursValue] = rtf.formatToParts(hours, 'hour').reverse();
    result.push(`${hoursValue.value}${hoursPlural.value}`.replace(' ', '\u00A0'));
  }
  if (minutes > 0) {
    const [minutesPlural, minutesValue] = rtf.formatToParts(minutes, 'minute').reverse();
    result.push(`${minutesValue.value}${minutesPlural.value}`.replace(' ', '\u00A0'));
  }
  return result.join(' ');
}
function formatHumanDay(lang, datetime) {
  if (isToday(datetime)) {
    return lang('Today');
  }
  if (isYesterday(datetime)) {
    return lang('Yesterday');
  }
  return formatFullDay(lang.code, datetime);
}
function formatFullDay(langCode, datetime) {
  const date = new Date(datetime);
  const dayStartAt = getDayStartAt(date);
  const today = getDayStart(new Date());
  const noYear = date.getFullYear() === today.getFullYear();
  return formatDayToStringWithCache(langCode, dayStartAt, noYear, 'long');
}
function formatShortDay(langCode, datetime) {
  let withTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let noYear = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const date = new Date(datetime);
  const dayStartAt = getDayStartAt(date);
  const today = getDayStart(new Date());
  const todayStartAt = getDayStartAt(today);
  const noDate = withTime && dayStartAt === todayStartAt;
  const targetAt = withTime ? getMinuteStart(date).getTime() : dayStartAt;
  noYear ||= date.getFullYear() === today.getFullYear();
  return formatDayToStringWithCache(langCode, targetAt, noYear, !noDate && 'short', noDate, withTime);
}
function formatTime(datetime) {
  const date = new Date(datetime);
  return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
}
function getCountDaysToDate(datetime) {
  const today = new Date();
  const date = datetime instanceof Date ? datetime : new Date(datetime);
  return Math.ceil((date.getTime() - today.getTime()) / DAY);
}
function getDayStart(datetime) {
  const date = new Date(datetime);
  date.setHours(0, 0, 0, 0);
  return date;
}
function getDayStartAt(datetime) {
  return getDayStart(datetime).getTime();
}
function getMinuteStart(datetime) {
  const date = new Date(datetime);
  date.setSeconds(0, 0);
  return date;
}
function isToday(datetime) {
  return getDayStartAt(new Date()) === getDayStartAt(new Date(datetime));
}
function isYesterday(datetime) {
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  return getDayStartAt(yesterday) === getDayStartAt(new Date(datetime));
}

/***/ }),

/***/ 10428:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* unused harmony export ApiLiquidUnstakeMode */
/**
 * The `fee` field should contain the final (real) fee, because we want to show the real fee in local transactions
 */

let ApiLiquidUnstakeMode = /*#__PURE__*/function (ApiLiquidUnstakeMode) {
  ApiLiquidUnstakeMode[ApiLiquidUnstakeMode["Default"] = 0] = "Default";
  ApiLiquidUnstakeMode[ApiLiquidUnstakeMode["Instant"] = 1] = "Instant";
  ApiLiquidUnstakeMode[ApiLiquidUnstakeMode["BestRate"] = 2] = "BestRate";
  return ApiLiquidUnstakeMode;
}({});

// Country codes from ISO-3166-1 spec

/** Each string value can be either an address or a domain name */

/***/ }),

/***/ 14235:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ generateUniqueId)
/* harmony export */ });
function generateUniqueId() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2);
}

/***/ }),

/***/ 16546:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $c: () => (/* binding */ ExceptionCode),
/* harmony export */   EA: () => (/* binding */ buildRequestInit),
/* harmony export */   E_: () => (/* binding */ WebPlugin),
/* harmony export */   F3: () => (/* binding */ registerPlugin),
/* harmony export */   I9: () => (/* binding */ CapacitorException),
/* harmony export */   Ii: () => (/* binding */ Capacitor)
/* harmony export */ });
/* unused harmony exports CapacitorCookies, CapacitorHttp, WebView */
/*! Capacitor: https://capacitorjs.com/ - MIT License */
var ExceptionCode;
(function (ExceptionCode) {
    /**
     * API is not implemented.
     *
     * This usually means the API can't be used because it is not implemented for
     * the current platform.
     */
    ExceptionCode["Unimplemented"] = "UNIMPLEMENTED";
    /**
     * API is not available.
     *
     * This means the API can't be used right now because:
     *   - it is currently missing a prerequisite, such as network connectivity
     *   - it requires a particular platform or browser version
     */
    ExceptionCode["Unavailable"] = "UNAVAILABLE";
})(ExceptionCode || (ExceptionCode = {}));
class CapacitorException extends Error {
    constructor(message, code, data) {
        super(message);
        this.message = message;
        this.code = code;
        this.data = data;
    }
}
const getPlatformId = (win) => {
    var _a, _b;
    if (win === null || win === void 0 ? void 0 : win.androidBridge) {
        return 'android';
    }
    else if ((_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
        return 'ios';
    }
    else {
        return 'web';
    }
};

const createCapacitor = (win) => {
    const capCustomPlatform = win.CapacitorCustomPlatform || null;
    const cap = win.Capacitor || {};
    const Plugins = (cap.Plugins = cap.Plugins || {});
    const getPlatform = () => {
        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
    };
    const isNativePlatform = () => getPlatform() !== 'web';
    const isPluginAvailable = (pluginName) => {
        const plugin = registeredPlugins.get(pluginName);
        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
            // JS implementation available for the current platform.
            return true;
        }
        if (getPluginHeader(pluginName)) {
            // Native implementation available.
            return true;
        }
        return false;
    };
    const getPluginHeader = (pluginName) => { var _a; return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find((h) => h.name === pluginName); };
    const handleError = (err) => win.console.error(err);
    const registeredPlugins = new Map();
    const registerPlugin = (pluginName, jsImplementations = {}) => {
        const registeredPlugin = registeredPlugins.get(pluginName);
        if (registeredPlugin) {
            console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
            return registeredPlugin.proxy;
        }
        const platform = getPlatform();
        const pluginHeader = getPluginHeader(pluginName);
        let jsImplementation;
        const loadPluginImplementation = async () => {
            if (!jsImplementation && platform in jsImplementations) {
                jsImplementation =
                    typeof jsImplementations[platform] === 'function'
                        ? (jsImplementation = await jsImplementations[platform]())
                        : (jsImplementation = jsImplementations[platform]);
            }
            else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {
                jsImplementation =
                    typeof jsImplementations['web'] === 'function'
                        ? (jsImplementation = await jsImplementations['web']())
                        : (jsImplementation = jsImplementations['web']);
            }
            return jsImplementation;
        };
        const createPluginMethod = (impl, prop) => {
            var _a, _b;
            if (pluginHeader) {
                const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find((m) => prop === m.name);
                if (methodHeader) {
                    if (methodHeader.rtype === 'promise') {
                        return (options) => cap.nativePromise(pluginName, prop.toString(), options);
                    }
                    else {
                        return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
                    }
                }
                else if (impl) {
                    return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
                }
            }
            else if (impl) {
                return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
            }
            else {
                throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
            }
        };
        const createPluginMethodWrapper = (prop) => {
            let remove;
            const wrapper = (...args) => {
                const p = loadPluginImplementation().then((impl) => {
                    const fn = createPluginMethod(impl, prop);
                    if (fn) {
                        const p = fn(...args);
                        remove = p === null || p === void 0 ? void 0 : p.remove;
                        return p;
                    }
                    else {
                        throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
                    }
                });
                if (prop === 'addListener') {
                    p.remove = async () => remove();
                }
                return p;
            };
            // Some flair âœ¨
            wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
            Object.defineProperty(wrapper, 'name', {
                value: prop,
                writable: false,
                configurable: false,
            });
            return wrapper;
        };
        const addListener = createPluginMethodWrapper('addListener');
        const removeListener = createPluginMethodWrapper('removeListener');
        const addListenerNative = (eventName, callback) => {
            const call = addListener({ eventName }, callback);
            const remove = async () => {
                const callbackId = await call;
                removeListener({
                    eventName,
                    callbackId,
                }, callback);
            };
            const p = new Promise((resolve) => call.then(() => resolve({ remove })));
            p.remove = async () => {
                console.warn(`Using addListener() without 'await' is deprecated.`);
                await remove();
            };
            return p;
        };
        const proxy = new Proxy({}, {
            get(_, prop) {
                switch (prop) {
                    // https://github.com/facebook/react/issues/20030
                    case '$$typeof':
                        return undefined;
                    case 'toJSON':
                        return () => ({});
                    case 'addListener':
                        return pluginHeader ? addListenerNative : addListener;
                    case 'removeListener':
                        return removeListener;
                    default:
                        return createPluginMethodWrapper(prop);
                }
            },
        });
        Plugins[pluginName] = proxy;
        registeredPlugins.set(pluginName, {
            name: pluginName,
            proxy,
            platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),
        });
        return proxy;
    };
    // Add in convertFileSrc for web, it will already be available in native context
    if (!cap.convertFileSrc) {
        cap.convertFileSrc = (filePath) => filePath;
    }
    cap.getPlatform = getPlatform;
    cap.handleError = handleError;
    cap.isNativePlatform = isNativePlatform;
    cap.isPluginAvailable = isPluginAvailable;
    cap.registerPlugin = registerPlugin;
    cap.Exception = CapacitorException;
    cap.DEBUG = !!cap.DEBUG;
    cap.isLoggingEnabled = !!cap.isLoggingEnabled;
    return cap;
};
const initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));

const Capacitor = /*#__PURE__*/ initCapacitorGlobal(typeof globalThis !== 'undefined'
    ? globalThis
    : typeof self !== 'undefined'
        ? self
        : typeof window !== 'undefined'
            ? window
            : typeof __webpack_require__.g !== 'undefined'
                ? __webpack_require__.g
                : {});
const registerPlugin = Capacitor.registerPlugin;

/**
 * Base class web plugins should extend.
 */
class WebPlugin {
    constructor() {
        this.listeners = {};
        this.retainedEventArguments = {};
        this.windowListeners = {};
    }
    addListener(eventName, listenerFunc) {
        let firstListener = false;
        const listeners = this.listeners[eventName];
        if (!listeners) {
            this.listeners[eventName] = [];
            firstListener = true;
        }
        this.listeners[eventName].push(listenerFunc);
        // If we haven't added a window listener for this event and it requires one,
        // go ahead and add it
        const windowListener = this.windowListeners[eventName];
        if (windowListener && !windowListener.registered) {
            this.addWindowListener(windowListener);
        }
        if (firstListener) {
            this.sendRetainedArgumentsForEvent(eventName);
        }
        const remove = async () => this.removeListener(eventName, listenerFunc);
        const p = Promise.resolve({ remove });
        return p;
    }
    async removeAllListeners() {
        this.listeners = {};
        for (const listener in this.windowListeners) {
            this.removeWindowListener(this.windowListeners[listener]);
        }
        this.windowListeners = {};
    }
    notifyListeners(eventName, data, retainUntilConsumed) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            if (retainUntilConsumed) {
                let args = this.retainedEventArguments[eventName];
                if (!args) {
                    args = [];
                }
                args.push(data);
                this.retainedEventArguments[eventName] = args;
            }
            return;
        }
        listeners.forEach((listener) => listener(data));
    }
    hasListeners(eventName) {
        return !!this.listeners[eventName].length;
    }
    registerWindowListener(windowEventName, pluginEventName) {
        this.windowListeners[pluginEventName] = {
            registered: false,
            windowEventName,
            pluginEventName,
            handler: (event) => {
                this.notifyListeners(pluginEventName, event);
            },
        };
    }
    unimplemented(msg = 'not implemented') {
        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
    }
    unavailable(msg = 'not available') {
        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
    }
    async removeListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            return;
        }
        const index = listeners.indexOf(listenerFunc);
        this.listeners[eventName].splice(index, 1);
        // If there are no more listeners for this type of event,
        // remove the window listener
        if (!this.listeners[eventName].length) {
            this.removeWindowListener(this.windowListeners[eventName]);
        }
    }
    addWindowListener(handle) {
        window.addEventListener(handle.windowEventName, handle.handler);
        handle.registered = true;
    }
    removeWindowListener(handle) {
        if (!handle) {
            return;
        }
        window.removeEventListener(handle.windowEventName, handle.handler);
        handle.registered = false;
    }
    sendRetainedArgumentsForEvent(eventName) {
        const args = this.retainedEventArguments[eventName];
        if (!args) {
            return;
        }
        delete this.retainedEventArguments[eventName];
        args.forEach((arg) => {
            this.notifyListeners(eventName, arg);
        });
    }
}

const WebView = /*#__PURE__*/ (/* unused pure expression or super */ null && (registerPlugin('WebView')));
/******** END WEB VIEW PLUGIN ********/
/******** COOKIES PLUGIN ********/
/**
 * Safely web encode a string value (inspired by js-cookie)
 * @param str The string value to encode
 */
const encode = (str) => encodeURIComponent(str)
    .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
    .replace(/[()]/g, escape);
/**
 * Safely web decode a string value (inspired by js-cookie)
 * @param str The string value to decode
 */
const decode = (str) => str.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
class CapacitorCookiesPluginWeb extends WebPlugin {
    async getCookies() {
        const cookies = document.cookie;
        const cookieMap = {};
        cookies.split(';').forEach((cookie) => {
            if (cookie.length <= 0)
                return;
            // Replace first "=" with CAP_COOKIE to prevent splitting on additional "="
            let [key, value] = cookie.replace(/=/, 'CAP_COOKIE').split('CAP_COOKIE');
            key = decode(key).trim();
            value = decode(value).trim();
            cookieMap[key] = value;
        });
        return cookieMap;
    }
    async setCookie(options) {
        try {
            // Safely Encoded Key/Value
            const encodedKey = encode(options.key);
            const encodedValue = encode(options.value);
            // Clean & sanitize options
            const expires = `; expires=${(options.expires || '').replace('expires=', '')}`; // Default is "; expires="
            const path = (options.path || '/').replace('path=', ''); // Default is "path=/"
            const domain = options.url != null && options.url.length > 0 ? `domain=${options.url}` : '';
            document.cookie = `${encodedKey}=${encodedValue || ''}${expires}; path=${path}; ${domain};`;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async deleteCookie(options) {
        try {
            document.cookie = `${options.key}=; Max-Age=0`;
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async clearCookies() {
        try {
            const cookies = document.cookie.split(';') || [];
            for (const cookie of cookies) {
                document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date().toUTCString()};path=/`);
            }
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
    async clearAllCookies() {
        try {
            await this.clearCookies();
        }
        catch (error) {
            return Promise.reject(error);
        }
    }
}
const CapacitorCookies = registerPlugin('CapacitorCookies', {
    web: () => new CapacitorCookiesPluginWeb(),
});
// UTILITY FUNCTIONS
/**
 * Read in a Blob value and return it as a base64 string
 * @param blob The blob value to convert to a base64 string
 */
const readBlobAsBase64 = async (blob) => new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
        const base64String = reader.result;
        // remove prefix "data:application/pdf;base64,"
        resolve(base64String.indexOf(',') >= 0 ? base64String.split(',')[1] : base64String);
    };
    reader.onerror = (error) => reject(error);
    reader.readAsDataURL(blob);
});
/**
 * Normalize an HttpHeaders map by lowercasing all of the values
 * @param headers The HttpHeaders object to normalize
 */
const normalizeHttpHeaders = (headers = {}) => {
    const originalKeys = Object.keys(headers);
    const loweredKeys = Object.keys(headers).map((k) => k.toLocaleLowerCase());
    const normalized = loweredKeys.reduce((acc, key, index) => {
        acc[key] = headers[originalKeys[index]];
        return acc;
    }, {});
    return normalized;
};
/**
 * Builds a string of url parameters that
 * @param params A map of url parameters
 * @param shouldEncode true if you should encodeURIComponent() the values (true by default)
 */
const buildUrlParams = (params, shouldEncode = true) => {
    if (!params)
        return null;
    const output = Object.entries(params).reduce((accumulator, entry) => {
        const [key, value] = entry;
        let encodedValue;
        let item;
        if (Array.isArray(value)) {
            item = '';
            value.forEach((str) => {
                encodedValue = shouldEncode ? encodeURIComponent(str) : str;
                item += `${key}=${encodedValue}&`;
            });
            // last character will always be "&" so slice it off
            item.slice(0, -1);
        }
        else {
            encodedValue = shouldEncode ? encodeURIComponent(value) : value;
            item = `${key}=${encodedValue}`;
        }
        return `${accumulator}&${item}`;
    }, '');
    // Remove initial "&" from the reduce
    return output.substr(1);
};
/**
 * Build the RequestInit object based on the options passed into the initial request
 * @param options The Http plugin options
 * @param extra Any extra RequestInit values
 */
const buildRequestInit = (options, extra = {}) => {
    const output = Object.assign({ method: options.method || 'GET', headers: options.headers }, extra);
    // Get the content-type
    const headers = normalizeHttpHeaders(options.headers);
    const type = headers['content-type'] || '';
    // If body is already a string, then pass it through as-is.
    if (typeof options.data === 'string') {
        output.body = options.data;
    }
    // Build request initializers based off of content-type
    else if (type.includes('application/x-www-form-urlencoded')) {
        const params = new URLSearchParams();
        for (const [key, value] of Object.entries(options.data || {})) {
            params.set(key, value);
        }
        output.body = params.toString();
    }
    else if (type.includes('multipart/form-data') || options.data instanceof FormData) {
        const form = new FormData();
        if (options.data instanceof FormData) {
            options.data.forEach((value, key) => {
                form.append(key, value);
            });
        }
        else {
            for (const key of Object.keys(options.data)) {
                form.append(key, options.data[key]);
            }
        }
        output.body = form;
        const headers = new Headers(output.headers);
        headers.delete('content-type'); // content-type will be set by `window.fetch` to includy boundary
        output.headers = headers;
    }
    else if (type.includes('application/json') || typeof options.data === 'object') {
        output.body = JSON.stringify(options.data);
    }
    return output;
};
// WEB IMPLEMENTATION
class CapacitorHttpPluginWeb extends WebPlugin {
    /**
     * Perform an Http request given a set of options
     * @param options Options to build the HTTP request
     */
    async request(options) {
        const requestInit = buildRequestInit(options, options.webFetchExtra);
        const urlParams = buildUrlParams(options.params, options.shouldEncodeUrlParams);
        const url = urlParams ? `${options.url}?${urlParams}` : options.url;
        const response = await fetch(url, requestInit);
        const contentType = response.headers.get('content-type') || '';
        // Default to 'text' responseType so no parsing happens
        let { responseType = 'text' } = response.ok ? options : {};
        // If the response content-type is json, force the response to be json
        if (contentType.includes('application/json')) {
            responseType = 'json';
        }
        let data;
        let blob;
        switch (responseType) {
            case 'arraybuffer':
            case 'blob':
                blob = await response.blob();
                data = await readBlobAsBase64(blob);
                break;
            case 'json':
                data = await response.json();
                break;
            case 'document':
            case 'text':
            default:
                data = await response.text();
        }
        // Convert fetch headers to Capacitor HttpHeaders
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return {
            data,
            headers,
            status: response.status,
            url: response.url,
        };
    }
    /**
     * Perform an Http GET request given a set of options
     * @param options Options to build the HTTP request
     */
    async get(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'GET' }));
    }
    /**
     * Perform an Http POST request given a set of options
     * @param options Options to build the HTTP request
     */
    async post(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'POST' }));
    }
    /**
     * Perform an Http PUT request given a set of options
     * @param options Options to build the HTTP request
     */
    async put(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'PUT' }));
    }
    /**
     * Perform an Http PATCH request given a set of options
     * @param options Options to build the HTTP request
     */
    async patch(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'PATCH' }));
    }
    /**
     * Perform an Http DELETE request given a set of options
     * @param options Options to build the HTTP request
     */
    async delete(options) {
        return this.request(Object.assign(Object.assign({}, options), { method: 'DELETE' }));
    }
}
const CapacitorHttp = registerPlugin('CapacitorHttp', {
    web: () => new CapacitorHttpPluginWeb(),
});
/******** END HTTP PLUGIN ********/


//# sourceMappingURL=index.js.map


/***/ }),

/***/ 19314:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ withCache)
/* harmony export */ });
const cache = new WeakMap();
function withCache(fn) {
  return function () {
    let fnCache = cache.get(fn);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const cacheKey = args.map(String).join('_');
    if (fnCache) {
      const cached = fnCache.get(cacheKey);
      if (cached) {
        return cached;
      }
    } else {
      fnCache = new Map();
      cache.set(fn, fnCache);
    }
    const newValue = fn(...args);
    fnCache.set(cacheKey, newValue);
    return newValue;
  };
}

/***/ }),

/***/ 19822:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Hd: () => (/* binding */ animateNumber),
/* harmony export */   ZM: () => (/* binding */ applyStyles),
/* harmony export */   i0: () => (/* binding */ animate),
/* harmony export */   iT: () => (/* binding */ animateInstantly),
/* harmony export */   qM: () => (/* binding */ timingFunctions)
/* harmony export */ });
/* unused harmony exports animateSingle, cancelSingleAnimation */
/* harmony import */ var _lib_fasterdom_fasterdom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66644);

let currentInstance;
function animateSingle(tick, schedulerFn, instance) {
  if (!instance) {
    if (currentInstance && !currentInstance.isCancelled) {
      currentInstance.isCancelled = true;
    }
    instance = {
      isCancelled: false
    };
    currentInstance = instance;
  }
  if (!instance.isCancelled && tick()) {
    schedulerFn(() => {
      animateSingle(tick, schedulerFn, instance);
    });
  }
}
function cancelSingleAnimation() {
  const dumbScheduler = cb => cb;
  const dumbCb = () => undefined;
  animateSingle(dumbCb, dumbScheduler);
}
function animate(tick, schedulerFn) {
  schedulerFn(() => {
    if (tick()) {
      animate(tick, schedulerFn);
    }
  });
}
function animateInstantly(tick, schedulerFn) {
  if (tick()) {
    schedulerFn(() => {
      animateInstantly(tick, schedulerFn);
    });
  }
}
const timingFunctions = {
  linear: t => t,
  easeIn: t => t ** 1.675,
  easeOut: t => -1 * t ** 1.675,
  easeInOut: t => 0.5 * (Math.sin((t - 0.5) * Math.PI) + 1),
  easeInQuad: t => t * t,
  easeOutQuad: t => t * (2 - t),
  easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  easeInCubic: t => t ** 3,
  easeOutCubic: t => --t * t * t + 1,
  easeInOutCubic: t => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  easeInQuart: t => t ** 4,
  easeOutQuart: t => 1 - --t * t ** 3,
  easeInOutQuart: t => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t * t ** 3,
  easeInQuint: t => t ** 5,
  easeOutQuint: t => 1 + --t * t ** 4,
  easeInOutQuint: t => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t * t ** 4
};
function animateNumber(_ref) {
  let {
    timing = timingFunctions.linear,
    onUpdate,
    duration,
    onEnd,
    from,
    to
  } = _ref;
  const t0 = Date.now();
  let isCanceled = false;
  animateInstantly(() => {
    if (isCanceled) return false;
    const t1 = Date.now();
    const t = Math.min((t1 - t0) / duration, 1);
    const progress = timing(t);
    if (typeof from === 'number' && typeof to === 'number') {
      onUpdate(from + (to - from) * progress);
    } else if (Array.isArray(from) && Array.isArray(to)) {
      const result = from.map((f, i) => f + (to[i] - f) * progress);
      onUpdate(result);
    }
    if (t === 1) {
      onEnd === null || onEnd === void 0 || onEnd();
    }
    return t < 1;
  }, _lib_fasterdom_fasterdom__WEBPACK_IMPORTED_MODULE_0__/* .requestMeasure */ .YS);
  return () => {
    isCanceled = true;
    onEnd === null || onEnd === void 0 || onEnd(true);
  };
}
function applyStyles(element, css) {
  Object.assign(element.style, css);
}

/***/ }),

/***/ 23174:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KL: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_1__.KL),
/* harmony export */   Nu: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_1__.Nu),
/* harmony export */   QD: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_1__.QD),
/* harmony export */   jc: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_1__.jc),
/* harmony export */   jf: () => (/* reexport safe */ _errors__WEBPACK_IMPORTED_MODULE_1__.jf)
/* harmony export */ });
/* harmony import */ var _misc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10428);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56051);











/***/ }),

/***/ 23693:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ NotificationType),
/* harmony export */   k: () => (/* binding */ ImpactStyle)
/* harmony export */ });
var ImpactStyle;
(function (ImpactStyle) {
    /**
     * A collision between large, heavy user interface elements
     *
     * @since 1.0.0
     */
    ImpactStyle["Heavy"] = "HEAVY";
    /**
     * A collision between moderately sized user interface elements
     *
     * @since 1.0.0
     */
    ImpactStyle["Medium"] = "MEDIUM";
    /**
     * A collision between small, light user interface elements
     *
     * @since 1.0.0
     */
    ImpactStyle["Light"] = "LIGHT";
})(ImpactStyle || (ImpactStyle = {}));
var NotificationType;
(function (NotificationType) {
    /**
     * A notification feedback type indicating that a task has completed successfully
     *
     * @since 1.0.0
     */
    NotificationType["Success"] = "SUCCESS";
    /**
     * A notification feedback type indicating that a task has produced a warning
     *
     * @since 1.0.0
     */
    NotificationType["Warning"] = "WARNING";
    /**
     * A notification feedback type indicating that a task has failed
     *
     * @since 1.0.0
     */
    NotificationType["Error"] = "ERROR";
})(NotificationType || (NotificationType = {}));
//# sourceMappingURL=definitions.js.map

/***/ }),

/***/ 24082:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HE: () => (/* binding */ encodeExtensionMessage),
/* harmony export */   d$: () => (/* binding */ decodeExtensionMessage)
/* harmony export */ });
/* unused harmony export UNDEFINED_PREFIX */
/* harmony import */ var _bigint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(809);

const UNDEFINED_PREFIX = 'undefined:';
function extensionMessageReplacer(key, value) {
  if (value === undefined) {
    return `${UNDEFINED_PREFIX}marker`;
  }

  // Bigint is replaced by patching `toJSON` method

  return value;
}
function extensionMessageReviver(key, value) {
  // Handle bigint values
  if (typeof value === 'string' && value.startsWith(_bigint__WEBPACK_IMPORTED_MODULE_0__/* .BIGINT_PREFIX */ .tH)) {
    return BigInt(value.slice(_bigint__WEBPACK_IMPORTED_MODULE_0__/* .BIGINT_PREFIX */ .tH.length));
  }

  // Handle undefined values
  if (typeof value === 'string' && value.startsWith(UNDEFINED_PREFIX)) {
    return undefined;
  }
  return value;
}
function encodeExtensionMessage(data) {
  return JSON.stringify(data, extensionMessageReplacer);
}
function decodeExtensionMessage(data) {
  if (typeof data === 'string') {
    return JSON.parse(data, extensionMessageReviver);
  }
  return data;
}

/***/ }),

/***/ 31481:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AIK: () => (/* binding */ MTW_TIPS_CHANNEL_NAME),
/* harmony export */   AuB: () => (/* binding */ SWAP_API_VERSION),
/* harmony export */   Avc: () => (/* binding */ WRONG_ATTEMPTS_BEFORE_LOG_OUT_SUGGESTION),
/* harmony export */   B9l: () => (/* binding */ BOT_USERNAME),
/* harmony export */   BZS: () => (/* binding */ CHANGELLY_AML_KYC),
/* harmony export */   Ba4: () => (/* binding */ DEFAULT_NOMINATORS_STAKING_STATE),
/* harmony export */   Bqy: () => (/* binding */ STAKED_TON_SLUG),
/* harmony export */   Bx3: () => (/* binding */ UNKNOWN_TOKEN),
/* harmony export */   C39: () => (/* binding */ APP_NAME),
/* harmony export */   CV: () => (/* binding */ LANG_CACHE_NAME),
/* harmony export */   Czf: () => (/* binding */ DEFAULT_CEX_SWAP_SECOND_TOKEN_SLUG),
/* harmony export */   Dde: () => (/* binding */ DEFAULT_LANDSCAPE_ACTION_TAB_ID),
/* harmony export */   DvZ: () => (/* binding */ BETA_URL),
/* harmony export */   F9m: () => (/* binding */ IMAGE_CACHE_NAME),
/* harmony export */   FHx: () => (/* binding */ DEBUG_ALERT_MSG),
/* harmony export */   FgL: () => (/* binding */ NFT_MARKETPLACE_URL),
/* harmony export */   Fgn: () => (/* binding */ DEFAULT_ENABLED_TOKEN_SLUGS),
/* harmony export */   Fkn: () => (/* binding */ SUPPORT_USERNAME),
/* harmony export */   Fmr: () => (/* binding */ STON_PTON_SLUG),
/* harmony export */   GX2: () => (/* binding */ MYCOIN_TESTNET),
/* harmony export */   Guj: () => (/* binding */ APP_ENV),
/* harmony export */   HOw: () => (/* binding */ TONCONNECT_WALLET_JSBRIDGE_KEY),
/* harmony export */   HWN: () => (/* binding */ CHANGELLY_SUPPORT_EMAIL),
/* harmony export */   I04: () => (/* binding */ FRACTION_DIGITS),
/* harmony export */   Ia6: () => (/* binding */ NFT_MARKETPLACE_TITLE),
/* harmony export */   JDR: () => (/* binding */ MYTONWALLET_MULTISEND_DAPP_URL),
/* harmony export */   JWy: () => (/* binding */ CHANGELLY_WAITING_DEADLINE),
/* harmony export */   JhS: () => (/* binding */ DEFAULT_SWAP_FIRST_TOKEN_SLUG),
/* harmony export */   Jxt: () => (/* binding */ IFRAME_WHITELIST),
/* harmony export */   K_I: () => (/* binding */ SHOULD_SHOW_ALL_ASSETS_AND_ACTIVITY),
/* harmony export */   Kfi: () => (/* binding */ HISTORY_PERIODS),
/* harmony export */   Kih: () => (/* binding */ MAIN_ACCOUNT_ID),
/* harmony export */   KmP: () => (/* binding */ NOTCOIN_VOUCHERS_ADDRESS),
/* harmony export */   Kq_: () => (/* binding */ CHANGELLY_TERMS_OF_USE),
/* harmony export */   LaL: () => (/* binding */ INACTIVE_MARKER),
/* harmony export */   MS3: () => (/* binding */ WHOLE_PART_DELIMITER),
/* harmony export */   MVx: () => (/* binding */ DEBUG_MORE),
/* harmony export */   NEx: () => (/* binding */ PIN_LENGTH),
/* harmony export */   NFS: () => (/* binding */ VALIDATION_PERIOD_MS),
/* harmony export */   OKZ: () => (/* binding */ CLAIM_ADDRESS),
/* harmony export */   OZB: () => (/* binding */ TOKEN_WITH_LABEL),
/* harmony export */   Oig: () => (/* binding */ DEBUG),
/* harmony export */   OuE: () => (/* binding */ IS_STAKING_DISABLED),
/* harmony export */   PKm: () => (/* binding */ GETGEMS_BASE_TESTNET_URL),
/* harmony export */   PcM: () => (/* binding */ PRIVATE_KEY_HEX_LENGTH),
/* harmony export */   Pcx: () => (/* binding */ WINDOW_PROVIDER_CHANNEL),
/* harmony export */   QSz: () => (/* binding */ TRC20_USDT_MAINNET_SLUG),
/* harmony export */   RTV: () => (/* binding */ IS_OPERA_EXTENSION),
/* harmony export */   S7e: () => (/* binding */ SWAP_DEX_LABELS),
/* harmony export */   ScF: () => (/* binding */ DEFAULT_TRANSFER_TOKEN_SLUG),
/* harmony export */   Svl: () => (/* binding */ STAKED_TOKEN_SLUGS),
/* harmony export */   TI6: () => (/* binding */ IS_CORE_WALLET),
/* harmony export */   Tu9: () => (/* binding */ TONCOIN),
/* harmony export */   UAn: () => (/* binding */ STAKING_MIN_AMOUNT),
/* harmony export */   UMQ: () => (/* binding */ IS_CAPACITOR),
/* harmony export */   USn: () => (/* binding */ DEFAULT_STAKING_STATE),
/* harmony export */   UuV: () => (/* binding */ GLOBAL_STATE_CACHE_DISABLED),
/* harmony export */   V3_: () => (/* binding */ APP_REPO_URL),
/* harmony export */   VL7: () => (/* binding */ IS_ANDROID_DIRECT),
/* harmony export */   Vxu: () => (/* binding */ SHORT_FRACTION_DIGITS),
/* harmony export */   W1_: () => (/* binding */ APP_INSTALL_URL),
/* harmony export */   W75: () => (/* binding */ IS_TEST),
/* harmony export */   WHY: () => (/* binding */ BURN_CHUNK_DURATION_APPROX_SEC),
/* harmony export */   WUE: () => (/* binding */ ETHENA_STAKING_MIN_AMOUNT),
/* harmony export */   WVU: () => (/* binding */ NOTCOIN_EXCHANGERS),
/* harmony export */   Wvq: () => (/* binding */ TINY_TRANSFER_MAX_COST),
/* harmony export */   X1K: () => (/* binding */ ONE_TON),
/* harmony export */   X6R: () => (/* binding */ TELEGRAM_GIFTS_SUPER_COLLECTION),
/* harmony export */   X7T: () => (/* binding */ TRX),
/* harmony export */   Xr6: () => (/* binding */ SUBPROJECT_URL_MASK),
/* harmony export */   YDh: () => (/* binding */ DEFAULT_OUR_SWAP_FEE),
/* harmony export */   YO8: () => (/* binding */ ANIMATED_STICKER_TINY_SIZE_PX),
/* harmony export */   YnH: () => (/* binding */ THEME_DEFAULT),
/* harmony export */   Yyb: () => (/* binding */ MNEMONIC_COUNTS),
/* harmony export */   ZYg: () => (/* binding */ CLAIM_COMMENT),
/* harmony export */   _bq: () => (/* binding */ DEFAULT_ENABLED_TOKEN_COUNT),
/* harmony export */   aD4: () => (/* binding */ NATIVE_BIOMETRICS_SERVER),
/* harmony export */   aEZ: () => (/* binding */ CLAIM_AMOUNT),
/* harmony export */   b2d: () => (/* binding */ MTW_CARDS_WEBSITE),
/* harmony export */   bOf: () => (/* binding */ TRANSACTION_ADDRESS_SHIFT),
/* harmony export */   c2m: () => (/* binding */ MOBILE_SCREEN_MAX_WIDTH),
/* harmony export */   dCY: () => (/* binding */ JVAULT_URL),
/* harmony export */   dL4: () => (/* binding */ MIN_ACTIVE_STAKING_REWARDS),
/* harmony export */   dlH: () => (/* binding */ DEBUG_API),
/* harmony export */   dmC: () => (/* binding */ MTW_CARDS_BASE_URL),
/* harmony export */   dnp: () => (/* binding */ ANIMATION_LEVEL_MIN),
/* harmony export */   dqR: () => (/* binding */ DEFAULT_FEE),
/* harmony export */   eZ2: () => (/* binding */ POPULAR_WALLET_VERSIONS),
/* harmony export */   eec: () => (/* binding */ MTW_CARDS_MINT_BASE_URL),
/* harmony export */   eoU: () => (/* binding */ MULTITAB_DATA_CHANNEL_NAME),
/* harmony export */   fPM: () => (/* binding */ DEFAULT_AUTOLOCK_OPTION),
/* harmony export */   fSo: () => (/* binding */ NFT_MARKETPLACE_TITLES),
/* harmony export */   gR8: () => (/* binding */ NFT_BATCH_SIZE),
/* harmony export */   gSB: () => (/* binding */ LANG_LIST),
/* harmony export */   gY_: () => (/* binding */ TONCONNECT_PROTOCOL_VERSION),
/* harmony export */   gbw: () => (/* binding */ AUTO_CONFIRM_DURATION_MINUTES),
/* harmony export */   gmk: () => (/* binding */ IS_AIR_APP),
/* harmony export */   gpw: () => (/* binding */ CHANGELLY_SECURITY_EMAIL),
/* harmony export */   gs5: () => (/* binding */ TON_DNS_ZONES),
/* harmony export */   h4K: () => (/* binding */ TELEGRAM_WEB_URL),
/* harmony export */   hL1: () => (/* binding */ IS_EXTENSION),
/* harmony export */   hUJ: () => (/* binding */ EMBEDDED_DAPP_BRIDGE_CHANNEL),
/* harmony export */   hUs: () => (/* binding */ LANDSCAPE_MIN_ASSETS_TAB_VIEW),
/* harmony export */   hkI: () => (/* binding */ NATIVE_BIOMETRICS_USERNAME),
/* harmony export */   hl5: () => (/* binding */ APP_VERSION),
/* harmony export */   hnd: () => (/* binding */ PROXY_HOSTS),
/* harmony export */   i11: () => (/* binding */ ANIMATION_LEVEL_DEFAULT),
/* harmony export */   iAh: () => (/* binding */ IS_BIP39_MNEMONIC_ENABLED),
/* harmony export */   iX4: () => (/* binding */ DEFAULT_TRX_SWAP_FIRST_TOKEN_SLUG),
/* harmony export */   igk: () => (/* binding */ ANIMATED_STICKER_BIG_SIZE_PX),
/* harmony export */   jht: () => (/* binding */ IS_PACKAGED_ELECTRON),
/* harmony export */   jt9: () => (/* binding */ TRX_SWAP_COUNT_FEE_ADDRESS),
/* harmony export */   jzp: () => (/* binding */ ANIMATED_STICKER_SMALL_SIZE_PX),
/* harmony export */   k9U: () => (/* binding */ DEFAULT_SLIPPAGE_VALUE),
/* harmony export */   kuH: () => (/* binding */ PRICELESS_TOKEN_HASHES),
/* harmony export */   kuw: () => (/* binding */ CHANGELLY_PRIVACY_POLICY),
/* harmony export */   lWW: () => (/* binding */ ANIMATED_STICKER_MIDDLE_SIZE_PX),
/* harmony export */   lfO: () => (/* binding */ TOKEN_INFO),
/* harmony export */   lk4: () => (/* binding */ ANIMATED_STICKER_ICON_PX),
/* harmony export */   lnc: () => (/* binding */ MINT_CARD_ADDRESS),
/* harmony export */   lsx: () => (/* binding */ ETHENA_ELIGIBILITY_CHECK_URL),
/* harmony export */   mEK: () => (/* binding */ HELP_CENTER_URL),
/* harmony export */   n3s: () => (/* binding */ EMPTY_HASH_VALUE),
/* harmony export */   nQN: () => (/* binding */ TON_DNS_COLLECTION),
/* harmony export */   nj6: () => (/* binding */ PORTRAIT_MIN_ASSETS_TAB_VIEW),
/* harmony export */   o$d: () => (/* binding */ CHANGELLY_LIVE_CHAT_URL),
/* harmony export */   oR5: () => (/* binding */ PRIORITY_TOKEN_SLUGS),
/* harmony export */   oUU: () => (/* binding */ MYCOIN),
/* harmony export */   ow1: () => (/* binding */ MNEMONIC_CHECK_COUNT),
/* harmony export */   p8S: () => (/* binding */ IS_PRODUCTION),
/* harmony export */   pLj: () => (/* binding */ NOMINATORS_STAKING_MIN_AMOUNT),
/* harmony export */   pV9: () => (/* binding */ BURN_ADDRESS),
/* harmony export */   pge: () => (/* binding */ GLOBAL_STATE_CACHE_KEY),
/* harmony export */   pyN: () => (/* binding */ MINT_CARD_REFUND_COMMENT),
/* harmony export */   q5n: () => (/* binding */ NFT_FRAGMENT_COLLECTIONS),
/* harmony export */   qL: () => (/* binding */ MTW_CARDS_COLLECTION),
/* harmony export */   qsd: () => (/* binding */ GIVEAWAY_CHECKIN_URL),
/* harmony export */   rFA: () => (/* binding */ APP_COMMIT_HASH),
/* harmony export */   rKC: () => (/* binding */ DEFAULT_SWAP_SECOND_TOKEN_SLUG),
/* harmony export */   rUK: () => (/* binding */ TON_USDT_SLUG),
/* harmony export */   reE: () => (/* binding */ ANIMATED_STICKER_HUGE_SIZE_PX),
/* harmony export */   rkj: () => (/* binding */ STRICTERDOM_ENABLED),
/* harmony export */   sml: () => (/* binding */ MINT_CARD_COMMENT),
/* harmony export */   tCm: () => (/* binding */ INIT_SWAP_ASSETS),
/* harmony export */   tI4: () => (/* binding */ TON_DNS_RENEWAL_NFT_WARNING_DAYS),
/* harmony export */   tKX: () => (/* binding */ IS_TELEGRAM_APP),
/* harmony export */   tOu: () => (/* binding */ ACTIVE_TAB_STORAGE_KEY),
/* harmony export */   tpB: () => (/* binding */ MYTONWALLET_PROMO_URL),
/* harmony export */   twH: () => (/* binding */ DEBUG_VIEW_ACCOUNTS),
/* harmony export */   uPU: () => (/* binding */ ALL_STAKING_POOLS),
/* harmony export */   uSm: () => (/* binding */ BROWSER_HISTORY_LIMIT),
/* harmony export */   uyj: () => (/* binding */ ELECTRON_HOST_URL),
/* harmony export */   v5B: () => (/* binding */ IS_FIREFOX_EXTENSION),
/* harmony export */   vOV: () => (/* binding */ APP_ENV_MARKER),
/* harmony export */   vdF: () => (/* binding */ MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT),
/* harmony export */   vsz: () => (/* binding */ TRC20_USDT_TESTNET_SLUG),
/* harmony export */   wOb: () => (/* binding */ DEFAULT_PRICE_CURRENCY),
/* harmony export */   wbd: () => (/* binding */ TON_DNS_RENEWAL_WARNING_DAYS),
/* harmony export */   wg4: () => (/* binding */ ANIMATED_STICKER_TINY_ICON_PX),
/* harmony export */   wln: () => (/* binding */ GETGEMS_BASE_MAINNET_URL),
/* harmony export */   wpN: () => (/* binding */ TON_USDE),
/* harmony export */   xA_: () => (/* binding */ MNEMONIC_COUNT),
/* harmony export */   xB5: () => (/* binding */ ANIMATION_END_DELAY),
/* harmony export */   xFF: () => (/* binding */ STARS_SYMBOL),
/* harmony export */   yR2: () => (/* binding */ CURRENCIES),
/* harmony export */   yq6: () => (/* binding */ PRODUCTION_URL),
/* harmony export */   zHL: () => (/* binding */ ANIMATION_LEVEL_MED),
/* harmony export */   zP3: () => (/* binding */ ANIMATION_LEVEL_MAX),
/* harmony export */   zTb: () => (/* binding */ AUTOLOCK_OPTIONS_LIST),
/* harmony export */   zll: () => (/* binding */ CHAIN_CONFIG)
/* harmony export */ });
/* unused harmony exports EXTENSION_NAME, EXTENSION_DESCRIPTION, IS_PERF, BASE_URL, SWAP_FEE_ADDRESS, DIESEL_ADDRESS, ANIMATED_STICKER_DEFAULT_PX, DEFAULT_PORTRAIT_WINDOW_SIZE, DEFAULT_LANDSCAPE_WINDOW_SIZE, TONCENTER_MAINNET_URL, TONCENTER_MAINNET_KEY, ELECTRON_TONCENTER_MAINNET_KEY, TONAPIIO_MAINNET_URL, TONCENTER_TESTNET_URL, TONCENTER_TESTNET_KEY, ELECTRON_TONCENTER_TESTNET_KEY, TONAPIIO_TESTNET_URL, BRILLIANT_API_BASE_URL, PROXY_API_BASE_URL, IPFS_GATEWAY_BASE_URL, SSE_BRIDGE_URL, TRON_MAINNET_API_URL, TRON_TESTNET_API_URL, MTW_STATIC_BASE_URL, UNSTAKE_TON_GRACE_PERIOD, STAKING_POOLS, LIQUID_POOL, LIQUID_JETTON, NFT_FRAGMENT_GIFT_IMAGE_TO_URL_REGEX, STAKED_MYCOIN_SLUG, MYCOIN_STAKING_POOL, ETHENA_STAKING_VAULT, SWAP_CROSSCHAIN_SLUGS, STON_PTON_ADDRESS, DNS_IMAGE_GEN_URL, TON_USDT, TON_TSUSDE, INDEXED_DB_NAME, INDEXED_DB_STORE_NAME, WINDOW_PROVIDER_PORT, DEFAULT_WALLET_VERSION, LEDGER_WALLET_VERSIONS, DEFAULT_TIMEOUT, DEFAULT_RETRIES, DEFAULT_ERROR_PAUSE, NOTCOIN_FORWARD_TON_AMOUNT, RE_LINK_TEMPLATE, RE_TG_BOT_MENTION, TONCENTER_ACTIONS_VERSION */
/* provided dependency */ var process = __webpack_require__(65606);
const APP_ENV = "development";
const IS_CORE_WALLET = "false" === '1';
const APP_NAME =  false || (IS_CORE_WALLET ? 'TON Wallet' : 'MyTonWallet');
const APP_VERSION = "4.1.3";
const APP_COMMIT_HASH = "03658ae9f7caa469fa0be2af5b3d6100b73de790";
const APP_ENV_MARKER = APP_ENV === 'staging' ? 'Beta' : APP_ENV === 'development' ? 'Dev' : undefined;
const EXTENSION_NAME = (/* unused pure expression or super */ null && (IS_CORE_WALLET ? 'TON Wallet' : 'MyTonWallet Â· My TON Wallet'));
const EXTENSION_DESCRIPTION = (/* unused pure expression or super */ null && (IS_CORE_WALLET ? 'Set up your own TON Wallet on The Open Network'
// eslint-disable-next-line @stylistic/max-len
: 'The most feature-rich TON+TRON wallet: multi-accounts, multi-send, Telegram Gifts and other collectibles, TON DNS+Proxy, and more.'));
const DEBUG = APP_ENV !== 'production' && APP_ENV !== 'perf' && APP_ENV !== 'test';
const DEBUG_MORE = false;
const DEBUG_API = false;
const DEBUG_VIEW_ACCOUNTS = false;
const IS_PRODUCTION = APP_ENV === 'production';
const IS_TEST = APP_ENV === 'test';
const IS_PERF = APP_ENV === 'perf';
const IS_EXTENSION = "" === '1';
const IS_FIREFOX_EXTENSION = "false" === '1';
const IS_OPERA_EXTENSION = process.env.IS_OPERA_EXTENSION === '1';
const IS_PACKAGED_ELECTRON = "false" === '1';
const IS_CAPACITOR = "false" === '1';
const IS_ANDROID_DIRECT = "false" === '1';
const IS_AIR_APP = "false" === '1';
const IS_TELEGRAM_APP = "1" === '1';
const ELECTRON_HOST_URL = 'https://dumb-host';
const INACTIVE_MARKER = '[Inactive]';
const PRODUCTION_URL = IS_CORE_WALLET ? 'https://wallet.ton.org' : 'https://mytonwallet.app';
const BETA_URL = IS_CORE_WALLET ? 'https://beta.wallet.ton.org' : 'https://beta.mytonwallet.app';
const APP_INSTALL_URL = 'https://get.mytonwallet.io/';
const APP_REPO_URL = 'https://github.com/mytonwallet-org/mytonwallet';
const BASE_URL = (/* unused pure expression or super */ null && ("https://mytonwallet.app"));
const BOT_USERNAME =  false || 'MyTonWalletBot';
const SWAP_FEE_ADDRESS = (/* unused pure expression or super */ null && ( false || 'UQDUkQbpTVIgt7v66-JTFR-3-eXRFz_4V66F-Ufn6vOg0GOp'));
const DIESEL_ADDRESS = (/* unused pure expression or super */ null && ( false || 'UQC9lQOaEHC6YASiJJ2NrKEOlITMMQmc8j0_iZEHy-4sl3tG'));
const STRICTERDOM_ENABLED = DEBUG && !IS_PACKAGED_ELECTRON;
const DEBUG_ALERT_MSG = 'Shoot!\nSomething went wrong, please see the error details in Dev Tools Console.';
const PIN_LENGTH = 4;
const NATIVE_BIOMETRICS_USERNAME = IS_CORE_WALLET ? 'TonWallet' : 'MyTonWallet';
const NATIVE_BIOMETRICS_SERVER = IS_CORE_WALLET ? 'https://wallet.ton.org' : 'https://mytonwallet.app';
const IS_BIP39_MNEMONIC_ENABLED = !IS_CORE_WALLET;
const MNEMONIC_COUNT = 24;
const MNEMONIC_COUNTS = IS_BIP39_MNEMONIC_ENABLED ? [12, 24] : [24];
const PRIVATE_KEY_HEX_LENGTH = 64;
const MNEMONIC_CHECK_COUNT = 3;
const MOBILE_SCREEN_MAX_WIDTH = 700; // px

const ANIMATION_END_DELAY = 50;
const ANIMATED_STICKER_TINY_ICON_PX = 16;
const ANIMATED_STICKER_ICON_PX = 30;
const ANIMATED_STICKER_TINY_SIZE_PX = 70;
const ANIMATED_STICKER_SMALL_SIZE_PX = 110;
const ANIMATED_STICKER_MIDDLE_SIZE_PX = 120;
const ANIMATED_STICKER_DEFAULT_PX = 150;
const ANIMATED_STICKER_BIG_SIZE_PX = 156;
const ANIMATED_STICKER_HUGE_SIZE_PX = 192;
const DEFAULT_PORTRAIT_WINDOW_SIZE = {
  width: 368,
  height: 770
};
const DEFAULT_LANDSCAPE_WINDOW_SIZE = {
  width: 980,
  height: 788
};
const DEFAULT_LANDSCAPE_ACTION_TAB_ID = 0;
const TRANSACTION_ADDRESS_SHIFT = 4;
const WHOLE_PART_DELIMITER = 'â€¯'; // https://www.compart.com/en/unicode/U+202F

const DEFAULT_SLIPPAGE_VALUE = 5;
const GLOBAL_STATE_CACHE_DISABLED = false;
const GLOBAL_STATE_CACHE_KEY = IS_CORE_WALLET ? 'tonwallet-global-state' : 'mytonwallet-global-state';
const ANIMATION_LEVEL_MIN = 0;
const ANIMATION_LEVEL_MED = 1;
const ANIMATION_LEVEL_MAX = 2;
const ANIMATION_LEVEL_DEFAULT = ANIMATION_LEVEL_MAX;
const THEME_DEFAULT = 'system';
const MAIN_ACCOUNT_ID = '0-ton-mainnet';
const TONCENTER_MAINNET_URL = (/* unused pure expression or super */ null && ("https://toncenter.mytonwallet.org" || 0));
const TONCENTER_MAINNET_KEY = (/* unused pure expression or super */ null && (""));
const ELECTRON_TONCENTER_MAINNET_KEY = (/* unused pure expression or super */ null && (""));
const TONAPIIO_MAINNET_URL = (/* unused pure expression or super */ null && ("https://tonapiio.mytonwallet.org" || 0));
const TONCENTER_TESTNET_URL = (/* unused pure expression or super */ null && ("https://toncenter-testnet.mytonwallet.org" || 0));
const TONCENTER_TESTNET_KEY = (/* unused pure expression or super */ null && ("cd6d372885d0ebc7bbd92d55f3d3121068ab75daac4ca6192e966106e3ff10d3"));
const ELECTRON_TONCENTER_TESTNET_KEY = (/* unused pure expression or super */ null && (""));
const TONAPIIO_TESTNET_URL = (/* unused pure expression or super */ null && ("https://tonapiio-testnet.mytonwallet.org" || 0));
const BRILLIANT_API_BASE_URL = (/* unused pure expression or super */ null && ( false || 'https://api.mytonwallet.org'));
const PROXY_API_BASE_URL = (/* unused pure expression or super */ null && ( false || 'https://api.mytonwallet.org/proxy'));
const IPFS_GATEWAY_BASE_URL = 'https://ipfs.io/ipfs/';
const SSE_BRIDGE_URL = 'https://tonconnectbridge.mytonwallet.org/bridge/';
const TRON_MAINNET_API_URL =  false || 'https://tronapi.mytonwallet.org';
const TRON_TESTNET_API_URL =  false || 'https://api.shasta.trongrid.io';
const FRACTION_DIGITS = 9;
const SHORT_FRACTION_DIGITS = 2;
const MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT = 3;
const SUPPORT_USERNAME = 'mysupport';
const MTW_TIPS_CHANNEL_NAME = {
  en: 'MyTonWalletTips',
  ru: 'MyTonWalletTipsRu'
};
const NFT_MARKETPLACE_TITLES = {
  getgems: 'Getgems',
  fragment: 'Fragment'
};
const MTW_STATIC_BASE_URL = 'https://static.mytonwallet.org';
const MTW_CARDS_BASE_URL = `${MTW_STATIC_BASE_URL}/cards/`;
const MTW_CARDS_MINT_BASE_URL = `${MTW_STATIC_BASE_URL}/mint-cards/`;
const MYTONWALLET_PROMO_URL = 'https://mytonwallet.io/';
const MYTONWALLET_MULTISEND_DAPP_URL = 'https://multisend.mytonwallet.io/';
const TELEGRAM_WEB_URL = 'https://web.telegram.org/a/';
const NFT_MARKETPLACE_URL = 'https://getgems.io/';
const NFT_MARKETPLACE_TITLE = NFT_MARKETPLACE_TITLES.getgems;
const GETGEMS_BASE_MAINNET_URL = 'https://getgems.io/';
const GETGEMS_BASE_TESTNET_URL = 'https://testnet.getgems.io/';
const EMPTY_HASH_VALUE = 'NOHASH';
const IFRAME_WHITELIST = ['http://localhost:*', 'https://tonscan.org'];
const SUBPROJECT_URL_MASK = 'https://*.mytonwallet.io';
const CHANGELLY_SUPPORT_EMAIL = 'support@changelly.com';
const CHANGELLY_LIVE_CHAT_URL = 'https://changelly.com/';
const CHANGELLY_SECURITY_EMAIL = 'security@changelly.com';
const CHANGELLY_TERMS_OF_USE = 'https://changelly.com/terms-of-use';
const CHANGELLY_PRIVACY_POLICY = 'https://changelly.com/privacy-policy';
const CHANGELLY_AML_KYC = 'https://changelly.com/aml-kyc';
const CHANGELLY_WAITING_DEADLINE = 3 * 60 * 60 * 1000; // 3 hours

const PROXY_HOSTS = "tonproxy.io:38080 tonproxy.io:38081 tonproxy.io:38082";
const TINY_TRANSFER_MAX_COST = 0.01;
const IMAGE_CACHE_NAME = 'mtw-image';
const LANG_CACHE_NAME = 'mtw-lang-232';
const LANG_LIST = [{
  langCode: 'en',
  name: 'English',
  nativeName: 'English',
  rtl: false
}, {
  langCode: 'es',
  name: 'Spanish',
  nativeName: 'EspaÃ±ol',
  rtl: false
}, {
  langCode: 'ru',
  name: 'Russian',
  nativeName: 'Ð ÑƒÑÑÐºÐ¸Ð¹',
  rtl: false
}, {
  langCode: 'zh-Hans',
  name: 'Chinese (Simplified)',
  nativeName: 'ç®€ä½“',
  rtl: false
}, {
  langCode: 'zh-Hant',
  name: 'Chinese (Traditional)',
  nativeName: 'ç¹é«”',
  rtl: false
}, {
  langCode: 'tr',
  name: 'Turkish',
  nativeName: 'TÃ¼rkÃ§e',
  rtl: false
}, {
  langCode: 'de',
  name: 'German',
  nativeName: 'Deutsch',
  rtl: false
}, {
  langCode: 'th',
  name: 'Thai',
  nativeName: 'à¹„à¸—à¸¢',
  rtl: false
}, {
  langCode: 'uk',
  name: 'Ukrainian',
  nativeName: 'Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°',
  rtl: false
}, {
  langCode: 'pl',
  name: 'Polish',
  nativeName: 'Polski',
  rtl: false
}];
const IS_STAKING_DISABLED = IS_CORE_WALLET;
const VALIDATION_PERIOD_MS = 65_536_000; // 18.2 h.
const ONE_TON = 1_000_000_000n;
const DEFAULT_FEE = 15_000_000n; // 0.015 TON
const UNSTAKE_TON_GRACE_PERIOD = (/* unused pure expression or super */ null && (20 * 60 * 1000)); // 20 m.

const STAKING_POOLS =  false ? 0 : [];
const LIQUID_POOL =  false || 'EQD2_4d91M4TVbEBVyBF8J1UwpMJc361LKVCz6bBlffMW05o';
const LIQUID_JETTON = (/* unused pure expression or super */ null && ( false || 'EQCqC6EhRJ_tpWngKxL6dV0k6DSnRUrs9GSVkLbfdCqsj6TE'));
const STAKING_MIN_AMOUNT = ONE_TON;
const NOMINATORS_STAKING_MIN_AMOUNT = 10_000n * ONE_TON;
const MIN_ACTIVE_STAKING_REWARDS = 100_000_000n; // 0.1 MY

const TONCONNECT_PROTOCOL_VERSION = 2;
const TONCONNECT_WALLET_JSBRIDGE_KEY = IS_CORE_WALLET ? 'tonwallet' : 'mytonwallet';
const EMBEDDED_DAPP_BRIDGE_CHANNEL = 'embedded-dapp-bridge';
const NFT_FRAGMENT_COLLECTIONS = ['0:0e41dc1dc3c9067ed24248580e12b3359818d83dee0304fabcf80845eafafdb2',
// Anonymous Telegram Numbers
'0:80d78a35f955a14b679faa887ff4cd5bfc0f43b4a4eea2a7e6927f3701b273c2' // Telegram Usernames
];
const NFT_FRAGMENT_GIFT_IMAGE_TO_URL_REGEX = /^https?:\/\/nft\.(fragment\.com\/gift\/[\w-]+-\d+)\.\w+$/i;
const TELEGRAM_GIFTS_SUPER_COLLECTION = 'super:telegram-gifts';
const MTW_CARDS_WEBSITE = 'https://cards.mytonwallet.io';
const MTW_CARDS_COLLECTION = 'EQCQE2L9hfwx1V8sgmF9keraHx1rNK9VmgR1ctVvINBGykyM';
const TON_DNS_COLLECTION = 'EQC3dNlesgVD8YbAazcauIrXBPfiVhMMr5YYk2in0Mtsz0Bz';
const TON_DNS_RENEWAL_WARNING_DAYS = 14;
const TON_DNS_RENEWAL_NFT_WARNING_DAYS = 30;
const TONCOIN = {
  name: 'Toncoin',
  symbol: 'TON',
  slug: 'toncoin',
  decimals: 9,
  chain: 'ton',
  cmcSlug: 'toncoin'
};
const TRX = {
  name: 'TRON',
  symbol: 'TRX',
  slug: 'trx',
  decimals: 6,
  chain: 'tron',
  cmcSlug: 'tron'
};
const MYCOIN = {
  name: 'MyTonWallet Coin',
  symbol: 'MY',
  slug: 'ton-eqcfvnlrbn',
  decimals: 9,
  chain: 'ton',
  minterAddress: 'EQCFVNlRb-NHHDQfv3Q9xvDXBLJlay855_xREsq5ZDX6KN-w'
};
const MYCOIN_TESTNET = {
  ...MYCOIN,
  slug: 'ton-kqawlxpebw',
  minterAddress: 'kQAWlxpEbwhCDFX9gp824ee2xVBhAh5VRSGWfbNFDddAbQoQ'
};
const CHAIN_CONFIG = {
  ton: {
    isMemoSupported: true,
    isDnsSupported: true,
    addressRegex: /^([-\w_]{48}|0:[\da-h]{64})$/i,
    addressPrefixRegex: /^([-\w_]{1,48}|0:[\da-h]{0,64})$/i,
    nativeToken: TONCOIN
  },
  tron: {
    isMemoSupported: false,
    isDnsSupported: false,
    addressRegex: /^T[1-9A-HJ-NP-Za-km-z]{33}$/,
    addressPrefixRegex: /^T[1-9A-HJ-NP-Za-km-z]{0,33}$/,
    nativeToken: TRX,
    mainnet: {
      apiUrl: TRON_MAINNET_API_URL,
      usdtAddress: 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t'
    },
    testnet: {
      apiUrl: TRON_TESTNET_API_URL,
      usdtAddress: 'TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs'
    }
  }
};
const TRC20_USDT_MAINNET_SLUG = 'tron-tr7nhqjekq';
const TRC20_USDT_TESTNET_SLUG = 'tron-tg3xxyexbk';
const TON_USDT_SLUG = 'ton-eqcxe6mutq';
const STAKED_TON_SLUG = 'ton-eqcqc6ehrj';
const STAKED_MYCOIN_SLUG = 'ton-eqcbzvsfwq';
const TRX_SWAP_COUNT_FEE_ADDRESS = 'TW2LXSebZ7Br1zHaiA2W1zRojDkDwjGmpw';
const MYCOIN_STAKING_POOL = 'EQC3roTiRRsoLzfYVK7yVVoIZjTEqAjQU3ju7aQ7HWTVL5o5';
const ETHENA_STAKING_VAULT = 'EQChGuD1u0e7KUWHH5FaYh_ygcLXhsdG2nSHPXHW8qqnpZXW';
const ETHENA_STAKING_MIN_AMOUNT = 1_000_000; // 1 USDe
// eslint-disable-next-line @stylistic/max-len
const ETHENA_ELIGIBILITY_CHECK_URL = 'https://t.me/id_app/start?startapp=cQeewNnc3pVphUcwY63WruKMQDpgePd1E7eMVoqphMZAdGoU9jwS4qRqrM1kSeaqrAiiDiC3EYAJPwZDGWqxZpw5vtGxmHma59XEt';

// In cross-chain swaps, only a few TON/TRON tokens are available.
// Itâ€™s not optimal to request swap history for all the others.
const SWAP_CROSSCHAIN_SLUGS = new Set([TONCOIN.slug, TON_USDT_SLUG, TRX.slug, TRC20_USDT_MAINNET_SLUG]);
const STON_PTON_ADDRESS = 'EQCM3B12QK1e4yZSf8GtBRT0aLMNyEsBc_DhVfRRtOEffLez';
const STON_PTON_SLUG = 'ton-eqcm3b12qk';
const DNS_IMAGE_GEN_URL = 'https://dns-image.mytonwallet.org/img?d=';
const TRC20_USDT = {
  name: 'Tether USD',
  symbol: 'USDT',
  decimals: 6,
  chain: 'tron'
};
const TON_USDT = {
  name: 'Tether USD',
  symbol: 'USDâ‚®',
  chain: 'ton',
  slug: TON_USDT_SLUG,
  decimals: 6,
  tokenAddress: 'EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs'
};
const TON_USDE = {
  name: 'Ethena USDe',
  symbol: 'USDe',
  chain: 'ton',
  tokenAddress: 'EQAIb6KmdfdDR7CN1GBqVJuP25iCnLKCvBlJ07Evuu2dzP5f',
  slug: 'ton-eqaib6kmdf',
  decimals: 6,
  // eslint-disable-next-line @stylistic/max-len
  image: 'https://imgproxy.toncenter.com/binMwUmcnFtjvgjp4wSEbsECXwfXUwbPkhVvsvpubNw/pr:small/aHR0cHM6Ly9tZXRhZGF0YS5sYXllcnplcm8tYXBpLmNvbS9hc3NldHMvVVNEZS5wbmc'
};
const TON_TSUSDE = {
  name: 'Ethena tsUSDe',
  symbol: 'tsUSDe',
  chain: 'ton',
  tokenAddress: 'EQDQ5UUyPHrLcQJlPAczd_fjxn8SLrlNQwolBznxCdSlfQwr',
  slug: 'ton-eqdq5uuyph',
  decimals: 6,
  // eslint-disable-next-line @stylistic/max-len
  image: 'https://cache.tonapi.io/imgproxy/vGZJ7erwsWPo7DpVG_V7ygNn7VGs0szZXcNLHB_l0ms/rs:fill:200:200:1/g:no/aHR0cHM6Ly9tZXRhZGF0YS5sYXllcnplcm8tYXBpLmNvbS9hc3NldHMvdHNVU0RlLnBuZw.webp'
};
const ALL_STAKING_POOLS = [LIQUID_POOL, MYCOIN_STAKING_POOL, ETHENA_STAKING_VAULT, TON_TSUSDE.tokenAddress];
const DEFAULT_ENABLED_TOKEN_SLUGS = [TONCOIN.slug, TON_USDT_SLUG, TRX.slug, TRC20_USDT_TESTNET_SLUG, TRC20_USDT_MAINNET_SLUG];

// Toncoin, USDT TON, TRX, USDT TRC20
const DEFAULT_ENABLED_TOKEN_COUNT = 4;
const PRIORITY_TOKEN_SLUGS = [TONCOIN.slug, TON_USDT_SLUG, TRX.slug];
const COMMON_TOKEN = {
  isFromBackend: true,
  price: 0,
  priceUsd: 0,
  percentChange24h: 0
};
const TOKEN_INFO = {
  toncoin: {
    ...TONCOIN,
    isFromBackend: true,
    price: 3.1,
    priceUsd: 3.1,
    percentChange24h: 0
  },
  trx: {
    ...TRX,
    ...COMMON_TOKEN
  },
  [TRC20_USDT_MAINNET_SLUG]: {
    // mainnet
    ...TRC20_USDT,
    slug: TRC20_USDT_MAINNET_SLUG,
    tokenAddress: 'TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t',
    ...COMMON_TOKEN
  },
  [TRC20_USDT_TESTNET_SLUG]: {
    // testnet
    ...TRC20_USDT,
    slug: TRC20_USDT_TESTNET_SLUG,
    tokenAddress: 'TG3XXyExBkPp9nzdajDZsozEu4BkaSJozs',
    ...COMMON_TOKEN
  },
  [TON_USDT_SLUG]: {
    ...TON_USDT,
    // eslint-disable-next-line @stylistic/max-len
    image: 'https://cache.tonapi.io/imgproxy/T3PB4s7oprNVaJkwqbGg54nexKE0zzKhcrPv8jcWYzU/rs:fill:200:200:1/g:no/aHR0cHM6Ly90ZXRoZXIudG8vaW1hZ2VzL2xvZ29DaXJjbGUucG5n.webp',
    slug: TON_USDT_SLUG,
    ...COMMON_TOKEN
  },
  [MYCOIN.slug]: {
    ...MYCOIN,
    // eslint-disable-next-line @stylistic/max-len
    image: 'https://cache.tonapi.io/imgproxy/Qy038wCBKISofJ0hYMlj6COWma330cx3Ju1ZSPM2LRU/rs:fill:200:200:1/g:no/aHR0cHM6Ly9teXRvbndhbGxldC5pby9sb2dvLTI1Ni1ibHVlLnBuZw.webp',
    ...COMMON_TOKEN
  },
  [TON_USDE.slug]: {
    ...TON_USDE,
    ...COMMON_TOKEN
  },
  [TON_TSUSDE.slug]: {
    ...TON_TSUSDE,
    ...COMMON_TOKEN
  }
};
const TOKEN_WITH_LABEL = {
  [TRC20_USDT_MAINNET_SLUG]: 'TRC-20',
  [TRC20_USDT_TESTNET_SLUG]: 'TRC-20',
  [TON_USDT_SLUG]: 'TON'
};
const INIT_SWAP_ASSETS = {
  toncoin: {
    name: 'Toncoin',
    symbol: TONCOIN.symbol,
    chain: TONCOIN.chain,
    slug: TONCOIN.slug,
    decimals: TONCOIN.decimals,
    price: 0,
    priceUsd: 0,
    isPopular: true
  },
  [TON_USDT_SLUG]: {
    name: 'Tether USD',
    symbol: 'USDâ‚®',
    chain: 'ton',
    slug: TON_USDT_SLUG,
    decimals: 9,
    // eslint-disable-next-line @stylistic/max-len
    image: 'https://cache.tonapi.io/imgproxy/T3PB4s7oprNVaJkwqbGg54nexKE0zzKhcrPv8jcWYzU/rs:fill:200:200:1/g:no/aHR0cHM6Ly90ZXRoZXIudG8vaW1hZ2VzL2xvZ29DaXJjbGUucG5n.webp',
    tokenAddress: 'EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs',
    price: 0,
    priceUsd: 0,
    isPopular: true
  }
};
const DEFAULT_TRX_SWAP_FIRST_TOKEN_SLUG = TONCOIN.slug;
const DEFAULT_SWAP_FIRST_TOKEN_SLUG = TONCOIN.slug;
const DEFAULT_SWAP_SECOND_TOKEN_SLUG = TON_USDT_SLUG;
const DEFAULT_TRANSFER_TOKEN_SLUG = TONCOIN.slug;
const DEFAULT_CEX_SWAP_SECOND_TOKEN_SLUG = TRC20_USDT_MAINNET_SLUG;
const SWAP_DEX_LABELS = {
  dedust: 'DeDust',
  ston: 'STON.fi'
};
const MULTITAB_DATA_CHANNEL_NAME = IS_CORE_WALLET ? 'tw-multitab' : 'mtw-multitab';
const ACTIVE_TAB_STORAGE_KEY = IS_CORE_WALLET ? 'tw-active-tab' : 'mtw-active-tab';
const INDEXED_DB_NAME = 'keyval-store';
const INDEXED_DB_STORE_NAME = 'keyval';
const WINDOW_PROVIDER_CHANNEL = 'windowProvider';
const WINDOW_PROVIDER_PORT = (/* unused pure expression or super */ null && (`${IS_CORE_WALLET ? 'TonWallet' : 'MyTonWallet'}_popup_reversed`));
const SHOULD_SHOW_ALL_ASSETS_AND_ACTIVITY = IS_CORE_WALLET;
const PORTRAIT_MIN_ASSETS_TAB_VIEW = 4;
const LANDSCAPE_MIN_ASSETS_TAB_VIEW = 6;
const DEFAULT_PRICE_CURRENCY = 'USD';
const CURRENCIES = {
  USD: {
    name: 'US Dollar',
    decimals: 2,
    shortSymbol: '$'
  },
  EUR: {
    name: 'Euro',
    decimals: 2,
    shortSymbol: 'â‚¬'
  },
  RUB: {
    name: 'Ruble',
    decimals: 2,
    shortSymbol: 'â‚½'
  },
  CNY: {
    name: 'Yuan',
    decimals: 2,
    shortSymbol: 'Â¥'
  },
  BTC: {
    name: 'Bitcoin',
    decimals: 9
  },
  [TONCOIN.symbol]: {
    name: 'Toncoin',
    decimals: 9
  }
};
const BURN_ADDRESS = 'UQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJKZ';
const DEFAULT_WALLET_VERSION = 'W5';
const POPULAR_WALLET_VERSIONS = ['v3R1', 'v3R2', 'v4R2', 'W5'];
const LEDGER_WALLET_VERSIONS = (/* unused pure expression or super */ null && (['v3R2', 'v4R2']));
const DEFAULT_TIMEOUT = 10000;
const DEFAULT_RETRIES = 3;
const DEFAULT_ERROR_PAUSE = 500;
const HISTORY_PERIODS = ['1D', '7D', '1M', '3M', '1Y', 'ALL'];
const BROWSER_HISTORY_LIMIT = 10;
const NFT_BATCH_SIZE = 4;
const NOTCOIN_VOUCHERS_ADDRESS = 'EQDmkj65Ab_m0aZaW8IpKw4kYqIgITw_HRstYEkVQ6NIYCyW';
const BURN_CHUNK_DURATION_APPROX_SEC = 30;
const NOTCOIN_FORWARD_TON_AMOUNT = 30000000n; // 0.03 TON
const NOTCOIN_EXCHANGERS = ['EQAPZauWVPUcm2hUJT9n36pxznEhl46rEn1bzBXN0RY_yiy2', 'EQASgm0Qv3h2H2mF0W06ikPqYq2ctT3dyXMJH_svbEKKB3iZ', 'EQArlmP-RhVIG2yAFGZyPZfM3m0YccxmpvoRi6sgRzWnAA0s', 'EQA6pL-spYqZp1Ck6o3rpY45Cl-bvLMW_j3qdVejOkUWpLnm', 'EQBJ_ehYjumQKbXfWUue1KHKXdTm1GuYJB0Fj2ST_DwORvpd', 'EQBRmYSjxh9xlZpUqEmGjF5UjukI9v_Cm2kCTu4CoBn3XkOD', 'EQBkiqncd7AFT5_23H-RoA2Vynk-Nzq_dLoeMVRthAU9RF0p', 'EQB_OzTHXbztABe0QHgr4PtAV8T64LR6aDunXgaAoihOdxwO', 'EQCL-x5kLg6tKVNGryItTuj6tG3FH5mhUEu0xRqQc-kbEmbe', 'EQCZh2yJ46RaQH3AYmjEA8SMMXi77Oein4-3lvqkHseIAhD-', 'EQChKo5IK3iNqUHUGDB9gtzjCjMTPtmsFqekuCA2MdreVEyu', 'EQC6DNCBv076TIliRMfOt20RpbS7rNKDfSky3WrFEapFt8AH', 'EQDE_XFZOYae_rl3ZMsgBCtRSmYhl8B4y2BZEP7oiGBDhlgy', 'EQDddqpGA2ePXQF47A2DSL3GF6ZzIVmimfM2d16cdymy2noT', 'EQDv0hNNAamhYltCh3pTJrq3oRB9RW2ZhEYkTP6fhj5BtZNu', 'EQD2mP7zgO7-imUJhqYry3i07aJ_SR53DaokMupfAAobt0Xw'];
const CLAIM_ADDRESS = 'EQB3zOTvPi1PmwdcTpqSfFKZnhi1GNKEVJM-LdoAirdLtash';
const CLAIM_AMOUNT = 30000000n; // 0.03 TON
const CLAIM_COMMENT = 'claim';
const MINT_CARD_ADDRESS = 'EQBpst3ZWJ9Dqq5gE2YH-yPsFK_BqMOmgi7Z_qK6v7WbrPWv';
const MINT_CARD_COMMENT = 'Mint card';
const MINT_CARD_REFUND_COMMENT = 'Refund';

// eslint-disable-next-line @stylistic/max-len
const RE_LINK_TEMPLATE = /((ftp|https?):\/\/)?(?<host>(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z][-a-zA-Z0-9]{1,62})\b([-a-zA-Z0-9()@:%_+.,~#?&/=]*)/g;
// eslint-disable-next-line @stylistic/max-len
const RE_TG_BOT_MENTION = /telegram[:\s-]*((@[a-z0-9_]+)|(https:\/\/)?(t\.me|telegram\.me|telegram\.dog)\/[a-z0-9_]+)/mig;
const STARS_SYMBOL = 'â­ï¸';
const GIVEAWAY_CHECKIN_URL =  false || 'https://giveaway.mytonwallet.io';
const AUTOLOCK_OPTIONS_LIST = [{
  value: 'never',
  name: 'Disabled',
  selectedName: 'Disabled',
  period: 0
}, {
  value: '1',
  name: '30 seconds',
  selectedName: 'If away for 30 sec',
  period: 30_000
}, {
  value: '2',
  name: '3 minutes',
  selectedName: 'If away for 3 min',
  period: 60_000 * 3
}, {
  value: '3',
  name: '10 minutes',
  selectedName: 'If away for 10 min',
  period: 60_000 * 10
}];
const AUTO_CONFIRM_DURATION_MINUTES = 5;
const PRICELESS_TOKEN_HASHES = new Set(['173e31eee054cb0c76f77edc7956bed766bf48a1f63bd062d87040dcd3df700f',
// FIVA SY tsTON EQAxGi9Al7hamLAORroxGkvfap6knGyzI50ThkP3CLPLTtOZ
'5226dd4e6db9af26b24d5ca822bc4053b7e08152f923932abf25030c7e38bb42',
// FIVA PT tsTON EQAkxIRGXgs2vD2zjt334MBjD3mXg2GsyEZHfzuYX_trQkFL
'fea2c08a704e5192b7f37434927170440d445b87aab865c3ea2a68abe7168204',
// FIVA YT tsTON EQAcy60qg22RCq87A_qgYK8hooEgjCZ44yxhdnKYdlWIfKXL
'e691cf9081a8aeb22ed4d94829f6626c9d822752e035800b5543c43f83d134b5',
// FIVA LP tsTON EQD3BjCjxuf8mu5kvxajVbe-Ila1ScZZlAi03oS7lMmAJjM3
'301ce25925830d713b326824e552e962925c4ff45b1e3ea21fc363a459a49b43',
// FIVA SY eUSDT EQDi9blCcyT-k8iMpFMYY0t7mHVyiCB50ZsRgyUECJDuGvIl
'02250f83fbb8624d859c2c045ac70ee2b3b959688c3d843aec773be9b36dbfc3',
// FIVA PT eUSDT EQBzVrYkYPHx8D_HPfQacm1xONa4XSRxl826vHkx_laP2HOe
'dba3adb2c917db80fd71a6a68c1fc9e12976491a8309d5910f9722efc084ce4d',
// FIVA YT eUSDT EQCwUSc2qrY5rn9BfFBG9ARAHePTUvITDl97UD0zOreWzLru
'7da9223b90984d6a144e71611a8d7c65a6298cad734faed79438dc0f7a8e53d1',
// FIVA LP eUSDT EQBNlIZxIbQGQ78cXgG3VRcyl8A0kLn_6BM9kabiHHhWC4qY
'ddf80de336d580ab3c11d194f189c362e2ca1225cae224ea921deeaba7eca818',
// tsUSDe EQDQ5UUyPHrLcQJlPAczd_fjxn8SLrlNQwolBznxCdSlfQwr
'eb9d9891a32ec94425c09735f6ade73f4c171da0091f874d6e9d25247d583990',
// Affluent TON Lending Vault EQADQ6JcK0NMuNM5uwCcS9bjcn2RTvcxYIZjNlhIhywUrfBN
'f66c149de251ffd031bdb34b79abe43a062ba16b815433691e3ec40a77f01d71',
// Affluent Ethena Multiply Vault EQDXmtbt1-WSP00tSh6N6FH-4lX7LbnrjORClmtmuZqg4Ymm
'bca42dbdcbc0d885aaffb1eeeb027d9f338c2dd68701a05641c1d1c3171a7400' // Affluent TON Multiply Vault EQDtxQqkgIRQQR5hWlrQxiJMtLwjR3rEYNUBbEcvPDwCs1Ng
]);
const STAKED_TOKEN_SLUGS = new Set([STAKED_TON_SLUG, STAKED_MYCOIN_SLUG, TON_TSUSDE.slug]);
const DEFAULT_OUR_SWAP_FEE = 0.875;
const DEFAULT_STAKING_STATE = {
  type: 'liquid',
  id: 'liquid',
  tokenSlug: TONCOIN.slug,
  annualYield: 3.9,
  yieldType: 'APY',
  balance: 0n,
  pool: LIQUID_POOL,
  tokenBalance: 0n,
  unstakeRequestAmount: 0n,
  instantAvailable: 0n,
  start: 0,
  end: 0
};
const DEFAULT_NOMINATORS_STAKING_STATE = {
  type: 'nominators',
  id: 'nominators',
  tokenSlug: TONCOIN.slug,
  annualYield: 3.9,
  yieldType: 'APY',
  balance: 0n,
  pool: 'Ef8dgIOIRyCLU0NEvF8TD6Me3wrbrkS1z3Gpjk3ppd8m8-s_',
  start: 0,
  end: 0,
  pendingDepositAmount: 0n
};
const SWAP_API_VERSION = 3;
const TONCENTER_ACTIONS_VERSION = 'v1';
const JVAULT_URL = 'https://jvault.xyz';
const HELP_CENTER_URL = {
  home: {
    en: 'https://help.mytonwallet.io/',
    ru: 'https://help.mytonwallet.io/ru'
  },
  domainScam: {
    en: 'https://help.mytonwallet.io/intro/scams/.ton-domain-scams',
    // eslint-disable-next-line @stylistic/max-len
    ru: 'https://help.mytonwallet.io/ru/baza-znanii/moshennichestvo-i-skamy/moshennichestvo-s-ispolzovaniem-domenov-.ton'
  },
  seedScam: {
    en: 'https://help.mytonwallet.io/intro/scams/leaked-seed-phrases',
    ru: 'https://help.mytonwallet.io/ru/baza-znanii/moshennichestvo-i-skamy/slitye-sid-frazy'
  },
  ethenaStaking: {
    en: 'https://help.mytonwallet.io/intro/staking/what-is-usde-how-does-usde-staking-work',
    ru: 'https://help.mytonwallet.io/ru/baza-znanii/steiking/chto-takoe-usde-kak-rabotaet-steiking-usde'
  }
};
const ALL_TON_DNS_ZONES = [{
  suffixes: ['ton'],
  baseFormat: /^([-\da-z]+\.){0,2}[-\da-z]{4,126}$/i,
  resolver: 'EQC3dNlesgVD8YbAazcauIrXBPfiVhMMr5YYk2in0Mtsz0Bz',
  collectionName: 'TON DNS Domains'
}, {
  suffixes: ['t.me'],
  baseFormat: /^([-\da-z]+\.){0,2}[-_\da-z]{4,32}$/i,
  resolver: 'EQCA14o1-VWhS2efqoh_9M1b_A9DtKTuoqfmkn83AbJzwnPi',
  isTelemint: true,
  collectionName: 'Telegram Usernames'
}, {
  suffixes: ['vip', 'ton.vip', 'vip.ton'],
  baseFormat: /^([-\da-z]+\.){0,2}?[\da-z]{1,24}$/i,
  resolver: 'EQBWG4EBbPDv4Xj7xlPwzxd7hSyHMzwwLB5O6rY-0BBeaixS',
  collectionName: 'VIP DNS Domains',
  isUnofficial: true
}, {
  suffixes: ['gram'],
  baseFormat: /^([-\da-z]+\.){0,2}[\da-z]{1,127}$/i,
  resolver: 'EQAic3zPce496ukFDhbco28FVsKKl2WUX_iJwaL87CBxSiLQ',
  collectionName: 'GRAM DNS Domains',
  isUnofficial: true
}];
const TON_DNS_ZONES = IS_CORE_WALLET ? ALL_TON_DNS_ZONES.filter(_ref => {
  let {
    isUnofficial
  } = _ref;
  return !isUnofficial;
}) : ALL_TON_DNS_ZONES;
const DEFAULT_AUTOLOCK_OPTION = '3';
const WRONG_ATTEMPTS_BEFORE_LOG_OUT_SUGGESTION = 2;
const UNKNOWN_TOKEN = {
  symbol: '[Unknown]',
  decimals: 9
};

/***/ }),

/***/ 36791:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   u: () => (/* binding */ getPlatform)
/* harmony export */ });
function getPlatform() {
  const {
    userAgent,
    platform
  } = window.navigator;
  if (/Android/.test(userAgent)) return 'Android';
  if (/Linux/.test(platform)) return 'Linux';
  const iosPlatforms = ['iPhone', 'iPad', 'iPod'];
  if (iosPlatforms.indexOf(platform) !== -1
  // For new IPads with M1 chip and IPadOS platform returns "MacIntel"
  || platform === 'MacIntel' && 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 2) {
    return 'iOS';
  }
  const macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
  if (macosPlatforms.indexOf(platform) !== -1) return 'macOS';
  const windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
  if (windowsPlatforms.indexOf(platform) !== -1) return 'Windows';
  return undefined;
}

/***/ }),

/***/ 37448:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Wi: () => (/* binding */ Encoding),
/* harmony export */   __: () => (/* binding */ Directory)
/* harmony export */ });
/* unused harmony exports FilesystemDirectory, FilesystemEncoding */
var Directory;
(function (Directory) {
    /**
     * The Documents directory.
     * On iOS it's the app's documents directory.
     * Use this directory to store user-generated content.
     * On Android it's the Public Documents folder, so it's accessible from other apps.
     * It's not accesible on Android 10 unless the app enables legacy External Storage
     * by adding `android:requestLegacyExternalStorage="true"` in the `application` tag
     * in the `AndroidManifest.xml`.
     * On Android 11 or newer the app can only access the files/folders the app created.
     *
     * @since 1.0.0
     */
    Directory["Documents"] = "DOCUMENTS";
    /**
     * The Data directory.
     * On iOS it will use the Documents directory.
     * On Android it's the directory holding application files.
     * Files will be deleted when the application is uninstalled.
     *
     * @since 1.0.0
     */
    Directory["Data"] = "DATA";
    /**
     * The Library directory.
     * On iOS it will use the Library directory.
     * On Android it's the directory holding application files.
     * Files will be deleted when the application is uninstalled.
     *
     * @since 1.1.0
     */
    Directory["Library"] = "LIBRARY";
    /**
     * The Cache directory.
     * Can be deleted in cases of low memory, so use this directory to write app-specific files.
     * that your app can re-create easily.
     *
     * @since 1.0.0
     */
    Directory["Cache"] = "CACHE";
    /**
     * The external directory.
     * On iOS it will use the Documents directory.
     * On Android it's the directory on the primary shared/external
     * storage device where the application can place persistent files it owns.
     * These files are internal to the applications, and not typically visible
     * to the user as media.
     * Files will be deleted when the application is uninstalled.
     *
     * @since 1.0.0
     */
    Directory["External"] = "EXTERNAL";
    /**
     * The external storage directory.
     * On iOS it will use the Documents directory.
     * On Android it's the primary shared/external storage directory.
     * It's not accesible on Android 10 unless the app enables legacy External Storage
     * by adding `android:requestLegacyExternalStorage="true"` in the `application` tag
     * in the `AndroidManifest.xml`.
     * It's not accesible on Android 11 or newer.
     *
     * @since 1.0.0
     */
    Directory["ExternalStorage"] = "EXTERNAL_STORAGE";
})(Directory || (Directory = {}));
var Encoding;
(function (Encoding) {
    /**
     * Eight-bit UCS Transformation Format
     *
     * @since 1.0.0
     */
    Encoding["UTF8"] = "utf8";
    /**
     * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the
     * Unicode character set
     * This encoding is only supported on Android.
     *
     * @since 1.0.0
     */
    Encoding["ASCII"] = "ascii";
    /**
     * Sixteen-bit UCS Transformation Format, byte order identified by an
     * optional byte-order mark
     * This encoding is only supported on Android.
     *
     * @since 1.0.0
     */
    Encoding["UTF16"] = "utf16";
})(Encoding || (Encoding = {}));
/**
 * @deprecated Use `Directory`.
 * @since 1.0.0
 */
const FilesystemDirectory = (/* unused pure expression or super */ null && (Directory));
/**
 * @deprecated Use `Encoding`.
 * @since 1.0.0
 */
const FilesystemEncoding = (/* unused pure expression or super */ null && (Encoding));
//# sourceMappingURL=definitions.js.map

/***/ }),

/***/ 37836:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Fe: () => (/* binding */ throttleWithTickEnd),
/* harmony export */   Gf: () => (/* binding */ setCancellableTimeout),
/* harmony export */   IJ: () => (/* binding */ fastRaf),
/* harmony export */   fm: () => (/* binding */ waitFor),
/* harmony export */   kI: () => (/* binding */ onIdle),
/* harmony export */   nF: () => (/* binding */ throttle),
/* harmony export */   nb: () => (/* binding */ throttleWith),
/* harmony export */   sg: () => (/* binding */ debounce),
/* harmony export */   v7: () => (/* binding */ pause),
/* harmony export */   yu: () => (/* binding */ onBeforeUnload)
/* harmony export */ });
/* unused harmony exports rafPromise, onTickEnd, createTaskQueue, forbidConcurrency */

const pause = ms => new Promise(resolve => {
  setTimeout(() => resolve(), ms);
});
function debounce(fn, ms) {
  let shouldRunFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let shouldRunLast = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  let waitingTimeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (waitingTimeout) {
      clearTimeout(waitingTimeout);
      waitingTimeout = undefined;
    } else if (shouldRunFirst) {
      fn(...args);
    }
    waitingTimeout = self.setTimeout(() => {
      if (shouldRunLast) {
        fn(...args);
      }
      waitingTimeout = undefined;
    }, ms);
  };
}

/**
 * An important feature of this throttle implementation is that it waits for `fn` to finish before scheduling the new
 * execution. That is, `fn` never gets executed in parallel with itself.
 */
function throttle(fn, ms) {
  let shouldRunFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let args;
  let isRunning = false;
  async function scheduleFn() {
    await (typeof ms === 'function' ? ms() : pause(ms));
    void runFn();
  }
  async function runFn() {
    if (!args) {
      isRunning = false;
      return;
    }
    try {
      const localArgs = args;
      args = undefined;
      await fn(...localArgs);
    } finally {
      // Voiding the promise to let the error produced by `fn` be thrown immediately
      void scheduleFn();
    }
  }
  return function () {
    for (var _len2 = arguments.length, _args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      _args[_key2] = arguments[_key2];
    }
    args = _args;
    if (!isRunning) {
      isRunning = true;
      if (shouldRunFirst) {
        void runFn();
      } else {
        void scheduleFn();
      }
    }
  };
}
function throttleWithTickEnd(fn) {
  return throttleWith(onTickEnd, fn);
}
function throttleWith(schedulerFn, fn) {
  let waiting = false;
  let args;
  return function () {
    for (var _len3 = arguments.length, _args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      _args[_key3] = arguments[_key3];
    }
    args = _args;
    if (!waiting) {
      waiting = true;
      schedulerFn(() => {
        waiting = false;
        fn(...args);
      });
    }
  };
}
function rafPromise() {
  return new Promise(resolve => {
    fastRaf(resolve);
  });
}
const FAST_RAF_TIMEOUT_FALLBACK_MS = 35; // < 30 FPS

let fastRafCallbacks;
let fastRafFallbackCallbacks;
let fastRafFallbackTimeout;

// May result in an immediate execution if called from another RAF callback which was scheduled
// (and therefore is executed) earlier than RAF callback scheduled by `fastRaf`
function fastRaf(callback) {
  let withTimeoutFallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!fastRafCallbacks) {
    fastRafCallbacks = new Set([callback]);
    requestAnimationFrame(() => {
      const currentCallbacks = fastRafCallbacks;
      fastRafCallbacks = undefined;
      fastRafFallbackCallbacks = undefined;
      if (fastRafFallbackTimeout) {
        clearTimeout(fastRafFallbackTimeout);
        fastRafFallbackTimeout = undefined;
      }
      currentCallbacks.forEach(cb => cb());
    });
  } else {
    fastRafCallbacks.add(callback);
  }
  if (withTimeoutFallback) {
    if (!fastRafFallbackCallbacks) {
      fastRafFallbackCallbacks = new Set([callback]);
    } else {
      fastRafFallbackCallbacks.add(callback);
    }
    if (!fastRafFallbackTimeout) {
      fastRafFallbackTimeout = window.setTimeout(() => {
        const currentTimeoutCallbacks = fastRafFallbackCallbacks;
        if (fastRafCallbacks) {
          currentTimeoutCallbacks.forEach(fastRafCallbacks.delete, fastRafCallbacks);
        }
        fastRafFallbackCallbacks = undefined;
        if (fastRafFallbackTimeout) {
          clearTimeout(fastRafFallbackTimeout);
          fastRafFallbackTimeout = undefined;
        }
        currentTimeoutCallbacks.forEach(cb => cb());
      }, FAST_RAF_TIMEOUT_FALLBACK_MS);
    }
  }
}
let onTickEndCallbacks;
function onTickEnd(callback) {
  if (!onTickEndCallbacks) {
    onTickEndCallbacks = [callback];
    void Promise.resolve().then(() => {
      const currentCallbacks = onTickEndCallbacks;
      onTickEndCallbacks = undefined;
      currentCallbacks.forEach(cb => cb());
    });
  } else {
    onTickEndCallbacks.push(callback);
  }
}
const IDLE_TIMEOUT = 500;
let onIdleCallbacks;
function onIdle(callback) {
  if (!self.requestIdleCallback) {
    onTickEnd(callback);
    return;
  }
  if (!onIdleCallbacks) {
    onIdleCallbacks = [callback];
    requestIdleCallback(deadline => {
      const currentCallbacks = onIdleCallbacks;
      onIdleCallbacks = undefined;
      while (currentCallbacks.length) {
        const cb = currentCallbacks.shift();
        cb();
        if (!deadline.timeRemaining()) break;
      }
      if (currentCallbacks.length) {
        if (onIdleCallbacks) {
          // Prepend the remaining callbacks if the next pass is already planned
          onIdleCallbacks = currentCallbacks.concat(onIdleCallbacks);
        } else {
          currentCallbacks.forEach(onIdle);
        }
      }
    }, {
      timeout: IDLE_TIMEOUT
    });
  } else {
    onIdleCallbacks.push(callback);
  }
}
let beforeUnloadCallbacks;
function onBeforeUnload(callback) {
  let isLast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!beforeUnloadCallbacks) {
    beforeUnloadCallbacks = [];
    self.addEventListener('beforeunload', () => {
      beforeUnloadCallbacks.forEach(cb => cb());
    });
  }
  if (isLast) {
    beforeUnloadCallbacks.push(callback);
  } else {
    beforeUnloadCallbacks.unshift(callback);
  }
  return () => {
    beforeUnloadCallbacks = beforeUnloadCallbacks.filter(cb => cb !== callback);
  };
}
async function waitFor(cb, interval, attempts) {
  let i = 0;
  let result = cb();
  while (!result && i < attempts) {
    await pause(interval);
    i++;
    result = cb();
  }
  return result;
}
function setCancellableTimeout(ms, cb) {
  const timeoutId = setTimeout(cb, ms);
  return () => clearTimeout(timeoutId);
}

/**
 * Returns a function that executes every given functions (tasks) with limited concurrency (not more than
 * `maxConcurrency` at a time). The tasks are executed in the same order that they are given. Unlike throttle, executes
 * every given task.
 */
function createTaskQueue() {
  let maxConcurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  const queue = [];
  let concurrency = 0;
  const runTasks = async () => {
    concurrency++;
    while (queue.length) {
      const task = queue.shift();
      await task(); // Expected never to throw, because the errors are caught below
    }
    concurrency--;
  };

  /** Schedules execution of the given function right now. The returned promise settles with the task result. */
  const run = task => {
    const deferred = new Deferred();
    queue.push(async () => {
      try {
        deferred.resolve(await task());
      } catch (err) {
        deferred.reject(err);
      }
    });
    if (concurrency < maxConcurrency) {
      void runTasks();
    }
    return deferred.promise;
  };

  /** Returns the same task function, but with limited concurrency */
  const wrap = task => {
    return function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return run(() => task(...args));
    };
  };
  return {
    run,
    wrap
  };
}

/**
 * Returns a function that prevents `actions` from running in parallel with itself. If the `action` is already running,
 * queues, the next call will be queued. Unlike `throttle`, never skips the calls.
 */
function forbidConcurrency(action) {
  return createTaskQueue(1).wrap(action);
}

/***/ }),

/***/ 41074:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ launchMediaWorkers),
/* harmony export */   M1: () => (/* binding */ requestMediaWorker),
/* harmony export */   bP: () => (/* binding */ MAX_WORKERS)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31481);
/* harmony import */ var _PostMessageConnector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5130);


const MAX_WORKERS = Math.min(navigator.hardwareConcurrency || 4, 4);
let instances;
function launchMediaWorkers() {
  if (_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_TEST */ .W75) return [];
  if (!instances) {
    instances = new Array(MAX_WORKERS).fill(undefined).map(() => {
      const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(524), __webpack_require__.b));
      const connector = (0,_PostMessageConnector__WEBPACK_IMPORTED_MODULE_1__/* .createConnector */ .U$)(worker);
      return {
        worker,
        connector
      };
    });
  }
  return instances;
}
function requestMediaWorker(payload, index) {
  return launchMediaWorkers()[index].connector.request(payload);
}

/***/ }),

/***/ 48217:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  H: () => (/* binding */ handleError)
});

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(31481);
// EXTERNAL MODULE: ./src/util/dateFormat.ts
var dateFormat = __webpack_require__(10309);
;// ./src/util/environment.ts

const IS_EXTENSION_PAGE_SCRIPT = config/* IS_EXTENSION */.hL1 && !['chrome-extension:', 'moz-extension:'].includes(self.location.protocol);
// EXTERNAL MODULE: ./src/util/logs.ts
var logs = __webpack_require__(55029);
// EXTERNAL MODULE: ./src/util/schedulers.ts
var schedulers = __webpack_require__(37836);
;// ./src/util/handleError.ts





const shouldShowAlert = (config/* APP_ENV */.Guj === 'development' || config/* APP_ENV */.Guj === 'staging') && typeof window === 'object' && !IS_EXTENSION_PAGE_SCRIPT;
const throttledAlert = (0,schedulers/* throttle */.nF)(message => window.alert(message), 10 * dateFormat/* SECOND */.Z2);
self.addEventListener('error', handleErrorEvent);
self.addEventListener('unhandledrejection', handleErrorEvent);
function handleErrorEvent(e) {
  // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded
  if (e instanceof ErrorEvent && e.message === 'ResizeObserver loop limit exceeded') {
    return;
  }
  e.preventDefault();
  handleError(e instanceof ErrorEvent ? e.error || e.message : e.reason);
}
function handleError(err) {
  (0,logs/* logDebugError */.SJ)('handleError', err);
  const message = typeof err === 'string' ? err : err.message;
  const stack = typeof err === 'object' ? err.stack : undefined;
  if (message.endsWith('Failed to import rlottie-wasm.js')) {
    return;
  }
  if (shouldShowAlert) {
    throttledAlert(`${config/* DEBUG_ALERT_MSG */.FHx}\n\n${message || err}\n${stack}`);
  }
}

/***/ }),

/***/ 48287:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(67526)
const ieee754 = __webpack_require__(251)
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
__webpack_unused_export__ = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
__webpack_unused_export__ = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ 48805:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   z: () => (/* binding */ Big)
/* harmony export */ });
/*
 *  big.js v6.2.1
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2022 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */

/************************************** EDITABLE DEFAULTS *****************************************/

// The default values below must be integers within the stated ranges.

/*
 * The maximum number of decimal places (DP) of the results of operations involving division:
 * div and sqrt, and pow with negative exponents.
 */
var DP = 20,
  // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,
  // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,
  // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,
  // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,
  // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,
  // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,
  // true or false

  /**************************************************************************************************/

  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',
  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

/*
 * Create and return a Big constructor.
 */
function _Big_() {
  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true && typeof n !== 'bigint') {
          throw TypeError(INVALID + 'value');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }
      parse(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }
  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;
  Big.roundDown = 0;
  Big.roundHalfUp = 1;
  Big.roundHalfEven = 2;
  Big.roundUp = 3;
  return Big;
}

/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;
  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {
    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    // Integer.
    e = n.length;
  }
  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;
  if (i == nl) {
    // Zero.
    x.c = [x.e = 0];
  } else {
    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }
  return x;
}

/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, sd, rm, more) {
  var xc = x.c;
  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }
  if (sd < 1) {
    more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
    xc.length = 1;
    if (more) {
      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {
      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {
    // xc[sd] is the digit after the digit that may be rounded up.
    more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd;

    // Round up?
    if (more) {
      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[--sd] > 9;) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }
  return x;
}

/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

    // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }
  return x.s < 0 && isNonzero ? '-' + s : s;
}

// Prototype/instance methods

/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};

/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;
  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};

/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,
    // dividend
    b = (y = new Big(y)).c,
    // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }
  var bl,
    bt,
    n,
    cmp,
    ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),
    // remainder
    rl = r.length,
    q = y,
    // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1; // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);
  do {
    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {
      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {
        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;else r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {
    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);
  return q;
};

/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};

/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};

/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};

/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};

/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};

/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i,
    j,
    t,
    xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {
    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};

/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;
  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx) return new Big(x);
  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;
  return this.minus(x.times(y));
};

/*
 * Return a new Big whose value is the value of this Big negated.
 */
P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};

/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e,
    k,
    t,
    x = this,
    Big = x.constructor;
  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }
  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }
    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};

/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }
  if (isneg) n = -n;
  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};

/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round(new this.constructor(this), sd, rm);
};

/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};

/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r,
    c,
    t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }
  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));
  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};

/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {
      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }
    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;
  return y;
};

/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }
  return stringify(x, true, !!n);
};

/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];
  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }
  return stringify(x, false, !!n);
};

/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};

/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = Number(stringify(this, true, true));
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};

/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];
  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }
  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};

/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};

// Export

var Big = _Big_();

/// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (Big)));

/***/ }),

/***/ 50110:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ safeExec)
/* harmony export */ });
/* unused harmony export safeExecAsync */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31481);
/* harmony import */ var _handleError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48217);


const SAFE_EXEC_ENABLED = !_config__WEBPACK_IMPORTED_MODULE_0__/* .DEBUG_MORE */ .MVx;
async function safeExecAsync(cb, options) {
  if (!SAFE_EXEC_ENABLED) {
    return cb();
  }
  const {
    rescue,
    always,
    shouldIgnoreError
  } = options ?? {};
  try {
    return await cb();
  } catch (err) {
    rescue === null || rescue === void 0 || rescue(err);
    if (!shouldIgnoreError) {
      handleError(err);
    }
    return undefined;
  } finally {
    always === null || always === void 0 || always();
  }
}
function safeExec(cb, options) {
  if (!SAFE_EXEC_ENABLED) {
    return cb();
  }
  const {
    rescue,
    always,
    shouldIgnoreError
  } = options ?? {};
  try {
    return cb();
  } catch (err) {
    rescue === null || rescue === void 0 || rescue(err);
    if (!shouldIgnoreError) {
      (0,_handleError__WEBPACK_IMPORTED_MODULE_1__/* .handleError */ .H)(err);
    }
    return undefined;
  } finally {
    always === null || always === void 0 || always();
  }
}

/***/ }),

/***/ 51915:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   i6: () => (/* binding */ onLedgerTabClose),
/* harmony export */   jT: () => (/* binding */ DETACHED_TAB_URL),
/* harmony export */   ks: () => (/* binding */ closeThisTab),
/* harmony export */   nm: () => (/* binding */ openLedgerTab),
/* harmony export */   rt: () => (/* binding */ closeLedgerTab)
/* harmony export */ });
const DETACHED_TAB_URL = '#detached';
let ledgerTabId;

/**
 * In order to connect to Ledger, the webapp needs to get the user permission to use the HID device. Chrome doesn't ask
 * the user to choose a device when the code runs in the extension popup: https://issues.chromium.org/issues/40233645.
 * So in case of extension we open a browser tab which asks the permission. The tab runs the same webapp but with a
 * limited UI. Once the user grants the permission, the extension can continue connecting to Ledger inside the popup.
 */
function openLedgerTab() {
  return createLedgerTab();
}
function closeLedgerTab() {
  if (!ledgerTabId) return;
  chrome.tabs.query({
    active: true
  }, () => {
    if (!ledgerTabId) return;
    void chrome.tabs.remove(ledgerTabId);
  });
}
async function closeThisTab() {
  const tab = await chrome.tabs.getCurrent();
  if (!(tab !== null && tab !== void 0 && tab.id)) return;
  await chrome.tabs.remove(tab.id);
}
function onLedgerTabClose(id, onClose) {
  const listener = closedTabId => {
    if (closedTabId !== id) {
      return;
    }
    ledgerTabId = undefined;
    chrome.tabs.onRemoved.removeListener(listener);
    onClose();
  };
  chrome.tabs.onRemoved.addListener(listener);
}
async function createLedgerTab() {
  const tab = await chrome.tabs.create({
    url: `index.html${DETACHED_TAB_URL}`,
    active: true
  });
  await chrome.windows.update(tab.windowId, {
    focused: true
  });
  ledgerTabId = tab.id;
  return ledgerTabId;
}

/***/ }),

/***/ 54218:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   kB: () => (/* binding */ createReverseIFrameInterface),
/* harmony export */   p: () => (/* binding */ createPostMessageInterface)
/* harmony export */ });
/* unused harmony exports createExtensionInterface, createReverseExtensionInterface */
/* harmony import */ var _extensionMessageSerializer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24082);
/* harmony import */ var _logs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55029);


const callbackState = new Map();
/**
 * Provides functions, defined in this messenger (a window, a worker), to another messenger.
 * The other messenger can call the functions using `createConnector`.
 */
function createPostMessageInterface(api, channel) {
  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : self;
  let shouldIgnoreErrors = arguments.length > 3 ? arguments[3] : undefined;
  function sendToOrigin(data, transferables) {
    data.channel = channel;
    if (transferables) {
      target.postMessage(data, transferables);
    } else {
      target.postMessage(data);
    }
  }
  if (!shouldIgnoreErrors) {
    handleErrors(sendToOrigin);
  }
  function handleMessage(e) {
    var _e$data;
    if (((_e$data = e.data) === null || _e$data === void 0 ? void 0 : _e$data.channel) === channel) {
      void onMessage(api, e.data, sendToOrigin);
    }
  }

  // Correct for any target, but TypeScript weirdly complains
  target.addEventListener('message', handleMessage);
  return () => {
    target.removeEventListener('message', handleMessage);
  };
}

/**
 * Provides functions, defined in the main window, to an IFrame.
 */
function createReverseIFrameInterface(api, targetOrigin, target, channel) {
  function sendToOrigin(data, transferables) {
    data.channel = channel;
    if (transferables) {
      throw new Error('Cannot send `Transferable` to `Window`');
    } else {
      target.postMessage(data, targetOrigin);
    }
  }
  function handleMessage(e) {
    var _e$data2;
    if (targetOrigin && e.origin !== targetOrigin) return;
    if (((_e$data2 = e.data) === null || _e$data2 === void 0 ? void 0 : _e$data2.channel) === channel) {
      void onMessage(api, e.data, sendToOrigin);
    }
  }
  window.addEventListener('message', handleMessage);
  return () => {
    window.removeEventListener('message', handleMessage);
  };
}

/**
 * Provides functions, defined in this extension service worker, to a window.
 * The window can call the functions using `createExtensionConnector`.
 */
function createExtensionInterface(portName, api, channel, cleanUpdater) {
  let withAutoInit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  chrome.runtime.onConnect.addListener(port => {
    var _port$sender;
    if (port.name !== portName) {
      return;
    }
    const url = (_port$sender = port.sender) === null || _port$sender === void 0 ? void 0 : _port$sender.url;
    const origin = url ? new URL(url).origin : undefined;
    const dAppUpdater = update => {
      sendToOrigin({
        type: 'update',
        update
      });
    };
    function sendToOrigin(data) {
      data.channel = channel;
      port.postMessage(encodeExtensionMessage(data));
    }
    handleErrors(sendToOrigin);
    port.onMessage.addListener(data => {
      data = decodeExtensionMessage(data);
      if (data.channel === channel) {
        void onMessage(api, data, sendToOrigin, dAppUpdater, origin);
      }
    });
    port.onDisconnect.addListener(() => {
      cleanUpdater === null || cleanUpdater === void 0 || cleanUpdater(dAppUpdater);
    });
    if (withAutoInit) {
      void onMessage(api, {
        type: 'init',
        args: []
      }, sendToOrigin, dAppUpdater);
    }
  });
}

/**
 * Provides functions, defined in this window, to the extension service worker.
 * The service worker can call the functions using `createReverseExtensionConnector`.
 */
function createReverseExtensionInterface(portName, api) {
  let port;
  function sendToServiceWorker(data) {
    port.postMessage(encodeExtensionMessage(data));
  }
  function connect() {
    port = chrome.runtime.connect({
      name: portName
    });
    port.onMessage.addListener(data => {
      data = decodeExtensionMessage(data);
      void onMessage(api, data, sendToServiceWorker);
    });

    // For some reason port can suddenly get disconnected
    port.onDisconnect.addListener(() => {
      connect();
    });
  }
  connect();
}
async function onMessage(api, data, sendToOrigin, onUpdate, origin) {
  if (!onUpdate) {
    onUpdate = update => {
      sendToOrigin({
        type: 'update',
        update
      });
    };
  }
  switch (data.type) {
    case 'init':
      {
        var _api$init;
        const {
          args
        } = data;
        const promise = typeof api === 'function' ? api('init', origin, onUpdate, ...args) : (_api$init = api.init) === null || _api$init === void 0 ? void 0 : _api$init.call(api, onUpdate, ...args);
        await promise;
        break;
      }
    case 'callMethod':
      {
        const {
          messageId,
          name,
          args,
          withCallback
        } = data;
        try {
          // This method is probably from another worker
          if (typeof api !== 'function' && !api[name]) return;
          if (messageId && withCallback) {
            const callback = function () {
              for (var _len = arguments.length, callbackArgs = new Array(_len), _key = 0; _key < _len; _key++) {
                callbackArgs[_key] = arguments[_key];
              }
              const lastArg = callbackArgs[callbackArgs.length - 1];
              sendToOrigin({
                type: 'methodCallback',
                messageId,
                callbackArgs
              }, isTransferable(lastArg) ? [lastArg] : undefined);
            };
            callbackState.set(messageId, callback);
            args.push(callback);
          }
          const response = typeof api === 'function' ? await api(name, origin, ...args) : await api[name](...args);
          const {
            arrayBuffer
          } = typeof response === 'object' && response && 'arrayBuffer' in response || {};
          if (messageId) {
            sendToOrigin({
              type: 'methodResponse',
              messageId,
              response
            }, arrayBuffer ? [arrayBuffer] : undefined);
          }
        } catch (err) {
          (0,_logs__WEBPACK_IMPORTED_MODULE_1__/* .logDebugError */ .SJ)(name, err);
          if (messageId) {
            sendToOrigin({
              type: 'methodResponse',
              messageId,
              error: {
                message: err.message
              }
            });
          }
        }
        if (messageId) {
          callbackState.delete(messageId);
        }
        break;
      }
    case 'cancelProgress':
      {
        const callback = callbackState.get(data.messageId);
        if (callback) {
          callback.isCanceled = true;
        }
        break;
      }
  }
}
function isTransferable(obj) {
  return obj instanceof ArrayBuffer || obj instanceof ImageBitmap;
}
function handleErrors(sendToOrigin) {
  self.onerror = e => {
    var _e$error, _e$error2;
    const message = ((_e$error = e.error) === null || _e$error === void 0 ? void 0 : _e$error.message) || 'Uncaught exception in worker';
    (0,_logs__WEBPACK_IMPORTED_MODULE_1__/* .logDebugError */ .SJ)(message, e.error);
    sendToOrigin({
      type: 'unhandledError',
      error: {
        message,
        stack: (_e$error2 = e.error) === null || _e$error2 === void 0 ? void 0 : _e$error2.stack
      }
    });
  };
  self.addEventListener('unhandledrejection', e => {
    var _e$reason, _e$reason2;
    const message = ((_e$reason = e.reason) === null || _e$reason === void 0 ? void 0 : _e$reason.message) || 'Unhandled rejection in worker';
    (0,_logs__WEBPACK_IMPORTED_MODULE_1__/* .logDebugError */ .SJ)(message, e.reason);
    sendToOrigin({
      type: 'unhandledError',
      error: {
        message,
        stack: (_e$reason2 = e.reason) === null || _e$reason2 === void 0 ? void 0 : _e$reason2.stack
      }
    });
  });
}

/***/ }),

/***/ 55029:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MD: () => (/* binding */ logDebug),
/* harmony export */   SJ: () => (/* binding */ logDebugError),
/* harmony export */   ao: () => (/* binding */ getLogs),
/* harmony export */   ef: () => (/* binding */ logSelfXssWarnings),
/* harmony export */   kJ: () => (/* binding */ logDebugApi)
/* harmony export */ });
/* unused harmony exports errorReplacer, addLog */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31481);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(59288);


const MAX_LOG_LENGTH = 999;
const logs = [];
function errorReplacer(_, value) {
  if (value instanceof Error) {
    return {
      name: value.name,
      message: value.message,
      stack: value.stack,
      metadata: value instanceof _assert__WEBPACK_IMPORTED_MODULE_1__/* .AssertionError */ .p ? value.metadata : undefined
    };
  }
  return value;
}
function addLog(log) {
  if (logs.length > MAX_LOG_LENGTH) {
    logs.shift();
  }
  logs.push({
    ...log,
    args: log.args.map(arg => JSON.stringify(arg, errorReplacer)),
    time: Date.now()
  });
}
function getLogs() {
  return logs;
}
function logDebugError(message) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  addLog({
    message,
    level: 'debugError',
    args
  });
  if (_config__WEBPACK_IMPORTED_MODULE_0__/* .DEBUG */ .Oig) {
    // eslint-disable-next-line no-console
    console.error(`[DEBUG][${message}]`, ...args);
  }
}
function logDebug(message) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  addLog({
    message,
    level: 'debug',
    args
  });
  if (_config__WEBPACK_IMPORTED_MODULE_0__/* .DEBUG */ .Oig) {
    // eslint-disable-next-line no-console
    console.log(`[DEBUG] ${message}`, ...args);
  }
}
function logDebugApi(message, obj1, obj2) {
  if (_config__WEBPACK_IMPORTED_MODULE_0__/* .DEBUG_API */ .dlH) {
    // eslint-disable-next-line no-console
    console.debug(`[DEBUG] ${message}`);
    // eslint-disable-next-line no-console
    if (obj1) console.dir(obj1);
    // eslint-disable-next-line no-console
    if (obj2) console.dir(obj2);
  }
}
function logSelfXssWarnings() {
  const selfXssWarnings = {
    en: 'WARNING! This console can be a way for bad people to take over your crypto wallet through something called ' + 'a Self-XSS attack. So, don\'t put in or paste code you don\'t understand. Stay safe!',
    ru: 'Ð’ÐÐ˜ÐœÐÐÐ˜Ð•! Ð§ÐµÑ€ÐµÐ· ÑÑ‚Ñƒ ÐºÐ¾Ð½ÑÐ¾Ð»ÑŒ Ð·Ð»Ð¾ÑƒÐ¼Ñ‹ÑˆÐ»ÐµÐ½Ð½Ð¸ÐºÐ¸ Ð¼Ð¾Ð³ÑƒÑ‚ Ð·Ð°Ñ…Ð²Ð°Ñ‚Ð¸Ñ‚ÑŒ Ð²Ð°Ñˆ ÐºÑ€Ð¸Ð¿Ñ‚Ð¾Ð²Ð°Ð»ÑŽÑ‚Ð½Ñ‹Ð¹ ÐºÐ¾ÑˆÐµÐ»Ñ‘Ðº Ñ Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒÑŽ Ñ‚Ð°Ðº ' + 'Ð½Ð°Ð·Ñ‹Ð²Ð°ÐµÐ¼Ð¾Ð¹ Ð°Ñ‚Ð°ÐºÐ¸ Self-XSS. ÐŸÐ¾ÑÑ‚Ð¾Ð¼Ñƒ Ð½Ðµ Ð²Ð²Ð¾Ð´Ð¸Ñ‚Ðµ Ð¸ Ð½Ðµ Ð²ÑÑ‚Ð°Ð²Ð»ÑÐ¹Ñ‚Ðµ ÐºÐ¾Ð´, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð²Ñ‹ Ð½Ðµ Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÐµÑ‚Ðµ. Ð‘ÐµÑ€ÐµÐ³Ð¸Ñ‚Ðµ ÑÐµÐ±Ñ!',
    es: 'Â¡ADVERTENCIA! Esta consola puede ser una forma en que las personas malintencionadas se apoderen de su ' + 'billetera de criptomonedas mediante un ataque llamado Self-XSS. Por lo tanto, ' + 'no introduzca ni pegue cÃ³digo que no comprenda. Â¡CuÃ­dese!',
    zh: 'è­¦å‘Šï¼è¿™ä¸ªæŽ§åˆ¶å°å¯èƒ½æˆä¸ºåäººé€šè¿‡æ‰€è°“çš„Self-XSSæ”»å‡»æ¥æŽ¥ç®¡ä½ çš„åŠ å¯†è´§å¸é’±åŒ…çš„æ–¹å¼ã€‚å› æ­¤ï¼Œè¯·ä¸è¦è¾“å…¥æˆ–ç²˜è´´æ‚¨ä¸ç†è§£çš„ä»£ç ã€‚è¯·ä¿æŠ¤è‡ªå·±ï¼'
  };
  const langCode = navigator.language.split('-')[0];
  const text = selfXssWarnings[langCode] || selfXssWarnings.en;

  // eslint-disable-next-line no-console
  console.log('%c%s', 'color: red; background: yellow; font-size: 18px;', text);
}

/***/ }),

/***/ 56051:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   KL: () => (/* binding */ ApiTransactionDraftError),
/* harmony export */   Nu: () => (/* binding */ ApiAuthError),
/* harmony export */   QD: () => (/* binding */ ApiCommonError),
/* harmony export */   jc: () => (/* binding */ ApiHardwareError),
/* harmony export */   jf: () => (/* binding */ ApiTransactionError)
/* harmony export */ });
let ApiCommonError = /*#__PURE__*/function (ApiCommonError) {
  ApiCommonError["Unexpected"] = "Unexpected";
  ApiCommonError["ServerError"] = "ServerError";
  ApiCommonError["DebugError"] = "DebugError";
  ApiCommonError["UnsupportedVersion"] = "UnsupportedVersion";
  ApiCommonError["InvalidPassword"] = "InvalidPassword";
  return ApiCommonError;
}({});
let ApiAuthError = /*#__PURE__*/function (ApiAuthError) {
  ApiAuthError["InvalidMnemonic"] = "InvalidMnemonic";
  ApiAuthError["InvalidAddress"] = "InvalidAddress";
  ApiAuthError["DomainNotResolved"] = "DomainNotResolved";
  return ApiAuthError;
}({});
let ApiTransactionDraftError = /*#__PURE__*/function (ApiTransactionDraftError) {
  ApiTransactionDraftError["InvalidAmount"] = "InvalidAmount";
  ApiTransactionDraftError["InvalidToAddress"] = "InvalidToAddress";
  ApiTransactionDraftError["InsufficientBalance"] = "InsufficientBalance";
  ApiTransactionDraftError["InvalidStateInit"] = "InvalidStateInit";
  ApiTransactionDraftError["DomainNotResolved"] = "DomainNotResolved";
  ApiTransactionDraftError["WalletNotInitialized"] = "WalletNotInitialized";
  ApiTransactionDraftError["InvalidAddressFormat"] = "InvalidAddressFormat";
  ApiTransactionDraftError["InactiveContract"] = "InactiveContract";
  return ApiTransactionDraftError;
}({});
let ApiTransactionError = /*#__PURE__*/function (ApiTransactionError) {
  ApiTransactionError["PartialTransactionFailure"] = "PartialTransactionFailure";
  ApiTransactionError["IncorrectDeviceTime"] = "IncorrectDeviceTime";
  ApiTransactionError["InsufficientBalance"] = "InsufficientBalance";
  ApiTransactionError["UnsuccesfulTransfer"] = "UnsuccesfulTransfer";
  ApiTransactionError["WrongAddress"] = "WrongAddress";
  ApiTransactionError["WrongNetwork"] = "WrongNetwork";
  ApiTransactionError["ConcurrentTransaction"] = "ConcurrentTransaction";
  return ApiTransactionError;
}({});
let ApiHardwareError = /*#__PURE__*/function (ApiHardwareError) {
  /** Used when the Ledger TON app needs to be updated to support this transaction */
  ApiHardwareError["HardwareOutdated"] = "HardwareOutdated";
  ApiHardwareError["BlindSigningNotEnabled"] = "BlindSigningNotEnabled";
  ApiHardwareError["RejectedByUser"] = "RejectedByUser";
  ApiHardwareError["ProofTooLarge"] = "ProofTooLarge";
  return ApiHardwareError;
}({});

/***/ }),

/***/ 59121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   po: () => (/* binding */ randomBytes),
/* harmony export */   yT: () => (/* binding */ random)
/* harmony export */ });
/* unused harmony exports sample, randomBase64 */
/* provided dependency */ var Buffer = __webpack_require__(48287)["Buffer"];
function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function sample(arr) {
  return arr[random(0, arr.length - 1)];
}
function randomBytes(size) {
  return self.crypto.getRandomValues(new Uint8Array(size));
}
function randomBase64(byteSize) {
  return Buffer.from(randomBytes(byteSize)).toString('base64');
}

/***/ }),

/***/ 59288:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   p: () => (/* binding */ AssertionError)
/* harmony export */ });
/* unused harmony export assert */
class AssertionError extends Error {
  constructor(message,
  // Any additional information for the error to help debug it. Don't put sensitive information here.
  metadata) {
    super(message);
    this.metadata = metadata;
  }
}
function assert(condition, message, metadata) {
  if (!condition) {
    throw new AssertionError(message, metadata);
  }
}

/***/ }),

/***/ 59301:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HN: () => (/* binding */ isLedgerConnectionBroken),
/* harmony export */   L5: () => (/* binding */ getLedgerAccountPathByIndex),
/* harmony export */   w6: () => (/* binding */ getLedgerAccountPathByWallet)
/* harmony export */ });
/* harmony import */ var _api_chains_ton_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3476);

const BROKEN_CONNECTION_ERRORS = new Set(['DisconnectedDeviceDuringOperation', 'TransportRaceCondition']);
function getLedgerAccountPathByWallet(network, wallet, workchain) {
  return getLedgerAccountPathByIndex(wallet.index, network !== 'mainnet', workchain);
}
function getLedgerAccountPathByIndex(index, isTestnet) {
  let workchain = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _api_chains_ton_constants__WEBPACK_IMPORTED_MODULE_0__/* .WORKCHAIN */ .Zm;
  const network = isTestnet ? 1 : 0;
  const chain = workchain === _api_chains_ton_constants__WEBPACK_IMPORTED_MODULE_0__/* .Workchain */ .li.MasterChain ? 255 : 0;
  return [44, 607, network, chain, index, 0];
}
function isLedgerConnectionBroken(error) {
  return BROKEN_CONNECTION_ERRORS.has(error);
}

/***/ }),

/***/ 61995:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   xT: () => (/* binding */ JettonStakingGas)
/* harmony export */ });
/* unused harmony exports JettonStakingOpCodes, Dividers */
const JettonStakingOpCodes = {
  GET_STATIC_DATA: 0X2FCB26A2,
  REPORT_STATIC_DATA: 0X8B771735,
  GET_STORAGE_DATA: 0X5B88E5CC,
  REPORT_STORAGE_DATA: 0XAAB4A8EF,
  EXCESSES: 0XD53276DB,
  // Jettons,
  TRANSFER_JETTON: 0X0F8A7EA5,
  INTERNAL_TRANSFER: 0X178D4519,
  TRANSFER_NOTIFICATION: 0X7362D09C,
  PROVIDE_WALLET_ADDRESS: 0X2C76B973,
  TAKE_WALLET_ADDRESS: 0XD1735400,
  BURN_JETTON: 0X595F07BC,
  // Staking pool,
  STAKE_JETTONS: 0XE3A06989,
  ADD_REWARDS: 0XDB16AC95,
  SEND_CLAIMED_REWARDS: 0X44BC1FE3,
  SEND_UNSTAKED_JETTONS: 0XFB232BC3,
  APPROVE_STAKE: 0X919DE781,
  CANCEL_STAKE: 0X9EADA1D9,
  ADD_REWARD_JETTONS: 0X10676AE7,
  CLAIM_COMMISSIONS: 0XBCA8F067,
  REQUEST_UPDATE_REWARDS: 0XF5C5BAA3,
  // Staked jetton wallet,
  CLAIM_REWARDS: 0X78D9F109,
  RECEIVE_JETTONS: 0XD68A4AC1,
  UNSTAKE_JETTONS: 0X499A9262,
  UNSTAKE_REQUEST: 0X0168D4B7,
  CANCEL_UNSTAKE_REQUEST: 0XA4910F1A,
  UPDATE_REWARDS: 0XAE9307CE,
  CONFIRM_TRANSFER: 0XBC85EB11,
  // Pools admin,
  DEPLOY_NEW_POOL: 0XDA861F17,
  SEND_COMMISSIONS: 0XB96ADAEA,
  SET_CODE: 0xe2d2d211,
  CHANGE_CREATION_FEE: 0x66D5528B,
  CHANGE_CONTENT: 0x0ec29200,
  UPDATE_CODES: 0x85c923cf
};
const JettonStakingGas = {
  MIN_RESERVE: 20_000_000n,
  DEPLOY_POOL: 340_000_000n,
  NOTIFICATION: 340_000_000n,
  JETTON_TRANSFER: 55_000_000n,
  BURN_JETTONS: 340_000_000n,
  STAKE_JETTONS: 300_000_000n,
  // It was 340000000n
  UNSTAKE_JETTONS: 340_000_000n,
  CANCEL_UNSTAKE: 340_000_000n,
  SEND_COMMISSIONS: 340_000_000n,
  SIMPLE_UPDATE_REQUEST: 340_000_000n,
  ADD_REWARDS: 340_000_000n,
  APPROVE_TRANSFER: 340_000_000n,
  SAVE_UPDATED_REWARDS: 340_000_000n,
  MIN_EXCESS: 10_000_000n,
  SEND_STAKED_JETTONS: 630_000_000n
};
const Dividers = {
  COMMISSION_DIVIDER: 10000n,
  REWARDS_DIVIDER: 1000,
  DISTRIBUTION_SPEED_DIVIDER: BigInt(24 * 60 * 60),
  DISTRIBUTED_REWARDS_DIVIDER: 100000000000000000000000000000000000000n
};

/***/ }),

/***/ 65606:
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 66644:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RK: () => (/* binding */ requestMutation),
/* harmony export */   YS: () => (/* binding */ requestMeasure),
/* harmony export */   gm: () => (/* binding */ requestForcedReflow)
/* harmony export */ });
/* unused harmony export requestNextMutation */
/* harmony import */ var _util_safeExec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50110);
/* harmony import */ var _util_schedulers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37836);
/* harmony import */ var _stricterdom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75357);



let pendingMeasureTasks = [];
let pendingMutationTasks = [];
let pendingForceReflowTasks = [];
const runUpdatePassOnRaf = throttleWithRafFallback(() => {
  const currentMeasureTasks = pendingMeasureTasks;
  pendingMeasureTasks = [];
  currentMeasureTasks.forEach(task => {
    (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(task);
  });

  // We use promises to provide correct order for Mutation Observer callback microtasks
  void Promise.resolve().then(() => {
    (0,_stricterdom__WEBPACK_IMPORTED_MODULE_1__/* .setPhase */ .A)('mutate');
    const currentMutationTasks = pendingMutationTasks;
    pendingMutationTasks = [];
    currentMutationTasks.forEach(task => {
      (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(task);
    });
  }).then(() => {
    (0,_stricterdom__WEBPACK_IMPORTED_MODULE_1__/* .setPhase */ .A)('measure');
    const pendingForceReflowMutationTasks = [];
    // Will include tasks created during the loop
    for (const task of pendingForceReflowTasks) {
      (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(() => {
        const mutationTask = task();
        if (mutationTask) {
          pendingForceReflowMutationTasks.push(mutationTask);
        }
      });
    }
    pendingForceReflowTasks = [];
    return pendingForceReflowMutationTasks;
  }).then(pendingForceReflowMutationTasks => {
    (0,_stricterdom__WEBPACK_IMPORTED_MODULE_1__/* .setPhase */ .A)('mutate');

    // Will include tasks created during the loop
    for (const task of pendingForceReflowMutationTasks) {
      (0,_util_safeExec__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(task);
    }
  }).then(() => {
    (0,_stricterdom__WEBPACK_IMPORTED_MODULE_1__/* .setPhase */ .A)('measure');
  });
});
function requestMeasure(cb) {
  pendingMeasureTasks.push(cb);
  runUpdatePassOnRaf();
}
function requestMutation(cb) {
  pendingMutationTasks.push(cb);
  runUpdatePassOnRaf();
}
function requestNextMutation(cb) {
  requestMeasure(() => {
    requestMutation(cb);
  });
}
function requestForcedReflow(cb) {
  pendingForceReflowTasks.push(cb);
  runUpdatePassOnRaf();
}
function throttleWithRafFallback(fn) {
  return (0,_util_schedulers__WEBPACK_IMPORTED_MODULE_2__/* .throttleWith */ .nb)(throttledFn => {
    (0,_util_schedulers__WEBPACK_IMPORTED_MODULE_2__/* .fastRaf */ .IJ)(throttledFn, true);
  }, fn);
}


/***/ }),

/***/ 67526:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ 75357:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Z3: () => (/* binding */ enableStrict),
  Uj: () => (/* binding */ forceMeasure),
  dL: () => (/* binding */ forceMutation),
  A: () => (/* binding */ setPhase),
  bo: () => (/* binding */ suppressStrict)
});

// UNUSED EXPORTS: disableStrict, getPhase, setHandler

;// ./src/lib/fasterdom/layoutCauses.ts
// https://gist.github.com/paulirish/5d52fb081b3570c81e3a

/* harmony default export */ const layoutCauses = ({
  Element: {
    props: ['clientLeft', 'clientTop', 'clientWidth', 'clientHeight', 'scrollWidth', 'scrollHeight', 'scrollLeft', 'scrollTop'],
    methods: ['getClientRects', 'getBoundingClientRect', 'scrollBy', 'scrollTo', 'scrollIntoView', 'scrollIntoViewIfNeeded']
  },
  HTMLElement: {
    props: ['offsetLeft', 'offsetTop', 'offsetWidth', 'offsetHeight', 'offsetParent', 'innerText'],
    methods: ['focus']
  },
  window: {
    props: ['scrollX', 'scrollY', 'innerHeight', 'innerWidth'],
    methods: ['getComputedStyle']
  },
  VisualViewport: {
    props: ['height', 'width', 'offsetTop', 'offsetLeft']
  },
  Document: {
    props: ['scrollingElement'],
    methods: ['elementFromPoint']
  },
  HTMLInputElement: {
    methods: ['select']
  },
  MouseEvent: {
    props: ['layerX', 'layerY', 'offsetX', 'offsetY']
  },
  Range: {
    methods: ['getClientRects', 'getBoundingClientRect']
  }
});
;// ./src/lib/fasterdom/stricterdom.ts

// eslint-disable-next-line no-console
const DEFAULT_ERROR_HANDLER = console.error;
let onError = DEFAULT_ERROR_HANDLER;
const nativeMethods = new Map();
let phase = 'measure';
let isStrict = false;
let observer;
function setPhase(newPhase) {
  phase = newPhase;
}
function getPhase() {
  return phase;
}
function enableStrict() {
  if (isStrict) return;
  isStrict = true;
  setupLayoutDetectors();
  setupMutationObserver();
}
function disableStrict() {
  if (!isStrict) return;
  clearMutationObserver();
  clearLayoutDetectors();
  isStrict = false;
}
function forceMeasure(cb) {
  if (phase !== 'mutate') {
    throw new Error('The current phase is \'measure\'');
  }
  phase = 'measure';
  const result = cb();
  phase = 'mutate';
  return result;
}
const forcedMutationAllowedFor = new Set();
function forceMutation(cb, nodes) {
  if (phase !== 'measure') {
    throw new Error('The current phase is \'mutate\'');
  }
  if (isStrict) {
    if (Array.isArray(nodes)) {
      nodes.forEach(node => {
        forcedMutationAllowedFor.add(node);
      });
    } else {
      forcedMutationAllowedFor.add(nodes);
    }
  }
  return cb();
}
function suppressStrict(cb) {
  if (!isStrict) {
    return cb();
  }
  disableStrict();
  const result = cb();
  enableStrict();
  return result;
}
function setHandler(handler) {
  onError = handler || DEFAULT_ERROR_HANDLER;
}
function setupLayoutDetectors() {
  Object.entries(layoutCauses).forEach(_ref => {
    let [name, causes] = _ref;
    const entity = window[name];
    if (!entity) return;
    const prototype = typeof entity === 'object' ? entity : entity.prototype;
    if ('props' in causes) {
      causes.props.forEach(prop => {
        var _Object$getOwnPropert;
        const nativeGetter = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(prototype, prop)) === null || _Object$getOwnPropert === void 0 ? void 0 : _Object$getOwnPropert.get;
        if (!nativeGetter) {
          return;
        }
        nativeMethods.set(`${name}#${prop}`, nativeGetter);
        Object.defineProperty(prototype, prop, {
          get() {
            onMeasure(prop);
            return nativeGetter.call(this);
          }
        });
      });
    }
    if ('methods' in causes) {
      causes.methods.forEach(method => {
        const nativeMethod = prototype[method];
        nativeMethods.set(`${name}#${method}`, nativeMethod);
        prototype[method] = function () {
          onMeasure(method);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return nativeMethod.apply(this, args);
        };
      });
    }
  });
}
function clearLayoutDetectors() {
  Object.entries(layoutCauses).forEach(_ref2 => {
    let [name, causes] = _ref2;
    const entity = window[name];
    if (!entity) return;
    const prototype = typeof entity === 'object' ? entity : entity.prototype;
    if ('props' in causes) {
      causes.props.forEach(prop => {
        const nativeGetter = nativeMethods.get(`${name}#${prop}`);
        if (!nativeGetter) {
          return;
        }
        Object.defineProperty(prototype, prop, {
          get: nativeGetter
        });
      });
    }
    if ('methods' in causes) {
      causes.methods.forEach(method => {
        prototype[method] = nativeMethods.get(`${name}#${method}`);
      });
    }
  });
  nativeMethods.clear();
}
function setupMutationObserver() {
  observer = new MutationObserver(mutations => {
    if (phase !== 'mutate') {
      mutations.forEach(_ref3 => {
        let {
          target,
          type,
          attributeName
        } = _ref3;
        if (!document.contains(target)) {
          return;
        }
        if (forcedMutationAllowedFor.has(target)) {
          return;
        }
        if (type === 'childList' && target instanceof HTMLElement && target.contentEditable) {
          return;
        }
        if (attributeName !== null && attributeName !== void 0 && attributeName.startsWith('data-')) {
          return;
        }
        onError(new Error(`Unexpected mutation detected: \`${type === 'attributes' ? attributeName : type}\``));
      });
    }
    forcedMutationAllowedFor.clear();
  });
  observer.observe(document.body, {
    childList: true,
    attributes: true,
    subtree: true,
    characterData: false
  });
}
function clearMutationObserver() {
  var _observer;
  (_observer = observer) === null || _observer === void 0 || _observer.disconnect();
  observer = undefined;
}
function onMeasure(propName) {
  if (phase !== 'measure') {
    onError(new Error(`Unexpected measurement detected: \`${propName}\``));
  }
}

/***/ }),

/***/ 76944:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  p: () => (/* reexport */ callApi),
  R: () => (/* reexport */ initApi)
});

// EXTERNAL MODULE: ./src/util/logs.ts
var logs = __webpack_require__(55029);
// EXTERNAL MODULE: ./src/util/PostMessageConnector.ts
var PostMessageConnector = __webpack_require__(5130);
// EXTERNAL MODULE: ./src/util/schedulers.ts
var schedulers = __webpack_require__(37836);
// EXTERNAL MODULE: ./src/util/windowEnvironment.ts
var windowEnvironment = __webpack_require__(82393);
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(31481);
// EXTERNAL MODULE: ./src/util/createPostMessageInterface.ts
var createPostMessageInterface = __webpack_require__(54218);
// EXTERNAL MODULE: ./src/util/windowProvider/methods/index.ts + 3 modules
var methods = __webpack_require__(95550);
;// ./src/util/windowProvider/index.ts



function createWindowProvider(worker) {
  (0,createPostMessageInterface/* createPostMessageInterface */.p)(methods, config/* WINDOW_PROVIDER_CHANNEL */.Pcx, worker, true);
}
function createWindowProviderForExtension() {
  createReverseExtensionInterface(WINDOW_PROVIDER_PORT, windowMethods);
}
;// ./src/api/providers/extension/config.ts

const POPUP_PORT = (/* unused pure expression or super */ null && (IS_CORE_WALLET ? 'TonWallet_popup' : 'MyTonWallet_popup'));
const CONTENT_SCRIPT_PORT = (/* unused pure expression or super */ null && (IS_CORE_WALLET ? 'TonWallet_contentScript' : 'MyTonWallet_contentScript'));
const PAGE_CONNECTOR_CHANNEL = (/* unused pure expression or super */ null && (IS_CORE_WALLET ? 'TonWallet_pageConnector' : 'MyTonWallet_pageConnector'));
;// ./src/api/providers/worker/connector.ts






const HEALTH_CHECK_TIMEOUT = 150;
const HEALTH_CHECK_MIN_DELAY = 5000; // 5 sec

let updateCallback;
let worker;
let connector;
let isInitialized = false;
function initApi(onUpdate, initArgs) {
  updateCallback = onUpdate;
  if (!connector) {
    // We use process.env.IS_EXTENSION instead of IS_EXTENSION in order to remove the irrelevant code during bundling
    if (false) // removed by dead control flow
{} else {
      worker = new Worker(/* webpackChunkName: "worker" */new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(941), __webpack_require__.b));
      connector = (0,PostMessageConnector/* createConnector */.U$)(worker, onUpdate);
      createWindowProvider(worker);
    }
  }
  if (!isInitialized) {
    if ( true && windowEnvironment/* IS_IOS */.pz) {
      setupIosHealthCheck();
    }
    isInitialized = true;
  }
  const args = typeof initArgs === 'function' ? initArgs() : initArgs;
  return connector.init(args);
}
async function callApi(fnName) {
  if (!connector) {
    (0,logs/* logDebugError */.SJ)('API is not initialized when calling', fnName);
    return undefined;
  }
  try {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    const result = await connector.request({
      name: fnName,
      args
    });
    (0,logs/* logDebugApi */.kJ)(`callApi: ${fnName}`, args, result);
    return result;
  } catch (err) {
    return undefined;
  }
}
function callApiWithThrow(fnName) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return connector.request({
    name: fnName,
    args
  });
}
const startedAt = Date.now();

// Workaround for iOS sometimes stops interacting with worker
function setupIosHealthCheck() {
  window.addEventListener('focus', () => {
    void ensureWorkerPing();
    // Sometimes a single check is not enough
    setTimeout(() => ensureWorkerPing(), 1000);
  });
}
async function ensureWorkerPing() {
  let isResolved = false;
  try {
    await Promise.race([callApiWithThrow('ping'), (0,schedulers/* pause */.v7)(HEALTH_CHECK_TIMEOUT).then(() => isResolved ? undefined : Promise.reject(new Error('HEALTH_CHECK_TIMEOUT')))]);
  } catch (err) {
    (0,logs/* logDebugError */.SJ)('ensureWorkerPing', err);
    if (Date.now() - startedAt >= HEALTH_CHECK_MIN_DELAY) {
      var _worker;
      (_worker = worker) === null || _worker === void 0 || _worker.terminate();
      worker = undefined;
      connector = undefined;
      updateCallback({
        type: 'requestReconnectApi'
      });
    }
  } finally {
    isResolved = true;
  }
}
;// ./src/api/index.ts
// export { initApi, callApi } from './providers/direct/connector';


/***/ }),

/***/ 82393:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $: () => (/* binding */ REM),
/* harmony export */   $q: () => (/* binding */ USER_AGENT_LANG_CODE),
/* harmony export */   By: () => (/* binding */ IS_OPERA),
/* harmony export */   ED: () => (/* binding */ IS_DAPP_SUPPORTED),
/* harmony export */   Et: () => (/* binding */ IS_CLIPBOARDS_SUPPORTED),
/* harmony export */   Fe: () => (/* binding */ IS_LEDGER_EXTENSION_TAB),
/* harmony export */   H8: () => (/* binding */ IS_WINDOWS),
/* harmony export */   KI: () => (/* binding */ IS_DELEGATING_BOTTOM_SHEET),
/* harmony export */   Kc: () => (/* binding */ setScrollbarWidthProperty),
/* harmony export */   Lv: () => (/* binding */ DPR),
/* harmony export */   MP: () => (/* binding */ IS_MAC_OS),
/* harmony export */   Ni: () => (/* binding */ IS_ANDROID),
/* harmony export */   TF: () => (/* binding */ IS_TOUCH_ENV),
/* harmony export */   XS: () => (/* binding */ STICKY_CARD_INTERSECTION_THRESHOLD),
/* harmony export */   Yw: () => (/* binding */ IS_SAFARI),
/* harmony export */   ZH: () => (/* binding */ IS_IOS_APP),
/* harmony export */   _7: () => (/* binding */ IS_PWA),
/* harmony export */   bA: () => (/* binding */ IS_DELEGATED_BOTTOM_SHEET),
/* harmony export */   bs: () => (/* binding */ IS_MULTITAB_SUPPORTED),
/* harmony export */   cp: () => (/* binding */ IS_ELECTRON),
/* harmony export */   iF: () => (/* binding */ IS_CHROME_EXTENSION),
/* harmony export */   ig: () => (/* binding */ IS_LINUX),
/* harmony export */   pr: () => (/* binding */ IS_EDGE),
/* harmony export */   pz: () => (/* binding */ IS_IOS),
/* harmony export */   sC: () => (/* binding */ IS_LEDGER_SUPPORTED),
/* harmony export */   u2: () => (/* binding */ IS_WEB),
/* harmony export */   uh: () => (/* binding */ IS_BIOMETRIC_AUTH_SUPPORTED),
/* harmony export */   v3: () => (/* binding */ getIsMobileTelegramApp),
/* harmony export */   vj: () => (/* binding */ DEFAULT_LANG_CODE),
/* harmony export */   xy: () => (/* binding */ IS_ANDROID_APP)
/* harmony export */ });
/* unused harmony exports PLATFORM_ENV, IS_FIREFOX */
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31481);
/* harmony import */ var _lib_fasterdom_fasterdom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66644);
/* harmony import */ var _ledger_tab__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51915);
/* harmony import */ var _getPlatform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36791);
var _window$chrome;




const TELEGRAM_MOBILE_PLATFORM = new Set(['android', 'android_x', 'ios']);
function isIPad() {
  const {
    userAgent,
    platform
  } = window.navigator;
  return platform === 'iPad' || userAgent.includes('iPad') || platform === 'MacIntel' && 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 2;
}
function getBrowserLanguage() {
  if (_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CORE_WALLET */ .TI6) return 'en';
  const {
    language
  } = navigator;
  const lang = language.startsWith('zh') ? language.endsWith('TW') || language.endsWith('HK') ? 'zh-Hant' : 'zh-Hans' : language.substring(0, 2);
  return _config__WEBPACK_IMPORTED_MODULE_0__/* .LANG_LIST */ .gSB.some(_ref => {
    let {
      langCode
    } = _ref;
    return langCode === lang;
  }) ? lang : 'en';
}
const IS_PWA = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone || document.referrer.includes('android-app://');
const PLATFORM_ENV = (0,_getPlatform__WEBPACK_IMPORTED_MODULE_2__/* .getPlatform */ .u)();
const IS_MAC_OS = PLATFORM_ENV === 'macOS';
const IS_WINDOWS = PLATFORM_ENV === 'Windows';
const IS_LINUX = PLATFORM_ENV === 'Linux';
const IS_IOS = PLATFORM_ENV === 'iOS';
const IS_ANDROID = PLATFORM_ENV === 'Android';
const IS_SAFARI = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
const IS_OPERA = navigator.userAgent.includes(' OPR/');
const IS_EDGE = navigator.userAgent.includes(' Edg/');
const IS_FIREFOX = navigator.userAgent.includes('Firefox/');
const IS_TOUCH_ENV = window.matchMedia('(pointer: coarse)').matches;
const IS_CHROME_EXTENSION = Boolean((_window$chrome = window.chrome) === null || _window$chrome === void 0 ? void 0 : _window$chrome.system);
const IS_ELECTRON = Boolean(window.electron);
const IS_WEB = !_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ && !IS_ELECTRON && !_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_EXTENSION */ .hL1 && !_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_TELEGRAM_APP */ .tKX;
const DEFAULT_LANG_CODE = 'en';
const USER_AGENT_LANG_CODE = getBrowserLanguage();
const DPR = window.devicePixelRatio || 1;
const IS_LEDGER_SUPPORTED = _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ || !(_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CORE_WALLET */ .TI6 || IS_IOS || _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_FIREFOX_EXTENSION */ .v5B || _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_TELEGRAM_APP */ .tKX);
const IS_LEDGER_EXTENSION_TAB = __webpack_require__.g.location.hash.startsWith(_ledger_tab__WEBPACK_IMPORTED_MODULE_3__/* .DETACHED_TAB_URL */ .jT);
// Disable biometric auth on electron for now until this issue is fixed:
// https://github.com/electron/electron/issues/24573
const IS_BIOMETRIC_AUTH_SUPPORTED = Boolean(!_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ && !_config__WEBPACK_IMPORTED_MODULE_0__/* .IS_TELEGRAM_APP */ .tKX && window.navigator.credentials && (!IS_ELECTRON || IS_MAC_OS));
const IS_DELEGATED_BOTTOM_SHEET = _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ && __webpack_require__.g.location.search.startsWith('?bottom-sheet');
const IS_DELEGATING_BOTTOM_SHEET = _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ && IS_IOS && !IS_DELEGATED_BOTTOM_SHEET && !isIPad();
const IS_MULTITAB_SUPPORTED = 'BroadcastChannel' in window && !IS_LEDGER_EXTENSION_TAB;
const IS_DAPP_SUPPORTED = _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_EXTENSION */ .hL1 || IS_ELECTRON || _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ;
const IS_IOS_APP = IS_IOS && _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ;
const IS_ANDROID_APP = IS_ANDROID && _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_CAPACITOR */ .UMQ;

// Note: As of 27-11-2023, Firefox does not support readText()
// Note: As of 22-02-2023, clipboard functionality is only available to the Telegram partners
// https://github.com/Telegram-Mini-Apps/telegram-apps/issues/609#issuecomment-2571435311
const IS_CLIPBOARDS_SUPPORTED = !(IS_FIREFOX || _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_FIREFOX_EXTENSION */ .v5B || _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_TELEGRAM_APP */ .tKX);
const REM = parseInt(getComputedStyle(document.documentElement).fontSize, 10);
const STICKY_CARD_INTERSECTION_THRESHOLD = -3 * REM;
function setScrollbarWidthProperty() {
  const el = document.createElement('div');
  el.style.cssText = 'overflow-x: hidden; overflow-y: scroll; visibility:hidden; position:absolute;';
  el.classList.add('custom-scroll');
  document.body.appendChild(el);
  (0,_lib_fasterdom_fasterdom__WEBPACK_IMPORTED_MODULE_1__/* .requestForcedReflow */ .gm)(() => {
    const width = el.offsetWidth - el.clientWidth;
    return () => {
      document.documentElement.style.setProperty('--scrollbar-width', `${width}px`);
      el.remove();
    };
  });
}
function getIsMobileTelegramApp() {
  var _window$Telegram;
  return _config__WEBPACK_IMPORTED_MODULE_0__/* .IS_TELEGRAM_APP */ .tKX && TELEGRAM_MOBILE_PLATFORM.has(((_window$Telegram = window.Telegram) === null || _window$Telegram === void 0 ? void 0 : _window$Telegram.WebApp.platform) ?? '');
}

/***/ }),

/***/ 86243:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LG: () => (/* binding */ getMainAccountAddress),
/* harmony export */   S: () => (/* binding */ getAccountTitle),
/* harmony export */   cK: () => (/* binding */ parseAccountId),
/* harmony export */   zu: () => (/* binding */ buildAccountId)
/* harmony export */ });
/* harmony import */ var _shortenAddress__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91049);

function parseAccountId(accountId) {
  const parts = accountId.split('-');
  const [id, network = 'mainnet'] = parts.length === 3 ? [parts[0], parts[2]] : parts;
  return {
    id: Number(id),
    network
  };
}
function buildAccountId(account) {
  const {
    id,
    network
  } = account;
  return `${id}-${network}`;
}
function getMainAccountAddress(addressByChain) {
  return addressByChain.ton ?? Object.values(addressByChain).find(Boolean);
}
function getAccountTitle(account) {
  return account.title || (0,_shortenAddress__WEBPACK_IMPORTED_MODULE_0__/* .shortenAddress */ .W)(getMainAccountAddress(account.addressByChain) ?? '');
}

/***/ }),

/***/ 87894:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $z: () => (/* binding */ groupBy),
/* harmony export */   Am: () => (/* binding */ unique),
/* harmony export */   Hl: () => (/* binding */ findDifference),
/* harmony export */   JY: () => (/* binding */ extractKey),
/* harmony export */   LG: () => (/* binding */ mapValues),
/* harmony export */   My: () => (/* binding */ orderBy),
/* harmony export */   Oy: () => (/* binding */ omitUndefined),
/* harmony export */   Uk: () => (/* binding */ findLast),
/* harmony export */   Up: () => (/* binding */ pick),
/* harmony export */   V6: () => (/* binding */ swapKeysAndValues),
/* harmony export */   Vh: () => (/* binding */ isLiteralObject),
/* harmony export */   _E: () => (/* binding */ pickTruthy),
/* harmony export */   cJ: () => (/* binding */ omit),
/* harmony export */   dU: () => (/* binding */ buildCollectionByKey),
/* harmony export */   k: () => (/* binding */ areSortedArraysEqual),
/* harmony export */   lD: () => (/* binding */ split),
/* harmony export */   lk: () => (/* binding */ filterValues),
/* harmony export */   mg: () => (/* binding */ cloneDeep),
/* harmony export */   oE: () => (/* binding */ compact),
/* harmony export */   yQ: () => (/* binding */ mergeSortedArrays)
/* harmony export */ });
/* unused harmony exports range, fromKeyValueArrays, uniqueByKey, intersection */
function buildCollectionByKey(collection, key) {
  return collection.reduce((byKey, member) => {
    byKey[member[key]] = member;
    return byKey;
  }, {});
}
function groupBy(collection, key) {
  return collection.reduce((byKey, member) => {
    const groupKey = member[key];
    if (!byKey[groupKey]) {
      byKey[groupKey] = [member];
    } else {
      byKey[groupKey].push(member);
    }
    return byKey;
  }, {});
}
function mapValues(byKey, callback) {
  return Object.keys(byKey).reduce((newByKey, key, index) => {
    newByKey[key] = callback(byKey[key], key, index, byKey);
    return newByKey;
  }, {});
}
function pick(object, keys) {
  return keys.reduce((result, key) => {
    result[key] = object[key];
    return result;
  }, {});
}
function pickTruthy(object, keys) {
  return keys.reduce((result, key) => {
    if (object[key]) {
      result[key] = object[key];
    }
    return result;
  }, {});
}
function omit(object, keys) {
  const stringKeys = new Set(keys.map(String));
  const savedKeys = Object.keys(object).filter(key => !stringKeys.has(key));
  return pick(object, savedKeys);
}
function omitUndefined(object) {
  return Object.keys(object).reduce((result, stringKey) => {
    const key = stringKey;
    if (object[key] !== undefined) {
      result[key] = object[key];
    }
    return result;
  }, {});
}
function orderBy(collection, orderRule) {
  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'asc';
  function compareValues(a, b, currentOrderRule, isAsc) {
    const aValue = (typeof currentOrderRule === 'function' ? currentOrderRule(a) : a[currentOrderRule]) || 0;
    const bValue = (typeof currentOrderRule === 'function' ? currentOrderRule(b) : b[currentOrderRule]) || 0;
    if (aValue === bValue) return 0;
    const condition = isAsc ? aValue > bValue : aValue < bValue;
    return condition ? 1 : -1;
  }
  if (Array.isArray(orderRule)) {
    const [mode1, mode2] = Array.isArray(mode) ? mode : [mode, mode];
    const [orderRule1, orderRule2] = orderRule;
    const isAsc1 = mode1 === 'asc';
    const isAsc2 = mode2 === 'asc';
    return collection.sort((a, b) => {
      return compareValues(a, b, orderRule1, isAsc1) || compareValues(a, b, orderRule2, isAsc2);
    });
  }
  const isAsc = mode === 'asc';
  return collection.sort((a, b) => {
    return compareValues(a, b, orderRule, isAsc);
  });
}
function unique(array) {
  return Array.from(new Set(array));
}
function compact(array) {
  return array.filter(Boolean);
}
function areSortedArraysEqual(array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }
  return array1.every((item, i) => item === array2[i]);
}
function split(array, chunkSize) {
  const result = [];
  for (let i = 0; i < array.length; i += chunkSize) {
    result.push(array.slice(i, i + chunkSize));
  }
  return result;
}
function cloneDeep(value) {
  if (!isObject(value)) {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(cloneDeep);
  }
  return Object.keys(value).reduce((acc, key) => {
    acc[key] = cloneDeep(value[key]);
    return acc;
  }, {});
}
function isLiteralObject(value) {
  return isObject(value) && !Array.isArray(value);
}
function isObject(value) {
  // eslint-disable-next-line no-null/no-null
  return typeof value === 'object' && value !== null;
}
function findLast(array, predicate) {
  let cursor = array.length;
  while (cursor--) {
    if (predicate(array[cursor], cursor, array)) {
      return array[cursor];
    }
  }
  return undefined;
}
function range(start, end) {
  const arr = [];
  for (let i = start; i < end;) {
    arr.push(i++);
  }
  return arr;
}
function fromKeyValueArrays(keys, values) {
  return keys.reduce((acc, key, index) => {
    acc[key] = Array.isArray(values) ? values[index] : values;
    return acc;
  }, {});
}
function extractKey(array, key) {
  return array.map(value => value[key]);
}
function findDifference(array1, array2) {
  const set2 = new Set(array2);
  const diff = [];
  for (const element of array1) {
    if (!set2.has(element)) {
      diff.push(element);
    }
  }
  return diff;
}
function filterValues(byKey, callback) {
  return Object.keys(byKey).reduce((newByKey, key, index) => {
    if (callback(byKey[key], key, index, byKey)) {
      newByKey[key] = byKey[key];
    }
    return newByKey;
  }, {});
}
function uniqueByKey(array, key, shouldKeepFirst) {
  if (shouldKeepFirst) {
    array = Array.from(array);
    array.reverse();
  }
  const result = [...new Map(array.map(item => [item[key], item])).values()];
  if (shouldKeepFirst) {
    result.reverse();
  }
  return result;
}
function intersection(x, y) {
  const result = new Set();
  for (const elem of y) {
    if (x.has(elem)) {
      result.add(elem);
    }
  }
  return result;
}
function swapKeysAndValues(object) {
  const result = {};
  for (const [key, value] of Object.entries(object)) {
    result[value] = key;
  }
  return result;
}

/**
 * `arr1` and `arr2` must be sorted according to `compareFn`, otherwise the result is not guaranteed.
 * `deduplicateEqual` doesn't remove duplicates if the input arrays contain duplicates.
 */
function mergeSortedArrays(arr1, arr2, compareFn, deduplicateEqual) {
  let index1 = 0;
  let index2 = 0;
  const result = [];
  while (index1 < arr1.length && index2 < arr2.length) {
    const compareResult = compareFn(arr1[index1], arr2[index2]);
    if (compareResult === 0) {
      result.push(arr1[index1]);
      if (!deduplicateEqual) {
        result.push(arr2[index2]);
      }
      index1++;
      index2++;
    } else if (compareResult < 0) {
      result.push(arr1[index1]);
      index1++;
    } else {
      result.push(arr2[index2]);
      index2++;
    }
  }
  for (; index1 < arr1.length; index1++) {
    result.push(arr1[index1]);
  }
  for (; index2 < arr2.length; index2++) {
    result.push(arr2[index2]);
  }
  return result;
}

/***/ }),

/***/ 91049:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ MEANINGFUL_CHAR_LENGTH),
/* harmony export */   W: () => (/* binding */ shortenAddress)
/* harmony export */ });
/* harmony import */ var _withCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19314);

const MEANINGFUL_CHAR_LENGTH = 6;
const FILLER = 'Â·Â·Â·';
const FILLER_LENGTH = FILLER.length;
const shortenAddress = (0,_withCache__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(function (address) {
  let shift = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MEANINGFUL_CHAR_LENGTH;
  let fromRight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : shift;
  if (!address) return undefined;
  if (address.length <= shift + fromRight + FILLER_LENGTH) return address;
  return `${address.slice(0, shift)}${FILLER}${address.slice(-fromRight)}`;
});

/***/ }),

/***/ 95550:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  capacitorStorageClear: () => (/* reexport */ capacitorStorageClear),
  capacitorStorageGetItem: () => (/* reexport */ capacitorStorageGetItem),
  capacitorStorageKeys: () => (/* reexport */ capacitorStorageKeys),
  capacitorStorageRemoveItem: () => (/* reexport */ capacitorStorageRemoveItem),
  capacitorStorageSetItem: () => (/* reexport */ capacitorStorageSetItem),
  exchangeWithLedger: () => (/* reexport */ exchangeWithLedger),
  init: () => (/* reexport */ init),
  localStorageClear: () => (/* reexport */ localStorageClear),
  localStorageGetAll: () => (/* reexport */ localStorageGetAll),
  localStorageGetItem: () => (/* reexport */ localStorageGetItem),
  localStorageGetMany: () => (/* reexport */ localStorageGetMany),
  localStorageRemoveItem: () => (/* reexport */ localStorageRemoveItem),
  localStorageSetItem: () => (/* reexport */ localStorageSetItem),
  localStorageSetMany: () => (/* reexport */ localStorageSetMany)
});

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(31481);
;// ./src/util/windowProvider/methods/capacitorStorage.ts

let SecureStoragePlugin;
let resolvePromise;
const promise = new Promise(resolve => {
  resolvePromise = resolve;
});
async function init() {
  if (config/* IS_CAPACITOR */.UMQ && !SecureStoragePlugin) {
    ({
      SecureStoragePlugin
    } = await __webpack_require__.e(/* import() | capacitorSecureStorage */ 201).then(__webpack_require__.bind(__webpack_require__, 5054)));
    resolvePromise();
  }
}
async function capacitorStorageGetItem(key) {
  var _await$get$catch;
  await promise;
  return (_await$get$catch = await SecureStoragePlugin.get({
    key
  }).catch(err => {
    const message = typeof err === 'string' ? err : err.message;
    if (message.includes('key does not exist')) {
      return undefined;
    } else {
      throw err;
    }
  })) === null || _await$get$catch === void 0 ? void 0 : _await$get$catch.value;
}
async function capacitorStorageSetItem(key, value) {
  await promise;
  return SecureStoragePlugin.set({
    key,
    value
  });
}
async function capacitorStorageRemoveItem(key) {
  await promise;
  return SecureStoragePlugin.remove({
    key
  });
}
async function capacitorStorageClear() {
  await promise;
  return SecureStoragePlugin.clear();
}
async function capacitorStorageKeys() {
  await promise;
  return SecureStoragePlugin.keys();
}
;// ./src/util/windowProvider/methods/ledger.ts
/* provided dependency */ var Buffer = __webpack_require__(48287)["Buffer"];
// String is used instead of Buffer, because Buffer can't be transferred to/from worker.
// Uint8Array is not used because it can't be transferred to/from extension service worker.
async function exchangeWithLedger(apduBase64) {
  const {
    getTransport
  } = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
  const transport = getTransport();
  if (!transport) {
    throw new Error('Ledger transport is not initialized');
  }
  const apduBuffer = Buffer.from(apduBase64, 'base64');
  const response = await transport.exchange(apduBuffer);
  return response.toString('base64');
}
// EXTERNAL MODULE: ./src/util/iteratees.ts
var iteratees = __webpack_require__(87894);
;// ./src/util/windowProvider/methods/localStorage.ts

function localStorageGetItem(key) {
  return localStorage.getItem(key);
}
function localStorageSetItem(key, value) {
  return localStorage.setItem(key, value);
}
function localStorageRemoveItem(key) {
  return localStorage.removeItem(key);
}
function localStorageClear() {
  return localStorage.clear();
}
function localStorageGetAll() {
  return {
    ...localStorage
  };
}
function localStorageGetMany(keys) {
  return (0,iteratees/* pick */.Up)(localStorage, keys);
}
function localStorageSetMany(items) {
  Object.assign(localStorage, items);
}
;// ./src/util/windowProvider/methods/index.ts




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + {"88":"cc359a033c0b26babd5b","104":"9347006a776b3d7a538e","106":"55d48c6aeb5d6673d6a3","148":"4d167030ecbc02281e52","168":"896a19d566f246289b20","196":"bc51b6ab35f68884c9f5","201":"c8d77125f3626db6ca61","215":"8c50e7e148f67437b2c7","283":"9d890e209a01a1029bda","408":"6403e5d45e0209dee132","411":"337e5677cb1bde8f514c","477":"7e711a5e99972ed9fd09","513":"881d0e291eb1b89c0086","524":"c8c70ee3b05c7762d8dd","542":"aaec82bde406cc057d5d","564":"1c2b6f95dda10b2a3db1","580":"90ee8eb1119c52865435","629":"3188db96e020e2801d55","642":"d0275244246013f8e5d0","789":"7f69fc1e59f42542479a","800":"09881729ade743d90448","803":"4a4cfed8e6225ff4e320","884":"e88c862767a79b94579d","895":"c82c6597b73a96da89b8","897":"3020f000079f29fdc8bc","909":"a7bb8f6eb0374ee347af","941":"e2dcebb506a6ee4b3938","949":"109a61890f6ab8269659","956":"aa3821ad2de8350af957","988":"9eea16b4e6269d266929"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "mytonwallet:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			792: 0,
/******/ 			840: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkmytonwallet"] = self["webpackChunkmytonwallet"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./src/config.ts
var src_config = __webpack_require__(31481);
// EXTERNAL MODULE: ./src/util/logs.ts
var logs = __webpack_require__(55029);
// EXTERNAL MODULE: ./src/util/windowEnvironment.ts
var windowEnvironment = __webpack_require__(82393);
// EXTERNAL MODULE: ./src/api/index.ts + 3 modules
var api = __webpack_require__(76944);
;// ./src/util/arePropsShallowEqual.ts
function arePropsShallowEqual(currentProps, newProps) {
  if (currentProps === newProps) {
    return true;
  }
  const currentKeys = Object.keys(currentProps);
  const currentKeysLength = currentKeys.length;
  const newKeysLength = Object.keys(newProps).length;
  if (currentKeysLength !== newKeysLength) {
    return false;
  }
  if (currentKeysLength === 0) {
    return true;
  }
  for (let i = 0; i < currentKeysLength; i++) {
    const prop = currentKeys[i];
    if (currentProps[prop] !== newProps[prop]) {
      return false;
    }
  }
  return true;
}
function logUnequalProps(currentProps, newProps, msg) {
  let debugKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  const currentKeys = Object.keys(currentProps);
  const currentKeysLength = currentKeys.length;
  const newKeysLength = Object.keys(newProps).length;
  if (currentKeysLength !== newKeysLength) {
    // eslint-disable-next-line no-console
    console.log(`${msg} LENGTH`);
    return;
  }

  // eslint-disable-next-line no-console
  console.log(msg);
  currentKeys.forEach(prop => {
    if (currentProps[prop] !== newProps[prop]) {
      // eslint-disable-next-line no-console
      console.log(debugKey, prop, ':', currentProps[prop], '=>', newProps[prop]);
    }
  });
}
// EXTERNAL MODULE: ./src/util/handleError.ts + 1 modules
var src_handleError = __webpack_require__(48217);
// EXTERNAL MODULE: ./src/util/iteratees.ts
var iteratees = __webpack_require__(87894);
// EXTERNAL MODULE: ./src/util/schedulers.ts
var schedulers = __webpack_require__(37836);
// EXTERNAL MODULE: ./src/util/animation.ts
var animation = __webpack_require__(19822);
;// ./src/util/debugOverlay.ts


const KEYS_TO_IGNORE = new Set(['TeactMemoWrapper renders', 'TeactNContainer renders', 'Button renders']);
const MIN_RENDERS_TO_SHOW = 5;
const MIN_DURATION_TO_SHOW = 2;
let counters = {};
const renderCountersThrottled = (0,schedulers/* throttle */.nF)(renderCounters, 500, false);
let loggerEl;
function debugToOverlay(text) {
  if (!loggerEl) {
    setupOverlay();
  }
  const date = new Date();
  const dateFormatted = `${date.toLocaleTimeString()}.${date.getMilliseconds()}`;
  const wasAtBottom = loggerEl.scrollTop + 10 >= loggerEl.scrollHeight - loggerEl.offsetHeight;
  loggerEl.append(`${dateFormatted}: ${text}`, document.createElement('br'));
  if (wasAtBottom) {
    loggerEl.scrollTop = loggerEl.scrollHeight;
  }
}
function incrementOverlayCounter(key) {
  let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  const now = Date.now();
  if (!counters[key]) {
    counters[key] = {
      value,
      lastUpdateAt: now
    };
  } else {
    counters[key].value += value;
    counters[key].lastUpdateAt = now;
  }
  renderCountersThrottled();
}
function renderCounters() {
  if (!loggerEl) {
    setupOverlay();
  }
  const halfSecondAgo = Date.now() - 500;
  const [maxRenders, maxDuration] = Object.entries(counters).reduce((acc, _ref) => {
    let [key, {
      value
    }] = _ref;
    if (KEYS_TO_IGNORE.has(key)) {
      return acc;
    }
    if (key.includes('renders') && value > acc[0]) {
      acc[0] = value;
    }
    if (key.includes('duration') && value > acc[1]) {
      acc[1] = value;
    }
    return acc;
  }, [0, 0]);
  loggerEl.innerHTML = '';
  Object.entries(counters).filter(_ref2 => {
    let [key, {
      value
    }] = _ref2;
    return !KEYS_TO_IGNORE.has(key) && (key.includes('renders') && value > MIN_RENDERS_TO_SHOW || key.includes('duration') && value > MIN_DURATION_TO_SHOW);
  }).sort((a, b) => b[1].lastUpdateAt - a[1].lastUpdateAt).forEach(_ref3 => {
    let [key, {
      value,
      lastUpdateAt
    }] = _ref3;
    const content = document.createElement('span');
    content.style.background = lastUpdateAt > halfSecondAgo ? 'lightgreen' : '';
    content.textContent = `${key}: ${Math.round(value)}`;
    const parent = document.createElement('div');
    parent.style.background = `#ff0000${factorToHex(value / (key.includes('renders') ? maxRenders : maxDuration))}`;
    parent.append(content);
    loggerEl.append(parent);
  });
}
function debugFps() {
  if (!loggerEl) {
    setupOverlay();
  }
  let ticks = [];
  let lastFrameAt = performance.now();
  animate(() => {
    const now = performance.now();
    ticks.push(now - lastFrameAt);
    lastFrameAt = now;
    if (ticks.length > 100) {
      ticks = ticks.slice(-100);
    }
    const avg = ticks.reduce((acc, t) => acc + t, 0) / ticks.length;
    loggerEl.textContent = `${Math.round(1000 / avg)} FPS`;
    return true;
  }, fastRaf);
}
function setupOverlay() {
  loggerEl = document.createElement('div');
  loggerEl.style.cssText = 'position: absolute; left: 0; bottom: 25px; z-index: 9998; width: 260px; height: 200px;' + ' border: 1px solid #555; background: rgba(255, 255, 255, 0.9); overflow: auto; font-size: 12px; color: black;';
  document.body.appendChild(loggerEl);
  const clearEl = document.createElement('a');
  clearEl.style.cssText = 'position: absolute; left: 222px; bottom: 198px; z-index: 9999; font-size: 20px; ' + 'cursor: pointer;';
  clearEl.innerText = 'ðŸ”„';
  clearEl.addEventListener('click', () => {
    counters = {};
    renderCountersThrottled();
  });
  document.body.appendChild(clearEl);
}
function factorToHex(factor) {
  return Math.round(255 * factor).toString(16).padStart(2, '0');
}
// EXTERNAL MODULE: ./src/util/safeExec.ts
var util_safeExec = __webpack_require__(50110);
;// ./src/util/callbacks.ts
function createCallbackManager() {
  const callbacks = new Set();
  function addCallback(cb) {
    callbacks.add(cb);
    return () => {
      removeCallback(cb);
    };
  }
  function removeCallback(cb) {
    callbacks.delete(cb);
  }
  function runCallbacks() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callbacks.forEach(callback => {
      callback(...args);
    });
  }
  function hasCallbacks() {
    return Boolean(callbacks.size);
  }
  return {
    runCallbacks,
    addCallback,
    removeCallback,
    hasCallbacks
  };
}
class EventEmitter {
  channels = new Map();
  on(name, handler) {
    this.resolveChannel(name).addCallback(handler);
    return this;
  }
  removeListener(name, handler) {
    this.resolveChannel(name).removeCallback(handler);
    return this;
  }
  emit(name) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    this.resolveChannel(name).runCallbacks(...args);
    return this;
  }
  resolveChannel(name) {
    let channel = this.channels.get(name);
    if (!channel) {
      channel = createCallbackManager();
      this.channels.set(name, channel);
    }
    return channel;
  }
}
;// ./src/util/signals.ts

const SIGNAL_MARK = Symbol('SIGNAL_MARK');
function isSignal(obj) {
  return typeof obj === 'function' && SIGNAL_MARK in obj;
}

// A shorthand to unsubscribe effect from all signals
const unsubscribesByEffect = new Map();
let currentEffect;
function createSignal(defaultValue) {
  const state = {
    value: defaultValue,
    effects: createCallbackManager()
  };
  function subscribe(effect) {
    const unsubscribe = state.effects.addCallback(effect);
    if (!unsubscribesByEffect.has(effect)) {
      unsubscribesByEffect.set(effect, new Set([unsubscribe]));
    } else {
      unsubscribesByEffect.get(effect).add(unsubscribe);
    }
    return () => {
      unsubscribe();
      const unsubscribes = unsubscribesByEffect.get(effect);
      unsubscribes.delete(unsubscribe);
      if (!unsubscribes.size) {
        unsubscribesByEffect.delete(effect);
      }
    };
  }
  function once(effect) {
    const unsub = subscribe(() => {
      unsub();
      effect();
    });
    return unsub;
  }
  function getter() {
    if (currentEffect) {
      subscribe(currentEffect);
    }
    return state.value;
  }
  function setter(newValue) {
    if (state.value === newValue) {
      return;
    }
    state.value = newValue;
    state.effects.runCallbacks();
  }
  const signal = Object.assign(getter, {
    [SIGNAL_MARK]: SIGNAL_MARK,
    subscribe,
    once
  });
  return [signal, setter];
}
function cleanupEffect(effect) {
  var _unsubscribesByEffect;
  (_unsubscribesByEffect = unsubscribesByEffect.get(effect)) === null || _unsubscribesByEffect === void 0 || _unsubscribesByEffect.forEach(unsubscribe => {
    unsubscribe();
  });
  unsubscribesByEffect.delete(effect);
}
// EXTERNAL MODULE: ./src/lib/fasterdom/fasterdom.ts
var fasterdom = __webpack_require__(66644);
;// ./src/lib/teact/heavyAnimation.ts



const AUTO_END_TIMEOUT = 1000;
let counter = 0;
let counterBlocking = 0;
const [getIsAnimating, setIsAnimating] = createSignal(false);
const [getIsBlockingAnimating, setIsBlockingAnimating] = createSignal(false);
const heavyAnimation_getIsHeavyAnimating = getIsAnimating;

function beginHeavyAnimation() {
  let duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : AUTO_END_TIMEOUT;
  let isBlocking = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  counter++;
  if (counter === 1) {
    setIsAnimating(true);
  }
  if (isBlocking) {
    counterBlocking++;
    if (counterBlocking === 1) {
      setIsBlockingAnimating(true);
    }
  }
  const timeout = window.setTimeout(onEnd, duration);
  let hasEnded = false;
  function onEnd() {
    if (hasEnded) return;
    hasEnded = true;
    clearTimeout(timeout);
    counter--;
    if (counter === 0) {
      setIsAnimating(false);
    }
    if (isBlocking) {
      counterBlocking--;
      if (counterBlocking === 0) {
        setIsBlockingAnimating(false);
      }
    }
  }
  return onEnd;
}
function onFullyIdle(cb) {
  (0,schedulers/* onIdle */.kI)(() => {
    if (getIsAnimating()) {
      (0,fasterdom/* requestMeasure */.YS)(() => {
        onFullyIdle(cb);
      });
    } else {
      cb();
    }
  });
}
function throttleWithFullyIdle(fn) {
  return throttleWith(onFullyIdle, fn);
}
;// ./src/lib/teact/teact.ts










let VirtualType = /*#__PURE__*/function (VirtualType) {
  VirtualType[VirtualType["Empty"] = 0] = "Empty";
  VirtualType[VirtualType["Text"] = 1] = "Text";
  VirtualType[VirtualType["Tag"] = 2] = "Tag";
  VirtualType[VirtualType["Component"] = 3] = "Component";
  VirtualType[VirtualType["Fragment"] = 4] = "Fragment";
  return VirtualType;
}({});
let MountState = /*#__PURE__*/function (MountState) {
  MountState[MountState["Mounting"] = 0] = "Mounting";
  MountState[MountState["Mounted"] = 1] = "Mounted";
  MountState[MountState["Unmounted"] = 2] = "Unmounted";
  return MountState;
}({});

// Compatibility with JSX types

const Fragment = Symbol('Fragment');
const DEBUG_RENDER_THRESHOLD = 7;
const DEBUG_EFFECT_THRESHOLD = 7;
const DEBUG_SILENT_RENDERS_FOR = new Set(['TeactMemoWrapper', 'TeactNContainer', 'Button', 'ListItem', 'MenuItem']);
let contextCounter = 0;
let lastComponentId = 0;
let renderingInstance;
function teact_isParentElement($element) {
  return $element.type === VirtualType.Tag || $element.type === VirtualType.Component || $element.type === VirtualType.Fragment;
}
function createElement(source, props) {
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  if (source === Fragment) {
    return buildFragmentElement(children);
  } else if (typeof source === 'function') {
    return createComponentInstance(source, props || {}, children);
  } else {
    return buildTagElement(source, props || {}, children);
  }
}
function buildFragmentElement(children) {
  return {
    type: VirtualType.Fragment,
    children: buildChildren(children, true)
  };
}
function createComponentInstance(Component, props, children) {
  if (children !== null && children !== void 0 && children.length) {
    props.children = children.length === 1 ? children[0] : children;
  }
  const componentInstance = {
    id: -1,
    $element: undefined,
    Component,
    name: Component.name,
    props,
    mountState: MountState.Unmounted
  };
  componentInstance.$element = buildComponentElement(componentInstance);
  return componentInstance.$element;
}
function buildComponentElement(componentInstance, children) {
  return {
    type: VirtualType.Component,
    componentInstance,
    props: componentInstance.props,
    children: children ? buildChildren(children, true) : []
  };
}
function buildTagElement(tag, props, children) {
  return {
    type: VirtualType.Tag,
    tag,
    props,
    children: buildChildren(children)
  };
}
function buildChildren(children) {
  let noEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const cleanChildren = dropEmptyTail(children, noEmpty);
  const newChildren = [];
  for (let i = 0, l = cleanChildren.length; i < l; i++) {
    const child = cleanChildren[i];
    if (Array.isArray(child)) {
      newChildren.push(...buildChildren(child, noEmpty));
    } else {
      newChildren.push(buildChildElement(child));
    }
  }
  return newChildren;
}

// We only need placeholders in the middle of collection (to ensure other elements order).
function dropEmptyTail(children) {
  let noEmpty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let i = children.length - 1;
  for (; i >= 0; i--) {
    if (!isEmptyPlaceholder(children[i])) {
      break;
    }
  }
  if (i === children.length - 1) {
    return children;
  }
  if (i === -1 && noEmpty) {
    return children.slice(0, 1);
  }
  return children.slice(0, i + 1);
}
function isEmptyPlaceholder(child) {
  return !child && child !== 0;
}
function buildChildElement(child) {
  if (isEmptyPlaceholder(child)) {
    return {
      type: VirtualType.Empty
    };
  } else if (teact_isParentElement(child)) {
    return child;
  } else {
    return {
      type: VirtualType.Text,
      value: String(child)
    };
  }
}
const DEBUG_components = {
  TOTAL: {
    name: 'TOTAL',
    renders: 0
  }
};
const DEBUG_memos = {};
const DEBUG_MEMOS_CALLS_THRESHOLD = 20;
document.addEventListener('dblclick', () => {
  // eslint-disable-next-line no-console
  console.warn('COMPONENTS', (0,iteratees/* orderBy */.My)(Object.values(DEBUG_components).map(_ref => {
    let {
      avgRenderTime,
      ...state
    } = _ref;
    return {
      ...state,
      ...(avgRenderTime !== undefined && {
        avgRenderTime: Number(avgRenderTime.toFixed(2))
      })
    };
  }), 'renders', 'desc'));

  // eslint-disable-next-line no-console
  console.warn('MEMOS', (0,iteratees/* orderBy */.My)(Object.values(DEBUG_memos).filter(_ref2 => {
    let {
      calls
    } = _ref2;
    return calls >= DEBUG_MEMOS_CALLS_THRESHOLD;
  }).map(state => ({
    ...state,
    hitRate: Number(state.hitRate.toFixed(2))
  })), 'hitRate', 'asc'));
});
let instancesPendingUpdate = new Set();
let idsToExcludeFromUpdate = new Set();
let pendingEffects = new Map();
let pendingCleanups = new Map();
let pendingLayoutEffects = new Map();
let pendingLayoutCleanups = new Map();
let areImmediateEffectsCaptured = false;

/*
  Order:
  - component effect cleanups
  - component effects
  - measure tasks
  - mutation tasks
  - component updates
  - component layout effect cleanups
  - component layout effects
  - forced layout measure tasks
  - forced layout mutation tasks
 */

const runUpdatePassOnRaf = (0,schedulers/* throttleWith */.nb)(fasterdom/* requestMeasure */.YS, () => {
  if (getIsBlockingAnimating()) {
    getIsBlockingAnimating.once(runUpdatePassOnRaf);
    return;
  }
  const runImmediateEffects = captureImmediateEffects();
  idsToExcludeFromUpdate = new Set();
  const instancesToUpdate = Array.from(instancesPendingUpdate).sort((a, b) => a.id - b.id);
  instancesPendingUpdate = new Set();
  const currentCleanups = pendingCleanups;
  pendingCleanups = new Map();
  currentCleanups.forEach(cb => cb());
  const currentEffects = pendingEffects;
  pendingEffects = new Map();
  currentEffects.forEach(cb => cb());
  (0,fasterdom/* requestMutation */.RK)(() => {
    instancesToUpdate.forEach(prepareComponentForFrame);
    instancesToUpdate.forEach(instance => {
      if (idsToExcludeFromUpdate.has(instance.id)) {
        return;
      }
      forceUpdateComponent(instance);
    });
    runImmediateEffects === null || runImmediateEffects === void 0 || runImmediateEffects();
  });
});
function captureImmediateEffects() {
  if (areImmediateEffectsCaptured) {
    return undefined;
  }
  areImmediateEffectsCaptured = true;
  return runCapturedImmediateEffects;
}
function runCapturedImmediateEffects() {
  const currentLayoutCleanups = pendingLayoutCleanups;
  pendingLayoutCleanups = new Map();
  currentLayoutCleanups.forEach(cb => cb());
  const currentLayoutEffects = pendingLayoutEffects;
  pendingLayoutEffects = new Map();
  currentLayoutEffects.forEach(cb => cb());
  areImmediateEffectsCaptured = false;
}
function renderComponent(componentInstance) {
  idsToExcludeFromUpdate.add(componentInstance.id);
  const {
    Component,
    props
  } = componentInstance;
  let newRenderedValue;
  (0,util_safeExec/* default */.A)(() => {
    renderingInstance = componentInstance;
    if (componentInstance.hooks) {
      if (componentInstance.hooks.state) {
        componentInstance.hooks.state.cursor = 0;
      }
      if (componentInstance.hooks.effects) {
        componentInstance.hooks.effects.cursor = 0;
      }
      if (componentInstance.hooks.memos) {
        componentInstance.hooks.memos.cursor = 0;
      }
      if (componentInstance.hooks.refs) {
        componentInstance.hooks.refs.cursor = 0;
      }
    }
    let DEBUG_startAt;
    if (src_config/* DEBUG */.Oig) {
      const componentName = DEBUG_resolveComponentName(Component);
      if (!DEBUG_components[componentName]) {
        DEBUG_components[componentName] = {
          name: componentName,
          renders: 0,
          avgRenderTime: 0
        };
      }
      if (src_config/* DEBUG_MORE */.MVx) {
        if (!DEBUG_SILENT_RENDERS_FOR.has(componentName)) {
          // eslint-disable-next-line no-console
          console.log(`[Teact] Render ${componentName}`);
        }
      }
      DEBUG_startAt = performance.now();
    }
    newRenderedValue = Component(props);
    if (src_config/* DEBUG */.Oig) {
      const duration = performance.now() - DEBUG_startAt;
      const componentName = DEBUG_resolveComponentName(Component);
      if (duration > DEBUG_RENDER_THRESHOLD) {
        // eslint-disable-next-line no-console
        console.warn(`[Teact] Slow component render: ${componentName}, ${Math.round(duration)} ms`);
      }
      const {
        renders,
        avgRenderTime
      } = DEBUG_components[componentName];
      DEBUG_components[componentName].avgRenderTime = (avgRenderTime * renders + duration) / (renders + 1);
      DEBUG_components[componentName].renders++;
      DEBUG_components.TOTAL.renders++;
      if (src_config/* DEBUG_MORE */.MVx) {
        incrementOverlayCounter(`${componentName} renders`);
        incrementOverlayCounter(`${componentName} duration`, duration);
      }
    }
  }, {
    rescue: () => {
      // eslint-disable-next-line no-console
      console.error(`[Teact] Error while rendering component ${componentInstance.name}`, componentInstance);
      newRenderedValue = componentInstance.renderedValue;
    }
  });
  if (componentInstance.mountState === MountState.Mounted && newRenderedValue === componentInstance.renderedValue) {
    return componentInstance.$element;
  }
  componentInstance.renderedValue = newRenderedValue;
  const children = Array.isArray(newRenderedValue) ? newRenderedValue : [newRenderedValue];
  componentInstance.$element = buildComponentElement(componentInstance, children);
  return componentInstance.$element;
}
function hasElementChanged($old, $new) {
  if (typeof $old !== typeof $new) {
    return true;
  } else if ($old.type !== $new.type) {
    return true;
  } else if ($old.type === VirtualType.Text && $new.type === VirtualType.Text) {
    return $old.value !== $new.value;
  } else if ($old.type === VirtualType.Tag && $new.type === VirtualType.Tag) {
    return $old.tag !== $new.tag || $old.props.key !== $new.props.key;
  } else if ($old.type === VirtualType.Component && $new.type === VirtualType.Component) {
    return $old.componentInstance.Component !== $new.componentInstance.Component || $old.props.key !== $new.props.key;
  }
  return false;
}
function mountComponent(componentInstance) {
  componentInstance.id = ++lastComponentId;
  componentInstance.mountState = MountState.Mounting;
  renderComponent(componentInstance);
  componentInstance.mountState = MountState.Mounted;
  return componentInstance.$element;
}
function unmountComponent(componentInstance) {
  var _componentInstance$ho;
  if (componentInstance.mountState === MountState.Unmounted) {
    return;
  }
  idsToExcludeFromUpdate.add(componentInstance.id);
  if ((_componentInstance$ho = componentInstance.hooks) !== null && _componentInstance$ho !== void 0 && _componentInstance$ho.effects) {
    for (const effect of componentInstance.hooks.effects.byCursor) {
      var _effect$releaseSignal;
      if (effect.cleanup) {
        (0,util_safeExec/* default */.A)(effect.cleanup);
      }
      effect.cleanup = undefined;
      (_effect$releaseSignal = effect.releaseSignals) === null || _effect$releaseSignal === void 0 || _effect$releaseSignal.call(effect);
    }
  }
  componentInstance.mountState = MountState.Unmounted;
  helpGc(componentInstance);
}

// We need to remove all references to DOM objects. We also clean all other references, just in case
function helpGc(componentInstance) {
  const {
    effects,
    state,
    memos,
    refs
  } = componentInstance.hooks || {};
  if (effects) {
    for (const hook of effects.byCursor) {
      hook.schedule = undefined;
      hook.cleanup = undefined;
      hook.releaseSignals = undefined;
      hook.dependencies = undefined;
    }
  }
  if (state) {
    for (const hook of state.byCursor) {
      hook.value = undefined;
      hook.nextValue = undefined;
      hook.setter = undefined;
    }
  }
  if (memos) {
    for (const hook of memos.byCursor) {
      hook.value = undefined;
      hook.dependencies = undefined;
    }
  }
  if (refs) {
    for (const hook of refs.byCursor) {
      hook.current = undefined;
      hook.onChange = undefined;
    }
  }
  componentInstance.hooks = undefined;
  componentInstance.$element = undefined;
  componentInstance.renderedValue = undefined;
  componentInstance.onUpdate = undefined;
}
function prepareComponentForFrame(componentInstance) {
  var _componentInstance$ho2;
  if (componentInstance.mountState === MountState.Unmounted) {
    return;
  }
  if ((_componentInstance$ho2 = componentInstance.hooks) !== null && _componentInstance$ho2 !== void 0 && _componentInstance$ho2.state) {
    for (const hook of componentInstance.hooks.state.byCursor) {
      hook.value = hook.nextValue;
    }
  }
}
function forceUpdateComponent(componentInstance) {
  if (componentInstance.mountState === MountState.Unmounted || !componentInstance.onUpdate) {
    return;
  }
  const currentElement = componentInstance.$element;
  renderComponent(componentInstance);
  if (componentInstance.$element !== currentElement) {
    componentInstance.onUpdate();
  }
}
function useState(initial, debugKey) {
  if (!renderingInstance.hooks) {
    renderingInstance.hooks = {};
  }
  if (!renderingInstance.hooks.state) {
    renderingInstance.hooks.state = {
      cursor: 0,
      byCursor: []
    };
  }
  const {
    cursor,
    byCursor
  } = renderingInstance.hooks.state;
  const componentInstance = renderingInstance;
  if (byCursor[cursor] === undefined) {
    byCursor[cursor] = {
      value: initial,
      nextValue: initial,
      setter: newValue => {
        if (componentInstance.mountState === MountState.Unmounted) {
          return;
        }
        if (typeof newValue === 'function') {
          newValue = newValue(byCursor[cursor].nextValue);
        }
        if (byCursor[cursor].nextValue === newValue) {
          return;
        }
        byCursor[cursor].nextValue = newValue;
        instancesPendingUpdate.add(componentInstance);
        runUpdatePassOnRaf();
        if (src_config/* DEBUG_MORE */.MVx) {
          // eslint-disable-next-line no-console
          console.log('[Teact.useState]', DEBUG_resolveComponentName(componentInstance.Component), `State update at cursor #${cursor}${debugKey ? ` (${debugKey})` : ''}, next value: `, byCursor[cursor].nextValue);
        }
      }
    };
  }
  renderingInstance.hooks.state.cursor++;
  return [byCursor[cursor].value, byCursor[cursor].setter];
}
function useEffectBase(isLayout, effect, dependencies, debugKey) {
  if (!renderingInstance.hooks) {
    renderingInstance.hooks = {};
  }
  if (!renderingInstance.hooks.effects) {
    renderingInstance.hooks.effects = {
      cursor: 0,
      byCursor: []
    };
  }
  const {
    cursor,
    byCursor
  } = renderingInstance.hooks.effects;
  const effectConfig = byCursor[cursor];
  const componentInstance = renderingInstance;
  function schedule() {
    scheduleEffect(componentInstance, cursor, effect, isLayout);
  }
  if (dependencies && effectConfig !== null && effectConfig !== void 0 && effectConfig.dependencies) {
    if (dependencies.some((dependency, i) => dependency !== effectConfig.dependencies[i])) {
      if (src_config/* DEBUG */.Oig && debugKey) {
        const causedBy = dependencies.reduce((res, newValue, i) => {
          const prevValue = effectConfig.dependencies[i];
          if (newValue !== prevValue) {
            res.push(`${i}: ${String(prevValue)} => ${String(newValue)}`);
          }
          return res;
        }, []);

        // eslint-disable-next-line no-console
        console.log(`[Teact] Effect "${debugKey}" caused by dependencies.`, causedBy.join(', '));
      }
      schedule();
    }
  } else {
    if (debugKey) {
      // eslint-disable-next-line no-console
      console.log(`[Teact] Effect "${debugKey}" caused by missing dependencies.`);
    }
    schedule();
  }
  function setupSignals() {
    const cleanups = dependencies === null || dependencies === void 0 ? void 0 : dependencies.filter(isSignal).map((signal, i) => signal.subscribe(() => {
      if (debugKey) {
        // eslint-disable-next-line no-console
        console.log(`[Teact] Effect "${debugKey}" caused by signal #${i} new value:`, signal());
      }
      byCursor[cursor].schedule();
    }));
    if (!(cleanups !== null && cleanups !== void 0 && cleanups.length)) {
      return undefined;
    }
    return () => {
      for (const cleanup of cleanups) {
        cleanup();
      }
    };
  }
  if (effectConfig) effectConfig.schedule = undefined; // Help GC

  byCursor[cursor] = {
    ...effectConfig,
    dependencies,
    schedule
  };
  if (!effectConfig) {
    byCursor[cursor].releaseSignals = setupSignals();
  }
  renderingInstance.hooks.effects.cursor++;
}
function scheduleEffect(componentInstance, cursor, effect, isLayout) {
  var _byCursor$cursor;
  const {
    byCursor
  } = componentInstance.hooks.effects;
  const cleanup = (_byCursor$cursor = byCursor[cursor]) === null || _byCursor$cursor === void 0 ? void 0 : _byCursor$cursor.cleanup;
  const cleanupsContainer = isLayout ? pendingLayoutCleanups : pendingCleanups;
  const effectsContainer = isLayout ? pendingLayoutEffects : pendingEffects;
  const effectId = `${componentInstance.id}_${cursor}`;
  if (cleanup) {
    const runEffectCleanup = () => (0,util_safeExec/* default */.A)(() => {
      if (componentInstance.mountState === MountState.Unmounted) {
        return;
      }
      let DEBUG_startAt;
      if (src_config/* DEBUG */.Oig) {
        DEBUG_startAt = performance.now();
      }
      cleanup();
      if (src_config/* DEBUG */.Oig) {
        const duration = performance.now() - DEBUG_startAt;
        const componentName = DEBUG_resolveComponentName(componentInstance.Component);
        if (duration > DEBUG_EFFECT_THRESHOLD) {
          // eslint-disable-next-line no-console
          console.warn(`[Teact] Slow cleanup at effect cursor #${cursor}: ${componentName}, ${Math.round(duration)} ms`);
        }
      }
    }, {
      rescue: () => {
        // eslint-disable-next-line no-console
        console.error(`[Teact] Error in effect cleanup at cursor #${cursor} in ${componentInstance.name}`, componentInstance);
      },
      always: () => {
        byCursor[cursor].cleanup = undefined;
      }
    });
    cleanupsContainer.set(effectId, runEffectCleanup);
  }
  const runEffect = () => (0,util_safeExec/* default */.A)(() => {
    if (componentInstance.mountState === MountState.Unmounted) {
      return;
    }
    let DEBUG_startAt;
    if (src_config/* DEBUG */.Oig) {
      DEBUG_startAt = performance.now();
    }
    const result = effect();
    if (typeof result === 'function') {
      byCursor[cursor].cleanup = result;
    }
    if (src_config/* DEBUG */.Oig) {
      const duration = performance.now() - DEBUG_startAt;
      const componentName = DEBUG_resolveComponentName(componentInstance.Component);
      if (duration > DEBUG_EFFECT_THRESHOLD) {
        // eslint-disable-next-line no-console
        console.warn(`[Teact] Slow effect at cursor #${cursor}: ${componentName}, ${Math.round(duration)} ms`);
      }
    }
  }, {
    rescue: () => {
      // eslint-disable-next-line no-console
      console.error(`[Teact] Error in effect at cursor #${cursor} in ${componentInstance.name}`, componentInstance);
    }
  });
  effectsContainer.set(effectId, runEffect);
  runUpdatePassOnRaf();
}
function teact_useEffect(effect, dependencies, debugKey) {
  return useEffectBase(false, effect, dependencies, debugKey);
}
function useLayoutEffect(effect, dependencies, debugKey) {
  return useEffectBase(true, effect, dependencies, debugKey);
}
function useUnmountCleanup(cleanup) {
  if (!renderingInstance.hooks) {
    renderingInstance.hooks = {};
  }
  if (!renderingInstance.hooks.effects) {
    renderingInstance.hooks.effects = {
      cursor: 0,
      byCursor: []
    };
  }
  const {
    cursor,
    byCursor
  } = renderingInstance.hooks.effects;
  if (!byCursor[cursor]) {
    byCursor[cursor] = {
      cleanup
    };
  }
  renderingInstance.hooks.effects.cursor++;
}
function teact_useMemo(resolver, dependencies, debugKey, debugHitRateKey) {
  if (!renderingInstance.hooks) {
    renderingInstance.hooks = {};
  }
  if (!renderingInstance.hooks.memos) {
    renderingInstance.hooks.memos = {
      cursor: 0,
      byCursor: []
    };
  }
  const {
    cursor,
    byCursor
  } = renderingInstance.hooks.memos;
  let {
    value
  } = byCursor[cursor] || {};
  let DEBUG_state;
  if (src_config/* DEBUG */.Oig && debugHitRateKey) {
    const instanceKey = `${debugHitRateKey}#${renderingInstance.id}`;
    DEBUG_state = DEBUG_memos[instanceKey];
    if (!DEBUG_state) {
      DEBUG_state = {
        key: instanceKey,
        calls: 0,
        misses: 0,
        hitRate: 0
      };
      DEBUG_memos[instanceKey] = DEBUG_state;
    }
    DEBUG_state.calls++;
    DEBUG_state.hitRate = (DEBUG_state.calls - DEBUG_state.misses) / DEBUG_state.calls;
  }
  if (byCursor[cursor] === undefined || dependencies.length !== byCursor[cursor].dependencies.length || dependencies.some((dependency, i) => dependency !== byCursor[cursor].dependencies[i])) {
    if (src_config/* DEBUG */.Oig) {
      if (debugKey) {
        const msg = `[Teact.useMemo] ${renderingInstance.name} (${debugKey}): Update is caused by:`;
        if (!byCursor[cursor]) {
          // eslint-disable-next-line no-console
          console.log(`${msg} [first render]`);
        } else {
          logUnequalProps(byCursor[cursor].dependencies, dependencies, msg, debugKey);
        }
      }
      if (DEBUG_state) {
        DEBUG_state.misses++;
        DEBUG_state.hitRate = (DEBUG_state.calls - DEBUG_state.misses) / DEBUG_state.calls;
        if (DEBUG_state.calls % 10 === 0 && DEBUG_state.calls >= DEBUG_MEMOS_CALLS_THRESHOLD && DEBUG_state.hitRate < 0.25) {
          // eslint-disable-next-line no-console
          console.warn(`[Teact] ${DEBUG_state.key}: Hit rate is ${DEBUG_state.hitRate.toFixed(2)} for ${DEBUG_state.calls} calls`);
        }
      }
    }
    value = resolver();
  }
  byCursor[cursor] = {
    value,
    dependencies
  };
  renderingInstance.hooks.memos.cursor++;
  return value;
}
function teact_useCallback(newCallback, dependencies, debugKey) {
  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  return teact_useMemo(() => newCallback, dependencies, debugKey);
}

// TT way (empty is `undefined`)

// React way (empty is `null`)

function teact_useRef(initial) {
  if (!renderingInstance.hooks) {
    renderingInstance.hooks = {};
  }
  if (!renderingInstance.hooks.refs) {
    renderingInstance.hooks.refs = {
      cursor: 0,
      byCursor: []
    };
  }
  const {
    cursor,
    byCursor
  } = renderingInstance.hooks.refs;
  if (!byCursor[cursor]) {
    byCursor[cursor] = {
      current: initial
    };
  }
  renderingInstance.hooks.refs.cursor++;
  return byCursor[cursor];
}
function createContext(defaultValue) {
  const contextId = String(contextCounter++);
  function TeactContextProvider(props) {
    const [getValue, setValue] = useSignal(props.value ?? defaultValue);
    // Create a new object to avoid mutations in the parent context
    renderingInstance.context = {
      ...renderingInstance.context
    };
    renderingInstance.context[contextId] = getValue;
    setValue(props.value);
    return props.children;
  }
  TeactContextProvider.DEBUG_contentComponentName = contextId;
  const context = {
    defaultValue,
    contextId,
    Provider: TeactContextProvider
  };
  return context;
}
function useContextSignal(context) {
  var _renderingInstance$co;
  const [getDefaultValue] = useSignal(context.defaultValue);
  return ((_renderingInstance$co = renderingInstance.context) === null || _renderingInstance$co === void 0 ? void 0 : _renderingInstance$co[context.contextId]) || getDefaultValue;
}
function useSignal(initial) {
  const signalRef = teact_useRef();
  signalRef.current ??= createSignal(initial);
  return signalRef.current;
}
function memo(Component, debugKey) {
  function TeactMemoWrapper(props) {
    return teact_useMemo(() => createElement(Component, props),
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
    Object.values(props), debugKey, src_config/* DEBUG_MORE */.MVx ? DEBUG_resolveComponentName(renderingInstance.Component) : undefined);
  }
  TeactMemoWrapper.DEBUG_contentComponentName = DEBUG_resolveComponentName(Component);
  return TeactMemoWrapper;
}
function DEBUG_resolveComponentName(Component) {
  const {
    name,
    DEBUG_contentComponentName
  } = Component;
  if (name === 'TeactNContainer') {
    return `container>${DEBUG_contentComponentName}`;
  }
  if (name === 'TeactMemoWrapper') {
    return `memo>${DEBUG_contentComponentName}`;
  }
  if (name === 'TeactContextProvider') {
    return `context>id${DEBUG_contentComponentName}`;
  }
  return name + (DEBUG_contentComponentName ? `>${DEBUG_contentComponentName}` : '');
}
/* harmony default export */ const teact = ({
  createElement,
  Fragment
});
;// ./src/hooks/useForceUpdate.ts

const useForceUpdate = () => {
  const [, setTrigger] = useState(false);
  return teact_useCallback(() => {
    setTrigger(trigger => !trigger);
  }, []);
};
/* harmony default export */ const hooks_useForceUpdate = (useForceUpdate);
// EXTERNAL MODULE: ./src/util/generateUniqueId.ts
var generateUniqueId = __webpack_require__(14235);
;// ./src/hooks/useEffectOnce.ts

function useEffectOnce(effect) {
  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  teact_useEffect(effect, []);
}
/* harmony default export */ const hooks_useEffectOnce = (useEffectOnce);
;// ./src/hooks/usePrevious.ts


// Deprecated. Use `usePrevious2` instead

function usePrevious(next, shouldSkipUndefined) {
  const ref = teact_useRef();
  const {
    current
  } = ref;
  if (!shouldSkipUndefined || next !== undefined) {
    ref.current = next;
  }
  return current;
}
/* harmony default export */ const hooks_usePrevious = (usePrevious);
;// ./src/hooks/useSyncEffect.ts



function useSyncEffect(effect, dependencies) {
  const prevDeps = hooks_usePrevious(dependencies);
  const cleanupRef = teact_useRef();
  if (!prevDeps || dependencies.some((d, i) => d !== prevDeps[i])) {
    var _cleanupRef$current;
    (_cleanupRef$current = cleanupRef.current) === null || _cleanupRef$current === void 0 || _cleanupRef$current.call(cleanupRef);
    cleanupRef.current = effect(prevDeps || []) ?? undefined;
  }
  hooks_useEffectOnce(() => {
    return () => {
      var _cleanupRef$current2;
      (_cleanupRef$current2 = cleanupRef.current) === null || _cleanupRef$current2 === void 0 || _cleanupRef$current2.call(cleanupRef);
    };
  });
}
;// ./src/hooks/useUniqueId.ts



function useUniqueId() {
  let prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  const idRef = teact_useRef();
  useSyncEffect(() => {
    idRef.current = prefix + (0,generateUniqueId/* default */.A)();
  }, [prefix]);
  return idRef.current;
}
;// ./src/lib/teact/teactn.tsx
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }








/* harmony default export */ const teactn = (teact);

// TODO: Add callback to typify

let currentGlobal = {
  isInited: false
};
let DEBUG_currentRandomId;
const DEBUG_invalidateGlobalOnTickEnd = (0,schedulers/* throttleWithTickEnd */.Fe)(() => {
  DEBUG_currentRandomId = Math.random();
});
const actionHandlers = {};
const callbacks = [updateContainers];
const actions = {};
const containers = new Map();
const runCallbacksThrottled = (0,schedulers/* throttleWithTickEnd */.Fe)(runCallbacks);
let forceOnHeavyAnimation = true;
function runCallbacks() {
  if (forceOnHeavyAnimation) {
    forceOnHeavyAnimation = false;
  } else if (heavyAnimation_getIsHeavyAnimating()) {
    heavyAnimation_getIsHeavyAnimating.once(runCallbacksThrottled);
    return;
  }
  callbacks.forEach(cb => cb(currentGlobal));
}
function setUntypedGlobal(newGlobal, options) {
  if (typeof newGlobal === 'object' && newGlobal !== currentGlobal) {
    if (src_config/* DEBUG */.Oig) {
      if (!(options !== null && options !== void 0 && options.forceOutdated) && newGlobal.DEBUG_randomId && newGlobal.DEBUG_randomId !== DEBUG_currentRandomId) {
        throw new Error('[TeactN.setGlobal] Attempt to set an outdated global');
      }
      DEBUG_currentRandomId = Math.random();
    }
    currentGlobal = newGlobal;
    if (options !== null && options !== void 0 && options.forceSyncOnIOs) {
      forceOnHeavyAnimation = true;
      runCallbacks();
    } else {
      if (options !== null && options !== void 0 && options.forceOnHeavyAnimation) {
        forceOnHeavyAnimation = true;
      }
      runCallbacksThrottled();
    }
  }
}
function getUntypedGlobal() {
  if (src_config/* DEBUG */.Oig) {
    currentGlobal = {
      ...currentGlobal,
      DEBUG_randomId: DEBUG_currentRandomId
    };
    DEBUG_invalidateGlobalOnTickEnd();
  }
  return currentGlobal;
}
function getUntypedActions() {
  return actions;
}
function forceOnHeavyAnimationOnce() {
  forceOnHeavyAnimation = true;
}
let actionQueue = [];
function handleAction(name, payload, options) {
  actionQueue.push(() => {
    var _actionHandlers$name;
    (_actionHandlers$name = actionHandlers[name]) === null || _actionHandlers$name === void 0 || _actionHandlers$name.forEach(handler => {
      const response = handler(src_config/* DEBUG */.Oig ? getUntypedGlobal() : currentGlobal, actions, payload);
      if (!response || typeof response.then === 'function') {
        return;
      }
      setUntypedGlobal(response, options);
    });
  });
  if (actionQueue.length === 1) {
    try {
      while (actionQueue.length) {
        actionQueue[0]();
        actionQueue.shift();
      }
    } finally {
      actionQueue = [];
    }
  }
}
function updateContainers() {
  let DEBUG_startAt;
  if (src_config/* DEBUG */.Oig) {
    DEBUG_startAt = performance.now();
  }
  for (const container of containers.values()) {
    const {
      mapStateToProps,
      ownProps,
      mappedProps,
      forceUpdate
    } = container;
    if (!activateContainer(container, currentGlobal, ownProps)) {
      continue;
    }
    let newMappedProps;
    try {
      newMappedProps = mapStateToProps(currentGlobal, ownProps);
    } catch (err) {
      (0,src_handleError/* handleError */.H)(err);
      return;
    }
    if (src_config/* DEBUG */.Oig) {
      if (Object.values(newMappedProps).some(Number.isNaN)) {
        // eslint-disable-next-line no-console
        console.warn(
        // eslint-disable-next-line @stylistic/max-len
        `[TeactN] Some of \`${container.DEBUG_componentName}\` mappers contain NaN values. This may cause redundant updates because of incorrect equality check.`);
      }
    }
    if (Object.keys(newMappedProps).length && !arePropsShallowEqual(mappedProps, newMappedProps)) {
      if (src_config/* DEBUG_MORE */.MVx) {
        logUnequalProps(mappedProps, newMappedProps, `[TeactN] Will update ${container.DEBUG_componentName} caused by:`);
      }
      container.mappedProps = newMappedProps;
      container.DEBUG_updates++;
      forceUpdate();
    }
  }
  if (src_config/* DEBUG */.Oig) {
    const updateTime = performance.now() - DEBUG_startAt;
    if (updateTime > 7) {
      // eslint-disable-next-line no-console
      console.warn(`[TeactN] Slow containers update: ${Math.round(updateTime)} ms`);
    }
  }
}
function addUntypedActionHandler(name, handler) {
  if (!actionHandlers[name]) {
    actionHandlers[name] = [];
    actions[name] = (payload, options) => {
      handleAction(name, payload, options);
    };
  }
  actionHandlers[name].push(handler);
}
function addCallback(cb) {
  callbacks.push(cb);
}
function removeCallback(cb) {
  const index = callbacks.indexOf(cb);
  if (index !== -1) {
    callbacks.splice(index, 1);
  }
}
function withUntypedGlobal() {
  let mapStateToProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => ({});
  let activationFn = arguments.length > 1 ? arguments[1] : undefined;
  return Component => {
    function TeactNContainer(props) {
      const id = useUniqueId();
      const forceUpdate = hooks_useForceUpdate();
      useUnmountCleanup(() => {
        containers.delete(id);
      });
      let container = containers.get(id);
      if (!container) {
        container = {
          mapStateToProps,
          activationFn,
          ownProps: props,
          forceUpdate,
          DEBUG_updates: 0,
          DEBUG_componentName: Component.name
        };
        containers.set(id, container);
      }
      if ((!container.mappedProps || !arePropsShallowEqual(container.ownProps, props)) && activateContainer(container, currentGlobal, props)) {
        try {
          container.mappedProps = mapStateToProps(currentGlobal, props);
        } catch (err) {
          (0,src_handleError/* handleError */.H)(err);
        }
      }
      container.ownProps = props;
      return /*#__PURE__*/teact.createElement(Component, _extends({}, container.mappedProps, props));
    }
    TeactNContainer.DEBUG_contentComponentName = DEBUG_resolveComponentName(Component);
    return TeactNContainer;
  };
}
function activateContainer(container, global, props) {
  const {
    activationFn,
    stuckTo
  } = container;
  if (!activationFn) {
    return true;
  }
  return activationFn(global, props, stickTo => {
    if (stuckTo) {
      return stuckTo === stickTo;
    } else if (stickTo !== undefined) {
      container.stuckTo = stickTo;
    }
    return true;
  });
}
function typify() {
  // When payload is allowed to be `undefined` we consider it optional

  return {
    getGlobal: getUntypedGlobal,
    setGlobal: setUntypedGlobal,
    getActions: getUntypedActions,
    addActionHandler: addUntypedActionHandler,
    withGlobal: withUntypedGlobal
  };
}
if (src_config/* DEBUG */.Oig) {
  window.getGlobal = getUntypedGlobal;
  window.setGlobal = setUntypedGlobal;
  window.getActions = getUntypedActions;
  document.addEventListener('dblclick', () => {
    // eslint-disable-next-line no-console
    console.warn('GLOBAL CONTAINERS', (0,iteratees/* orderBy */.My)(Array.from(containers.values()).map(_ref => {
      let {
        DEBUG_componentName,
        DEBUG_updates
      } = _ref;
      return {
        DEBUG_componentName,
        DEBUG_updates
      };
    }), 'DEBUG_updates', 'desc'));
  });
}
;// ./src/global/index.ts

const typed = typify();
const getGlobal = typed.getGlobal;
const setGlobal = typed.setGlobal;
const getActions = typed.getActions;
const addActionHandler = typed.addActionHandler;
const withGlobal = typed.withGlobal;
// EXTERNAL MODULE: ./src/util/account.ts
var util_account = __webpack_require__(86243);
;// ./src/util/isEmptyObject.ts
function isEmptyObject(obj) {
  return !isKeyCountGreater(obj, 0);
}
function isKeyCountGreater(obj, countToOutnumber) {
  if (countToOutnumber < 0) return true;
  let keyCount = 0;
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyCount++;
      if (keyCount > countToOutnumber) {
        return true;
      }
    }
  }
  return false;
}
;// ./src/util/isViewAccount.ts

function isViewAccount(accountType) {
  return !src_config/* DEBUG_VIEW_ACCOUNTS */.twH && accountType === 'view';
}
;// ./src/util/memoize.ts

const cache = new WeakMap();
function memoize(fn, ttlSeconds) {
  const wrapper = function () {
    const cached = cache.get(fn);
    const now = Date.now();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (cached) {
      const isCacheDisabled = cached.isDisabledUntil && cached.isDisabledUntil > now;
      const isStale = ttlSeconds && cached.lastTime + ttlSeconds * 1000 < now;
      if (!isCacheDisabled && !isStale && (0,iteratees/* areSortedArraysEqual */.k)(cached.lastArgs, args)) {
        return cached.lastResult;
      }
    }
    const result = fn(...args);
    cache.set(fn, {
      ...cached,
      lastArgs: args,
      lastResult: result,
      lastTime: now
    });
    return result;
  };
  wrapper.disableCache = seconds => {
    const cached = cache.get(fn);
    if (cached) {
      cached.isDisabledUntil = Date.now() + seconds * 1000;
    }
  };
  return wrapper;
}
// EXTERNAL MODULE: ./src/util/withCache.ts
var withCache = __webpack_require__(19314);
;// ./src/global/selectors/accounts.ts





function selectAccounts(global) {
  var _global$accounts;
  return (_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.byId;
}
const selectNetworkAccountsMemoized = memoize((network, accountsById) => {
  if (!accountsById) {
    return undefined;
  }
  return Object.fromEntries(Object.entries(accountsById).filter(_ref => {
    let [accountId] = _ref;
    return (0,util_account/* parseAccountId */.cK)(accountId).network === network;
  }));
});
function selectNetworkAccounts(global) {
  var _global$accounts2;
  return selectNetworkAccountsMemoized(selectCurrentNetwork(global), (_global$accounts2 = global.accounts) === null || _global$accounts2 === void 0 ? void 0 : _global$accounts2.byId);
}
function selectCurrentNetwork(global) {
  return global.settings.isTestnet ? 'testnet' : 'mainnet';
}
function selectCurrentAccount(global) {
  return selectAccount(global, global.currentAccountId);
}
function selectAccount(global, accountId) {
  var _selectAccounts;
  return (_selectAccounts = selectAccounts(global)) === null || _selectAccounts === void 0 ? void 0 : _selectAccounts[accountId];
}
function selectAccountOrAuthAccount(global, accountId) {
  const account = selectAccount(global, accountId);
  if (account) {
    return account;
  }
  for (const account of [global.auth.firstNetworkAccount, global.auth.secondNetworkAccount]) {
    if ((account === null || account === void 0 ? void 0 : account.accountId) === accountId) {
      return account;
    }
  }
  return undefined;
}
function selectCurrentAccountState(global) {
  return accounts_selectAccountState(global, global.currentAccountId);
}
function accounts_selectAccountState(global, accountId) {
  return global.byAccountId[accountId];
}
function selectAccountSettings(global, accountId) {
  return global.settings.byAccountId[accountId];
}
function selectCurrentAccountSettings(global) {
  return selectAccountSettings(global, global.currentAccountId);
}
function isHardwareAccount(account) {
  return account.type === 'hardware';
}

// To prevent passing accountId=undefined by accident

function selectIsHardwareAccount(global, accountId) {
  const account = selectAccount(global, accountId ?? global.currentAccountId);
  return Boolean(account) && isHardwareAccount(account);
}
function selectAllHardwareAccounts(global, network) {
  const accounts = selectAccounts(global);
  return Object.entries(accounts ?? {}).reduce((accounts, _ref2) => {
    let [accountId, account] = _ref2;
    if (isHardwareAccount(account) && (0,util_account/* parseAccountId */.cK)(accountId).network === network) {
      accounts.push(account);
    }
    return accounts;
  }, []);
}
function selectIsOneAccount(global) {
  return Object.keys(selectAccounts(global) || {}).length === 1;
}
const selectEnabledTokensCountMemoizedFor = (0,withCache/* default */.A)(accountId => memoize(tokens => {
  return (tokens ?? []).filter(_ref3 => {
    let {
      isDisabled
    } = _ref3;
    return !isDisabled;
  }).length;
}));
function selectLedgerAccountIndexToImport(global, network) {
  const hardwareAccounts = selectAllHardwareAccounts(global, network);
  const hardwareAccountIndexes = hardwareAccounts === null || hardwareAccounts === void 0 ? void 0 : hardwareAccounts.map(account => account.ledger.index).sort((a, b) => a - b);
  if (hardwareAccountIndexes.length === 0 || hardwareAccountIndexes[0] !== 0) {
    return -1;
  }
  if (hardwareAccountIndexes.length === 1) {
    return 0;
  }
  for (let i = 1; i < hardwareAccountIndexes.length; i++) {
    if (hardwareAccountIndexes[i] - hardwareAccountIndexes[i - 1] !== 1) {
      return i - 1;
    }
  }
  return hardwareAccountIndexes.length - 1;
}
function isMnemonicAccount(account) {
  return account.type === 'mnemonic';
}
function selectIsMnemonicAccount(global) {
  const account = selectCurrentAccount(global);
  return Boolean(account) && isMnemonicAccount(account);
}
const selectIsPasswordPresentMemoized = memoize(accounts => {
  return Object.values(accounts ?? {}).some(isMnemonicAccount);
});
function selectIsPasswordPresent(global) {
  return selectIsPasswordPresentMemoized(selectAccounts(global));
}
function selectAccountIdByAddress(global, chain, address) {
  const accounts = selectAccounts(global);
  if (!accounts) return undefined;
  const requiredAccount = Object.entries(accounts).find(_ref4 => {
    let [accountId, account] = _ref4;
    return account.addressByChain[chain] === address ? accountId : undefined;
  });
  return requiredAccount === null || requiredAccount === void 0 ? void 0 : requiredAccount[0];
}

// Slow, not to be used in `withGlobal`
function selectVestingPartsReadyToUnfreeze(global, accountId) {
  var _selectAccountState;
  const vesting = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 || (_selectAccountState = _selectAccountState.vesting) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.info) || [];
  return vesting.reduce((acc, currentVesting) => {
    currentVesting.parts.forEach(part => {
      if (part.status === 'ready') {
        acc.push({
          id: currentVesting.id,
          partId: part.id
        });
      }
    });
    return acc;
  }, []);
}
function selectCurrentAccountNftByAddress(global, nftAddress) {
  return selectAccountNftByAddress(global, global.currentAccountId, nftAddress);
}
function selectAccountNftByAddress(global, accountId, nftAddress) {
  var _selectAccountState2;
  return (_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 || (_selectAccountState2 = _selectAccountState2.nfts) === null || _selectAccountState2 === void 0 || (_selectAccountState2 = _selectAccountState2.byAddress) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2[nftAddress];
}
function selectIsMultichainAccount(global, accountId) {
  var _selectAccount;
  const addressByChain = (_selectAccount = selectAccount(global, accountId)) === null || _selectAccount === void 0 ? void 0 : _selectAccount.addressByChain;
  return Boolean(addressByChain) && isKeyCountGreater(addressByChain, 1);
}
function selectIsMultisigAccount(global, accountId, chain) {
  var _account$isMultisigBy;
  const account = selectAccount(global, accountId);
  return Boolean(account === null || account === void 0 || (_account$isMultisigBy = account.isMultisigByChain) === null || _account$isMultisigBy === void 0 ? void 0 : _account$isMultisigBy[chain]);
}
function selectHasSession(global) {
  return Boolean(global.currentAccountId);
}
function selectIsBiometricAuthEnabled(global) {
  const {
    authConfig
  } = global.settings;
  return !!authConfig && authConfig.kind !== 'password';
}
function selectIsNativeBiometricAuthEnabled(global) {
  const {
    authConfig
  } = global.settings;
  return !!authConfig && authConfig.kind === 'native-biometrics';
}
function selectIsAllowSuspiciousActions(global, accountId) {
  const accountSettings = selectAccountSettings(global, accountId);
  return (accountSettings === null || accountSettings === void 0 ? void 0 : accountSettings.isAllowSuspiciousActions) ?? false;
}
function selectIsCurrentAccountViewMode(global) {
  const {
    type
  } = selectCurrentAccount(global) || {};
  return isViewAccount(type);
}
function selectDoesAccountSupportNft(global) {
  const account = selectCurrentAccount(global);
  return Boolean(account === null || account === void 0 ? void 0 : account.addressByChain.ton);
}
// EXTERNAL MODULE: ./src/api/chains/ton/constants.ts
var constants = __webpack_require__(3476);
;// ./src/util/ton/transfer.ts

function isNftTransferPayload(payload) {
  return (payload === null || payload === void 0 ? void 0 : payload.type) === 'nft:transfer';
}
function isTokenTransferPayload(payload) {
  return (payload === null || payload === void 0 ? void 0 : payload.type) === 'tokens:transfer' || (payload === null || payload === void 0 ? void 0 : payload.type) === 'tokens:transfer-non-standard';
}

/** How many messages can be sent in a single transaction */
function getMaxMessagesInTransaction(account, ignoreLedger) {
  const {
    type,
    ton: {
      version
    }
  } = account;
  if (type === 'ledger' && !ignoreLedger) {
    return constants/* LEDGER_MAX_MESSAGES */.qP;
  } else if (version === 'W5') {
    return constants/* W5_MAX_MESSAGES */.Bm;
  } else {
    return constants/* DEFAULT_MAX_MESSAGES */.EV;
  }
}
;// ./src/global/selectors/dapp.ts




const selectCurrentDappTransferTotalsMemoized = memoize(transactions => {
  const amountsBySlug = {};
  const addSlugAmount = (tokenSlug, amount) => {
    amountsBySlug[tokenSlug] = (amountsBySlug[tokenSlug] ?? 0n) + amount;
  };
  let isScam = false;
  let isDangerous = false;
  let nftCount = 0;
  for (const transaction of transactions ?? []) {
    if (transaction.isScam) isScam = true;
    if (transaction.isDangerous) isDangerous = true;
    addSlugAmount(src_config/* TONCOIN */.Tu9.slug, transaction.amount + transaction.networkFee);
    if (isTokenTransferPayload(transaction.payload)) {
      addSlugAmount(transaction.payload.slug, transaction.payload.amount);
    } else if (isNftTransferPayload(transaction.payload)) {
      nftCount++;
    }
  }
  return {
    amountsBySlug,
    isScam,
    isDangerous,
    nftCount
  };
});
const selectDappTransferInsufficientTokensMemoized = memoize((amountsBySlug, balances, tokensBySlug) => {
  if (!balances || !tokensBySlug) {
    return undefined;
  }
  const insufficientTokens = [];
  for (const [slug, requiredAmount] of Object.entries(amountsBySlug)) {
    const token = tokensBySlug[slug] ?? src_config/* UNKNOWN_TOKEN */.Bx3;
    const balanceSlug = slug === src_config/* STON_PTON_SLUG */.Fmr ? src_config/* TONCOIN */.Tu9.slug : slug;
    const availableBalance = balances[balanceSlug] ?? 0n;
    if (availableBalance < requiredAmount) {
      const symbol = slug === src_config/* STON_PTON_SLUG */.Fmr ? src_config/* TONCOIN */.Tu9.symbol : token.symbol;
      insufficientTokens.push(symbol);
    }
  }
  return insufficientTokens.length > 0 ? insufficientTokens.join(', ') : undefined;
});
function selectCurrentDappTransferTotals(global) {
  const {
    transactions
  } = global.currentDappTransfer;
  return selectCurrentDappTransferTotalsMemoized(transactions);
}
function selectDappTransferInsufficientTokens(global) {
  var _accountState$balance;
  const accountState = selectCurrentAccountState(global);
  const balances = accountState === null || accountState === void 0 || (_accountState$balance = accountState.balances) === null || _accountState$balance === void 0 ? void 0 : _accountState$balance.bySlug;
  const tokensBySlug = global.tokenInfo.bySlug;
  const {
    amountsBySlug
  } = selectCurrentDappTransferTotals(global);
  return selectDappTransferInsufficientTokensMemoized(amountsBySlug, balances, tokensBySlug);
}
// EXTERNAL MODULE: ./src/util/decimals.ts
var util_decimals = __webpack_require__(398);
// EXTERNAL MODULE: ./src/lib/big.js/index.js
var big_js = __webpack_require__(48805);
;// ./src/util/round.ts

function round(value) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let roundingMode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : big_js/* Big */.z.roundHalfUp;
  const bn = new big_js/* Big */.z(value);
  return bn.round(precision, roundingMode).toNumber();
}
function floor(value) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return round(value, precision, Big.roundDown);
}
function ceil(value) {
  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return round(value, precision, Big.roundUp);
}
;// ./src/global/selectors/tokens.ts






function getIsNewAccount(balancesBySlug, tokenInfo) {
  return Object.keys(balancesBySlug).length === src_config/* DEFAULT_ENABLED_TOKEN_COUNT */._bq && Object.entries(balancesBySlug).every(_ref => {
    let [slug, balance] = _ref;
    const {
      decimals,
      priceUsd
    } = tokenInfo.bySlug[slug];
    const balanceBig = (0,util_decimals/* toBig */.CF)(balance, decimals);
    const hasCost = balanceBig.mul(priceUsd ?? 0).lt(src_config/* TINY_TRANSFER_MAX_COST */.Wvq);
    return hasCost;
  });
}
const selectAccountTokensMemoizedFor = (0,withCache/* default */.A)(accountId => memoize(function (balancesBySlug, tokenInfo) {
  let accountSettings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  let isSortByValueEnabled = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let areTokensWithNoCostHidden = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  const isNewAccount = getIsNewAccount(balancesBySlug, tokenInfo);
  return Object.entries(balancesBySlug).filter(_ref2 => {
    var _accountSettings$dele;
    let [slug] = _ref2;
    return slug in tokenInfo.bySlug && !((_accountSettings$dele = accountSettings.deletedSlugs) !== null && _accountSettings$dele !== void 0 && _accountSettings$dele.includes(slug));
  }).map(_ref3 => {
    var _accountSettings$alwa, _accountSettings$alwa2;
    let [slug, balance] = _ref3;
    const {
      symbol,
      name,
      image,
      decimals,
      cmcSlug,
      color,
      chain,
      tokenAddress,
      codeHash,
      type,
      price = 0,
      percentChange24h = 0,
      priceUsd
    } = tokenInfo.bySlug[slug];
    const balanceBig = (0,util_decimals/* toBig */.CF)(balance, decimals);
    const totalValue = balanceBig.mul(price).round(decimals).toString();
    const hasCost = balanceBig.mul(priceUsd ?? 0).gte(src_config/* TINY_TRANSFER_MAX_COST */.Wvq);
    const isPricelessTokenWithBalance = src_config/* PRICELESS_TOKEN_HASHES */.kuH.has(codeHash) && balance > 0n;
    const isEnabled = isNewAccount && src_config/* DEFAULT_ENABLED_TOKEN_SLUGS */.Fgn.includes(slug) || !areTokensWithNoCostHidden || areTokensWithNoCostHidden && hasCost || isPricelessTokenWithBalance || ((_accountSettings$alwa = accountSettings.alwaysShownSlugs) === null || _accountSettings$alwa === void 0 ? void 0 : _accountSettings$alwa.includes(slug));
    const isDisabled = !isEnabled || ((_accountSettings$alwa2 = accountSettings.alwaysHiddenSlugs) === null || _accountSettings$alwa2 === void 0 ? void 0 : _accountSettings$alwa2.includes(slug));
    return {
      chain,
      symbol,
      slug,
      amount: balance,
      name,
      image,
      price,
      priceUsd,
      decimals,
      change24h: round(percentChange24h / 100, 4),
      isDisabled,
      cmcSlug,
      totalValue,
      color,
      tokenAddress,
      codeHash,
      type
    };
  }).sort((tokenA, tokenB) => {
    if (isSortByValueEnabled || !accountSettings.orderedSlugs) {
      const priorityA = src_config/* PRIORITY_TOKEN_SLUGS */.oR5.indexOf(tokenA.slug);
      const priorityB = src_config/* PRIORITY_TOKEN_SLUGS */.oR5.indexOf(tokenB.slug);

      // If both tokens are prioritized and their balances match
      if (priorityA !== -1 && priorityB !== -1 && tokenA.totalValue === tokenB.totalValue) {
        return priorityA - priorityB;
      }

      // If one token is prioritized and the other is not
      if (priorityA !== -1 && priorityB === -1) return -1;
      if (priorityB !== -1 && priorityA === -1) return 1;
      return Number(tokenB.totalValue) - Number(tokenA.totalValue);
    }
    const indexA = accountSettings.orderedSlugs.indexOf(tokenA.slug);
    const indexB = accountSettings.orderedSlugs.indexOf(tokenB.slug);
    return indexA - indexB;
  });
}));
function selectCurrentAccountTokens(global) {
  return selectAccountTokens(global, global.currentAccountId);
}
function selectCurrentAccountTokenBalance(global, slug) {
  var _selectCurrentAccount;
  return ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 || (_selectCurrentAccount = _selectCurrentAccount.balances) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.bySlug[slug]) ?? 0n;
}
function selectCurrentToncoinBalance(global) {
  return selectCurrentAccountTokenBalance(global, src_config/* TONCOIN */.Tu9.slug);
}
function selectAccountTokens(global, accountId) {
  var _selectAccountState;
  const balancesBySlug = (_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 || (_selectAccountState = _selectAccountState.balances) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.bySlug;
  if (!balancesBySlug || !global.tokenInfo) {
    return undefined;
  }
  const accountSettings = selectAccountSettings(global, accountId);
  const {
    areTokensWithNoCostHidden,
    isSortByValueEnabled
  } = global.settings;
  return selectAccountTokensMemoizedFor(accountId)(balancesBySlug, global.tokenInfo, accountSettings, isSortByValueEnabled, areTokensWithNoCostHidden);
}
function selectAccountTokenBySlug(global, slug) {
  const accountTokens = selectCurrentAccountTokens(global);
  return accountTokens === null || accountTokens === void 0 ? void 0 : accountTokens.find(token => token.slug === slug);
}
function selectTokenAddress(global, slug) {
  if (slug === src_config/* TONCOIN */.Tu9.slug) return undefined;
  return selectToken(global, slug).tokenAddress;
}
function selectToken(global, slug) {
  return global.tokenInfo.bySlug[slug];
}
function selectMycoin(global) {
  const {
    isTestnet
  } = global.settings;
  return selectToken(global, isTestnet ? src_config/* MYCOIN_TESTNET */.GX2.slug : src_config/* MYCOIN */.oUU.slug);
}
function selectTokenByMinterAddress(global, minter) {
  return Object.values(global.tokenInfo.bySlug).find(token => token.tokenAddress === minter);
}
function selectChainTokenWithMaxBalanceSlow(global, chain) {
  return (selectCurrentAccountTokens(global) ?? []).filter(token => token.chain === chain).reduce((maxToken, currentToken) => {
    const currentBalance = currentToken.priceUsd * Number(currentToken.amount);
    const maxBalance = maxToken ? maxToken.priceUsd * Number(maxToken.amount) : 0;
    return currentBalance > maxBalance ? currentToken : maxToken;
  });
}
// EXTERNAL MODULE: ./src/util/shortenAddress.ts
var shortenAddress = __webpack_require__(91049);
;// ./src/util/poisoningHash.ts


const poisoningHash_cache = new Map();
function getKey(address) {
  return (0,shortenAddress/* shortenAddress */.W)(address, src_config/* TRANSACTION_ADDRESS_SHIFT */.bOf);
}
function addToCache(address, amount, timestamp) {
  const key = getKey(address);
  poisoningHash_cache.set(key, {
    address,
    amount,
    timestamp
  });
}
function getFromCache(address) {
  const key = getKey(address);
  return poisoningHash_cache.get(key);
}
function updatePoisoningCache(tx) {
  const {
    fromAddress: address,
    amount,
    timestamp
  } = tx;
  const cached = getFromCache(address);
  if (!cached || cached.timestamp < timestamp || cached.timestamp === timestamp && cached.amount > amount) {
    addToCache(address, amount, timestamp);
  }
}
function getIsTransactionWithPoisoning(tx) {
  const {
    fromAddress: address
  } = tx;
  const cached = getFromCache(address);
  return cached && cached.address !== address;
}
function clearPoisoningCache() {
  poisoningHash_cache.clear();
}
;// ./src/util/activities/index.ts



const TRANSACTION_TYPE_TITLES = {
  stake: ['Staked', 'Staking', '$stake_action'],
  unstake: ['Unstaked', 'Unstaking', '$unstake_action'],
  unstakeRequest: ['Requested Unstake', 'Requesting Unstake', '$request_unstake_action'],
  callContract: ['Called Contract', 'Calling Contract', '$call_contract_action'],
  excess: ['Excess', 'Excess', 'Excess'],
  contractDeploy: ['Deployed Contract', 'Deploying Contract', '$deploy_contract_action'],
  bounced: ['Bounced', 'Bouncing', '$bounce_action'],
  mint: ['Minted', 'Minting', '$mint_action'],
  burn: ['Burned', 'Burning', '$burn_action'],
  auctionBid: ['NFT Auction Bid', 'Bidding at NFT Auction', 'NFT Auction Bid '],
  dnsChangeAddress: ['Updated Address', 'Updating Address', '$update_address_action'],
  dnsChangeSite: ['Updated Site', 'Updating Site', '$update_site_action'],
  dnsChangeSubdomains: ['Updated Subdomains', 'Updating Subdomains', '$update_subdomains_action'],
  dnsChangeStorage: ['Updated Storage', 'Updating Storage', '$update_storage_action'],
  dnsDelete: ['Deleted Domain Record', 'Deleting Domain Record', '$delete_domain_record_action'],
  dnsRenew: ['Renewed Domain', 'Renewing Domain', '$renew_domain_action'],
  liquidityDeposit: ['Provided Liquidity', 'Providing Liquidity', '$provide_liquidity_action'],
  liquidityWithdraw: ['Withdrawn Liquidity', 'Withdrawing Liquidity', '$withdraw_liquidity_action']
};
const STAKING_TRANSACTION_TYPES = new Set(['stake', 'unstake', 'unstakeRequest']);
const DNS_TRANSACTION_TYPES = new Set(['dnsChangeAddress', 'dnsChangeSite', 'dnsChangeStorage', 'dnsChangeSubdomains', 'dnsDelete', 'dnsRenew']);
function parseTxId(txId) {
  const [hash, subId, type] = txId.split(':');
  return {
    hash,
    type,
    subId
  };
}
function getIsTxIdLocal(txId) {
  return txId.endsWith(':local');
}
function getIsBackendSwapId(id) {
  return id.endsWith(':backend-swap');
}
function buildBackendSwapId(backendId) {
  return buildTxId(backendId, undefined, 'backend-swap');
}
function buildLocalTxId(hash, subId) {
  return buildTxId(hash, subId, 'local');
}
function buildTxId(hash, subId, type) {
  if (!type && subId === undefined) return hash;
  if (type === undefined) return `${hash}:${subId}`;
  return `${hash}:${subId ?? ''}:${type}`;
}
function getActivityTokenSlugs(activity) {
  switch (activity.kind) {
    case 'transaction':
      {
        if (activity.nft) return []; // We don't want NFT activities to get into any token activity list
        return [activity.slug];
      }
    case 'swap':
      {
        return [activity.from, activity.to];
      }
  }
}
function getIsActivitySuitableForFetchingTimestamp(activity) {
  return !!activity && !getIsTxIdLocal(activity.id) && !getIsBackendSwapId(activity.id) && !getIsActivityPending(activity);
}
function getTransactionTitle(_ref, tense, translate) {
  let {
    type,
    isIncoming,
    nft
  } = _ref;
  const tenseIndex = tense === 'past' ? 0 : tense === 'present' ? 1 : 2;
  let titles;
  if (type === 'nftTrade') {
    titles = isIncoming ? ['Sold NFT', 'Selling NFT', '$sell_nft_action'] : ['Bought NFT', 'Buying NFT', '$buy_nft_action'];
  } else if (type && TRANSACTION_TYPE_TITLES[type]) {
    titles = TRANSACTION_TYPE_TITLES[type];
  } else {
    titles = isIncoming ? ['Received', 'Receiving', '$receive_action'] : ['Sent', 'Sending', '$send_action'];
  }
  let title = translate(titles[tenseIndex]);
  if (nft && (!type || type === 'mint' || type === 'burn')) {
    title += ' NFT';
  }
  return title;
}
function isScamTransaction(transaction) {
  var _transaction$metadata;
  return Boolean((_transaction$metadata = transaction.metadata) === null || _transaction$metadata === void 0 ? void 0 : _transaction$metadata.isScam) || transaction.isIncoming && getIsTransactionWithPoisoning(transaction);
}
function shouldShowTransactionComment(transaction) {
  return Boolean(transaction.comment || transaction.encryptedComment) && !STAKING_TRANSACTION_TYPES.has(transaction.type) && !isScamTransaction(transaction);
}
function getTransactionAmountDisplayMode(_ref2) {
  let {
    type,
    amount,
    nft
  } = _ref2;
  const isPlainTransfer = type === undefined && !nft;
  if (!amount && !isPlainTransfer) {
    return 'hide';
  }
  return type === 'stake' || type === 'unstake' ? 'noSign' : 'normal';
}

/** Returns the UI sections where the address should be shown */
function shouldShowTransactionAddress(transaction) {
  const {
    type,
    isIncoming,
    nft,
    toAddress,
    fromAddress,
    extra
  } = transaction;
  if (type === 'nftTrade') {
    return extra !== null && extra !== void 0 && extra.marketplace ? ['list'] : [];
  }
  const shouldHide = isOurStakingTransaction(transaction) || type === 'burn' || !isIncoming && nft && toAddress === nft.address || isIncoming && type === 'excess' && fromAddress === src_config/* BURN_ADDRESS */.pV9;
  return shouldHide ? [] : ['list', 'modal'];
}

/** "Our" is staking that can be controlled with MyTonWallet app */
function isOurStakingTransaction(_ref3) {
  let {
    type,
    isIncoming,
    toAddress,
    fromAddress
  } = _ref3;
  return STAKING_TRANSACTION_TYPES.has(type) && src_config/* ALL_STAKING_POOLS */.uPU.includes(isIncoming ? fromAddress : toAddress);
}
function shouldShowTransactionAnnualYield(transaction) {
  return transaction.type === 'stake' && isOurStakingTransaction(transaction);
}
function getIsActivityWithHash(activity) {
  var _activity$extra;
  return !getIsTxIdLocal(activity.id) || !((_activity$extra = activity.extra) !== null && _activity$extra !== void 0 && _activity$extra.withW5Gasless);
}
function getIsActivityPending(activity) {
  // "Pending" is a blockchain term. The activities originated by our backend are never considered pending in this sense.
  return (activity.status === 'pending' || activity.status === 'pendingTrusted') && !getIsBackendSwapId(activity.id);
}

/**
 * Sometimes activity ids change. This function finds the new id withing `nextActivities` for each activity in
 * `prevActivities`. Currently only local and pending activity ids change, so it's enough to provide only such
 * activities in `prevActivities`.
 *
 * The ids should be unique within each input array. The returned map has previous activity ids as keys and next
 * activity ids as values. If the map has no value for a previous id, it means that there is no matching next activity.
 * The values may be not unique.
 */
function getActivityIdReplacements(prevActivities, nextActivities) {
  // Each previous activity must fall into either of the groups, otherwise the resulting map will falsely miss previous ids
  const prevLocalActivities = [];
  const prevChainActivities = [];
  for (const activity of prevActivities) {
    const group = getIsTxIdLocal(activity.id) ? prevLocalActivities : prevChainActivities;
    group.push(activity);
  }
  return {
    ...getLocalActivityIdReplacements(prevLocalActivities, nextActivities),
    ...getChainActivityIdReplacements(prevChainActivities, nextActivities)
  };
}

/** Replaces local activity ids. See `getActivityIdReplacements` for more details. */
function getLocalActivityIdReplacements(prevLocalActivities, nextActivities) {
  const idReplacements = {};
  if (!prevLocalActivities.length) {
    return idReplacements;
  }
  const nextActivityIds = new Set((0,iteratees/* extractKey */.JY)(nextActivities, 'id'));
  const nextChainActivities = nextActivities.filter(activity => !getIsTxIdLocal(activity.id));
  for (const localActivity of prevLocalActivities) {
    const {
      id: prevId
    } = localActivity;

    // Try a direct id match
    if (nextActivityIds.has(prevId)) {
      idReplacements[prevId] = prevId;
      continue;
    }

    // Otherwise, try to find a match by a heuristic
    const chainActivity = nextChainActivities.find(chainActivity => {
      return doesLocalActivityMatch(localActivity, chainActivity);
    });
    if (chainActivity) {
      idReplacements[prevId] = chainActivity.id;
    }

    // Otherwise, there is no match
  }
  return idReplacements;
}

/** Replaces chain (i.e. not local) activity ids. See `getActivityIdReplacements` for more details. */
function getChainActivityIdReplacements(prevActivities, nextActivities) {
  const idReplacements = {};
  if (!prevActivities.length) {
    return idReplacements;
  }
  const nextActivityIds = new Set((0,iteratees/* extractKey */.JY)(nextActivities, 'id'));
  const nextActivitiesByMessageHash = (0,iteratees/* groupBy */.$z)(nextActivities, 'externalMsgHashNorm');
  for (const {
    id: prevId,
    externalMsgHashNorm
  } of prevActivities) {
    // Try a direct id match
    if (nextActivityIds.has(prevId)) {
      idReplacements[prevId] = prevId;
      continue;
    }

    // Otherwise, match by the message hash
    if (externalMsgHashNorm) {
      const nextSubActivities = nextActivitiesByMessageHash[externalMsgHashNorm];
      if (nextSubActivities !== null && nextSubActivities !== void 0 && nextSubActivities.length) {
        idReplacements[prevId] = nextSubActivities[0].id;

        // Leaving 1 activity in each group to ensure there is a match for the further prev activities with the same hash
        if (nextSubActivities.length > 1) {
          nextSubActivities.shift();
        }
      }
    }

    // Otherwise, there is no match
  }
  return idReplacements;
}

/** Decides whether the local activity matches the activity from the blockchain */
function doesLocalActivityMatch(localActivity, chainActivity) {
  var _localActivity$extra;
  if ((_localActivity$extra = localActivity.extra) !== null && _localActivity$extra !== void 0 && _localActivity$extra.withW5Gasless) {
    if (localActivity.kind === 'transaction' && chainActivity.kind === 'transaction') {
      return !chainActivity.isIncoming && localActivity.normalizedAddress === chainActivity.normalizedAddress && localActivity.amount === chainActivity.amount && localActivity.slug === chainActivity.slug;
    } else if (localActivity.kind === 'swap' && chainActivity.kind === 'swap') {
      return localActivity.from === chainActivity.from && localActivity.to === chainActivity.to && localActivity.fromAmount === chainActivity.fromAmount;
    }
  }
  if (localActivity.externalMsgHashNorm) {
    return localActivity.externalMsgHashNorm === chainActivity.externalMsgHashNorm && !chainActivity.shouldHide;
  }
  return parseTxId(localActivity.id).hash === parseTxId(chainActivity.id).hash;
}
;// ./src/global/selectors/activities.ts



function selectNewestActivityTimestamps(global, accountId) {
  var _selectAccountState;
  return (0,iteratees/* mapValues */.LG)(((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 || (_selectAccountState = _selectAccountState.activities) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.newestActivitiesBySlug) || {}, _ref => {
    let {
      timestamp
    } = _ref;
    return timestamp;
  });
}
function selectLastActivityTimestamp(global, accountId, tokenSlug) {
  var _selectAccountState2;
  const activities = (_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.activities;
  if (!activities) return undefined;
  const {
    byId,
    idsMain,
    idsBySlug
  } = activities;
  const ids = (tokenSlug ? idsBySlug === null || idsBySlug === void 0 ? void 0 : idsBySlug[tokenSlug] : idsMain) || [];
  const txId = (0,iteratees/* findLast */.Uk)(ids, id => getIsActivitySuitableForFetchingTimestamp(byId[id]));
  if (!txId) return undefined;
  return byId[txId].timestamp;
}
function selectLocalActivitiesSlow(global, accountId) {
  var _global$byAccountId$a;
  const {
    byId = {},
    localActivityIds = []
  } = ((_global$byAccountId$a = global.byAccountId[accountId]) === null || _global$byAccountId$a === void 0 ? void 0 : _global$byAccountId$a.activities) ?? {};
  return (0,iteratees/* compact */.oE)(localActivityIds.map(id => byId[id]));
}

/** Doesn't include local activities */
function selectPendingActivitiesSlow(global, accountId, chain) {
  var _global$byAccountId$a2;
  const {
    byId = {},
    pendingActivityIds = {}
  } = ((_global$byAccountId$a2 = global.byAccountId[accountId]) === null || _global$byAccountId$a2 === void 0 ? void 0 : _global$byAccountId$a2.activities) ?? {};
  const ids = pendingActivityIds[chain] ?? [];
  return (0,iteratees/* compact */.oE)(ids.map(id => byId[id]));
}
function selectRecentNonLocalActivitiesSlow(global, accountId, maxCount) {
  var _global$byAccountId$a3;
  const {
    byId = {},
    idsMain = []
  } = ((_global$byAccountId$a3 = global.byAccountId[accountId]) === null || _global$byAccountId$a3 === void 0 ? void 0 : _global$byAccountId$a3.activities) ?? {};
  const result = [];
  for (const id of idsMain) {
    if (result.length >= maxCount) {
      break;
    }
    if (getIsTxIdLocal(id)) {
      continue;
    }
    const activity = byId[id];
    if (activity) {
      result.push(activity);
    }
  }
  return result;
}
function selectIsHistoryEndReached(global, accountId, tokenSlug) {
  const accountState = accounts_selectAccountState(global, accountId);
  const {
    isMainHistoryEndReached,
    isHistoryEndReachedBySlug
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.activities) ?? {};
  return tokenSlug ? !!(isHistoryEndReachedBySlug !== null && isHistoryEndReachedBySlug !== void 0 && isHistoryEndReachedBySlug[tokenSlug]) : !!isMainHistoryEndReached;
}

/** If returns `undefined`, the activities haven't been loaded yet. If returns `[]`, there are no activities. */
function selectActivityHistoryIds(global, accountId, tokenSlug) {
  var _selectAccountState3;
  const {
    idsMain,
    idsBySlug
  } = ((_selectAccountState3 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState3 === void 0 ? void 0 : _selectAccountState3.activities) ?? {};
  return tokenSlug ? idsBySlug === null || idsBySlug === void 0 ? void 0 : idsBySlug[tokenSlug] : idsMain;
}
;// ./src/global/types.ts
let AppState = /*#__PURE__*/function (AppState) {
  AppState[AppState["Auth"] = 0] = "Auth";
  AppState[AppState["Main"] = 1] = "Main";
  AppState[AppState["Explore"] = 2] = "Explore";
  AppState[AppState["Settings"] = 3] = "Settings";
  AppState[AppState["Ledger"] = 4] = "Ledger";
  AppState[AppState["Inactive"] = 5] = "Inactive";
  return AppState;
}({});
let AuthState = /*#__PURE__*/function (AuthState) {
  AuthState[AuthState["none"] = 0] = "none";
  AuthState[AuthState["createWallet"] = 1] = "createWallet";
  AuthState[AuthState["checkPassword"] = 2] = "checkPassword";
  AuthState[AuthState["createPin"] = 3] = "createPin";
  AuthState[AuthState["confirmPin"] = 4] = "confirmPin";
  AuthState[AuthState["createBiometrics"] = 5] = "createBiometrics";
  AuthState[AuthState["confirmBiometrics"] = 6] = "confirmBiometrics";
  AuthState[AuthState["createNativeBiometrics"] = 7] = "createNativeBiometrics";
  AuthState[AuthState["createPassword"] = 8] = "createPassword";
  AuthState[AuthState["createBackup"] = 9] = "createBackup";
  AuthState[AuthState["disclaimerAndBackup"] = 10] = "disclaimerAndBackup";
  AuthState[AuthState["importWalletCheckPassword"] = 11] = "importWalletCheckPassword";
  AuthState[AuthState["importWallet"] = 12] = "importWallet";
  AuthState[AuthState["importWalletCreatePin"] = 13] = "importWalletCreatePin";
  AuthState[AuthState["importWalletConfirmPin"] = 14] = "importWalletConfirmPin";
  AuthState[AuthState["importWalletCreateNativeBiometrics"] = 15] = "importWalletCreateNativeBiometrics";
  AuthState[AuthState["importWalletCreateBiometrics"] = 16] = "importWalletCreateBiometrics";
  AuthState[AuthState["importWalletConfirmBiometrics"] = 17] = "importWalletConfirmBiometrics";
  AuthState[AuthState["importWalletCreatePassword"] = 18] = "importWalletCreatePassword";
  AuthState[AuthState["disclaimer"] = 19] = "disclaimer";
  AuthState[AuthState["ready"] = 20] = "ready";
  AuthState[AuthState["about"] = 21] = "about";
  AuthState[AuthState["safetyRules"] = 22] = "safetyRules";
  AuthState[AuthState["mnemonicPage"] = 23] = "mnemonicPage";
  AuthState[AuthState["checkWords"] = 24] = "checkWords";
  AuthState[AuthState["importViewAccount"] = 25] = "importViewAccount";
  return AuthState;
}({});
let BiometricsState = /*#__PURE__*/function (BiometricsState) {
  BiometricsState[BiometricsState["None"] = 0] = "None";
  BiometricsState[BiometricsState["TurnOnPasswordConfirmation"] = 1] = "TurnOnPasswordConfirmation";
  BiometricsState[BiometricsState["TurnOnRegistration"] = 2] = "TurnOnRegistration";
  BiometricsState[BiometricsState["TurnOnVerification"] = 3] = "TurnOnVerification";
  BiometricsState[BiometricsState["TurnOnComplete"] = 4] = "TurnOnComplete";
  BiometricsState[BiometricsState["TurnOffWarning"] = 5] = "TurnOffWarning";
  BiometricsState[BiometricsState["TurnOffBiometricConfirmation"] = 6] = "TurnOffBiometricConfirmation";
  BiometricsState[BiometricsState["TurnOffCreatePassword"] = 7] = "TurnOffCreatePassword";
  BiometricsState[BiometricsState["TurnOffComplete"] = 8] = "TurnOffComplete";
  return BiometricsState;
}({});
let TransferState = /*#__PURE__*/function (TransferState) {
  TransferState[TransferState["None"] = 0] = "None";
  TransferState[TransferState["WarningHardware"] = 1] = "WarningHardware";
  TransferState[TransferState["Initial"] = 2] = "Initial";
  TransferState[TransferState["Confirm"] = 3] = "Confirm";
  TransferState[TransferState["Password"] = 4] = "Password";
  TransferState[TransferState["ConnectHardware"] = 5] = "ConnectHardware";
  TransferState[TransferState["ConfirmHardware"] = 6] = "ConfirmHardware";
  TransferState[TransferState["Complete"] = 7] = "Complete";
  return TransferState;
}({});
let ScamWarningType = /*#__PURE__*/function (ScamWarningType) {
  ScamWarningType[ScamWarningType["SeedPhrase"] = 1] = "SeedPhrase";
  ScamWarningType[ScamWarningType["DomainLike"] = 2] = "DomainLike";
  return ScamWarningType;
}({});
let SignDataState = /*#__PURE__*/function (SignDataState) {
  SignDataState[SignDataState["None"] = 0] = "None";
  SignDataState[SignDataState["Initial"] = 1] = "Initial";
  SignDataState[SignDataState["Password"] = 2] = "Password";
  SignDataState[SignDataState["Complete"] = 3] = "Complete";
  return SignDataState;
}({});
let DomainRenewalState = /*#__PURE__*/function (DomainRenewalState) {
  DomainRenewalState[DomainRenewalState["None"] = 0] = "None";
  DomainRenewalState[DomainRenewalState["Initial"] = 1] = "Initial";
  DomainRenewalState[DomainRenewalState["Password"] = 2] = "Password";
  DomainRenewalState[DomainRenewalState["ConnectHardware"] = 3] = "ConnectHardware";
  DomainRenewalState[DomainRenewalState["ConfirmHardware"] = 4] = "ConfirmHardware";
  DomainRenewalState[DomainRenewalState["Complete"] = 5] = "Complete";
  return DomainRenewalState;
}({});
let DomainLinkingState = /*#__PURE__*/function (DomainLinkingState) {
  DomainLinkingState[DomainLinkingState["None"] = 0] = "None";
  DomainLinkingState[DomainLinkingState["Initial"] = 1] = "Initial";
  DomainLinkingState[DomainLinkingState["Password"] = 2] = "Password";
  DomainLinkingState[DomainLinkingState["ConnectHardware"] = 3] = "ConnectHardware";
  DomainLinkingState[DomainLinkingState["ConfirmHardware"] = 4] = "ConfirmHardware";
  DomainLinkingState[DomainLinkingState["Complete"] = 5] = "Complete";
  return DomainLinkingState;
}({});
let SwapState = /*#__PURE__*/function (SwapState) {
  SwapState[SwapState["None"] = 0] = "None";
  SwapState[SwapState["Initial"] = 1] = "Initial";
  SwapState[SwapState["Blockchain"] = 2] = "Blockchain";
  SwapState[SwapState["Password"] = 3] = "Password";
  SwapState[SwapState["WaitTokens"] = 4] = "WaitTokens";
  SwapState[SwapState["Complete"] = 5] = "Complete";
  SwapState[SwapState["SelectTokenFrom"] = 6] = "SelectTokenFrom";
  SwapState[SwapState["SelectTokenTo"] = 7] = "SelectTokenTo";
  return SwapState;
}({});
let SwapInputSource = /*#__PURE__*/function (SwapInputSource) {
  SwapInputSource[SwapInputSource["In"] = 0] = "In";
  SwapInputSource[SwapInputSource["Out"] = 1] = "Out";
  return SwapInputSource;
}({});
let SwapErrorType = /*#__PURE__*/function (SwapErrorType) {
  SwapErrorType[SwapErrorType["UnexpectedError"] = 0] = "UnexpectedError";
  SwapErrorType[SwapErrorType["InvalidPair"] = 1] = "InvalidPair";
  SwapErrorType[SwapErrorType["NotEnoughLiquidity"] = 2] = "NotEnoughLiquidity";
  SwapErrorType[SwapErrorType["ChangellyMinSwap"] = 3] = "ChangellyMinSwap";
  SwapErrorType[SwapErrorType["ChangellyMaxSwap"] = 4] = "ChangellyMaxSwap";
  SwapErrorType[SwapErrorType["NotEnoughForFee"] = 5] = "NotEnoughForFee";
  SwapErrorType[SwapErrorType["TooSmallAmount"] = 6] = "TooSmallAmount";
  return SwapErrorType;
}({});
let SwapType = /*#__PURE__*/function (SwapType) {
  SwapType[SwapType["OnChain"] = 0] = "OnChain";
  SwapType[SwapType["CrosschainFromWallet"] = 1] = "CrosschainFromWallet";
  SwapType[SwapType["CrosschainToWallet"] = 2] = "CrosschainToWallet";
  return SwapType;
}({});
let DappConnectState = /*#__PURE__*/function (DappConnectState) {
  DappConnectState[DappConnectState["Info"] = 0] = "Info";
  DappConnectState[DappConnectState["Password"] = 1] = "Password";
  DappConnectState[DappConnectState["ConnectHardware"] = 2] = "ConnectHardware";
  DappConnectState[DappConnectState["ConfirmHardware"] = 3] = "ConfirmHardware";
  return DappConnectState;
}({});
let HardwareConnectState = /*#__PURE__*/function (HardwareConnectState) {
  HardwareConnectState[HardwareConnectState["Connect"] = 0] = "Connect";
  HardwareConnectState[HardwareConnectState["Connecting"] = 1] = "Connecting";
  HardwareConnectState[HardwareConnectState["Failed"] = 2] = "Failed";
  HardwareConnectState[HardwareConnectState["ConnectedWithSeveralWallets"] = 3] = "ConnectedWithSeveralWallets";
  HardwareConnectState[HardwareConnectState["ConnectedWithSingleWallet"] = 4] = "ConnectedWithSingleWallet";
  HardwareConnectState[HardwareConnectState["WaitingForRemoteTab"] = 5] = "WaitingForRemoteTab";
  return HardwareConnectState;
}({});
let StakingState = /*#__PURE__*/function (StakingState) {
  StakingState[StakingState["None"] = 0] = "None";
  StakingState[StakingState["StakeInitial"] = 1] = "StakeInitial";
  StakingState[StakingState["StakePassword"] = 2] = "StakePassword";
  StakingState[StakingState["StakeConnectHardware"] = 3] = "StakeConnectHardware";
  StakingState[StakingState["StakeConfirmHardware"] = 4] = "StakeConfirmHardware";
  StakingState[StakingState["StakeComplete"] = 5] = "StakeComplete";
  StakingState[StakingState["UnstakeInitial"] = 6] = "UnstakeInitial";
  StakingState[StakingState["UnstakePassword"] = 7] = "UnstakePassword";
  StakingState[StakingState["UnstakeConnectHardware"] = 8] = "UnstakeConnectHardware";
  StakingState[StakingState["UnstakeConfirmHardware"] = 9] = "UnstakeConfirmHardware";
  StakingState[StakingState["UnstakeComplete"] = 10] = "UnstakeComplete";
  StakingState[StakingState["ClaimPassword"] = 11] = "ClaimPassword";
  StakingState[StakingState["ClaimConnectHardware"] = 12] = "ClaimConnectHardware";
  StakingState[StakingState["ClaimConfirmHardware"] = 13] = "ClaimConfirmHardware";
  StakingState[StakingState["ClaimComplete"] = 14] = "ClaimComplete";
  return StakingState;
}({});
let VestingUnfreezeState = /*#__PURE__*/function (VestingUnfreezeState) {
  VestingUnfreezeState[VestingUnfreezeState["Password"] = 0] = "Password";
  VestingUnfreezeState[VestingUnfreezeState["ConnectHardware"] = 1] = "ConnectHardware";
  VestingUnfreezeState[VestingUnfreezeState["ConfirmHardware"] = 2] = "ConfirmHardware";
  return VestingUnfreezeState;
}({});
let SettingsState = /*#__PURE__*/function (SettingsState) {
  SettingsState[SettingsState["Initial"] = 0] = "Initial";
  SettingsState[SettingsState["PushNotifications"] = 1] = "PushNotifications";
  SettingsState[SettingsState["Appearance"] = 2] = "Appearance";
  SettingsState[SettingsState["Assets"] = 3] = "Assets";
  SettingsState[SettingsState["Security"] = 4] = "Security";
  SettingsState[SettingsState["Dapps"] = 5] = "Dapps";
  SettingsState[SettingsState["Language"] = 6] = "Language";
  SettingsState[SettingsState["About"] = 7] = "About";
  SettingsState[SettingsState["Disclaimer"] = 8] = "Disclaimer";
  SettingsState[SettingsState["NativeBiometricsTurnOn"] = 9] = "NativeBiometricsTurnOn";
  SettingsState[SettingsState["SelectTokenList"] = 10] = "SelectTokenList";
  SettingsState[SettingsState["WalletVersion"] = 11] = "WalletVersion";
  SettingsState[SettingsState["LedgerConnectHardware"] = 12] = "LedgerConnectHardware";
  SettingsState[SettingsState["LedgerSelectWallets"] = 13] = "LedgerSelectWallets";
  SettingsState[SettingsState["HiddenNfts"] = 14] = "HiddenNfts";
  SettingsState[SettingsState["BackupWallet"] = 15] = "BackupWallet";
  return SettingsState;
}({});
let MintCardState = /*#__PURE__*/function (MintCardState) {
  MintCardState[MintCardState["Initial"] = 0] = "Initial";
  MintCardState[MintCardState["Password"] = 1] = "Password";
  MintCardState[MintCardState["ConnectHardware"] = 2] = "ConnectHardware";
  MintCardState[MintCardState["ConfirmHardware"] = 3] = "ConfirmHardware";
  MintCardState[MintCardState["Done"] = 4] = "Done";
  return MintCardState;
}({});
let ActiveTab = /*#__PURE__*/function (ActiveTab) {
  ActiveTab[ActiveTab["Receive"] = 0] = "Receive";
  ActiveTab[ActiveTab["Transfer"] = 1] = "Transfer";
  ActiveTab[ActiveTab["Swap"] = 2] = "Swap";
  ActiveTab[ActiveTab["Stake"] = 3] = "Stake";
  return ActiveTab;
}({});
let ContentTab = /*#__PURE__*/function (ContentTab) {
  ContentTab[ContentTab["Assets"] = 0] = "Assets";
  ContentTab[ContentTab["Activity"] = 1] = "Activity";
  ContentTab[ContentTab["Explore"] = 2] = "Explore";
  ContentTab[ContentTab["Nft"] = 3] = "Nft";
  return ContentTab;
}({});
let MediaType = /*#__PURE__*/function (MediaType) {
  MediaType[MediaType["Nft"] = 0] = "Nft";
  return MediaType;
}({});
let LoadMoreDirection = /*#__PURE__*/function (LoadMoreDirection) {
  LoadMoreDirection[LoadMoreDirection["Forwards"] = 0] = "Forwards";
  LoadMoreDirection[LoadMoreDirection["Backwards"] = 1] = "Backwards";
  return LoadMoreDirection;
}({});
;// ./src/util/chain.ts

function getChainConfig(chain) {
  return src_config/* CHAIN_CONFIG */.zll[chain];
}
function findChainConfig(chain) {
  return chain in src_config/* CHAIN_CONFIG */.zll ? src_config/* CHAIN_CONFIG */.zll[chain] : undefined;
}
;// ./src/util/tokens.ts



const chainByNativeSlug = Object.fromEntries(Object.entries(src_config/* CHAIN_CONFIG */.zll).map(_ref => {
  let [chain, {
    nativeToken
  }] = _ref;
  return [nativeToken.slug, chain];
}));
function getIsNativeToken(slug) {
  return slug ? slug in chainByNativeSlug : false;
}
function getIsTonToken(slug, withNative) {
  return Boolean(slug.startsWith('ton-') || withNative && slug === src_config/* TONCOIN */.Tu9.slug);
}
function getNativeToken(chain) {
  return getChainConfig(chain).nativeToken;
}
function getChainBySlug(slug) {
  const items = slug.split('-');
  return items.length > 1 ? items[0] : chainByNativeSlug[slug];
}
function getIsServiceToken(token) {
  const {
    type,
    codeHash = '',
    slug = ''
  } = token ?? {};
  return type === 'lp_token' || src_config/* STAKED_TOKEN_SLUGS */.Svl.has(slug) || src_config/* PRICELESS_TOKEN_HASHES */.kuH.has(codeHash);
}
function buildUserToken(token) {
  return {
    ...(0,iteratees/* pick */.Up)(token, ['symbol', 'slug', 'name', 'image', 'decimals', 'keywords', 'chain', 'tokenAddress', 'type']),
    amount: 0n,
    totalValue: '0',
    price: 0,
    priceUsd: 0,
    change24h: 0
  };
}
;// ./src/global/selectors/swap.ts








function createTokenList(swapTokenInfo, balancesBySlug, sortFn, filterFn) {
  return Object.entries(swapTokenInfo.bySlug).filter(_ref => {
    let [, token] = _ref;
    return !filterFn || filterFn(token);
  }).map(_ref2 => {
    let [slug, {
      symbol,
      name,
      image,
      decimals,
      keywords,
      chain,
      tokenAddress,
      isPopular,
      color,
      price = 0,
      priceUsd = 0
    }] = _ref2;
    const amount = balancesBySlug[slug] ?? 0n;
    const totalValue = (0,util_decimals/* toBig */.CF)(amount, decimals).mul(price).toString();
    return {
      symbol,
      slug,
      amount,
      price,
      priceUsd,
      name,
      image,
      decimals,
      isDisabled: false,
      canSwap: true,
      isPopular,
      keywords,
      totalValue,
      color,
      chain,
      tokenAddress
    };
  }).sort(sortFn);
}
const selectPopularTokensMemoizedFor = (0,withCache/* default */.A)(accountId => memoize((balancesBySlug, swapTokenInfo) => {
  const popularTokenOrder = ['TON', 'USDâ‚®', 'USDT', 'BTC', 'ETH', 'jUSDT', 'jWBTC'];
  const orderMap = new Map(popularTokenOrder.map((item, index) => [item, index]));
  const filterFn = token => token.isPopular;
  const sortFn = (tokenA, tokenB) => {
    const orderIndexA = orderMap.has(tokenA.symbol) ? orderMap.get(tokenA.symbol) : popularTokenOrder.length;
    const orderIndexB = orderMap.has(tokenB.symbol) ? orderMap.get(tokenB.symbol) : popularTokenOrder.length;
    return orderIndexA - orderIndexB;
  };
  return createTokenList(swapTokenInfo, balancesBySlug, sortFn, filterFn);
}));
const selectSwapTokensMemoizedFor = (0,withCache/* default */.A)(accountId => memoize((balancesBySlug, swapTokenInfo) => {
  const sortFn = (tokenA, tokenB) => tokenA.name.trim().toLowerCase().localeCompare(tokenB.name.trim().toLowerCase());
  return createTokenList(swapTokenInfo, balancesBySlug, sortFn);
}));
const selectAccountTokensForSwapMemoizedFor = (0,withCache/* default */.A)(accountId => memoize(function (balancesBySlug, tokenInfo, swapTokenInfo, accountSettings) {
  let isSortByValueEnabled = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  let areTokensWithNoCostHidden = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  return selectAccountTokensMemoizedFor(accountId)(balancesBySlug, tokenInfo, accountSettings, isSortByValueEnabled, areTokensWithNoCostHidden).filter(token => token.slug in swapTokenInfo.bySlug && !token.isDisabled);
}));
function selectAvailableUserForSwapTokens(global) {
  var _selectCurrentAccount;
  const balancesBySlug = (_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 || (_selectCurrentAccount = _selectCurrentAccount.balances) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.bySlug;
  if (!balancesBySlug || !global.tokenInfo || !global.swapTokenInfo) {
    return undefined;
  }
  const accountSettings = selectCurrentAccountSettings(global) ?? {};
  const {
    areTokensWithNoCostHidden,
    isSortByValueEnabled
  } = global.settings;
  return selectAccountTokensForSwapMemoizedFor(global.currentAccountId)(balancesBySlug, global.tokenInfo, global.swapTokenInfo, accountSettings, isSortByValueEnabled, areTokensWithNoCostHidden);
}
function selectPopularTokens(global) {
  var _selectCurrentAccount2;
  const balancesBySlug = (_selectCurrentAccount2 = selectCurrentAccountState(global)) === null || _selectCurrentAccount2 === void 0 || (_selectCurrentAccount2 = _selectCurrentAccount2.balances) === null || _selectCurrentAccount2 === void 0 ? void 0 : _selectCurrentAccount2.bySlug;
  if (!balancesBySlug || !global.swapTokenInfo) {
    return undefined;
  }
  return selectPopularTokensMemoizedFor(global.currentAccountId)(balancesBySlug, global.swapTokenInfo);
}
function selectSwapTokens(global) {
  var _selectCurrentAccount3;
  const balancesBySlug = (_selectCurrentAccount3 = selectCurrentAccountState(global)) === null || _selectCurrentAccount3 === void 0 || (_selectCurrentAccount3 = _selectCurrentAccount3.balances) === null || _selectCurrentAccount3 === void 0 ? void 0 : _selectCurrentAccount3.bySlug;
  if (!balancesBySlug || !global.swapTokenInfo) {
    return undefined;
  }
  return selectSwapTokensMemoizedFor(global.currentAccountId)(balancesBySlug, global.swapTokenInfo);
}
function selectCurrentSwapTokenIn(global) {
  const {
    tokenInSlug
  } = global.currentSwap;
  return tokenInSlug === undefined ? undefined : global.swapTokenInfo.bySlug[tokenInSlug];
}
function selectCurrentSwapTokenOut(global) {
  const {
    tokenOutSlug
  } = global.currentSwap;
  return tokenOutSlug === undefined ? undefined : global.swapTokenInfo.bySlug[tokenOutSlug];
}
function selectSwapType(global) {
  const {
    tokenInSlug = src_config/* DEFAULT_SWAP_FIRST_TOKEN_SLUG */.JhS,
    tokenOutSlug = src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC
  } = global.currentSwap;
  const tokenInChain = getChainBySlug(tokenInSlug);
  const tokenOutChain = getChainBySlug(tokenOutSlug);
  if (tokenInChain === 'ton' && tokenOutChain === 'ton') {
    return SwapType.OnChain;
  }
  const {
    addressByChain
  } = selectCurrentAccount(global) ?? {
    addressByChain: {}
  };
  if (tokenInChain in addressByChain) {
    return SwapType.CrosschainFromWallet;
  }
  return SwapType.CrosschainToWallet;
}
function selectIsSwapDisabled(global) {
  return src_config/* IS_CORE_WALLET */.TI6 || global.restrictions.isSwapDisabled || global.settings.isTestnet || selectIsHardwareAccount(global);
}
// EXTERNAL MODULE: ./src/util/bigint.ts
var bigint = __webpack_require__(809);
;// ./src/util/fee/transferFee.ts




/**
 * Converts the transfer fee data returned from API into data that is ready to be displayed in the transfer form UI.
 */
function explainApiTransferFee(input) {
  return shouldUseDiesel(input) ? explainGaslessTransferFee(input) : explainGasfullTransferFee(input);
}

/**
 * Calculates the maximum amount available for the transfer.
 * Returns undefined when it can't be calculated because of insufficient input data.
 */
function getMaxTransferAmount(_ref) {
  let {
    tokenBalance,
    tokenSlug,
    fullFee,
    canTransferFullBalance
  } = _ref;
  if (tokenBalance === undefined) {
    return undefined;
  }

  // Returning the full balance when the fee is unknown for a better UX
  if (canTransferFullBalance || !fullFee) {
    return tokenBalance;
  }
  let fee = fullFee.token ?? 0n;
  if (getIsNativeToken(tokenSlug)) {
    // When the token is native, both `token` and `native` refer to the same currency, so they should be added
    fee += fullFee.native ?? 0n;
  }
  return (0,bigint/* bigintMax */._O)(tokenBalance - fee, 0n);
}

/**
 * Decides whether the balance is sufficient to transfer the amount and pay the fees.
 * Returns undefined when it can't be calculated because of insufficient input data.
 */
function isBalanceSufficientForTransfer(_ref2) {
  let {
    tokenBalance,
    nativeTokenBalance,
    transferAmount,
    fullFee,
    canTransferFullBalance
  } = _ref2;
  if (transferAmount === undefined || tokenBalance === undefined || nativeTokenBalance === undefined || !fullFee) {
    return undefined;
  }
  const isFullTokenTransfer = transferAmount === tokenBalance && canTransferFullBalance;
  const tokenRequiredAmount = (fullFee.token ?? 0n) + (isFullTokenTransfer ? 0n : transferAmount);
  const nativeTokenRequiredAmount = fullFee.native ?? 0n;
  return tokenRequiredAmount <= tokenBalance && nativeTokenRequiredAmount <= nativeTokenBalance;
}
function isDieselAvailable(diesel) {
  return diesel.status !== 'not-available' && diesel.amount !== undefined;
}
function getDieselTokenAmount(diesel) {
  return diesel.status === 'stars-fee' ? 0n : diesel.amount ?? 0n;
}
function shouldUseDiesel(input) {
  return input.diesel !== undefined && isDieselAvailable(input.diesel);
}

/**
 * Converts the data of a transfer not involving diesel
 */
function explainGasfullTransferFee(input) {
  const result = {
    isGasless: false,
    canTransferFullBalance: input.tokenSlug === src_config/* TONCOIN */.Tu9.slug
  };
  if (input.fee !== undefined) {
    result.fullFee = {
      precision: input.realFee === input.fee ? 'exact' : 'lessThan',
      terms: {
        native: input.fee
      },
      nativeSum: input.fee
    };
    result.realFee = result.fullFee;
  }
  if (input.realFee !== undefined) {
    result.realFee = {
      precision: input.realFee === input.fee ? 'exact' : 'approximate',
      terms: {
        native: input.realFee
      },
      nativeSum: input.realFee
    };
  }
  if (input.fee !== undefined && input.realFee !== undefined) {
    result.excessFee = input.fee - input.realFee;
  }
  return result;
}

/**
 * Converts the diesel of semi-diesel transfer data
 */
function explainGaslessTransferFee(_ref3) {
  let {
    diesel
  } = _ref3;
  const isStarsDiesel = diesel.status === 'stars-fee';
  const dieselKey = isStarsDiesel ? 'stars' : 'token';
  const realFeeInDiesel = convertFee(diesel.realFee, diesel.nativeAmount, diesel.amount);
  // Cover as much displayed real fee as possible with diesel, because in the excess it will return as the native token.
  const dieselRealFee = (0,bigint/* bigintMin */.UA)(diesel.amount, realFeeInDiesel);
  // Cover the remaining real fee with the native token.
  const nativeRealFee = (0,bigint/* bigintMax */._O)(0n, diesel.realFee - diesel.nativeAmount);
  return {
    isGasless: true,
    canTransferFullBalance: false,
    fullFee: {
      precision: 'lessThan',
      terms: {
        [dieselKey]: diesel.amount,
        native: diesel.remainingFee
      },
      nativeSum: diesel.nativeAmount + diesel.remainingFee
    },
    realFee: {
      precision: 'approximate',
      terms: {
        [dieselKey]: dieselRealFee,
        native: nativeRealFee
      },
      nativeSum: diesel.realFee
    },
    excessFee: diesel.nativeAmount + diesel.remainingFee - diesel.realFee
  };
}

/**
 * `exampleFromAmount` and `exampleToAmount` define the exchange rate used to convert `amount`.
 * `exampleFromAmount` is defined in the same currency as `amount`. Mustn't be 0.
 * `exampleToAmount` is defined in the currency you want to get.
 */
function convertFee(amount, exampleFromAmount, exampleToAmount) {
  const exchangeRate = (0,big_js/* Big */.z)(exampleToAmount.toString()).div(exampleFromAmount.toString());
  return BigInt((0,big_js/* Big */.z)(amount.toString()).mul(exchangeRate).round().toString());
}
// EXTERNAL MODULE: ./src/util/dateFormat.ts
var dateFormat = __webpack_require__(10309);
;// ./src/util/dns.ts


function isDnsDomain(value) {
  return getDnsDomainZone(value) !== undefined;
}
function getDnsDomainZone(domain) {
  for (const zone of src_config/* TON_DNS_ZONES */.gs5) {
    const {
      suffixes,
      baseFormat
    } = zone;

    // Iterating the zones in reverse to prioritize longer zones when multiple zones match (assuming the zones go from
    // the shortest to the longest). For example, `test.ton.vip` matches both `vip` and `ton.vip`, and `ton.vip` must be
    // used.
    for (let i = suffixes.length - 1; i >= 0; i--) {
      const suffix = suffixes[i];
      if (!domain.endsWith(`.${suffix}`)) {
        continue;
      }
      const base = domain.slice(0, -suffix.length - 1);
      if (!baseFormat.test(base)) {
        continue;
      }
      return {
        base,
        zone
      };
    }
  }
  return undefined;
}
function getDnsZoneByCollection(collectionAddress) {
  return TON_DNS_ZONES.find(zone => zone.resolver === collectionAddress);
}
function isTonDnsNft(nft) {
  return (nft === null || nft === void 0 ? void 0 : nft.collectionAddress) === src_config/* TON_DNS_COLLECTION */.nQN;
}
function getTonDnsExpirationDate(nft, dnsExpiration) {
  return isTonDnsNft(nft) ? dnsExpiration === null || dnsExpiration === void 0 ? void 0 : dnsExpiration[nft.address] : undefined;
}
function filterExpiringDomains(nftAddresses, nftByAddress, dnsExpiration) {
  const expiringDomains = [];
  if (nftByAddress && dnsExpiration) {
    for (const address of nftAddresses) {
      const nft = nftByAddress[address];
      if ((0,dateFormat/* getCountDaysToDate */.GS)(getTonDnsExpirationDate(nft, dnsExpiration) ?? Infinity) <= src_config/* TON_DNS_RENEWAL_WARNING_DAYS */.wbd) {
        expiringDomains.push(nft);
      }
    }
  }
  return expiringDomains;
}
function getDomainsExpirationDate(nfts, nftByAddress, dnsExpiration) {
  if (!dnsExpiration) {
    return undefined;
  }
  return nfts.reduce((minDate, nftOrAddress) => {
    const nft = typeof nftOrAddress === 'string' ? nftByAddress === null || nftByAddress === void 0 ? void 0 : nftByAddress[nftOrAddress] : nftOrAddress;
    const expirationDate = getTonDnsExpirationDate(nft, dnsExpiration);
    return expirationDate ? Math.min(expirationDate, minDate ?? Infinity) : minDate;
  }, undefined);
}
;// ./src/util/isValidAddressOrDomain.ts


function isValidAddressOrDomain(address, chain, allowPrefix) {
  const config = getChainConfig(chain);
  return address && (config[allowPrefix ? 'addressPrefixRegex' : 'addressRegex'].test(address) || config.isDnsSupported && isDnsDomain(address));
}
;// ./src/global/selectors/transfer.ts





function selectCurrentTransferMaxAmount(global) {
  const {
    currentTransfer
  } = global;
  const tokenBalance = selectCurrentAccountTokenBalance(global, currentTransfer.tokenSlug);
  const {
    fullFee,
    canTransferFullBalance
  } = explainApiTransferFee(currentTransfer);
  return getMaxTransferAmount({
    tokenBalance,
    tokenSlug: currentTransfer.tokenSlug,
    fullFee: fullFee === null || fullFee === void 0 ? void 0 : fullFee.terms,
    canTransferFullBalance
  });
}

/**
 * Returns the token slug that should be set to current transfer form to keep the token in sync with the "to" address
 */
function selectTokenMatchingCurrentTransferAddressSlow(global) {
  const {
    tokenSlug: currentTokenSlug,
    toAddress
  } = global.currentTransfer;
  const currentChain = getChainBySlug(currentTokenSlug);
  if (!toAddress) {
    return currentTokenSlug;
  }

  // First try to match a chain by the full address, then by the prefix.
  // Because a valid TRON address is a prefix of a valid TON address, and we want to match TRON in this case.
  for (const isCheckingPrefix of [false, true]) {
    var _selectCurrentAccount;
    // If the current token already matches the address, no need to change it
    if (!toAddress || isValidAddressOrDomain(toAddress, currentChain, isCheckingPrefix)) {
      return currentTokenSlug;
    }

    // Otherwise, find the best token of the address's chain
    const availableChains = (_selectCurrentAccount = selectCurrentAccount(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.addressByChain;
    if (availableChains) {
      for (const chain of Object.keys(availableChains)) {
        if (!isValidAddressOrDomain(toAddress, chain, isCheckingPrefix)) {
          continue;
        }
        const token = selectChainTokenWithMaxBalanceSlow(global, chain);
        if (token) return token.slug;
      }
    }
  }

  // If the address matches no available chain, don't change the selected token
  return currentTokenSlug;
}
;// ./src/global/selectors/staking.ts





const selectAccountStakingStatesMemoizedFor = (0,withCache/* default */.A)(accountId => memoize((stateDefault, stateById) => {
  const states = stateById ? Object.values(stateById) : undefined;
  return states !== null && states !== void 0 && states.length ? states : [stateDefault];
}));
function selectAccountStakingStates(global, accountId) {
  var _selectAccountState;
  const {
    stateById
  } = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.staking) ?? {};
  return selectAccountStakingStatesMemoizedFor(accountId)(global.stakingDefault, stateById);
}
const selectAccountStakingStatesBySlugMemoizedFor = (0,withCache/* default */.A)(accountId => memoize(stakingStates => (0,iteratees/* buildCollectionByKey */.dU)(stakingStates, 'tokenSlug')));
function selectAccountStakingStatesBySlug(global, accountId) {
  return selectAccountStakingStatesBySlugMemoizedFor(accountId)(selectAccountStakingStates(global, accountId));
}
function selectAccountStakingState(global, accountId) {
  var _selectAccountState2;
  const {
    stateById,
    stakingId,
    shouldUseNominators
  } = ((_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.staking) ?? {};
  if (!stateById || !stakingId || !(stakingId in stateById)) {
    return shouldUseNominators ? src_config/* DEFAULT_NOMINATORS_STAKING_STATE */.Ba4 : global.stakingDefault;
  }
  return stateById[stakingId];
}
function selectAccountStakingHistory(global, accountId) {
  const accountState = accounts_selectAccountState(global, accountId);
  const stakingState = selectAccountStakingState(global, accountId);
  return stakingState.tokenSlug === src_config/* TONCOIN */.Tu9.slug ? accountState === null || accountState === void 0 ? void 0 : accountState.stakingHistory : undefined;
}
function selectAccountStakingTotalProfit(global, accountId) {
  var _accountState$staking;
  const accountState = accounts_selectAccountState(global, accountId);
  const stakingState = selectAccountStakingState(global, accountId);
  return (stakingState.tokenSlug === src_config/* TONCOIN */.Tu9.slug ? accountState === null || accountState === void 0 || (_accountState$staking = accountState.staking) === null || _accountState$staking === void 0 ? void 0 : _accountState$staking.totalProfit : undefined) ?? 0n;
}
function selectIsStakingDisabled(global) {
  return Boolean(src_config/* IS_STAKING_DISABLED */.OuE || global.settings.isTestnet);
}
;// ./src/global/selectors/domains.ts


function selectTonDnsLinkedAddress(global, nft) {
  var _selectCurrentAccount;
  const {
    linkedAddressByAddress
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  return isTonDnsNft(nft) ? linkedAddressByAddress === null || linkedAddressByAddress === void 0 ? void 0 : linkedAddressByAddress[nft.address] : undefined;
}
;// ./src/global/selectors/index.ts








;// ./src/global/actions/api/initial.ts






addActionHandler('initApi', async (global, actions) => {
  var _global$accounts;
  (0,logs/* logDebug */.MD)('initApi action called');
  const accountIds = (_global$accounts = global.accounts) !== null && _global$accounts !== void 0 && _global$accounts.byId ? Object.keys(global.accounts.byId) : [];
  (0,api/* initApi */.R)(actions.apiUpdate, {
    isElectron: windowEnvironment/* IS_ELECTRON */.cp,
    isNativeBottomSheet: windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA,
    isIosApp: windowEnvironment/* IS_IOS_APP */.ZH,
    isAndroidApp: windowEnvironment/* IS_ANDROID_APP */.xy,
    referrer: new URLSearchParams(window.location.search).get('r') ?? undefined,
    accountIds
  });
  await (0,api/* callApi */.p)('waitDataPreload');
  const {
    currentAccountId
  } = getGlobal();
  if (!currentAccountId) {
    return;
  }
  const newestActivityTimestamps = selectNewestActivityTimestamps(global, currentAccountId);
  void (0,api/* callApi */.p)('activateAccount', currentAccountId, newestActivityTimestamps);
});
addActionHandler('resetApiSettings', (global, actions, params) => {
  const isDefaultEnabled = !(params !== null && params !== void 0 && params.areAllDisabled);
  if (src_config/* IS_EXTENSION */.hL1) {
    actions.toggleTonMagic({
      isEnabled: false
    });
    actions.toggleTonProxy({
      isEnabled: false
    });
  }
  if (src_config/* IS_EXTENSION */.hL1 || windowEnvironment/* IS_ELECTRON */.cp) {
    actions.toggleDeeplinkHook({
      isEnabled: isDefaultEnabled
    });
  }
  actions.changeBaseCurrency({
    currency: src_config/* DEFAULT_PRICE_CURRENCY */.wOb
  });
});
// EXTERNAL MODULE: ./node_modules/@capacitor/core/dist/index.js
var dist = __webpack_require__(16546);
;// ./node_modules/@capgo/capacitor-native-biometric/dist/esm/definitions.js
var BiometryType;
(function (BiometryType) {
    // Android, iOS
    BiometryType[BiometryType["NONE"] = 0] = "NONE";
    // iOS
    BiometryType[BiometryType["TOUCH_ID"] = 1] = "TOUCH_ID";
    // iOS
    BiometryType[BiometryType["FACE_ID"] = 2] = "FACE_ID";
    // Android
    BiometryType[BiometryType["FINGERPRINT"] = 3] = "FINGERPRINT";
    // Android
    BiometryType[BiometryType["FACE_AUTHENTICATION"] = 4] = "FACE_AUTHENTICATION";
    // Android
    BiometryType[BiometryType["IRIS_AUTHENTICATION"] = 5] = "IRIS_AUTHENTICATION";
    // Android
    BiometryType[BiometryType["MULTIPLE"] = 6] = "MULTIPLE";
})(BiometryType || (BiometryType = {}));
/**
 * Keep this in sync with BiometricAuthError in README.md
 * Update whenever `convertToPluginErrorCode` functions are modified
 */
var BiometricAuthError;
(function (BiometricAuthError) {
    BiometricAuthError[BiometricAuthError["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
    BiometricAuthError[BiometricAuthError["BIOMETRICS_UNAVAILABLE"] = 1] = "BIOMETRICS_UNAVAILABLE";
    BiometricAuthError[BiometricAuthError["USER_LOCKOUT"] = 2] = "USER_LOCKOUT";
    BiometricAuthError[BiometricAuthError["BIOMETRICS_NOT_ENROLLED"] = 3] = "BIOMETRICS_NOT_ENROLLED";
    BiometricAuthError[BiometricAuthError["USER_TEMPORARY_LOCKOUT"] = 4] = "USER_TEMPORARY_LOCKOUT";
    BiometricAuthError[BiometricAuthError["AUTHENTICATION_FAILED"] = 10] = "AUTHENTICATION_FAILED";
    BiometricAuthError[BiometricAuthError["APP_CANCEL"] = 11] = "APP_CANCEL";
    BiometricAuthError[BiometricAuthError["INVALID_CONTEXT"] = 12] = "INVALID_CONTEXT";
    BiometricAuthError[BiometricAuthError["NOT_INTERACTIVE"] = 13] = "NOT_INTERACTIVE";
    BiometricAuthError[BiometricAuthError["PASSCODE_NOT_SET"] = 14] = "PASSCODE_NOT_SET";
    BiometricAuthError[BiometricAuthError["SYSTEM_CANCEL"] = 15] = "SYSTEM_CANCEL";
    BiometricAuthError[BiometricAuthError["USER_CANCEL"] = 16] = "USER_CANCEL";
    BiometricAuthError[BiometricAuthError["USER_FALLBACK"] = 17] = "USER_FALLBACK";
})(BiometricAuthError || (BiometricAuthError = {}));
//# sourceMappingURL=definitions.js.map
;// ./node_modules/@capgo/capacitor-native-biometric/dist/esm/index.js

const NativeBiometric = (0,dist/* registerPlugin */.F3)("NativeBiometric", {
    web: () => __webpack_require__.e(/* import() */ 542).then(__webpack_require__.bind(__webpack_require__, 35542)).then((m) => new m.NativeBiometricWeb()),
});


//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./src/api/types/index.ts
var types = __webpack_require__(23174);
// EXTERNAL MODULE: ./src/util/random.ts
var random = __webpack_require__(59121);
;// ./src/util/windowSize.ts







const WINDOW_RESIZE_THROTTLE_MS = src_config/* IS_TELEGRAM_APP */.tKX ? 25 : 250;
const WINDOW_ORIENTATION_CHANGE_THROTTLE_MS = windowEnvironment/* IS_IOS */.pz ? 350 : 250;
const SAFE_AREA_INITIALIZATION_DELAY = dateFormat/* SECOND */.Z2;
const SAFE_AREA_TOLERANCE_HEIGHT_PX = 40;
const initialHeight = window.innerHeight;
const virtualKeyboardOpenListeners = [];
let currentWindowSize = updateSizes();
window.addEventListener('orientationchange', (0,schedulers/* throttle */.nF)(() => {
  currentWindowSize = updateSizes();
}, WINDOW_ORIENTATION_CHANGE_THROTTLE_MS, false));
if (!windowEnvironment/* IS_IOS */.pz) {
  window.addEventListener('resize', (0,schedulers/* throttle */.nF)(() => {
    currentWindowSize = updateSizes();
  }, WINDOW_RESIZE_THROTTLE_MS, true));
}
if (src_config/* IS_CAPACITOR */.UMQ) {
  void __webpack_require__.e(/* import() */ 408).then(__webpack_require__.bind(__webpack_require__, 408)).then(_ref => {
    let {
      Keyboard
    } = _ref;
    void Keyboard.addListener('keyboardDidShow', async info => {
      await adjustBodyPaddingForKeyboard(info.keyboardHeight);
      for (const cb of virtualKeyboardOpenListeners) {
        (0,util_safeExec/* default */.A)(cb);
      }
    });
    void Keyboard.addListener('keyboardWillHide', () => {
      void adjustBodyPaddingForKeyboard(0);
    });
  });
}
if ('visualViewport' in window && (windowEnvironment/* IS_IOS */.pz || windowEnvironment/* IS_ANDROID */.Ni)) {
  window.visualViewport.addEventListener('resize', (0,schedulers/* throttle */.nF)(e => {
    const target = e.target;

    // In the TMA application on iOS, the VisualViewport behaves incorrectly,
    // not taking into account the height of the virtual keyboard.
    if (windowEnvironment/* IS_IOS */.pz && src_config/* IS_TELEGRAM_APP */.tKX) {
      const keyboardHeight = initialHeight - target.height;
      void adjustBodyPaddingForKeyboard(keyboardHeight > SAFE_AREA_TOLERANCE_HEIGHT_PX ? keyboardHeight : 0).finally(() => {
        (0,fasterdom/* requestMeasure */.YS)(() => {
          currentWindowSize = {
            ...getWindowSize(),
            height: target.height
          };
        });
      });
    } else {
      patchVh();
      currentWindowSize = {
        ...getWindowSize(),
        height: target.height
      };
    }
  }, WINDOW_RESIZE_THROTTLE_MS, true));
}
function updateSizes() {
  patchVh();
  patchSafeAreaProperty();
  return getWindowSize();
}
function getWindowSize() {
  return {
    width: window.innerWidth,
    height: window.innerHeight,
    screenHeight: window.screen.height,
    safeAreaTop: getSafeAreaTop(),
    safeAreaBottom: getSafeAreaBottom()
  };
}
/* harmony default export */ const windowSize = ({
  get: () => currentWindowSize,
  getIsKeyboardVisible: () => initialHeight > currentWindowSize.height
});

// Registers a callback that will be fired each time the virtual keyboard is opened and the <body> size is adjusted
function onVirtualKeyboardOpen(cb) {
  virtualKeyboardOpenListeners.push(cb);
}
function patchVh() {
  if (!(windowEnvironment/* IS_IOS */.pz || windowEnvironment/* IS_ANDROID */.Ni) || src_config/* IS_CAPACITOR */.UMQ || windowEnvironment/* IS_IOS */.pz && src_config/* IS_TELEGRAM_APP */.tKX) return;
  const height = windowEnvironment/* IS_IOS */.pz ? window.visualViewport.height + window.visualViewport.pageTop : window.innerHeight;
  (0,fasterdom/* requestMutation */.RK)(() => {
    const vh = height * 0.01;
    document.documentElement.style.setProperty('--vh', `${vh}px`);
  });
}
function adjustBodyPaddingForKeyboard(keyboardHeight) {
  return new Promise(resolve => {
    (0,fasterdom/* requestMutation */.RK)(() => {
      (0,animation/* applyStyles */.ZM)(document.body, {
        paddingBottom: keyboardHeight ? `${keyboardHeight}px` : ''
      });
      resolve();
    });
  });
}
function patchSafeAreaProperty() {
  toggleSafeAreaClasses();

  // WebKit has issues with this property on page load
  // https://bugs.webkit.org/show_bug.cgi?id=191872
  setTimeout(() => {
    toggleSafeAreaClasses();
    updateSafeAreaValues();
  }, SAFE_AREA_INITIALIZATION_DELAY);
}
function getSafeAreaTop() {
  const value = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-top-value'), 10);
  return Number.isNaN(value) ? 0 : value;
}
function getSafeAreaBottom() {
  const value = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--safe-area-bottom-value'), 10);
  return Number.isNaN(value) ? 0 : value;
}
function toggleSafeAreaClasses() {
  const {
    safeAreaTop,
    safeAreaBottom
  } = getWindowSize();
  const {
    documentElement
  } = document;
  (0,fasterdom/* requestMutation */.RK)(() => {
    documentElement.classList.toggle('with-safe-area-top', !Number.isNaN(safeAreaTop) && safeAreaTop > 0);
    documentElement.classList.toggle('with-safe-area-bottom', !Number.isNaN(safeAreaBottom) && safeAreaBottom > 0);
  });
}
function updateSafeAreaValues() {
  const {
    safeAreaTop,
    safeAreaBottom
  } = getWindowSize();
  currentWindowSize = {
    ...currentWindowSize,
    safeAreaTop,
    safeAreaBottom
  };
}
;// ./src/util/telegram/index.ts




let webApp;
let isBiometricInited = false;
let isNativeBiometricAuthSupported = false;
let isFaceIdAvailable = false;
let isTouchIdAvailable = false;
let disableSwipeRequests = 0;
function initTelegramApp() {
  var _window$Telegram;
  webApp = (_window$Telegram = window.Telegram) === null || _window$Telegram === void 0 ? void 0 : _window$Telegram.WebApp;
  if (!webApp) {
    (0,logs/* logDebugError */.SJ)('[telegram] Can\'t initialize Telegram Mini-App');
    return;
  }
  enableTelegramMiniAppSwipeToClose();
  webApp.lockOrientation();
  webApp.SecondaryButton.setParams({
    position: 'bottom'
  });
  webApp.BackButton.hide();
  webApp.SettingsButton.hide();
  webApp.expand();
  if ((0,windowEnvironment/* getIsMobileTelegramApp */.v3)()) {
    webApp.onEvent('safeAreaChanged', updateSafeAreaProperties);
    webApp.onEvent('contentSafeAreaChanged', updateSafeAreaProperties);
  }
  webApp.onEvent('viewportChanged', updateViewport);
  updateSafeAreaProperties();
  initTelegramAppBiometric();
  webApp.ready();
}
function initTelegramWithGlobal(global) {
  if (global.isFullscreen) {
    webApp.requestFullscreen();
  }
  webApp.onEvent('fullscreenChanged', updateFullscreenState);
  webApp.onEvent('fullscreenFailed', onFullscreenFailed);
}
function initTelegramAppBiometric() {
  var _webApp;
  const biometricManager = (_webApp = webApp) === null || _webApp === void 0 ? void 0 : _webApp.BiometricManager;
  if (!biometricManager || isBiometricInited) return;
  isBiometricInited = true;
  biometricManager.init(() => {
    const {
      isBiometricAvailable,
      biometricType,
      isAccessGranted,
      isAccessRequested
    } = biometricManager;
    isNativeBiometricAuthSupported = isBiometricAvailable && (isAccessGranted || !isAccessRequested);
    if (webApp.platform === 'ios') {
      isFaceIdAvailable = biometricType === 'face';
      isTouchIdAvailable = biometricType === 'finger';
    }
  });
}
function getIsTelegramBiometricAuthSupported() {
  return isNativeBiometricAuthSupported;
}
function getIsTelegramFaceIdAvailable() {
  return isFaceIdAvailable;
}
function getIsTelegramTouchIdAvailable() {
  return isTouchIdAvailable;
}
function getIsTelegramBiometricsRestricted() {
  var _webApp2;
  const biometricManager = (_webApp2 = webApp) === null || _webApp2 === void 0 ? void 0 : _webApp2.BiometricManager;
  if (!biometricManager) return undefined;
  const {
    isBiometricAvailable,
    isAccessGranted,
    isAccessRequested
  } = biometricManager;
  return isBiometricAvailable && isAccessRequested && !isAccessGranted;
}
function telegram_getTelegramApp() {
  return webApp;
}
function getTelegramAppAsync() {
  return new Promise(resolve => {
    window.addEventListener('DOMContentLoaded', () => {
      resolve(telegram_getTelegramApp());
    });
  });
}
function updateViewport(_ref) {
  let {
    isStateStable
  } = _ref;
  if (isStateStable) {
    updateSizes();
  }
}
function updateSafeAreaProperties() {
  const {
    top,
    left,
    right,
    bottom
  } = webApp.safeAreaInset;
  const {
    top: contentTop,
    left: contentLeft,
    right: contentRight,
    bottom: contentBottom
  } = webApp.contentSafeAreaInset;
  document.documentElement.style.setProperty('--safe-area-top', `${top + contentTop}px`);
  document.documentElement.style.setProperty('--safe-area-left', `${left + contentLeft}px`);
  document.documentElement.style.setProperty('--safe-area-right', `${right + contentRight}px`);
  document.documentElement.style.setProperty('--safe-area-bottom', `${bottom + contentBottom}px`);
}
function updateFullscreenState() {
  if (webApp.isFullscreen) {
    getActions().openFullscreen();
    disableTelegramMiniAppSwipeToClose();
  } else {
    getActions().closeFullscreen();
    enableTelegramMiniAppSwipeToClose();
  }
}
function onFullscreenFailed(params) {
  enableTelegramMiniAppSwipeToClose();
  // This error occurs when the user has requested fullscreen, but the application is already open fullscreen.
  // In this case, we just mark in the global that the application is running in fullscreen mode.
  if (params.error === 'ALREADY_FULLSCREEN') {
    getActions().openFullscreen();
    disableTelegramMiniAppSwipeToClose();
  }
}
function disableTelegramMiniAppSwipeToClose() {
  disableSwipeRequests += 1;
  if (disableSwipeRequests === 1) {
    var _webApp3;
    (_webApp3 = webApp) === null || _webApp3 === void 0 || _webApp3.disableVerticalSwipes();
  }
}
function enableTelegramMiniAppSwipeToClose() {
  disableSwipeRequests = Math.max(0, disableSwipeRequests - 1);
  if (disableSwipeRequests === 0) {
    var _webApp4;
    (_webApp4 = webApp) === null || _webApp4 === void 0 || _webApp4.enableVerticalSwipes();
  }
}
;// ./src/util/authApi/telegram.ts




function requestBiometricAccess(options) {
  return new Promise((resolve, reject) => {
    telegram_getTelegramApp().BiometricManager.requestAccess(options, accessGranted => {
      if (accessGranted) {
        resolve(accessGranted);
      } else {
        reject(new Error('Access denied'));
      }
    });
  });
}
async function setBiometricCredentials(password) {
  const biometricManager = telegram_getTelegramApp().BiometricManager;
  if (!biometricManager.isAccessGranted) {
    const isAccessGranted = await requestBiometricAccess({
      reason: src_config/* APP_NAME */.C39
    });
    if (!isAccessGranted) {
      throw new Error('Access to biometric data has not been granted');
    }
  }
  return new Promise((resolve, reject) => {
    biometricManager.updateBiometricToken(password, updated => {
      if (updated) {
        resolve(password);
      } else {
        reject(new Error('Failed to update or save the biometric token'));
      }
    });
  });
}
async function verifyIdentity() {
  const biometricManager = telegram_getTelegramApp().BiometricManager;
  if (!biometricManager.isAccessGranted) {
    const isAccessGranted = await requestBiometricAccess({
      reason: src_config/* APP_NAME */.C39
    });
    if (!isAccessGranted) {
      throw new Error('Biometric access was denied. Please grant access to proceed.');
    }
  }
  return new Promise((resolve, reject) => {
    biometricManager.authenticate({
      reason: ''
    },
    // @ts-ignore Wrong type signature https://github.com/twa-dev/types/pull/12
    (success, token) => {
      if (success) {
        resolve({
          success,
          token
        });
      } else {
        reject(new Error('Biometric authentication failed. Please try again.'));
      }
    });
  });
}
function signCustomData(initDataFields, payload, options) {
  const app = getTelegramApp();
  return new Promise((resolve, reject) => {
    app.invokeCustomMethod('prepareSignedPayload', {
      init_data: app.initData,
      init_data_sign_fields: initDataFields,
      payload,
      ...((options === null || options === void 0 ? void 0 : options.shouldSignHash) && {
        sign_sha256: true
      }),
      ...((options === null || options === void 0 ? void 0 : options.isPayloadBinary) && {
        is_payload_binary: true
      })
    }, (err, result) => {
      if (result) {
        resolve({
          result,
          resultUnsafe: parseResultUnsafe(result)
        });
      } else {
        reject(err || 'Unknown Error');
      }
    });
  });
}
function parseResultUnsafe(appData) {
  const resultUnsafe = window.Telegram.Utils.urlParseQueryString(appData);
  return mapValues(resultUnsafe, value => {
    if (value.startsWith('{') && value.endsWith('}') || value.startsWith('[') && value.endsWith(']')) {
      return safeExec(() => JSON.parse(value));
    }
    return value;
  });
}
;// ./src/util/authApi/webAuthn.ts
/* provided dependency */ var Buffer = __webpack_require__(48287)["Buffer"];



var PubkeyAlg = /*#__PURE__*/function (PubkeyAlg) {
  PubkeyAlg[PubkeyAlg["Ed25519"] = -8] = "Ed25519";
  PubkeyAlg[PubkeyAlg["ES256"] = -7] = "ES256";
  PubkeyAlg[PubkeyAlg["RS256"] = -257] = "RS256";
  return PubkeyAlg;
}(PubkeyAlg || {});
const CREDENTIAL_SIZE = 32;
const RP_NAME = src_config/* APP_NAME */.C39;
const USER_NAME = src_config/* APP_NAME */.C39;
const PAUSE = 300;
const CREDENTIAL_TIMEOUT = 120000;
async function createCredential() {
  const rpId = window.location.hostname;
  const userHandle = (0,random/* randomBytes */.po)(CREDENTIAL_SIZE);
  const credBlob = (0,random/* randomBytes */.po)(CREDENTIAL_SIZE);
  const options = {
    publicKey: {
      challenge: (0,random/* randomBytes */.po)(CREDENTIAL_SIZE),
      rp: {
        name: RP_NAME,
        id: rpId
      },
      user: {
        id: userHandle,
        name: USER_NAME,
        displayName: RP_NAME
      },
      pubKeyCredParams: [{
        type: 'public-key',
        alg: PubkeyAlg.ES256
      }, {
        type: 'public-key',
        alg: PubkeyAlg.RS256
      }, {
        type: 'public-key',
        alg: PubkeyAlg.Ed25519
      }],
      authenticatorSelection: {
        requireResidentKey: true,
        userVerification: 'preferred'
      },
      extensions: {
        credBlob,
        hmacCreateSecret: true
      },
      timeout: CREDENTIAL_TIMEOUT,
      excludeCredentials: []
    }
  };
  const credential = await navigator.credentials.create(options);
  if (!credential) {
    throw new Error('Missing credential');
  }
  const extensions = credential.getClientExtensionResults();
  const type = extensions.credBlob ? 'credBlob' : 'userHandle';
  return {
    type,
    password: {
      credBlob: Buffer.from(credBlob).toString('hex'),
      userHandle: Buffer.from(userHandle).toString('hex')
    },
    credential
  };
}
async function verify(_ref) {
  let {
    credential,
    password,
    type
  } = _ref;
  await (0,schedulers/* pause */.v7)(PAUSE);
  const transports = credential.response && credential.response.getTransports && credential.response.getTransports();
  const credentialId = Buffer.from(credential.rawId).toString('hex');
  const options = {
    publicKey: {
      challenge: (0,random/* randomBytes */.po)(CREDENTIAL_SIZE),
      allowCredentials: [{
        id: credential.rawId,
        type: 'public-key',
        transports
      }],
      userVerification: 'required',
      extensions: {
        getCredBlob: true
      }
    }
  };
  const assertion = await navigator.credentials.get(options);
  if (!assertion) {
    throw new Error('Missing authentication');
  }
  const response = assertion.response;
  let result;
  switch (type) {
    case 'userHandle':
      {
        if (!response.userHandle) {
          throw new Error('Missing stored userHandle');
        }
        if (!Buffer.from(password.userHandle, 'hex').equals(Buffer.from(response.userHandle))) {
          throw new Error('Stored blob not equals passed blob');
        }
        result = password.userHandle;
        break;
      }
  }
  if (!result) {
    throw new Error('Missing stored blob');
  }
  const config = {
    kind: 'webauthn',
    type,
    credentialId,
    transports
  };
  return {
    config,
    password: result
  };
}
async function getPassword(config) {
  if (config.kind !== 'webauthn') {
    throw new Error('Unexpected auth kind');
  }
  const {
    credentialId,
    transports,
    type
  } = config;
  const controller = new AbortController();
  const signal = controller.signal;
  const options = {
    publicKey: {
      challenge: (0,random/* randomBytes */.po)(CREDENTIAL_SIZE),
      allowCredentials: [{
        id: Buffer.from(credentialId, 'hex'),
        type: 'public-key',
        transports
      }],
      userVerification: 'required',
      extensions: {
        getCredBlob: true
      }
    },
    signal
  };
  const assertion = await navigator.credentials.get(options);
  if (signal.aborted) {
    throw new Error('Verification canceled');
  }
  const response = assertion.response;
  const extensions = assertion.getClientExtensionResults();
  if (type === 'userHandle') {
    if (!response.userHandle) {
      throw new Error('missing userHandle');
    }
    return Buffer.from(response.userHandle).toString('hex');
  } else {
    return Buffer.from(extensions.getCredBlob ?? '').toString('hex');
  }
}
/* harmony default export */ const webAuthn = ({
  createCredential,
  verify,
  getPassword
});
;// ./src/util/authApi/index.ts
/* provided dependency */ var authApi_Buffer = __webpack_require__(48287)["Buffer"];






const authApi_CREDENTIAL_SIZE = 32;
async function setupBiometrics(_ref) {
  let {
    credential
  } = _ref;
  let result;
  try {
    if (!credential) {
      var _window$electron;
      const password = authApi_Buffer.from((0,random/* randomBytes */.po)(authApi_CREDENTIAL_SIZE)).toString('hex');
      const encryptedPassword = await ((_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.encryptPassword(password));
      if (!encryptedPassword) {
        return result;
      }
      result = {
        password,
        config: {
          kind: 'electron-safe-storage',
          encryptedPassword
        }
      };
    } else {
      result = await webAuthn.verify(credential);
    }
  } catch (err) {
    (0,logs/* logDebugError */.SJ)('setupBiometrics', err);
  }
  return result;
}
async function setupNativeBiometrics(password) {
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    await setBiometricCredentials(password);
    return {
      password,
      config: {
        kind: 'native-biometrics'
      }
    };
  }
  await NativeBiometric.setCredentials({
    username: src_config/* NATIVE_BIOMETRICS_USERNAME */.hkI,
    password,
    server: src_config/* NATIVE_BIOMETRICS_SERVER */.aD4
  });
  return {
    password,
    config: {
      kind: 'native-biometrics'
    }
  };
}
function removeNativeBiometrics() {
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    return setBiometricCredentials('');
  }
  return NativeBiometric.deleteCredentials({
    server: src_config/* NATIVE_BIOMETRICS_SERVER */.aD4
  });
}
async function authApi_getPassword(config) {
  let password;
  try {
    if (config.kind === 'webauthn') {
      password = await webAuthn.getPassword(config);
    } else if (config.kind === 'electron-safe-storage') {
      var _window$electron2;
      password = await ((_window$electron2 = window.electron) === null || _window$electron2 === void 0 ? void 0 : _window$electron2.decryptPassword(config.encryptedPassword));
    } else if (src_config/* IS_TELEGRAM_APP */.tKX && config.kind === 'native-biometrics') {
      const {
        success: isVerified,
        token
      } = await verifyIdentity();
      if (!isVerified) return undefined;
      password = token;
    } else if (config.kind === 'native-biometrics') {
      const isVerified = await NativeBiometric.verifyIdentity({
        title: src_config/* APP_NAME */.C39,
        subtitle: '',
        isWeakAuthenticatorAllowed: true,
        maxAttempts: 1
      }).then(() => true).catch(() => false);
      if (!isVerified) return undefined;
      const credentials = await NativeBiometric.getCredentials({
        server: src_config/* NATIVE_BIOMETRICS_SERVER */.aD4
      });
      password = credentials.password;
    } else {
      throw new Error('Unexpected auth kind');
    }
  } catch (err) {
    (0,logs/* logDebugError */.SJ)('getPassword', err);
  }
  return password;
}
/* harmony default export */ const authApi = ({
  setupBiometrics,
  setupNativeBiometrics,
  removeNativeBiometrics,
  getPassword: authApi_getPassword,
  webAuthn: webAuthn
});
;// ./node_modules/@capacitor/app/dist/esm/index.js

const App = (0,dist/* registerPlugin */.F3)('App', {
    web: () => __webpack_require__.e(/* import() */ 168).then(__webpack_require__.bind(__webpack_require__, 41168)).then(m => new m.AppWeb()),
});


//# sourceMappingURL=index.js.map
;// ./node_modules/@capacitor/splash-screen/dist/esm/index.js

const SplashScreen = (0,dist/* registerPlugin */.F3)('SplashScreen', {
    web: () => __webpack_require__.e(/* import() */ 411).then(__webpack_require__.bind(__webpack_require__, 7411)).then(m => new m.SplashScreenWeb()),
});


//# sourceMappingURL=index.js.map
;// ./mobile/plugins/air-app-launcher/dist/esm/index.js

const AirAppLauncher = (0,dist/* registerPlugin */.F3)('AirAppLauncher');


;// ./node_modules/capacitor-plugin-safe-area/dist/esm/index.js

const SafeArea = (0,dist/* registerPlugin */.F3)('SafeArea', {
    web: () => __webpack_require__.e(/* import() */ 88).then(__webpack_require__.bind(__webpack_require__, 28088)).then(m => new m.SafeAreaWeb()),
});


//# sourceMappingURL=index.js.map
;// ./node_modules/@capacitor/app-launcher/dist/esm/index.js

const AppLauncher = (0,dist/* registerPlugin */.F3)('AppLauncher', {
    web: () => __webpack_require__.e(/* import() */ 895).then(__webpack_require__.bind(__webpack_require__, 73895)).then(m => new m.AppLauncherWeb()),
});


//# sourceMappingURL=index.js.map
;// ./mobile/plugins/native-bottom-sheet/dist/esm/index.js

const esm_BottomSheet = (0,dist/* registerPlugin */.F3)('BottomSheet');


;// ./src/util/domEvents.ts
const stopEvent = e => {
  e.stopPropagation();
  e.preventDefault();
};
function listenOnce(target, name, handler) {
  const handleEvent = event => {
    target.removeEventListener(name, handleEvent);
    handler(event);
  };
  target.addEventListener(name, handleEvent);
}
;// ./package.json
const package_namespaceObject = {"rE":"4.1.3"};
;// ./src/util/tonConnectEnvironment.ts




/*
 This function is called in TonConnect `connect` method (where we know the wallet version)
 and in JS Bridge (where no account is selected, so we show maximum number of messages).
*/
function tonConnectGetDeviceInfo(account) {
  const features = ['SendTransaction',
  // TODO DEPRECATED
  {
    name: 'SendTransaction',
    maxMessages: account ? getTonConnectMaxMessages(account) : constants/* W5_MAX_MESSAGES */.Bm
  }];
  if (!account || account.type !== 'ledger') {
    features.push({
      name: 'SignData',
      types: ['text', 'binary', 'cell']
    });
  }
  return {
    platform: getPlatform(),
    appName: src_config/* APP_NAME */.C39,
    appVersion: package_namespaceObject.rE,
    maxProtocolVersion: src_config/* TONCONNECT_PROTOCOL_VERSION */.gY_,
    features
  };
}

/** How many messages can be sent in a single TON Connect transaction sending */
function getTonConnectMaxMessages(account) {
  const {
    type
  } = account;
  if (type === 'ledger') {
    return constants/* DEFAULT_MAX_MESSAGES */.EV; // TODO Remove after DEXs support the 1 message limit
  } else {
    return getMaxMessagesInTransaction(account);
  }
}
function getPlatform() {
  var _navigator;
  const {
    userAgent
  } = navigator;
  const platform = navigator.platform || ((_navigator = navigator) === null || _navigator === void 0 || (_navigator = _navigator.userAgentData) === null || _navigator === void 0 ? void 0 : _navigator.platform) || '';
  const macosPlatforms = ['macOS', 'Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
  const windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
  const iphonePlatforms = ['iPhone'];
  const ipadPlatforms = ['iPad', 'iPod'];
  let devicePlatform;
  if (src_config/* IS_EXTENSION */.hL1 || src_config/* IS_TELEGRAM_APP */.tKX) {
    devicePlatform = 'browser';
  } else if (/Android/.test(userAgent)) {
    devicePlatform = 'android';
  } else if (iphonePlatforms.indexOf(platform) !== -1) {
    devicePlatform = 'iphone';
  } else if (ipadPlatforms.indexOf(platform) !== -1) {
    devicePlatform = 'ipad';
  } else if (macosPlatforms.indexOf(platform) !== -1) {
    devicePlatform = 'mac';
  } else if (windowsPlatforms.indexOf(platform) !== -1) {
    devicePlatform = 'windows';
  } else if (/Linux/.test(platform)) {
    devicePlatform = 'linux';
  } else {
    devicePlatform = 'browser';
  }
  return devicePlatform;
}
;// ./src/util/embeddedDappBridge/connector/connector.ts
/**
 * Allows calling functions, provided by another messenger (the parent window, or the Capacitor main view), in this messenger.
 * The other messenger must provide the functions using `createReverseIFrameInterface`.
 *
 * `PostMessageConnect` is not used here (as any other dependencies) because this needs to be easily stringified.
 */
function initConnector(bridgeKey, channel, target, tonConnectProperties) {
  if (window[bridgeKey]) return;
  const TON_CONNECT_BRIDGE_METHODS = ['connect', 'restoreConnection', 'disconnect', 'send'];
  const requestStates = new Map();
  const updateHandlers = new Set();
  setupPostMessageHandler();
  setupGlobalOverrides();
  initTonConnect();
  function setupPostMessageHandler() {
    window.addEventListener('message', _ref => {
      let {
        data
      } = _ref;
      const message = data;
      if (message.channel !== channel) {
        return;
      }
      if (message.type === 'methodResponse') {
        const requestState = requestStates.get(message.messageId);
        if (!requestState) return;
        requestStates.delete(message.messageId);
        if (message.error) {
          requestState.reject(message.error);
        } else {
          requestState.resolve(message.response);
        }
      } else if (message.type === 'update') {
        updateHandlers.forEach(handler => handler(message.update));
      }
    });
  }
  function setupGlobalOverrides() {
    window.open = url => {
      url = sanitizeUrl(url);
      if (url) {
        void callApi('window:open', {
          url
        });
      }

      // eslint-disable-next-line no-null/no-null
      return null;
    };
    window.close = () => {
      void callApi('window:close');
    };
    window.addEventListener('click', e => {
      if (!(e.target instanceof HTMLElement)) return;
      const {
        href,
        target
      } = e.target.closest('a') || {};
      if (href && (target === '_blank' || !href.startsWith('http'))) {
        e.preventDefault();
        const url = sanitizeUrl(href);
        if (url) {
          void callApi('window:open', {
            url
          });
        }
      }
    }, false);
  }
  function initTonConnect() {
    const methods = Object.fromEntries(TON_CONNECT_BRIDGE_METHODS.map(name => {
      return [name, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return callApi(`tonConnect:${name}`, ...args);
      }];
    }));
    function addUpdateHandler(cb) {
      updateHandlers.add(cb);
      return () => {
        updateHandlers.delete(cb);
      };
    }
    window[bridgeKey] = {
      tonconnect: {
        ...tonConnectProperties,
        ...methods,
        listen: addUpdateHandler
      }
    };
  }
  function callApi(name) {
    const messageId = generateUniqueId();
    const promise = new Promise((resolve, reject) => {
      requestStates.set(messageId, {
        resolve,
        reject
      });
    });
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    const messageData = {
      channel,
      messageId,
      type: 'callMethod',
      name,
      args
    };
    if ('parent' in target) {
      target.postMessage(messageData, '*');
    } else {
      target.postMessage(JSON.stringify(messageData));
    }
    return promise;
  }
  function generateUniqueId() {
    return Date.now().toString(36) + Math.random().toString(36).slice(2);
  }
  function sanitizeUrl(url) {
    if (!url) return undefined;

    // eslint-disable-next-line no-control-regex
    url = String(url).trim().replace(/[\x00-\x1F\x7F]/g, '');
    if (url.startsWith('//')) {
      return `https:${url}`;
    }
    const UNSAFE_PATTERNS = [/^\s*javascript\s*:/i, /^\s*data\s*:/i, /^\s*vbscript\s*:/i, /^\s*file\s*:/i, /^\s*about\s*:/i, /^\s*blob\s*:/i, /^\s*filesystem\s*:/i, /^\s*chrome(-extension)?\s*:/i, /^\s*moz-extension\s*:/i, /^\s*ms-browser-extension\s*:/i];
    if (UNSAFE_PATTERNS.some(p => p.test(url))) {
      return undefined;
    }
    if (!/^[a-z][a-z0-9+.-]*:/i.test(url)) {
      return undefined;
    }
    return url;
  }
}
const initConnectorString = initConnector.toString();
;// ./src/util/embeddedDappBridge/connector/inAppBrowserConnector.ts



function buildInAppBrowserBridgeConnectorCode() {
  return `
(${initConnectorString})(
  '${src_config/* TONCONNECT_WALLET_JSBRIDGE_KEY */.HOw}',
  '${src_config/* EMBEDDED_DAPP_BRIDGE_CHANNEL */.hUJ}',
  'cordova_iab' in window ? window.cordova_iab : window.webkit.messageHandlers.cordova_iab,
  {
    deviceInfo: ${JSON.stringify(tonConnectGetDeviceInfo())},
    protocolVersion: ${src_config/* TONCONNECT_PROTOCOL_VERSION */.gY_},
    isWalletBrowser: true,
  }
);
  `;
}
// EXTERNAL MODULE: ./src/util/createPostMessageInterface.ts
var createPostMessageInterface = __webpack_require__(54218);
;// ./src/api/tonConnect/types/index.ts
// This and the other enums can be imported from @tonconnect/protocol. We copy the enums instead of importing because
// importing that module increases the compiled code size significantly.

let CONNECT_EVENT_ERROR_CODES = /*#__PURE__*/function (CONNECT_EVENT_ERROR_CODES) {
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["MANIFEST_NOT_FOUND_ERROR"] = 2] = "MANIFEST_NOT_FOUND_ERROR";
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["MANIFEST_CONTENT_ERROR"] = 3] = "MANIFEST_CONTENT_ERROR";
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  CONNECT_EVENT_ERROR_CODES[CONNECT_EVENT_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
  return CONNECT_EVENT_ERROR_CODES;
}({});
let SEND_TRANSACTION_ERROR_CODES = /*#__PURE__*/function (SEND_TRANSACTION_ERROR_CODES) {
  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["UNKNOWN_ERROR"] = 0] = "UNKNOWN_ERROR";
  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["BAD_REQUEST_ERROR"] = 1] = "BAD_REQUEST_ERROR";
  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["UNKNOWN_APP_ERROR"] = 100] = "UNKNOWN_APP_ERROR";
  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["USER_REJECTS_ERROR"] = 300] = "USER_REJECTS_ERROR";
  SEND_TRANSACTION_ERROR_CODES[SEND_TRANSACTION_ERROR_CODES["METHOD_NOT_SUPPORTED"] = 400] = "METHOD_NOT_SUPPORTED";
  return SEND_TRANSACTION_ERROR_CODES;
}({});
let CHAIN = /*#__PURE__*/function (CHAIN) {
  CHAIN["MAINNET"] = "-239";
  CHAIN["TESTNET"] = "-3";
  return CHAIN;
}({});
;// ./src/util/embeddedDappBridge/provider/tonConnectBridgeApi.ts







let requestId = 0;
function buildTonConnectBridgeApi(pageUrl) {
  const {
    openLoadingOverlay,
    closeLoadingOverlay
  } = getActions();
  const url = new URL(pageUrl).origin.toLowerCase();
  return {
    connect: async (protocolVersion, request) => {
      try {
        if (protocolVersion > src_config/* TONCONNECT_PROTOCOL_VERSION */.gY_) {
          return buildConnectError(requestId, 'Unsupported protocol version', CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR);
        }
        verifyConnectRequest(request);
        openLoadingOverlay();
        const response = await (0,api/* callApi */.p)('tonConnect_connect', buildDappRequest(url), request, requestId);
        closeLoadingOverlay();
        requestId++;
        return response;
      } catch (err) {
        (0,logs/* logDebugError */.SJ)('useDAppBridge:connect', err);
        if ('event' in err && 'id' in err && 'payload' in err) {
          return err;
        }
        return buildConnectError(requestId, err === null || err === void 0 ? void 0 : err.message, CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR);
      }
    },
    restoreConnection: async () => {
      try {
        const response = await (0,api/* callApi */.p)('tonConnect_reconnect', buildDappRequest(url), requestId);
        requestId++;
        return response;
      } catch (err) {
        (0,logs/* logDebugError */.SJ)('useDAppBridge:reconnect', err);
        if ('event' in err && 'id' in err && 'payload' in err) {
          return err;
        }
        return buildConnectError(requestId, err === null || err === void 0 ? void 0 : err.message, CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR);
      }
    },
    disconnect: async () => {
      requestId = 0;
      await (0,api/* callApi */.p)('tonConnect_disconnect', buildDappRequest(url), {
        id: requestId.toString(),
        method: 'disconnect',
        params: []
      });
    },
    send: async request => {
      var _global$byAccountId$d;
      requestId++;
      const global = getGlobal();
      const isConnected = (_global$byAccountId$d = global.byAccountId[global.currentAccountId].dapps) === null || _global$byAccountId$d === void 0 ? void 0 : _global$byAccountId$d.some(dapp => dapp.url === url);
      if (!isConnected) {
        return {
          error: {
            code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR,
            message: 'Unknown app'
          },
          id: request.id.toString()
        };
      }
      const dappRequest = buildDappRequest(url);
      try {
        switch (request.method) {
          case 'disconnect':
            {
              return await (0,api/* callApi */.p)('tonConnect_disconnect', dappRequest, request);
            }
          case 'sendTransaction':
            {
              const result = await (0,api/* callApi */.p)('tonConnect_sendTransaction', dappRequest, request);
              if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
                void esm_BottomSheet.applyScrollPatch();
              }
              return result;
            }
          case 'signData':
            {
              return await (0,api/* callApi */.p)('tonConnect_signData', dappRequest, request);
            }
          default:
            {
              const anyRequest = request;
              return {
                id: String(anyRequest.id),
                error: {
                  code: SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR,
                  message: `Method "${anyRequest.method}" is not supported`
                }
              };
            }
        }
      } catch (err) {
        (0,logs/* logDebugError */.SJ)('useDAppBridge:send', err);
        return {
          id: String(request.id),
          error: {
            code: SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR,
            message: err === null || err === void 0 ? void 0 : err.message
          }
        };
      }
    }
  };
}
function buildConnectError(id) {
  let msg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Unknown error.';
  let code = arguments.length > 2 ? arguments[2] : undefined;
  return {
    event: 'connect_error',
    id,
    payload: {
      code: code || CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR,
      message: msg
    }
  };
}
function verifyConnectRequest(request) {
  var _request$items;
  if (!(request && request.manifestUrl && (_request$items = request.items) !== null && _request$items !== void 0 && _request$items.length)) {
    throw new Error('Wrong request data');
  }
}
function buildDappRequest(origin) {
  return {
    url: origin,
    isUrlEnsured: true,
    accountId: getGlobal().currentAccountId
  };
}
;// ./src/util/embeddedDappBridge/provider/bridgeApi.ts



function buildBridgeApi(pageUrl) {
  const {
    closeBrowser
  } = getActions();
  const tonConnectApi = buildTonConnectBridgeApi(pageUrl);
  const prefixedTonConnectApi = tonConnectApi ? prefixApi(tonConnectApi, 'tonConnect:') : undefined;
  return {
    'window:open'(_ref) {
      let {
        url
      } = _ref;
      void openDeeplinkOrUrl(url, {
        isExternal: true,
        isFromInAppBrowser: true
      });
    },
    'window:close'() {
      closeBrowser();
    },
    ...prefixedTonConnectApi
  };
}
function prefixApi(api, prefix) {
  const newEntries = Object.entries(api).map(_ref2 => {
    let [k, v] = _ref2;
    return [`${prefix}${k}`, v];
  });
  return Object.fromEntries(newEntries);
}
;// ./src/hooks/useStateRef.ts


// Allows to use state value as "silent" dependency in hooks (not causing updates).
// Also useful for state values that update frequently (such as controlled input value).
function useStateRef(value) {
  const ref = teact_useRef(value);
  ref.current = value;
  return ref;
}
;// ./src/hooks/useLastCallback.ts


function useLastCallback(callback) {
  const ref = useStateRef(callback);

  // No need for ref dependency
  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  return teact_useCallback(function () {
    var _ref$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.call(ref, ...args);
  }, []);
}
;// ./src/util/embeddedDappBridge/provider/InAppBrowserPostMessageAdapter.ts
class InAppBrowserPostMessageAdapter {
  constructor(inAppBrowser) {
    this.inAppBrowser = inAppBrowser;
  }
  addEventListener(eventName, handler) {
    void this.inAppBrowser.addEventListener(eventName, handler);
  }
  removeEventListener(eventName, handler) {
    void this.inAppBrowser.removeEventListener(eventName, handler);
  }
  postMessage(message) {
    void this.inAppBrowser.executeScript({
      code: `window.dispatchEvent(new MessageEvent('message', { data: ${JSON.stringify(message)} }));`
    });
  }
}
;// ./src/util/embeddedDappBridge/provider/useInAppBrowserBridgeProvider.ts






function useInAppBrowserBridgeProvider(pageUrl) {
  const cleanupRef = teact_useRef();
  const setupDappBridge = useLastCallback(inAppBrowser => {
    cleanupRef.current = (0,createPostMessageInterface/* createPostMessageInterface */.p)(buildBridgeApi(pageUrl), src_config/* EMBEDDED_DAPP_BRIDGE_CHANNEL */.hUJ, new InAppBrowserPostMessageAdapter(inAppBrowser));
  });
  teact_useEffect(() => {
    if (!pageUrl) return;
    return () => {
      var _cleanupRef$current;
      (_cleanupRef$current = cleanupRef.current) === null || _cleanupRef$current === void 0 || _cleanupRef$current.call(cleanupRef);
    };
  }, [pageUrl]);
  return {
    setupDappBridge,
    cleanupDappBridge: () => {
      var _cleanupRef$current2;
      return (_cleanupRef$current2 = cleanupRef.current) === null || _cleanupRef$current2 === void 0 ? void 0 : _cleanupRef$current2.call(cleanupRef);
    }
  };
}
;// ./src/util/base64toHex.ts
/* provided dependency */ var base64toHex_Buffer = __webpack_require__(48287)["Buffer"];
function base64ToHex(base64) {
  const buffer = base64toHex_Buffer.from(base64, 'base64');
  return buffer.toString('hex');
}
;// ./src/util/url.ts




// Regexp from https://stackoverflow.com/a/3809435
const URL_REGEX = /[-a-z0-9@:%._+~#=]{1,256}\.[a-z0-9()]{1,6}\b([-a-z0-9()@:%_+.~#?&/=]*)/gi;
const VALID_PROTOCOLS = new Set(['http:', 'https:']);

// The configuration does not contain data for NFT addresses, they must be configured separately
const EXPLORER_CONFIGURATIONS = {
  ton: {
    name: 'Tonscan',
    base: {
      mainnet: 'https://tonscan.org/',
      testnet: 'https://testnet.tonscan.org/'
    },
    address: '{base}address/{address}',
    explorer: '{base}jetton/{address}',
    transaction: '{base}tx/{hash}'
  },
  tron: {
    name: 'Tronscan',
    base: {
      mainnet: 'https://tronscan.org/#/',
      testnet: 'https://shasta.tronscan.org/#/'
    },
    address: '{base}address/{address}',
    explorer: '{base}token20/{address}',
    transaction: '{base}transaction/{hash}'
  }
};
function isValidUrl(url) {
  let validProtocols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : VALID_PROTOCOLS;
  try {
    const match = url.match(URL_REGEX);
    if (!match) return false;
    const urlObject = new URL(url);
    return validProtocols.has(urlObject.protocol);
  } catch (e) {
    (0,logs/* logDebugError */.SJ)('isValidUrl', e);
    return false;
  }
}
function getHostnameFromUrl(url) {
  try {
    const urlObject = new URL(url);
    return urlObject.hostname;
  } catch (e) {
    (0,logs/* logDebugError */.SJ)('getHostnameFromUrl', e);
    return url;
  }
}
function getExplorerName(chain) {
  return EXPLORER_CONFIGURATIONS[chain].name;
}
function getExplorerBaseUrl(chain) {
  let isTestnet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return EXPLORER_CONFIGURATIONS[chain].base[isTestnet ? 'testnet' : 'mainnet'];
}
function getTokenExplorerBaseUrl(chain) {
  let isTestnet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return EXPLORER_CONFIGURATIONS[chain].explorer.replace('{base}', getExplorerBaseUrl(chain, isTestnet));
}
function getExplorerTransactionUrl(chain, transactionHash, isTestnet) {
  if (!transactionHash || transactionHash === src_config/* EMPTY_HASH_VALUE */.n3s) return undefined;
  return EXPLORER_CONFIGURATIONS[chain].transaction.replace('{base}', getExplorerBaseUrl(chain, isTestnet)).replace('{hash}', chain === 'ton' ? base64ToHex(transactionHash) : transactionHash);
}
function getExplorerAddressUrl(chain, address, isTestnet) {
  if (!address) return undefined;
  return EXPLORER_CONFIGURATIONS[chain].address.replace('{base}', getExplorerBaseUrl(chain, isTestnet)).replace('{address}', address);
}
function getExplorerNftCollectionUrl(nftCollectionAddress, isTestnet) {
  if (!nftCollectionAddress) return undefined;
  return `${getExplorerBaseUrl('ton', isTestnet)}nft/${nftCollectionAddress}`;
}
function getExplorerNftUrl(nftAddress, isTestnet) {
  if (!nftAddress) return undefined;
  return `${getExplorerBaseUrl('ton', isTestnet)}nft/${nftAddress}`;
}
function getExplorerTokenUrl(chain, slug, address, isTestnet) {
  if (!slug && !address) return undefined;
  return address ? getTokenExplorerBaseUrl(chain, isTestnet).replace('{address}', address) : `https://coinmarketcap.com/currencies/${slug}/`;
}
function isTelegramUrl(url) {
  return url.startsWith('https://t.me/');
}
function getCardNftImageUrl(nft) {
  return `${src_config/* MTW_CARDS_BASE_URL */.dmC}${nft.metadata.mtwCardId}.webp`;
}
;// ./src/global/helpers/renderText.tsx


const SIMPLE_MARKDOWN_REGEX = /(\*\*|__).+?\1/g;
function renderText(part) {
  let filters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['simple_markdown', 'br'];
  if (typeof part !== 'string') {
    return [part];
  }
  return (0,iteratees/* compact */.oE)(filters.reduce((text, filter) => {
    switch (filter) {
      case 'simple_markdown':
        return replaceSimpleMarkdown(text);
      case 'br':
        return addLineBreaks(text);
    }
    return text;
  }, [part]));
}
function replaceSimpleMarkdown(textParts) {
  return textParts.reduce((result, part) => {
    if (typeof part !== 'string') {
      result.push(part);
      return result;
    }
    const parts = part.split(SIMPLE_MARKDOWN_REGEX);
    const entities = part.match(SIMPLE_MARKDOWN_REGEX) || [];
    result.push(parts[0]);
    return entities.reduce((entityResult, entity, i) => {
      entityResult.push(entity.startsWith('**') ? /*#__PURE__*/teact.createElement("b", null, entity.replace(/\*\*/g, '')) : /*#__PURE__*/teact.createElement("i", null, entity.replace(/__/g, '')));
      const index = i * 2 + 2;
      if (parts[index]) {
        entityResult.push(parts[index]);
      }
      return entityResult;
    }, result);
  }, []);
}
function addLineBreaks(textParts) {
  return textParts.reduce((result, part) => {
    if (typeof part !== 'string') {
      result.push(part);
      return result;
    }
    const splittenParts = part.split(/\r\n|\r|\n/g).reduce((parts, line, i, source) => {
      // This adds non-breaking space if line was indented with spaces, to preserve the indentation
      const trimmedLine = line.trimStart();
      const indentLength = line.length - trimmedLine.length;
      parts.push(String.fromCharCode(160).repeat(indentLength) + trimmedLine);
      if (i !== source.length - 1) {
        parts.push(/*#__PURE__*/teact.createElement("br", null));
      }
      return parts;
    }, []);
    return [...result, ...splittenParts];
  }, []);
}
;// ./src/i18n/en.json
const en_namespaceObject = /*#__PURE__*/JSON.parse('{"$auth_intro":"**Securely** store crypto\\nand make blockchain payments\\nat the **speed of light**.\\n","Create New Wallet":"Create New Wallet","Import From %1$d Secret Words":"Import From %1$d Secret Words","More about %app_name%":"More about %app_name%","Creating Wallet...":"Creating Wallet...","On the count of three...":"On the count of three...","$back_up_auth":"Back Up","$back_up_security":"Back Up","Passwords must be equal.":"Passwords must be equal.","To protect your wallet as much as possible, use a password with":"To protect your wallet as much as possible, use a password with","$auth_password_rule_8chars":"at least 8 characters","$auth_password_rule_one_small_char":"one small letter","$auth_password_rule_one_capital_char":"one capital letter","$auth_password_rule_one_digit":"one digit","$auth_password_rule_one_special_char":"and one special character","The wallet is imported":"The wallet is imported","The wallet is ready":"The wallet is ready","Create a password to protect it.":"Create a password to protect it.","Enter your password":"Enter your password","Enter your password...":"Enter your password...","...and repeat it":"...and repeat it","Cancel":"Cancel","Insecure Password":"Insecure Password","Your have entered an insecure password, which can be easily guessed by scammers.":"Your have entered an insecure password, which can be easily guessed by scammers.","Continue or change password to something more secure?":"Continue or change password to something more secure?","Change":"Change","%1$d Secret Words":"%1$d Secret Words","Secret Words":"Secret Words","$auth_import_mnemonic_description":"You can restore access to your wallet by entering the **12 or 24 secret words** that you wrote down when creating the wallet.\\n","Letâ€™s make sure your secrets words are recorded correctly.":"Letâ€™s make sure your secrets words are recorded correctly.","$mnemonic_check_words_list":"Please enter the words **%1$s** below.","$mnemonic_check_error":"The secret words you have entered do not match the ones in the list. Please try again.","$check_words_description":"Now letâ€™s check that you wrote\\nyour secret words correctly.\\n","$mnemonic_list_description":"Write down these words in the **correct order** and store them in a **secure place**.","$private_key_description":"Save this private key **correctly** and store it in a **secure place**.","$mnemonic_warning":"**Do not** send or show it to anyone,\\n**do not** enter it anywhere.\\n","View Secret Words":"View Secret Words","View TON Private Key":"View TON Private Key","Can be imported to non-multichain wallets for TON.":"Can be imported to non-multichain wallets for TON.","Can be imported to any multichain wallet supporting TON.":"Can be imported to any multichain wallet supporting TON.","Let\'s Check":"Let\'s Check","Let\'s Check!":"Let\'s Check!","Safety Rules":"Safety Rules","$safety_rules_private_key_one":"On the next screen you will see the **TON private key**. Save it correctly and **store in a secure place**.\\n","$safety_rules_private_key_two":"It allows to **open your wallet** if you lose your password or access to this device.","$safety_rules_private_key_three":"If anybody else sees this private key, your funds **may be stolen**. **Do not send or show it to anyone**, not even developers or technical support.","$safety_rules_one":"On the next screen you will see the **secret words**. Write them down in the correct order and **store in a secure place**.\\n","$safety_rules_two":"They allow to **open your wallet** if you lose your password or access to this device.","$safety_rules_three":"If anybody else sees these words your funds **may be stolen**. **Do not send it to anyone**, not even developers or technical support.","Understood":"Understood","Congratulations!":"Congratulations!","Continue":"Continue","Close":"Close","Back":"Back","Search...":"Search...","Main menu":"Main menu","TON Proxy":"TON Proxy","Toggle TON Proxy":"Toggle TON Proxy","TON Magic":"TON Magic","Toggle TON Magic":"Toggle TON Magic","Open Telegram Web":"Open Telegram Web","Back Up Secret Words":"Back Up Secret Words","Settings":"Settings","About %app_name%":"About %app_name%","Exit":"Exit","Remove Wallet":"Remove Wallet","Something went wrong.":"Something went wrong.","Something went wrong":"Something went wrong","Logo":"Logo","$about_description1":"Securely store crypto, explore decentralized apps, and make blockchain payments at the **speed of light**.","$about_description2":"The wallet is **non-custodial and safe**. The developers **do not** have access to your funds, browser history or any other information.","What is TON Proxy?":"What is TON Proxy?","$about_extension_description1":"TON Proxy opens a way to **decentralized internet** by allowing to anonymously access TON Sites.","More info and demo.":"More info and demo.","$about_extension_description2":"TON Magic provides native **Telegram integration** by patching the official Telegram Web app.","$about_extension_description3":"Turn it on to send and receive Toncoins from any Telegram user.","$about_proxy_magic_title":"What about %ninja% TON Proxy and %unicorn% TON Magic?","$about_proxy_magic_description":"To enjoy **decentralized internet**, access **TON Sites**, and leverage native **Telegram integration**, feel free to install the %extension_link%.","$about_extension_link_text":"**%app_name% extension**","Is it open source?":"Is it open source?","$about_wallet_github":"Yes, it is. Feel free to explore our %github_link%.","$about_github_link_text":"**GitHub repository**","Is there a community?":"Is there a community?","$about_wallet_community":"Sure, welcome to our %community_link%.","$about_community_link_text":"**Telegram channel**","Currency History":"Currency History","Enter Password":"Enter Password","Send":"Send","Add Wallet":"Add Wallet","Done":"Done","Delete":"Delete","Delete Saved Address":"Delete Saved Address","Are you sure you want to remove this address from your saved ones?":"Are you sure you want to remove this address from your saved ones?","You will be able to save it again via Transaction Info with this address.":"You will be able to save it again via Transaction Info with this address.","Address removed from saved":"Address removed from saved","Warning!":"Warning!","Log Out":"Log Out","$logout_without_backup_warning":"You have not backed up this wallet. If you remove it now, you will lose access to your tokens and NFTs.","$logout_accounts_without_backup_warning":"You have not backed up %links%. If you proceed, you will lose access to your tokens and NFTs.","$logout_warning":"This will remove the current wallet from the app. Make sure you have your **secret words** backed up.","Your address was copied!":"Your address was copied!","Create Deposit Link":"Create Deposit Link","$receive_invoice_description":"You can specify the amount and purpose of\\nthe payment to save the sender some time.\\n","Amount":"Amount","Comment":"Comment","Comment or Memo":"Comment or Memo","Share this URL to receive %token%":"Share this URL to receive %token%","Invoice link was copied!":"Invoice link was copied!","Theme":"Theme","Language":"Language","Enable Animations":"Enable Animations","Base Currency":"Base Currency","Investor View":"Investor View","Toggle Investor View":"Toggle Investor View","Hide Tiny Transfers":"Hide Tiny Transfers","Toggle Hide Tiny Transfers":"Toggle Hide Tiny Transfers","Network":"Network","Developer Options":"Developer Options","All Wallet Versions":"All Wallet Versions","Add TON-Only Wallet":"Add TON-Only Wallet","Confirmation":"Confirmation","Signing Data":"Signing Data","Contract Initialization Data":"Contract Initialization Data","$dont_have_required_token":"You donâ€™t have the required token to send, but it can be swapped.","$unknown_token_address":"Unknown token address.","$dont_have_required_nft":"You donâ€™t have the required NFT to send.","$state_init_invalid":"Invalid contract initialization data.","$signature_warning":"Signing custom data is very dangerous. Use it only if you trust the source of it.","Sign":"Sign","Done!":"Done!","Signing was confirmed!":"Signing was confirmed!","Transaction Info":"Transaction Info","Transaction in progress":"Transaction in progress","Comment was copied!":"Comment was copied!","Sender":"Sender","Recipient":"Recipient","Address was copied!":"Address was copied!","Repeat":"Repeat","Switch Account":"Switch Account","Copy wallet address":"Copy wallet address","View address on %ton_explorer_name%":"View address on %ton_explorer_name%","You have just created a new wallet":"You have just created a new wallet","You can now transfer your tokens from another wallet or exchange.":"You can now transfer your tokens from another wallet or exchange.","Assets":"Assets","Activity":"Activity","NFT":"NFT","No NFTs yet":"No NFTs yet","$nft_explore_offer":"Explore a marketplace to discover\\nexisting NFT collections.\\n","Received":"Received","Sent":"Sent","$transaction_from":"from %address%","$transaction_to":"to %address%","$transaction_on":"on %address%","Wallet is not backed up":"Wallet is not backed up","Testnet Version":"Testnet Version","Error reading clipboard":"Error reading clipboard","$fee_value":"Fee %fee%","$fee_value_with_colon":"Fee: %fee%","Pay fee with %stars_symbol%":"Pay fee with %stars_symbol%","Loading...":"Loading...","Recipient Address":"Recipient Address","Wallet address or domain":"Wallet address or domain","Incorrect address":"Incorrect address","Incorrect address.":"Incorrect address.","Paste":"Paste","Insufficient balance":"Insufficient balance","Insufficient Balance":"Insufficient Balance","$seed_phrase_scam_warning":"This wallet does not have enough funds to cover the fees for token withdrawal.\\n\\nThis seems to be a common **SCAM** where you\'re encouraged to deposit your own funds to cover fees.\\n\\n**Do not deposit** your own funds, as you may lose them!Â Learn more about this and other scams in our %help_center_link%.\\n","$help_center_prepositional":"Help Center","Optional":"Optional","$send_token_symbol":"Send %1$s","Is it all ok?":"Is it all ok?","Receiving Address":"Receiving Address","Fee":"Fee","Edit":"Edit","Confirm":"Confirm","Coins have been sent!":"Coins have been sent!","Transaction Sent!":"Transaction Sent!","Data Signed!":"Data Signed!","Details":"Details","Change password visibility":"Change password visibility","Amount value":"Amount value","Save Address":"Save Address","Name":"Name","Save":"Save","Copy":"Copy","Remove From Saved":"Remove From Saved","View on Explorer":"View on Explorer","No suggestions, you\'re on your own!":"No suggestions, you\'re on your own!","Play Sounds":"Play Sounds","Focus on asset value rather than current balance":"Focus on asset value rather than current balance","$logout_confirm":"Remove **all** wallets","$logout_warning2":"Wallets are located in the decentralized TON Blockchain. If you want the wallet to be deleted simply transfer all the TON from it and leave it empty.","$tiny_transfers_help":"Hide transfers worth less than $%value%. Keep in mind: small amounts are often sent by spammers and scammers.","Today":"Today","Yesterday":"Yesterday","Now":"Now","$receive_ton_description":"Scan this QR or share your address to top up your wallet balance.","Wrong password, please try again.":"Wrong password, please try again.","Appearance":"Appearance","Light":"Light","Dark":"Dark","System":"System","$stake_asset":"Stake %symbol%","Earn from your tokens while holding them":"Earn from your tokens while holding them","Why this is safe":"Why this is safe","Why is staking safe?":"Why is staking safe?","$safe_staking_description1":"Staking is **fully decentralized** and operated by the **official TON Liquid Staking** smart contracts.","$safe_staking_description2":"The deposited stake will be used for the TON network validation as part of its **proof-of-stake** essence.","$safe_staking_description3":"You can withdraw your stake at **any time** and it will be deposited back to your account within **two days**.","$safe_staking_description_jetton1":"Token staking is **fully decentralized** and operated by the **open-source** smart contracts developed by %jvault_link% and passed **security audits**.","$safe_staking_description_jetton2":"You can withdraw your stake at **any time** and it will be deposited back to your account **instantly**.","$min_value":"Min %value%","Est. balance in a year":"Est. balance in a year","Confirm Staking":"Confirm Staking","Confirm operation with your password":"Confirm operation with your password","Coins have been staked!":"Coins have been staked!","View":"View","Stake More":"Stake More","Staking":"Staking","Currently Staked":"Currently Staked","Unstake":"Unstake","Earning History":"Earning History","$total":"Total: %value%","$unstake_asset":"Unstake %symbol%","Amount to unstake":"Amount to unstake","Confirm Unstaking":"Confirm Unstaking","Request for unstaking is sent!":"Request for unstaking is sent!","$unstaking_when_receive":"You will receive your unstaked deposit in %time%.","$unstaking_when_receive_with_amount":"You will receive your unstaked %amount% in %time%.","$unstaking_when_receive_with_amount_ethena":"You will be able to receive your unstaked %amount% in %time%.","$unstake_insufficient_balance":"You need to have %balance% on your main balance to proceed with unstaking.","at %annual_yield%":"at %annual_yield%","Est. %annual_yield%":"Est. %annual_yield%","Staked":"Staked","$stake_action":"Stake","Unstaked":"Unstaked","Unstaking":"Unstaking","$unstake_action":"Unstake","The network fee has slightly changed, try sending again.":"The network fee has slightly changed, try sending again.","Transfer was unsuccessful. Try again later.":"Transfer was unsuccessful. Try again later.","Invalid amount":"Invalid amount","Invalid address":"Invalid address","Domain is not connected to a wallet":"Domain is not connected to a wallet","Unexpected error":"Unexpected error","Unexpected Error":"Unexpected Error","Earn":"Earn","Earning":"Earning","Unexpected":"Unexpected error","You can save this address for quick access while sending.":"You can save this address for quick access while sending.","Stake Again":"Stake Again","Earned":"Earned","Connect Dapp":"Connect Dapp","Select wallet to use on this dapp":"Select wallet to use on this dapp","Connect":"Connect","Dapp Permissions":"Dapp Permissions","$dapp_can_view_balance":"%dappname% will be able to view wallet address and balance.","Send Transaction":"Send Transaction","Payload":"Payload","$many_transactions":{"zeroValue":"No Transactions","oneValue":"%1$d Transaction","otherValue":"%1$d Transactions"},"Total Amount":"Total Amount","$unstaking_short":"Unstaking","Handle ton:// links":"Handle ton:// links","Back up wallet to have full access to it":"Back up wallet to have full access to it","Consider More Secure Version":"Consider More Secure Version","Install our native app or browser extension.":"Install our native app or browser extension.","Scam":"Scam","Scam comment is hidden.":"Scam comment is hidden.","Display":"Display","Connected Dapps":"Connected Dapps","Disconnect All Dapps":"Disconnect All Dapps","Disconnect":"Disconnect","Disconnect Dapp":"Disconnect Dapp","Disconnect Dapps":"Disconnect Dapps","Are you sure you want to disconnect?":"Are you sure you want to disconnect %dappname%?","Are you sure you want to disconnect all websites?":"Are you sure you want to disconnect all websites?","$dapps-description":"You can log in on dapps that support %app_name%. They can view wallet address, balance, and request operations.","Logged in with %app_name%":"Logged in with %app_name%","No active connections":"No active connections","Other":"Other","Assets & Activity":"Assets & Activity","Token Settings":"Token Settings","My Tokens":"My Tokens","Add Token":"Add Token","Delete Token":"Delete Token","Are you sure you want to delete?":"Are you sure you want to delete %token%?","Hide Tokens With No Cost":"Hide Tokens With No Cost","Sort By Cost":"Sort By Cost","Update %app_name%":"Update %app_name%","Connect Ledger":"Connect Ledger","Connecting to your Ledger...":"Connecting to your Ledger...","Failed to connect":"Failed to connect","Ledger Connected!":"Ledger Connected!","Select Ledger Wallets":"Select Ledger Wallets","%1$d Selected":"%1$d Selected","Add":"Add","Try Again":"Try Again","Driver":"Driver","Unlock it and open the TON App":"Unlock it and open the TON App","Maybe you need to check the password or change the driver.":"Maybe you need to check the password or change the driver.","Confirm via Ledger":"Confirm via Ledger","Please confirm transaction on your Ledger":"Please confirm transaction on your Ledger","Declined":"Declined","Create Wallet":"Create Wallet","Switch to the newly opened tab to connect Ledger.":"Switch to the newly opened tab to connect Ledger.","Once connected, switch back to this window to proceed.":"Once connected, switch back to this window to proceed.","Not all transactions were sent successfully":"Not all transactions were sent successfully","The time on your device is incorrect, sync it and try again":"The time on your device is incorrect, sync it and try again","Name or Address...":"Name or Address...","Such error, many tabs":"Such error, many tabs","$many_tabs_error_description":"%app_name% supports only one active tab with the app.\\nPlease reload this page to continue using this tab or close it.\\n","Reload App":"Reload App","Please confirm operation on your Ledger":"Please confirm operation on your Ledger","Token Not Found":"Token Not Found","Try another keyword or address.":"Try another keyword or address.","Decrypt":"Decrypt","Encrypted Message":"Encrypted Message","Message is encrypted.":"Message is encrypted.","$dapp_ledger_warning1":"You are about to send a multi-way transaction using your **Ledger** wallet. You will need to sign each underlying transaction **one by one manually**.","$dapp_ledger_warning2":"Please take your time and do not interrupt the process.","Agree":"Agree","$swap_action":"Swap","Swap":"Swap","You sell":"You sell","You buy":"You buy","Swap Details":"Swap Details","Blockchain Fee":"Blockchain Fee","Aggregator Fee":"Aggregator Fee","Included":"Included","Price Impact":"Price Impact","Minimum Received":"Minimum Received","Slippage":"Slippage","$swap_from_to":"Swap %from% %icon% %to%","The exchange rate is below market value!":"The exchange rate is %value% below market value!","Invalid Pair":"Invalid Pair","We do not recommend to perform an exchange, try to specify a lower amount.":"We do not recommend to perform an exchange, try to specify a lower amount.","$swap_minimum_received_tooltip1":"This is the least amount of new tokens you\'ll get from this swap, considering current market conditions, slippage tolerance, and potential price impact.","$swap_minimum_received_tooltip2":"It\'s an expected minimum, but if the conditions change a lot while your swap is being processed, the final amount could be less.","$swap_price_impact_tooltip1":"This shows how much your trade might change the token\'s price.","$swap_price_impact_tooltip2":"Big trades can make the price go up or down more. Lower is usually better.","$swap_slippage_tooltip1":"This sets how much the price is allowed to change before your swap is processed.","$swap_slippage_tooltip2":"If during the processing of your swap, the price changes more than this value, your order will be canceled.","Coins have been swapped!":"Coins have been swapped!","Slippage not specified":"Slippage not specified","Slippage too high":"Slippage too high","Not Enough %symbol%":"Not Enough %symbol%","Use Responsibly":"Use Responsibly","$auth_responsibly_description1":"%app_name% is a **self-custodial** wallet, which means that **only you** have full control and, most importantly, **full responsibility** for your funds.\\n","$auth_responsibly_description2":"Your private keys are stored on your device and are subject to **hacker attacks**. If your computer is infected with **malware**, your funds are likely to be stolen.\\n","$auth_responsibly_description3":"The %app_name% team is **not responsible** for the safety of your funds, just as your computer manufacturer or internet provider is not responsible.\\n","$auth_responsibly_description4":"**Never** store all your funds in one place. **Diversify** and use various software and hardware. Always **do your own research** and learn more about crypto security.\\n","Start Wallet":"Start Wallet","$auth_backup_warning_notice":"Now you need to manually **back up secret keys** in case you forget your password or lose access to this device.\\n","Later":"Later","Back Up Now":"Back Up Now","I have read and accept this information":"I have read and accept this information.","$ledger_verify_address":"Always verify pasted address using your Ledger device.","$ledger_not_ready":"Ledger is not connected or TON app is not open.","Verify now":"Verify now","Invalid address format. Only URL Safe Base64 format is allowed.":"Invalid address format. Only URL Safe Base64 format is allowed.","$auth_backup_description1":"This is a **secure wallet**\\nand is only **controlled by you**.\\n","$auth_backup_description2":"And with great power comes **great responsibility**.","$auth_backup_description3":"You need to manually **back up secret keys** in case you forget your password or lose access to this device.\\n","Swap Placed":"Swap Placed","Swapping":"Swapping","Swapped":"Swapped","Swap Again":"Swap Again","Terms of Use":"Terms of Use","Privacy Policy":"Privacy Policy","Insufficient liquidity":"Insufficient liquidity","This address is new and never received transfers before.":"This address is new and never received transfers before.","Create Backup":"Create Backup","Sending":"Sending","$send_action":"Send","Failed":"Failed","Refunded":"Refunded","On Hold":"On Hold","Expired":"Expired","In Progress":"In Progress","Waiting for Payment":"Waiting for Payment","Blockchain":"Blockchain","Your address on another blockchain":"Your address on another blockchain","Please provide an address of your wallet in %blockchain% blockchain to receive bought tokens.":"Please provide an address of your wallet in %blockchain% blockchain to receive bought tokens.","The time for sending coins is over.":"The time for sending coins is over.","You have not sent the coins to the specified address.":"You have not sent the coins to the specified address.","$swap_changelly_to_ton_description1":"Send %value% to this address in %blockchain% blockchain within %time%","Exchange failed and coins were refunded to your wallet.":"Exchange failed and coins were refunded to your wallet.","$swap_changelly_kyc_security":"Please contact **%email%** and provide **Transaction ID** to pass the KYC procedure:","Swap Expired":"Swap Expired","Address for %blockchain% transfer":"Address for %blockchain% transfer","Cross-chain exchange provided by Changelly":"Cross-chain exchange provided by Changelly","$swap_changelly_agreement_message":"By continuing, you agree to the %terms% and %policy% and understand that the transaction may trigger verification according to %kyc%.","$swap_changelly_terms_of_use":"terms of use","$swap_changelly_privacy_policy":"privacy policy","Password must contain %length% digits.":"Password must contain %length% digits.","Deposit Link":"Deposit Link","$swap_changelly_from_ton_description":"Tokens will be sent to your address in %blockchain% blockchain soon:","Please note that it may take up to a few hours for tokens to appear in your wallet.":"Please note that it may take up to a few hours for tokens to appear in your wallet.","Minimum amount":"Minimum %value%","Maximum amount":"Maximum %value%","Display Tray Icon":"Display Tray Icon","Auto-Updates":"Auto-Updates","Biometric Authentication":"Biometric Authentication","If you turn off biometric protection, you will need to create a password.":"If you turn off biometric protection, you will need to create a password.","Enter your current password":"Enter your current password","Turn On Biometrics":"Turn On Biometrics","Please confirm transaction using biometrics":"Please confirm transaction using biometrics","Enabling biometric confirmation will reset the password.":"Enabling biometric confirmation will reset the password.","Biometric Registration":"Biometric Registration","Step 1 of 2. Registration":"Step 1 of 2. Registration","Step 2 of 2. Verification":"Step 2 of 2. Verification","Download Logs":"Download Logs","Copy Logs":"Copy Logs","Logs were copied!":"Logs were copied!","Biometric setup failed.":"Biometric setup failed.","Biometric confirmation failed.":"Biometric confirmation failed.","Failed to disable biometrics.":"Failed to disable biometrics.","Biometric Confirmation":"Biometric Confirmation","Please verify the operation.":"Please verify the operation.","Create Password":"Create Password","Complete":"Complete","Verification":"Verification","Create a password or use biometric authentication to protect it.":"Create a password or use biometric authentication to protect it.","Connect Biometrics":"Connect Biometrics","Use Password":"Use Password","Biometrics Disabled":"Biometrics Disabled","Biometrics Enabled":"Biometrics Enabled","A request is already pending":"A request is already pending","Please confirm operation using biometrics":"Please confirm operation using biometrics","Scan QR Code":"Scan QR Code","Permission denied. Please grant camera permission to use the QR code scanner.":"Permission denied. Please grant camera permission to use the QR code scanner.","This QR Code is not supported":"This QR Code is not supported","An error on the server side. Please try again.":"An error on the server side. Please try again.","Address was saved!":"Address was saved!","US Dollar":"US Dollar","Euro":"Euro","Ruble":"Ruble","Yuan":"Yuan","Bitcoin":"Bitcoin","Toncoin":"Toncoin","$max_balance":"Max: %balance%","$unstake_information_instantly":"You will get your deposit instantly","Select Token":"Select Token","MY":"MY","POPULAR":"POPULAR","Not Found":"Not Found","Wallet is ready!":"Wallet is ready!","Wallet is imported!":"Wallet is imported!","Create a code to protect it":"Create a code to protect it","Enter your code again":"Enter your code again","Codes don\'t match":"Codes donâ€™t match","Code set successfully":"Code set successfully","Use Biometrics":"Use Biometrics","Use Touch ID":"Use Touch ID","Use Face ID":"Use Face ID","You can connect your biometric data for more convenience":"You can connect your biometric data for more convenience","Connect Touch ID":"Connect Touch ID","Connect Face ID":"Connect Face ID","Not Now":"Not Now","Touch ID":"Touch ID","Face ID":"Face ID","Turn Off Touch ID":"Turn Off Touch ID","Turn Off Face ID":"Turn Off Face ID","Turn Off Biometrics":"Turn Off Biometrics","Enter code":"Enter code","Enter code or use Face ID":"Enter code or use Face ID","Enter code or use Touch ID":"Enter code or use Touch ID","Enter code or use biometrics":"Enter code or use biometrics","Wrong code, please try again":"Wrong code, please try again","Scan your fingerprint":"Scan your fingerprint","Incorrect code, please try again.":"Incorrect code, please try again.","Correct":"Correct","Confirm Action":"Confirm Action","Confirm Swap":"Confirm Swap","Confirm Rewards Claim":"Confirm Rewards Claim","%amount% to %address%":"%amount% to %address%","%amount_from% to %amount_to%":"%amount_from% to %amount_to%","Failed to enable biometrics.":"Failed to enable biometrics.","Please try to confirm your biometrics again":"Please try to confirm your biometrics again","Unknown error":"Unknown error","Are you sure you want to disable Face ID?":"Are you sure you want to disable Face ID?","Are you sure you want to disable Touch ID?":"Are you sure you want to disable Touch ID?","Are you sure you want to disable biometrics?":"Are you sure you want to disable biometrics?","Yes":"Yes","Biometric confirmation failed":"Biometric confirmation failed","No Activity":"No Activity","Add / Buy":"Add / Buy","Buy with Card":"Buy with Card","Buy with Crypto":"Buy with Crypto","Cannot load widget":"Cannot load widget","Explore":"Explore","No partners yet":"No partners yet","Clear":"Clear","Get TON":"Get TON","$unstake_up_to_information":"Instantly â€“ up to %value%","$all_balance":"All: %balance%","$unstaking_not_enough_balance":"You need to have %value% on your main balance to proceed with unstaking.","$ledger_verify_address_on_device":"Please, verify the address on your Ledger.","Wallet Versions":"Wallet Versions","$read_more_about_wallet_version":"Read more about types of wallet contracts on %ton_link%.","$current_wallet_version":"Your current wallet version is %version%.","You have tokens on other versions of your wallet. You can import them from here.":"You have tokens on other versions of your wallet. You can import them from here.","$wallet_switch_version_1":"You can also %action%.","$wallet_switch_version_2":"switch to another wallet version","or import from":"or import from","Insufficient fee":"Insufficient fee","$insufficient_fee":"Insufficient fee: %fee%","Required":"Required","Comment is too long.":"Comment is too long.","Memo":"Memo","Memo was copied!":"Memo was copied!","$hide_tokens_no_cost_help":"Hide tokens worth less than $%value%. Keep in mind: worthless tokens are often sent by spammers and scammers. On the same screen below, you can hide individual tokens.","No internet connection. Please check your connection and try again.":"No internet connection. Please check your connection and try again.","To use this feature, first enable Face ID in your phone settings.":"To use this feature, first enable Face ID in your phone settings.","To use this feature, first enable biometrics in your phone settings.":"To use this feature, first enable biometrics in your phone settings.","Open Settings":"Open Settings","$service_token_transfer_warning":"You are about to transfer an important service token required to withdraw your deposit or complete service operations. Please ensure this is the action you intend to take.","No Price":"No Price","$ledger_outdated":"This operation is not supported by your version of the Ledger TON App. Please update it using Ledger Live.","$ledger_unsupported_ton_connect":"TonConnect is not supported by version of your Ledger TON App. Please update it using Ledger Live.","$dapp_transfer_tokens_burn":"Burning %amount%","$dapp_dns_set_wallet_payload":"Changing linked wallet of domain %domain% to %address%","$dapp_dns_delete_wallet_payload":"Deleting linked wallet of domain %domain%","$dapp_dns_change_record_payload":"Changing \\"%category%\\" record of domain %domain% to %value%","$dapp_dns_delete_record_payload":"Deleting \\"%category%\\" record of domain %domain%","$dapp_token_bridge_pay_swap_payload":"Confirmation of exchange via cross-chain bridge","$dapp_liquid_staking_deposit_payload":"Deposit to liquid staking","$dapp_liquid_staking_vote_payload":"Voting \\"%vote%\\" for proposal %votingAddress%","$dapp_single_nominator_change_validator_payload":"Changing address of SingleNominator staking contract validator to %address%","$dapp_single_nominator_withdraw_payload":"Withdrawal of %amount% TON from SingleNominator staking contract","$dapp_vesting_add_whitelist_payload":"Adding %address% to vesting wallet whitelist","Search or enter address":"Search or enter address","Connecting dapps is not yet supported by Ledger.":"Connecting dapps is not yet supported by Ledger.","Time synchronization issue. Please ensure your device\'s time settings are correct.":"Time synchronization issue. Please ensure your device\'s time settings are correct.","Data was copied!":"Data was copied!","Open NFT Collection":"Open NFT Collection","Previous":"Previous","Next":"Next","Insufficient TON for fee.":"Insufficient TON for fee.","Send NFT":"Send NFT","NFT has been sent!":"NFT has been sent!","Cannot be sent":"Cannot be sent","NFT is for sale":"NFT is for sale","More actions":"More actions","Open on %ton_explorer_name%":"Open on %ton_explorer_name%","Swap is not supported in Testnet.":"Swap is not supported in Testnet.","Swap is not yet supported by Ledger.":"Swap is not yet supported by Ledger.","Buying with card is not supported in Testnet.":"Buying with card is not supported in Testnet.","Staking is not supported in Testnet.":"Staking is not supported in Testnet.","Get Support":"Get Support","$transfer_inactive_contract_error":"You entered an address in the \\"EQ...\\" format, but the address is not active, so the transaction will not be completed.\\nIf you definitely want to send to this address, then enter the address in the \\"UQ...\\" format.\\n","$transfer_link_expired":"Transfer link has expired","$transfer_text_and_bin_exclusive":"Cannot use both text and bin parameters together","$unsupported_deeplink_parameter":"This deeplink contains unsupported parameters","Successfully":"Successfully","Unstake More":"Unstake More","WrongAddress":"The dapp requested a transaction from another wallet.","Are you sure you want to burn this NFT? It will be lost forever.":"Are you sure you want to burn this NFT?\\nIt will be lost forever.\\n","$multi_burn_nft_warning":"You are going to burn %amount% NFTs.","$multi_send_nft_warning":"The process may take ~%duration% minute(s). Please do not close the app and do not switch accounts until it is finished.","Burn NFT":"Burn NFT","Burn":"Burn","Private Key":"Private Key","%amount% NFTs":"%amount% NFTs","1 NFT":"1 NFT","1 NFT Selected":"1 NFT Selected","%amount% NFTs Selected":"%amount% NFTs Selected","For sale. Cannot be sent and burned":"For sale. Cannot be sent and burned","Select":"Select","Send All":"Send All","Burn All":"Burn All","Select All":"Select All","Collection":"Collection","Transaction ID was copied!":"Transaction ID was copied!","$swap_changelly_support":"If there are any problems, please contact %livechat% or %email% and provide **Transaction ID**:","Changelly Live Chat":"Changelly Live Chat","Your %blockchain% Address":"Your %blockchain% Address","Vesting":"Vesting","Vesting Balance":"Vesting Balance","Ready to Unfreeze":"Ready to Unfreeze","You will receive your unfrozen coins in a few minutes.":"You will receive your unfrozen coins in a few minutes.","Vesting Schedule":"Vesting Schedule","Loyal User Airdrop":"Loyal User Airdrop","Unfrozen":"Unfrozen","Missed":"Missed","Frozen":"Frozen","until %date%":"until %date%","Until %date%":"Until %date%","%volume% in %amount% parts":"%volume% in %amount% parts","Unfreeze":"Unfreeze","Claim":"Claim","Confirm Unfreezing":"Confirm Unfreezing","Insufficient Balance for Fee":"Insufficient Balance for Fee","$fee_value_bold":"**Fee:** %fee%","%app_name% Features":"%app_name% Features","Security":"Security","To avoid entering the passcode every time, you can use biometrics.":"To avoid entering the passcode every time, you can use biometrics.","Change Passcode":"Change Passcode","Change Password":"Change Password","Confirm Password":"Confirm Password","The passcode will be changed for all your wallets.":"The passcode will be changed for all your wallets.","Password Changed!":"Password Changed!","Passcode Changed!":"Passcode Changed!","New code set successfully":"New code set successfully","Codes donâ€™t match":"Codes donâ€™t match","Enter your new code":"Enter your new code","Re-enter your new code":"Re-enter your new code","Install on Desktop":"Install on Desktop","Install on Mobile":"Install on Mobile","Install App":"Install App","WrongNetwork":"The dapp requested a transaction from another network.","Hide":"Hide","Hidden NFTs":"Hidden NFTs","Hidden By Me":"Hidden By Me","Probably Scam":"Probably Scam","$settings_nft_probably_scam_description":"These NFTs were automatically disabled by Anti-Scam Protection. You can return the necessary ones to Home if you think they were included in this list by mistake.","Unhide":"Unhide","Hide All":"Hide All","Hide NFT":"Hide NFT","Reload Page":"Reload Page","Open in Safari":"Open in Safari","Open in Browser":"Open in browser","CopyURL":"Copy URL","Share":"Share","Unhide NFT":"Unhide NFT","$unhide_nft_warning":"Are you sure you want to unhide %name%? This NFT looks suspicious and may not match its name and description.","Hide NFTs":"Hide NFTs","Are you sure you want to hide this NFT collection containing %number% NFTs?":"Are you sure you want to hide this NFT collection containing %number% NFTs?","Are you sure you want to hide these %number% NFTs?":"Are you sure you want to hide these %number% NFTs?","Show":"Show","Confirm Sending":"Confirm Sending","Confirm Burning":"Confirm Burning","Confirm Passcode":"Confirm Passcode","Enter your code":"Enter your code","$hardware_payload_warning":"**A third-party service is requesting access to your wallet.** This could lead to the loss of funds. Cancel the operation if you are not sure about the reliability of this service.","$hardware_blind_sign_not_enabled":"**A third-party service is requesting access to your wallet.** This could lead to the loss of funds. Cancel the operation if you are not sure about the reliability of this service.\\n\\nTo continue, enable the \\"Blind Signing\\" option in the settings of the TON App on Ledger.\\n","$hardware_blind_sign_not_enabled_internal":"To continue, enable the \\"Blind Signing\\" option in the settings of the TON App on Ledger.","Switch to W5":"Switch to W5","Not Scam":"Not Scam","Untitled":"Untitled","Multichain":"Multichain","$swap_too_small_amount":"Too small amount","Not enough %symbol%":"Not enough %symbol%","$receive_tron_description":"Scan this QR or share your address to top up your wallet balance.","You have just created a new multichain wallet":"You have just created a new multichain wallet","Now you can transfer tokens from your TON and TRON wallets.":"Now you can transfer tokens from your TON and TRON wallets.","Enter Secret Words":"Enter Secret Words","Turn this off so you can manually download updates and verify signatures.":"Turn this off so you can manually download updates and verify signatures.","InvalidMnemonic":"Your mnemonic words are invalid","NFT Menu":"NFT Menu","Connection Type":"Connection Type","Ledger is not supported on this device":"Ledger is not supported on this device","Connect your Ledger":"Connect your Ledger","$app_lock_description":"When app lock is enabled, a lock icon appears on the card on the main page. Use it to lock %app_name%.","App Lock":"App Lock","Auto-Lock":"Auto-Lock","Disabled":"Disabled","30 seconds":"30 seconds","3 minutes":"3 minutes","10 minutes":"10 minutes","If away for 30 sec":"If away for 30 sec","If away for 3 min":"If away for 3 min","If away for 10 min":"If away for 10 min","Unlock":"Unlock","This address mimics another address that you previously interacted with.":"This address mimics another address that you previously interacted with.","Biometric authentication failed":"Biometric authentication failed","Reset biometrics in security settings, or use a passcode.":"Reset biometrics in security settings, or use a passcode.","Best Rate":"Best Rate","via %dex_name%":"via %dex_name%","$swap_dex_chooser_rate_title":"Analyzed actual rates on **DeDust** and **STON.fi** to use the **best rate**.","You will receive %amount% **more**.":"You will receive %amount% **more**.","You will spend %amount% **less**.":"You will spend %amount% **less**.","Best":"Best","Use Best Rate":"Use Best Rate","Switch to %dex_name%":"Switch to %dex_name%","Built-in DEX Aggregator":"Built-in DEX Aggregator","Add Tokens":"Add Tokens","No tokens yet":"No tokens yet","$no_tokens_description":"Receive tokens from another wallet, or simply enable preferred tokens in the settings for monitoring.","Exchange Rate":"Exchange Rate","Install Card":"Install Card","Reset Card":"Reset Card","Apply Palette":"Install Palette","Reset Palette":"Reset Palette","Notifications & Sounds":"Notifications & Sounds","Sounds":"Sounds","Push Notifications":"Push Notifications","Select up to %count% wallets for notifications":"Select up to %count% wallets for notifications","$swap_aggregator_fee_tooltip":"A built-in **DEX aggregator** finds the **best rate** across available DEXes. Service fee is %percent%.","Accumulated Rewards":"Accumulated Rewards","$swap_reverse_prohibited":"Setting the buy amount is impossible for this pair of tokens","Blockchain Fee Details":"Blockchain Fee Details","Final Fee":"Final Fee","Excess":"Excess","$fee_details":"%full_fee% need to be immediately debited from your wallet to pay the fee. Part of this will be returned **in **%excess_symbol% to you as excess within a few minutes.\\n\\nThis is how %chain_name% Blockchain works.\\n","Got It":"Got It","Wallet":"Wallet","Connected":"Connected","All Dapps":"All Dapps","Trending":"Trending","No Data":"No Data","Toggle fullscreen":"Toggle fullscreen","Request is sent!":"Request is sent!","Transaction ID":"Transaction ID","Help Center":"Help Center","MyTonWallet Tips":"MyTonWallet Tips","$auth_import_24_mnemonic_description":"You can restore access to your wallet by entering the **24 secret words** that you wrote down when creating the wallet.\\n","Open %nft_marketplace%":"Open %nft_marketplace%","Link was copied!":"Link was copied!","Share Link":"Share Link","$dapp_return_details":"%fee_amount% will be immediately debited from your wallet to pay the fee.\\n\\n%received_amount% will be returned to you within a few minutes.\\n","Additional Amount Sent":"Additional Amount Sent","Show Sensitive Data":"Show Sensitive Data","Hide Sensitive Data":"Hide Sensitive Data","Copy Address":"Copy Address","Copy Transaction ID":"Copy Transaction ID","Requesting Unstake":"Requesting Unstake","Requested Unstake":"Requested Unstake","$request_unstake_action":"Request Unstake","Calling Contract":"Calling Contract","Called Contract":"Called Contract","$call_contract_action":"Call Contract","Deploying Contract":"Deploying Contract","Deployed Contract":"Deployed Contract","$deploy_contract_action":"Deploy Contract","Minting":"Minting","Minted":"Minted","$mint_action":"Mint","Burning":"Burning","Burned":"Burned","$burn_action":"Burn","Updating Address":"Updating Address","Updated Address":"Updated Address","$update_address_action":"Update Address","Updating Site":"Updating Site","Updated Site":"Updated Site","$update_site_action":"Update Site","Updating Subdomains":"Updating Subdomains","Updated Subdomains":"Updated Subdomains","$update_subdomains_action":"Update Subdomains","Updating Storage":"Updating Storage","Updated Storage":"Updated Storage","$update_storage_action":"Update Storage","Deleting Domain Record":"Deleting Domain Record","Deleted Domain Record":"Deleted Domain Record","$delete_domain_record_action":"Delete Domain Record","Renewing Domain":"Renewing Domain","Renewed Domain":"Renewed Domain","$renew_domain_action":"Renew Domain","Providing Liquidity":"Providing Liquidity","Provided Liquidity":"Provided Liquidity","$provide_liquidity_action":"Provide Liquidity","Withdrawing Liquidity":"Withdrawing Liquidity","Withdrawn Liquidity":"Withdrawn Liquidity","$withdraw_liquidity_action":"Withdraw Liquidity","Bounced":"Bounced","Bouncing":"Bouncing","$bounce_action":"Bounce","NFT Auction Bid":"NFT Auction Bid","Bidding at NFT Auction":"Bidding at NFT Auction","Buying NFT":"Buying NFT","Bought NFT":"Bought NFT","$buy_nft_action":"Buy NFT","Sold NFT":"Sold NFT","Selling NFT":"Selling NFT","$sell_nft_action":"Sell NFT","Receiving":"Receiving","$receive_action":"Receive","Change Palette":"Change Palette","Palette":"Palette","Unlock New Palettes":"Unlock New Palettes","Get a unique MyTonWallet Card to unlock new palettes.":"Get a unique MyTonWallet Card to unlock new palettes.","Mint Cards":"Mint Cards","Card has been upgraded!":"Card has been upgraded!","$mint_card_result":"NFT Card will be **minted** and **installed automatically** within a minute.","Unique":"Unique","Get a card with unique background and personalized palette for wallet interface.":"Get a card with unique background and personalized palette for wallet interface.","Transferable":"Transferable","Easily send your upgraded card to any of your friends.":"Easily send your upgraded card to any of your friends.","Tradable":"Tradable","Sell or auction your card on third-party NFT marketplaces.":"Sell or auction your card on third-party NFT marketplaces.","Upgrade for %currency% %amount%":"Upgrade for %currency% %amount%","%amount% left":"%amount% left","%amount% sold":"%amount% sold","This card has been sold out":"This card has been sold out","Import Existing Wallet":"Import Existing Wallet","View Any Address":"View Any Address","12/24 Secret Words":"12/24 Secret Words","24 Secret Words":"24 Secret Words","Wallet Address or Domain":"Wallet Address or Domain","$import_view_account_note":"Enter **any address** on TON or TRON network to open it in **View Mode**.","$view_mode":"View","Import Wallet":"Import Wallet","Please top up your TON balance.":"Please top up your TON balance.","Remember Passcode":"Remember Passcode","Remember Password":"Remember Password","Not available with biometrics.":"Not available with biometrics.","App will not ask for signature for %1$d minutes after last entry.":"The app will not ask for a signature for %1$d minutes after the last entry.","Remember for %1$d minutes":"Remember for %1$d minutes","Preview":"Preview","$preview_not_guaranteed":"Preview result **is not guaranteed **and **can be forged **by the service.","Unverified Source":"Unverified Source","$reopen_in_iab":"For your safety, please re-open this dapp in %browserButton%.","MyTonWallet Browser":"MyTonWallet Browser","Exit all wallets":"Exit all wallets","Can\'t confirm?":"Can\'t confirm?","$safe_staking_ethena_description1":"Staking is fully decentralized and operated by **Ethenaâ€™s official** audited liquid staking **smart contracts**.","$safe_staking_ethena_description2":"The deposited USDe stake is used in Ethenaâ€™s **trading and investment strategies** to yield rewards automatically and transparently.","$safe_staking_ethena_description3":"You can **withdraw** your stake with rewards at any time, and it will be returned to your account **in 7 days**, according to Ethenaâ€™s standard withdrawal period.","Unstake %amount%":"Unstake %amount%","Request Unstaking":"Request Unstaking","$unstaking_when_receive_ethena":"You will be able to receive your unstaked deposit in **7 days**.","Coins have been unstaked!":"Coins have been unstaked!","Confirm Upgrading":"Confirm Upgrading","How does it work?":"How does it work?","Multisend":"Multisend","Renew All":"Renew All","Renew":"Renew","Renew Domain":"Renew Domain","Renew Domains":"Renew Domains","Some domains are about to expire":"Some domains are about to expire","$domain_expire":"**%domain%** expires %days%","%token% Staking":"%token% Staking","Add Tab":"Add Tab","Remove Tab":"Remove Tab","$domains_amount %1$d":{"zeroValue":"No domains","oneValue":"%1$d domain","otherValue":"%1$d domains"},"Stake":"Stake","Manage Tokens":"Manage Tokens","Claim Rewards":"Claim Rewards","Configure DNS":"Configure DNS","Link to Wallet":"Link to Wallet","Change Wallet":"Change Wallet","Change Linked Wallet":"Change Linked Wallet","Domain has been renewed!":"Domain has been renewed!","Domains have been renewed!":"Domains have been renewed!","Linked Wallet":"Linked Wallet","Domain has been linked!":"Domain has been linked!","Link":"Link","Confirm Renewing":"Confirm Renewing","Confirm Linking":"Confirm Linking","$domains_expire":{"zeroValue":"No domains expires %days%","oneValue":"**%domain% domain** expires %days%","otherValue":"**%domain% domains** expire %days%"},"$in_days":{"zeroValue":"today","oneValue":"tomorrow","otherValue":"in %1$d days"},"$domain_was_expired":"**%domain%** is expired","$domains_was_expired":{"zeroValue":"No domains is expired","oneValue":"**%domain% domain** is expired","otherValue":"**%domain% domains** are expired"},"Reload":"Reload","Copy Link":"Copy Link","Check eligibility for max APY":"Check eligibility for max APY","Check eligibility":"Check eligibility","$expired_many":"Expired","$expires_in %days%":"Expires %days%","Message":"Message","Binary Data":"Binary Data","The binary data content is unclear. Sign it only if you trust the service.":"The binary data content is unclear. Sign it only if you trust the service.","Cell Schema":"Cell Schema","Cell Data":"Cell Data","Sign Data":"Sign Data","Please confirm signature on your Ledger":"Please confirm signature on your Ledger","Utilities":"Utilities","Games":"Games","Entertainment":"Entertainment","Toggle to landscape layout":"Toggle to landscape layout","Toggle to portrait layout":"Toggle to portrait layout","Attributes":"Attributes","Show All":"Show All","Description":"Description","No additional data.":"No additional data.","Domain was copied!":"Domain was copied!","$in_currency":"in %currency%","Rename Wallet":"Rename Wallet","You can rename this wallet for easier identification.":"You can rename this wallet for easier identification.","$storage_cleared_title":"Application Storage Cleared","$storage_cleared_message":"Your wallet data has been cleared due to browser-related or disk space issues. Please log out from all wallets and then re-import them manually using your secret words.\\n\\nIf you need assistance, please contact %support_link%.\\n","Telegram Gifts":"Telegram Gifts","Collectibles":"Collectibles","Bluetooth unavailable":"Bluetooth unavailable","$bluetooth_enable_guide":"Turn on Bluetooth in the device settings and allow the app to access Bluetooth.","Another transaction was sent from this wallet simultaneously. Please try again.":"Another transaction was sent from this wallet simultaneously. Please try again.","Canceled by the user":"Canceled by the user","The proof for signing provided by the Dapp is too large":"The proof for signing provided by the Dapp is too large","$domain_like_scam_warning":"The entered address is likely a **SCAM**. This is **NOT** an address of any exchange or your token wallet.\\n\\nThis is a long **domain** that **scammers** use to convince people they are sending tokens to a known address.\\n\\n**Cancel** this transfer and **never** trust strangers. Learn more about this and other scams in our %help_center_link%.\\n","Allow Suspicious Actions":"Allow Suspicious Actions","$allow_suspicious_actions_description":"Allow sending to suspicious addresses and interacting with potentially unsafe contracts.","Multisig Wallet Detected":"Multisig Wallet Detected","$multisig_warning_text":"This wallet requires multiple signatures to make transfers. You **cannot withdraw** any funds here using MyTonWallet. Make sure itâ€™s yours â€” otherwise, it may be part of a scam. %multisig_warning_link%","$multisig_warning_link":"Tap to learn more","Multisig sending disabled":"Multisig sending disabled","$try_new_air_version":"Try the native app experience â€” lighter, faster, and built for your device. You can switch back anytime."}');
;// ./src/util/cacheApi.ts

const cacheApi = self.caches;
async function cacheApi_fetch(cacheName, key) {
  if (!cacheApi) {
    return undefined;
  }
  try {
    // To avoid the error "Request scheme 'webdocument' is unsupported"
    const request = src_config/* IS_PACKAGED_ELECTRON */.jht ? `${src_config/* ELECTRON_HOST_URL */.uyj}/${key.replace(/:/g, '_')}` : new Request(key.replace(/:/g, '_'));
    const cache = await cacheApi.open(cacheName);
    const response = await cache.match(request);
    if (!response) {
      return undefined;
    }
    return await response.json();
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn(err);
    return undefined;
  }
}
async function save(cacheName, key, data) {
  if (!cacheApi) {
    return undefined;
  }
  try {
    const cacheData = typeof data === 'string' || data instanceof Blob || data instanceof ArrayBuffer ? data : JSON.stringify(data);
    // To avoid the error "Request scheme 'webdocument' is unsupported"
    const request = src_config/* IS_PACKAGED_ELECTRON */.jht ? `${src_config/* ELECTRON_HOST_URL */.uyj}/${key.replace(/:/g, '_')}` : new Request(key.replace(/:/g, '_'));
    const response = new Response(cacheData);

    // To avoid the error "Request scheme 'chrome-extension' is unsupported"
    // https://github.com/iamshaunjp/pwa-tutorial/issues/1
    if (request instanceof Request && request.url.indexOf('chrome-extension') === 0) {
      return undefined;
    }
    const cache = await cacheApi.open(cacheName);
    return await cache.put(request, response);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn(err);
    return undefined;
  }
}
async function remove(cacheName, key) {
  try {
    if (!cacheApi) {
      return undefined;
    }
    const cache = await cacheApi.open(cacheName);
    return await cache.delete(key);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn(err);
    return undefined;
  }
}
async function clear(cacheName) {
  try {
    if (!cacheApi) {
      return undefined;
    }
    return await cacheApi.delete(cacheName);
  } catch (err) {
    // eslint-disable-next-line no-console
    console.warn(err);
    return undefined;
  }
}
;// ./src/util/formatNumber.ts





const SHORT_SYMBOLS = new Set(Object.values(src_config/* CURRENCIES */.yR2).map(currency => currency.shortSymbol).filter(Boolean));
const formatNumber = (0,withCache/* default */.A)(function (value) {
  let fractionDigits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  let noTruncate = arguments.length > 2 ? arguments[2] : undefined;
  let bigValue = new big_js/* Big */.z(value);
  if (bigValue.eq(0)) return '0';
  const isNegative = bigValue.lt(0);
  if (isNegative) bigValue = bigValue.neg();
  const method = bigValue.lt(1) ? 'toPrecision' : 'round';
  let formatted = bigValue[method](fractionDigits, noTruncate ? big_js/* Big */.z.roundHalfUp : big_js/* Big */.z.roundDown).toString()
  // Remove extra zeros after rounding to the specified accuracy
  .replace(/(\.\d*?)0+$/, '$1').replace(/\.$/, '');
  formatted = applyThousandsGrouping(formatted);
  if (isNegative) formatted = `-${formatted}`;
  return formatted;
});
function formatCurrency(value, currency, fractionDigits, noTruncate) {
  const formatted = formatNumber(value, fractionDigits, noTruncate);
  return addCurrency(formatted, currency);
}
function formatCurrencyExtended(value, currency) {
  let noSign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let fractionDigits = arguments.length > 3 ? arguments[3] : undefined;
  let isZeroNegative = arguments.length > 4 ? arguments[4] : undefined;
  const numericValue = Number(value);
  const isNegative = numericValue === 0 ? isZeroNegative : numericValue < 0;
  const prefix = !noSign ? !isNegative ? '+\u202F' : '\u2212\u202F' : '';
  value = value.toString();
  return prefix + formatCurrency(noSign ? value : value.replace(/^-/, ''), currency, fractionDigits);
}
function formatCurrencySimple(value, currency, decimals) {
  if (typeof value !== 'string') {
    value = (0,util_decimals/* toDecimal */.nI)(value, decimals);
  }
  return addCurrency(value, currency);
}
function addCurrency(value, currency) {
  return SHORT_SYMBOLS.has(currency) ? `${currency}${value}`.replace(`${currency}-`, `-${currency}`) : `${value} ${currency}`;
}
function getShortCurrencySymbol(currency) {
  if (!currency) currency = src_config/* DEFAULT_PRICE_CURRENCY */.wOb;
  return src_config/* CURRENCIES */.yR2[currency].shortSymbol ?? currency;
}
function applyThousandsGrouping(str) {
  const [wholePart, fractionPart = ''] = str.split('.');
  const groupedWhole = wholePart.replace(/\B(?=(\d{3})+(?!\d))/g, `$&${src_config/* WHOLE_PART_DELIMITER */.MS3}`);
  return [groupedWhole, fractionPart].filter(Boolean).join('.');
}

/** Formats the base currency amount of a transaction */
function formatBaseCurrencyAmount(amount, baseCurrency, token) {
  const baseCurrencyAmount = (0,big_js/* Big */.z)((0,util_decimals/* toDecimal */.nI)((0,bigint/* bigintAbs */.wg)(amount), token.decimals, true)).mul(token.price);
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  // The rounding logic should match the original amount rounding logic implemented by formatCurrencyExtended.
  // It's for cases when the base currency matches the transaction currency.
  return formatCurrency(baseCurrencyAmount, shortBaseSymbol);
}
;// ./src/util/regex.ts
// Source: https://github.com/sindresorhus/escape-string-regexp

function escapeStringRegexp(string) {
  // Escape characters with special meaning either inside or outside character sets.
  // Use a simple backslash escape when itâ€™s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patternsâ€™ stricter grammar.
  return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
;// ./src/util/langProvider.ts


// @ts-ignore this file is autogenerated






const defaultLangPack = en_namespaceObject;
const {
  addCallback: langProvider_addCallback,
  removeCallback: langProvider_removeCallback,
  runCallbacks: langProvider_runCallbacks
} = createCallbackManager();

const SUBSTITUTION_REGEX = /%\d?\$?[sdf@]/g;
const PLURAL_OPTIONS = ['value', 'zeroValue', 'oneValue', 'twoValue', 'fewValue', 'manyValue', 'otherValue'];
// Some rules edited from https://github.com/eemeli/make-plural/blob/master/packages/plurals/cardinals.js
// de - zeroValue, oneValue, otherValue
// en - zeroValue, oneValue, otherValue
// es - zeroValue, oneValue, otherValue
// pl - zeroValue, oneValue, fewValue, manyValue
// ru - zeroValue, oneValue, fewValue, manyValue
// th - zeroValue, otherValue
// tr - zeroValue, oneValue, otherValue
// uk - zeroValue, oneValue, fewValue, manyValue
// zh-Hans - zeroValue, otherValue
// zh-Hant - zeroValue, otherValue
const PLURAL_RULES = {
  /* eslint-disable @stylistic/max-len */
  de: n => n === 0 ? 1 : n !== 1 ? 6 : 2,
  en: n => n === 0 ? 1 : n !== 1 ? 6 : 2,
  es: n => n === 0 ? 1 : n !== 1 ? 6 : 2,
  pl: n => n === 0 ? 1 : n === 1 ? 2 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 4 : 5,
  ru: n => n === 0 ? 1 : n % 10 === 1 && n % 100 !== 11 ? 2 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 4 : 5,
  th: n => n === 0 ? 1 : 6,
  tr: n => n === 0 ? 1 : n > 1 ? 6 : 2,
  uk: n => n === 0 ? 1 : n % 10 === 1 && n % 100 !== 11 ? 2 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 4 : 5,
  'zh-Hans': n => n === 0 ? 1 : 6,
  'zh-Hant': n => n === 0 ? 1 : 6
  /* eslint-enable @stylistic/max-len */
};
const langProvider_cache = new Map();
let langPack;
let currentLangCode;
function createLangFn() {
  return (key, value, format, pluralValue) => {
    var _langPack;
    if (value !== undefined && (typeof value !== 'object' || Array.isArray(value))) {
      const cacheValue = Array.isArray(value) ? JSON.stringify(value) : value;
      const cached = langProvider_cache.get(`${key}_${cacheValue}_${format}${pluralValue ? `_${pluralValue}` : ''}`);
      if (cached) {
        return cached;
      }
    }
    if (!langPack && !defaultLangPack) {
      return key;
    }
    const langString = ((_langPack = langPack) === null || _langPack === void 0 ? void 0 : _langPack[key]) || (defaultLangPack === null || defaultLangPack === void 0 ? void 0 : defaultLangPack[key]) || key;
    return processTranslation(langString, key, value, format, pluralValue);
  };
}
let getTranslation = createLangFn();
async function setLanguage(langCode, callback) {
  if (langPack && langCode === currentLangCode) {
    if (callback) {
      callback();
    }
    return;
  }
  let newLangPack = await cacheApi_fetch(src_config/* LANG_CACHE_NAME */.CV, langCode);
  if (!newLangPack) {
    newLangPack = await fetchRemote(langCode);
    if (!newLangPack) {
      return;
    }
  }
  langProvider_cache.clear();
  currentLangCode = langCode;
  langPack = newLangPack;
  document.documentElement.lang = langCode;
  const langInfo = src_config/* LANG_LIST */.gSB === null || src_config/* LANG_LIST */.gSB === void 0 ? void 0 : src_config/* LANG_LIST */.gSB.find(l => l.langCode === langCode);
  getTranslation = createLangFn();
  getTranslation.isRtl = Boolean(langInfo === null || langInfo === void 0 ? void 0 : langInfo.rtl);
  getTranslation.code = langCode.replace('-raw', '');
  getTranslation.langName = langInfo === null || langInfo === void 0 ? void 0 : langInfo.nativeName;
  if (callback) {
    callback();
  }
  langProvider_runCallbacks();
}
function clearPreviousLangpacks() {
  const langCachePrefix = src_config/* LANG_CACHE_NAME */.CV.replace(/\d+$/, '');
  const langCacheVersion = Number((src_config/* LANG_CACHE_NAME */.CV.match(/\d+$/) || [0])[0]);
  for (let i = 0; i < langCacheVersion; i++) {
    void clear(`${langCachePrefix}${i === 0 ? '' : i}`);
  }
}
async function fetchRemote(langCode) {
  if (langCode === windowEnvironment/* DEFAULT_LANG_CODE */.vj) {
    return defaultLangPack;
  }
  const response = await fetch(`${src_config/* IS_PACKAGED_ELECTRON */.jht ? '.' : '..'}/i18n/${langCode}.json`);
  if (!response.ok) {
    const message = `An error has occured: ${response.status}`;
    throw new Error(message);
  }
  const remote = await response.json();
  if (remote) {
    await save(src_config/* LANG_CACHE_NAME */.CV, langCode, remote);
    return remote;
  }
  return undefined;
}
function getPluralOption(amount) {
  const langCode = currentLangCode || windowEnvironment/* DEFAULT_LANG_CODE */.vj;
  const optionIndex = PLURAL_RULES[langCode] ? PLURAL_RULES[langCode](amount) : 0;
  return PLURAL_OPTIONS[optionIndex];
}
function processTemplate(template, value) {
  value = Array.isArray(value) ? value : [value];
  const translationSlices = template.split(SUBSTITUTION_REGEX);
  const initialValue = translationSlices.shift();
  return translationSlices.reduce((result, str, index) => {
    return `${result}${String(value[index] ?? '')}${str}`;
  }, initialValue || '');
}

// Export a function for testing purposes
function processTemplateJsx(template, value) {
  // Replace all primitive values (strings and numbers)
  let processedTemplate = template;
  Object.entries(value).forEach(_ref => {
    let [key, val] = _ref;
    if (typeof val === 'string' || typeof val === 'number') {
      processedTemplate = processedTemplate.replace(new RegExp(`%${escapeStringRegexp(key)}%`, 'g'), String(val));
    }
  });

  // Check if there are any components
  const hasComponents = Object.values(value).some(val => typeof val !== 'string' && typeof val !== 'number');

  // If no components, just process through renderText
  if (!hasComponents) {
    return renderText(processedTemplate);
  }

  // If there are components, process in parts
  const parts = processedTemplate.split(/%(\w+)%/);
  const result = [];
  for (let i = 0; i < parts.length; i++) {
    if (i % 2 === 0) {
      // Text part
      if (parts[i]) {
        result.push(...renderText(parts[i]));
      }
    } else {
      // Token (between % symbols)
      const tokenValue = value[parts[i]];
      if (tokenValue !== undefined) {
        result.push(tokenValue);
      }
    }
  }
  return result;
}
function processTranslation(langString, key, value, format, pluralValue) {
  const preferredPluralOption = typeof value === 'number' || pluralValue !== undefined ? getPluralOption(pluralValue ?? value) : 'value';
  const template = typeof langString === 'string' ? langString : preferredPluralOption === 'value'
  // Support cached older `langString` interface
  ? typeof langString === 'object' ? langString.value : langString : typeof langString === 'object' ? (langString === null || langString === void 0 ? void 0 : langString[preferredPluralOption]) || langString.otherValue : undefined;
  if (!template || !template.trim() || value === undefined) {
    return template;
  }
  const formattedValue = format === 'i' ? formatNumber(value) : value;
  const result = typeof value === 'object' && !Array.isArray(value) ? processTemplateJsx(template, formattedValue) : processTemplate(template, formattedValue);
  if (typeof value !== 'object' && typeof result === 'string') {
    const cacheValue = Array.isArray(value) ? JSON.stringify(value) : value;
    langProvider_cache.set(`${key}_${cacheValue}_${format}${pluralValue ? `_${pluralValue}` : ''}`, result);
  }
  return result;
}
;// ./src/hooks/useLang.ts



const useLang = () => {
  const forceUpdate = hooks_useForceUpdate();
  hooks_useEffectOnce(() => {
    return langProvider_addCallback(forceUpdate);
  });
  return getTranslation;
};
/* harmony default export */ const hooks_useLang = (useLang);
;// ./src/util/buildClassName.ts
function buildClassName() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  return parts.filter(Boolean).join(' ');
}
function createClassNameBuilder(componentName) {
  return function (elementName) {
    const baseName = elementName === '&' ? componentName : `${componentName}__${elementName}`;
    for (var _len2 = arguments.length, modifiers = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      modifiers[_key2 - 1] = arguments[_key2];
    }
    return modifiers.reduce((acc, modifier) => {
      if (modifier) {
        // A bit hacky way to pass global class names
        if (Array.isArray(modifier)) {
          acc.push(...modifier);
        } else {
          acc.push(`${baseName}--${modifier}`);
        }
      }
      return acc;
    }, [baseName]).join(' ');
  };
}
// EXTERNAL MODULE: ./src/lib/fasterdom/stricterdom.ts + 1 modules
var stricterdom = __webpack_require__(75357);
;// ./src/util/lethargy.ts
/**
 * Lethargy help distinguish between scroll events initiated by the user, and those by inertial scrolling.
 * Lethargy does not have external dependencies.
 *
 * @param stability - Specifies the length of the rolling average.
 * In effect, the larger the value, the smoother the curve will be.
 * This attempts to prevent anomalies from firing 'real' events. Valid values are all positive integers,
 * but in most cases, you would need to stay between 5 and around 30.
 *
 * @param sensitivity - Specifies the minimum value for wheelDelta for it to register as a valid scroll event.
 * Because the tail of the curve have low wheelDelta values,
 * this will stop them from registering as valid scroll events.
 * The unofficial standard wheelDelta is 120, so valid values are positive integers below 120.
 *
 * @param tolerance - Prevent small fluctuations from affecting results.
 * Valid values are decimals from 0, but should ideally be between 0.05 and 0.3.
 *
 * Based on https://github.com/d4nyll/lethargy
 */

class Lethargy {
  constructor() {
    let {
      stability = 8,
      sensitivity = 100,
      tolerance = 1.1,
      delay = 150
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.stability = stability;
    this.sensitivity = sensitivity;
    this.tolerance = tolerance;
    this.delay = delay;
    this.lastUpDeltas = new Array(this.stability * 2).fill(0);
    this.lastDownDeltas = new Array(this.stability * 2).fill(0);
    this.deltasTimestamp = new Array(this.stability * 2).fill(0);
  }
  check(e) {
    let lastDelta;
    e = e.originalEvent || e;
    if (e.wheelDelta !== undefined) {
      lastDelta = e.wheelDelta;
    } else if (e.deltaY !== undefined) {
      lastDelta = e.deltaY * -40;
    } else if (e.detail !== undefined || e.detail === 0) {
      lastDelta = e.detail * -40;
    }
    this.deltasTimestamp.push(Date.now());
    this.deltasTimestamp.shift();
    if (lastDelta > 0) {
      this.lastUpDeltas.push(lastDelta);
      this.lastUpDeltas.shift();
      return this.isInertia(1);
    } else {
      this.lastDownDeltas.push(lastDelta);
      this.lastDownDeltas.shift();
      return this.isInertia(-1);
    }
  }
  isInertia(direction) {
    const lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;
    if (lastDeltas[0] === undefined) return direction;
    if (this.deltasTimestamp[this.stability * 2 - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[this.stability * 2 - 1]) {
      return false;
    }
    const lastDeltasOld = lastDeltas.slice(0, this.stability);
    const lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);
    const oldSum = lastDeltasOld.reduce((t, s) => t + s);
    const newSum = lastDeltasNew.reduce((t, s) => t + s);
    const oldAverage = oldSum / lastDeltasOld.length;
    const newAverage = newSum / lastDeltasNew.length;
    return Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && this.sensitivity < Math.abs(newAverage);
  }
}
;// ./src/util/math.ts
const clamp = (num, min, max) => Math.min(max, Math.max(min, num));
const isBetween = (num, min, max) => num >= min && num <= max;
const math_round = function (num) {
  let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return Math.round(num * 10 ** decimals) / 10 ** decimals;
};
const lerp = (start, end, interpolationRatio) => {
  return (1 - interpolationRatio) * start + interpolationRatio * end;
};

// Fractional values cause blurry text & canvas. Round to even to keep whole numbers while centering
function roundToNearestEven(value) {
  return Math.round(value / 2) * 2;
}
;// ./src/util/captureEvents.ts






let SwipeDirection = /*#__PURE__*/function (SwipeDirection) {
  SwipeDirection[SwipeDirection["Up"] = 0] = "Up";
  SwipeDirection[SwipeDirection["Down"] = 1] = "Down";
  SwipeDirection[SwipeDirection["Left"] = 2] = "Left";
  SwipeDirection[SwipeDirection["Right"] = 3] = "Right";
  return SwipeDirection;
}({});

// https://stackoverflow.com/questions/11287877/how-can-i-get-e-offsetx-on-mobile-ipad
// Android does not have this value, and iOS has it but as read-only

const IOS_SCREEN_EDGE_THRESHOLD = 20;
const SWIPE_DIRECTION_THRESHOLD = 10;
const SWIPE_DIRECTION_TOLERANCE = 1.5;
const MOVE_THRESHOLD = 15;
const SWIPE_THRESHOLD_DEFAULT = 20;
const RELEASE_WHEEL_ZOOM_DELAY = 150;
const RELEASE_WHEEL_DRAG_DELAY = 150;
function getDistance(a, b) {
  if (!b) return 0;
  return Math.hypot(b.pageX - a.pageX, b.pageY - a.pageY);
}
function getTouchCenter(a, b) {
  return {
    x: (a.pageX + b.pageX) / 2,
    y: (a.pageY + b.pageY) / 2
  };
}
let lastClickTime = 0;
const lethargy = new Lethargy({
  stability: 5,
  sensitivity: 25,
  tolerance: windowEnvironment/* IS_WINDOWS */.H8 ? 1 : 0.6,
  // Windows `scrollDelta` does not die down to 0
  delay: 150
});
function captureEvents(element, options) {
  let captureEvent;
  let hasMoved = false;
  let hasSwiped = false;
  let isZooming = false;
  let initialDistance = 0;
  let wheelZoom = options.initialZoom ?? 1;
  let initialDragOffset = {
    x: 0,
    y: 0
  };
  let isDragCanceled = {
    x: false,
    y: false
  };
  const currentWindowSize = windowSize.get();
  let initialTouchCenter = {
    x: currentWindowSize.width / 2,
    y: currentWindowSize.height / 2
  };
  let initialSwipeAxis;
  const minZoom = options.minZoom ?? 1;
  const maxZoom = options.maxZoom ?? 4;
  function onCapture(e) {
    var _options$onCapture;
    const target = e.target;
    const {
      excludedClosestSelector,
      includedClosestSelector,
      withNativeDrag,
      withCursor,
      onDrag
    } = options;
    if (element !== target && !element.contains(target)) {
      return;
    }
    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
      return;
    }
    if (excludedClosestSelector && (target.matches(excludedClosestSelector) || target.closest(excludedClosestSelector)) || includedClosestSelector && !(target.matches(includedClosestSelector) || target.closest(includedClosestSelector))) {
      return;
    }
    captureEvent = e;
    if (e.type === 'mousedown') {
      if (!withNativeDrag && onDrag) {
        e.preventDefault();
      }
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onRelease);
    } else if (e.type === 'touchstart') {
      // We need to always listen on `touchstart` target:
      // https://stackoverflow.com/questions/33298828/touch-move-event-dont-fire-after-touch-start-target-is-removed
      target.addEventListener('touchmove', onMove, {
        passive: true
      });
      target.addEventListener('touchend', onRelease, {
        passive: true
      });
      target.addEventListener('touchcancel', onRelease, {
        passive: true
      });
      if ('touches' in e) {
        if (e.pageX === undefined) {
          e.pageX = e.touches[0].pageX;
        }
        if (e.pageY === undefined) {
          e.pageY = e.touches[0].pageY;
        }
        if (e.touches.length === 2) {
          initialDistance = getDistance(e.touches[0], e.touches[1]);
          initialTouchCenter = getTouchCenter(e.touches[0], e.touches[1]);
        }
      }
    }
    if (withCursor) {
      document.body.classList.add('cursor-grabbing');
    }
    (_options$onCapture = options.onCapture) === null || _options$onCapture === void 0 || _options$onCapture.call(options, e);
  }
  function onRelease(e) {
    if (captureEvent) {
      if (options.withCursor) {
        document.body.classList.remove('cursor-grabbing');
      }
      document.removeEventListener('mouseup', onRelease);
      document.removeEventListener('mousemove', onMove);
      captureEvent.target.removeEventListener('touchcancel', onRelease);
      captureEvent.target.removeEventListener('touchend', onRelease);
      captureEvent.target.removeEventListener('touchmove', onMove);
      if (windowEnvironment/* IS_IOS */.pz && options.selectorToPreventScroll) {
        const nodes = Array.from(document.querySelectorAll(options.selectorToPreventScroll));
        (0,stricterdom/* forceMutation */.dL)(() => {
          nodes.forEach(scrollable => {
            scrollable.style.overflow = '';
          });
        }, nodes);
      }
      if (e) {
        if (hasMoved) {
          if (options.onRelease) {
            options.onRelease(e);
          }
        } else if (e.type === 'mouseup') {
          if (options.onDoubleClick && Date.now() - lastClickTime < 300) {
            options.onDoubleClick(e, {
              centerX: captureEvent.pageX,
              centerY: captureEvent.pageY
            });
          } else if (options.onClick && (!('button' in e) || e.button === 0)) {
            options.onClick(e);
          }
          lastClickTime = Date.now();
        }
      }
    }
    hasMoved = false;
    hasSwiped = false;
    isZooming = false;
    initialDistance = 0;
    wheelZoom = clamp(wheelZoom, minZoom, maxZoom);
    initialSwipeAxis = undefined;
    initialDragOffset = {
      x: 0,
      y: 0
    };
    isDragCanceled = {
      x: false,
      y: false
    };
    const newWindowSize = windowSize.get();
    initialTouchCenter = {
      x: newWindowSize.width / 2,
      y: newWindowSize.height / 2
    };
    captureEvent = undefined;
  }
  function onMove(e) {
    if (captureEvent) {
      if (e.type === 'touchmove' && 'touches' in e) {
        if (e.pageX === undefined) {
          e.pageX = e.touches[0].pageX;
        }
        if (e.pageY === undefined) {
          e.pageY = e.touches[0].pageY;
        }
        if (options.onZoom && initialDistance > 0 && e.touches.length === 2) {
          const endDistance = getDistance(e.touches[0], e.touches[1]);
          const touchCenter = getTouchCenter(e.touches[0], e.touches[1]);
          const dragOffsetX = touchCenter.x - initialTouchCenter.x;
          const dragOffsetY = touchCenter.y - initialTouchCenter.y;
          const zoomFactor = endDistance / initialDistance;
          options.onZoom(e, {
            zoomFactor,
            initialCenterX: initialTouchCenter.x,
            initialCenterY: initialTouchCenter.y,
            dragOffsetX,
            dragOffsetY,
            currentCenterX: touchCenter.x,
            currentCenterY: touchCenter.y
          });
          if (zoomFactor !== 1) hasMoved = true;
        }
      }
      const dragOffsetX = e.pageX - captureEvent.pageX;
      const dragOffsetY = e.pageY - captureEvent.pageY;
      if (Math.abs(dragOffsetX) >= MOVE_THRESHOLD || Math.abs(dragOffsetY) >= MOVE_THRESHOLD) {
        hasMoved = true;
      }
      let shouldPreventScroll = false;
      if (options.onDrag) {
        options.onDrag(e, captureEvent, {
          dragOffsetX,
          dragOffsetY
        });
        shouldPreventScroll = true;
      }
      if (options.onSwipe && !hasSwiped) {
        hasSwiped = onSwipe(e, dragOffsetX, dragOffsetY);
        shouldPreventScroll = hasSwiped;
      }
      if (windowEnvironment/* IS_IOS */.pz && shouldPreventScroll && options.selectorToPreventScroll) {
        const nodes = Array.from(document.querySelectorAll(options.selectorToPreventScroll));
        (0,stricterdom/* forceMutation */.dL)(() => {
          nodes.forEach(scrollable => {
            scrollable.style.overflow = 'hidden';
          });
        }, nodes);
      }
    }
  }
  function onSwipe(e, dragOffsetX, dragOffsetY) {
    // Avoid conflicts with swipe-to-back gestures
    if (windowEnvironment/* IS_IOS */.pz) {
      const x = 'touches' in e ? e.touches[0].pageX // RealTouchEvent
      : e.pageX; // Event on iPad or iPhone with connected mouse
      if (x <= IOS_SCREEN_EDGE_THRESHOLD || x >= windowSize.get().width - IOS_SCREEN_EDGE_THRESHOLD) {
        return false;
      }
    }
    const xAbs = Math.abs(dragOffsetX);
    const yAbs = Math.abs(dragOffsetY);
    const threshold = options.swipeThreshold ?? SWIPE_THRESHOLD_DEFAULT;
    let axis;
    if (xAbs > yAbs && xAbs >= threshold) {
      axis = 'x';
    } else if (yAbs > xAbs && yAbs >= threshold) {
      axis = 'y';
    }
    if (!axis) {
      return false;
    }
    if (!initialSwipeAxis) {
      initialSwipeAxis = axis;
    } else if (initialSwipeAxis !== axis) {
      // Prevent horizontal swipe after vertical to prioritize scroll
      return false;
    }
    return processSwipe(e, axis, dragOffsetX, dragOffsetY, options.onSwipe);
  }
  const releaseWheelDrag = (0,schedulers/* debounce */.sg)(onRelease, RELEASE_WHEEL_DRAG_DELAY, false);
  const releaseWheelZoom = (0,schedulers/* debounce */.sg)(onRelease, RELEASE_WHEEL_ZOOM_DELAY, false);
  function onWheelCapture(e) {
    if (hasMoved) return;
    onCapture(e);
    hasMoved = true;
    initialTouchCenter = {
      x: e.x,
      y: e.y
    };
  }
  function onWheelZoom(e) {
    if (!options.onZoom) return;
    onWheelCapture(e);
    const dragOffsetX = e.x - initialTouchCenter.x;
    const dragOffsetY = e.y - initialTouchCenter.y;
    const delta = clamp(e.deltaY, -25, 25);
    wheelZoom -= delta * 0.01;
    wheelZoom = clamp(wheelZoom, minZoom * 0.5, maxZoom * 3);
    isZooming = true;
    options.onZoom(e, {
      zoom: math_round(wheelZoom, 2),
      initialCenterX: initialTouchCenter.x,
      initialCenterY: initialTouchCenter.y,
      dragOffsetX,
      dragOffsetY,
      currentCenterX: e.x,
      currentCenterY: e.y
    });
    releaseWheelZoom(e);
  }
  function onWheelDrag(e) {
    if (!options.onDrag) return;
    onWheelCapture(e);
    // Ignore wheel inertia if drag is canceled in this direction
    if (!isDragCanceled.x || Math.sign(initialDragOffset.x) === Math.sign(e.deltaX)) {
      initialDragOffset.x -= e.deltaX;
    }
    if (!isDragCanceled.y || Math.sign(initialDragOffset.y) === Math.sign(e.deltaY)) {
      initialDragOffset.y -= e.deltaY;
    }
    const {
      x,
      y
    } = initialDragOffset;
    options.onDrag(e, captureEvent, {
      dragOffsetX: x,
      dragOffsetY: y
    }, (dx, dy) => {
      isDragCanceled = {
        x: dx,
        y: dy
      };
    });
    releaseWheelDrag(e);
  }
  function onWheel(e) {
    if (!options.onZoom && !options.onDrag) return;
    if (options.excludedClosestSelector && (e.target.matches(options.excludedClosestSelector) || e.target.closest(options.excludedClosestSelector))) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const {
      doubleTapZoom = 3
    } = options;
    if (options.onDoubleClick && Object.is(e.deltaX, -0) && Object.is(e.deltaY, -0) && e.ctrlKey) {
      onWheelCapture(e);
      wheelZoom = wheelZoom > 1 ? 1 : doubleTapZoom;
      options.onDoubleClick(e, {
        centerX: e.pageX,
        centerY: e.pageY
      });
      hasMoved = false;
      return;
    }
    const metaKeyPressed = e.metaKey || e.ctrlKey || e.shiftKey;
    if (metaKeyPressed) {
      onWheelZoom(e);
    }
    if (!metaKeyPressed && !isZooming) {
      // Check if this event produced by user scroll and not by inertia
      const isUserEvent = lethargy.check(e);
      if (wheelZoom !== 1 || isUserEvent) {
        onWheelDrag(e);
      }
    }
  }
  if (options.withWheelDrag) {
    element.addEventListener('wheel', onWheel);
  }
  element.addEventListener('mousedown', onCapture);
  document.body.addEventListener('touchstart', onCapture, {
    passive: !options.isNotPassive
  });
  return () => {
    onRelease();
    document.body.removeEventListener('touchstart', onCapture);
    element.removeEventListener('mousedown', onCapture);
    element.removeEventListener('wheel', onWheel);
  };
}
function processSwipe(e, currentSwipeAxis, dragOffsetX, dragOffsetY, onSwipe) {
  const offsets = {
    dragOffsetX,
    dragOffsetY
  };
  if (currentSwipeAxis === 'x') {
    if (dragOffsetX < 0) {
      return onSwipe(e, SwipeDirection.Left, offsets);
    } else {
      return onSwipe(e, SwipeDirection.Right, offsets);
    }
  } else if (currentSwipeAxis === 'y') {
    if (dragOffsetY < 0) {
      return onSwipe(e, SwipeDirection.Up, offsets);
    } else {
      return onSwipe(e, SwipeDirection.Down, offsets);
    }
  }
  return false;
}
;// ./src/util/captureKeyboardListeners.ts
const keyToHandlerName = {
  Enter: 'onEnter',
  Backspace: 'onBackspace',
  Delete: 'onDelete',
  Esc: 'onEsc',
  Escape: 'onEsc',
  ArrowUp: 'onUp',
  ArrowDown: 'onDown',
  ArrowLeft: 'onLeft',
  ArrowRight: 'onRight',
  Tab: 'onTab'
};
const handlers = {
  onEnter: [],
  onDelete: [],
  onBackspace: [],
  onEsc: [],
  onUp: [],
  onDown: [],
  onLeft: [],
  onRight: [],
  onTab: []
};
function captureKeyboardListeners(options) {
  if (!hasActiveHandlers()) {
    document.addEventListener('keydown', handleKeyDown, true);
  }
  Object.keys(options).forEach(handlerName => {
    const option = options[handlerName];
    if (!option) {
      return;
    }
    const currentEventHandlers = handlers[handlerName];
    if (currentEventHandlers) {
      currentEventHandlers.push(option);
    }
  });
  return () => {
    releaseKeyboardListener(options);
  };
}
function hasActiveHandlers() {
  return Object.values(handlers).some(keyHandlers => Boolean(keyHandlers.length));
}
function handleKeyDown(e) {
  const handlerName = keyToHandlerName[e.key];
  if (!handlerName) {
    return;
  }
  const {
    length
  } = handlers[handlerName];
  if (!length) {
    return;
  }
  const handlerOrOptions = handlers[handlerName][length - 1];
  if (typeof handlerOrOptions === 'function') {
    void handlerOrOptions(e);
    e.stopPropagation();
  } else {
    const {
      handler,
      noStopPropagation,
      shouldPreventDefault
    } = handlerOrOptions;
    if (!noStopPropagation) {
      e.stopPropagation();
    }
    if (shouldPreventDefault) {
      e.preventDefault();
    }
    handler(e);
  }
}
function releaseKeyboardListener(options) {
  Object.keys(options).forEach(handlerName => {
    const option = options[handlerName];
    const currentEventHandlers = handlers[handlerName];
    if (currentEventHandlers) {
      const index = currentEventHandlers.findIndex(cb => {
        if (typeof cb === 'function') {
          return cb === option;
        } else {
          return option && 'handler' in option && cb.handler === option.handler;
        }
      });
      if (index !== -1) {
        currentEventHandlers.splice(index, 1);
      }
    }
  });
  if (!hasActiveHandlers()) {
    document.removeEventListener('keydown', handleKeyDown, false);
  }
}
;// ./src/util/modalSwipeManager.ts
let modalSwipeManager_counter = 0;
function disableSwipeToClose() {
  modalSwipeManager_counter += 1;
}
function enableSwipeToClose() {
  modalSwipeManager_counter -= 1;
}
function getIsSwipeToCloseDisabled() {
  return modalSwipeManager_counter > 0;
}
;// ./src/util/trapFocus.ts
function trapFocus(element) {
  function handleKeyDown(e) {
    if (e.key !== 'Tab') {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const focusableElements = Array.from(element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'));
    if (!focusableElements.length) {
      return;
    }
    const currentFocusedIndex = focusableElements.findIndex(em => em.isSameNode(document.activeElement));
    let newFocusedIndex = 0;
    if (currentFocusedIndex >= 0) {
      if (e.shiftKey) {
        newFocusedIndex = currentFocusedIndex > 0 ? currentFocusedIndex - 1 : focusableElements.length - 1;
      } else {
        newFocusedIndex = currentFocusedIndex < focusableElements.length - 1 ? currentFocusedIndex + 1 : 0;
      }
    }
    focusableElements[newFocusedIndex].focus();
  }
  document.addEventListener('keydown', handleKeyDown, false);
  return () => {
    document.removeEventListener('keydown', handleKeyDown, false);
  };
}
;// ./src/hooks/freezeWhenClosed.ts

function freezeWhenClosed(Component) {
  function ComponentWrapper(props) {
    const newProps = teact_useRef(props);
    if (props.isOpen) {
      newProps.current = props;
    } else {
      newProps.current = {
        ...newProps.current,
        isOpen: false
      };
    }
    return Component(newProps.current);
  }
  return ComponentWrapper;
}
;// ./src/util/cssColorToHex.ts
function cssColorToHex(cssColor) {
  if (/^#[0-9A-F]{6}$/i.test(cssColor)) return cssColor;
  return `#${cssColor.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/).slice(1).map((n, i) => (i === 3 ? Math.round(parseFloat(n) * 255) : parseFloat(n)).toString(16).padStart(2, '0').replace('NaN', '')).join('')}`;
}
;// ./node_modules/@capacitor/status-bar/dist/esm/definitions.js
/// <reference types="@capacitor/cli" />
var Style;
(function (Style) {
    /**
     * Light text for dark backgrounds.
     *
     * @since 1.0.0
     */
    Style["Dark"] = "DARK";
    /**
     * Dark text for light backgrounds.
     *
     * @since 1.0.0
     */
    Style["Light"] = "LIGHT";
    /**
     * The style is based on the device appearance.
     * If the device is using Dark mode, the statusbar text will be light.
     * If the device is using Light mode, the statusbar text will be dark.
     *
     * @since 1.0.0
     */
    Style["Default"] = "DEFAULT";
})(Style || (Style = {}));
var Animation;
(function (Animation) {
    /**
     * No animation during show/hide.
     *
     * @since 1.0.0
     */
    Animation["None"] = "NONE";
    /**
     * Slide animation during show/hide.
     * It doesn't work on iOS 15+.
     *
     * @deprecated Use Animation.Fade or Animation.None instead.
     *
     * @since 1.0.0
     */
    Animation["Slide"] = "SLIDE";
    /**
     * Fade animation during show/hide.
     *
     * @since 1.0.0
     */
    Animation["Fade"] = "FADE";
})(Animation || (Animation = {}));
/**
 * @deprecated Use `Animation`.
 * @since 1.0.0
 */
const StatusBarAnimation = (/* unused pure expression or super */ null && (Animation));
/**
 * @deprecated Use `Style`.
 * @since 1.0.0
 */
const StatusBarStyle = (/* unused pure expression or super */ null && (Style));
//# sourceMappingURL=definitions.js.map
;// ./node_modules/@capacitor/status-bar/dist/esm/index.js

const StatusBar = (0,dist/* registerPlugin */.F3)('StatusBar');


//# sourceMappingURL=index.js.map
;// ./node_modules/@mauricewegner/capacitor-navigation-bar/dist/esm/navigationbar.events.js
var NavigationBarPluginEvents;
(function (NavigationBarPluginEvents) {
    /**
     * Called after the navigation bar is displayed
     */
    NavigationBarPluginEvents["SHOW"] = "onShow";
    /**
     * Called after navigation bar is hidden
     */
    NavigationBarPluginEvents["HIDE"] = "onHide";
    /**
     * Called after navigation bar color is changed
     */
    NavigationBarPluginEvents["COLOR_CHANGE"] = "onColorChange";
})(NavigationBarPluginEvents || (NavigationBarPluginEvents = {}));
//# sourceMappingURL=navigationbar.events.js.map
;// ./node_modules/@mauricewegner/capacitor-navigation-bar/dist/esm/index.js

const NavigationBar = (0,dist/* registerPlugin */.F3)('NavigationBar', {
    web: () => __webpack_require__.e(/* import() */ 884).then(__webpack_require__.bind(__webpack_require__, 15884)).then(m => new m.NavigationBarWeb()),
});



//# sourceMappingURL=index.js.map
;// ./src/util/capacitor/switchStatusBar.ts



function switchStatusBar(currentAppTheme, isSystemDark, forceDarkBackground, isModalOpen) {
  const style = forceDarkBackground || currentAppTheme === 'dark' ? Style.Dark : isSystemDark && currentAppTheme === 'system' ? Style.Dark : Style.Light;
  void StatusBar.setStyle({
    style,
    isModalOpen
  });
  if (windowEnvironment/* IS_ANDROID_APP */.xy) {
    void NavigationBar.setColor({
      color: '#00000000',
      darkButtons: currentAppTheme === 'light' || !isSystemDark && currentAppTheme === 'system'
    });
  }
}
;// ./src/util/switchTheme.ts






const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
let currentTheme;
let forcedDarkStatusBarBackground;
function switchTheme(theme, isInModal) {
  currentTheme = theme;
  setThemeValue();
  setStatusBarStyle({
    isInModal
  });
  setThemeColor();
}
function setThemeValue() {
  var _getTelegramApp;
  const isDarkTheme = currentTheme === 'dark' || currentTheme === 'system' && (src_config/* IS_TELEGRAM_APP */.tKX ? ((_getTelegramApp = telegram_getTelegramApp()) === null || _getTelegramApp === void 0 ? void 0 : _getTelegramApp.colorScheme) === 'dark' : prefersDark.matches);
  document.documentElement.classList.toggle('theme-dark', isDarkTheme);
}
function handlePrefersColorSchemeChange() {
  setThemeValue();
  setStatusBarStyle();
}
function setThemeColor() {
  (0,fasterdom/* requestMeasure */.YS)(() => {
    var _document$querySelect;
    const color = getComputedStyle(document.documentElement).getPropertyValue('--color-background-second');
    (_document$querySelect = document.querySelector('meta[name="theme-color"]')) === null || _document$querySelect === void 0 || _document$querySelect.setAttribute('content', color);
  });
}
function setStatusBarStyle(options) {
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    (0,fasterdom/* requestMeasure */.YS)(() => {
      var _getTelegramApp2, _getTelegramApp3, _getTelegramApp4;
      const color = getComputedStyle(document.documentElement).getPropertyValue('--color-background-second');
      if (!color) return;
      const hexColor = cssColorToHex(color);
      (_getTelegramApp2 = telegram_getTelegramApp()) === null || _getTelegramApp2 === void 0 || _getTelegramApp2.setHeaderColor(hexColor);
      (_getTelegramApp3 = telegram_getTelegramApp()) === null || _getTelegramApp3 === void 0 || _getTelegramApp3.setBackgroundColor(hexColor);
      (_getTelegramApp4 = telegram_getTelegramApp()) === null || _getTelegramApp4 === void 0 || _getTelegramApp4.setBottomBarColor(hexColor);
    });
    return;
  }
  if (!src_config/* IS_CAPACITOR */.UMQ) return;
  if ((options === null || options === void 0 ? void 0 : options.forceDarkBackground) !== undefined) forcedDarkStatusBarBackground = options.forceDarkBackground;
  switchStatusBar(currentTheme, prefersDark.matches, forcedDarkStatusBarBackground, options === null || options === void 0 ? void 0 : options.isInModal);
}
prefersDark.addEventListener('change', handlePrefersColorSchemeChange);
if (src_config/* IS_TELEGRAM_APP */.tKX) {
  void getTelegramAppAsync().then(telegramApp => {
    telegramApp.onEvent('themeChanged', onThemeChanged);
  });
}
function unsubscribeOnTelegramThemeChange() {
  var _getTelegramApp5;
  (_getTelegramApp5 = getTelegramApp()) === null || _getTelegramApp5 === void 0 || _getTelegramApp5.offEvent('themeChanged', onThemeChanged);
}
function onThemeChanged() {
  if (getGlobal().settings.theme === 'system') {
    handlePrefersColorSchemeChange();
  }
}
;// ./src/hooks/useMediaQuery.ts
/**
 * Pulled from @react-hookz/web library source with some edits to match the code-style and use Teact
 * See https://github.com/react-hookz/web/blob/master/src/useMediaQuery/useMediaQuery.ts
 */


// eslint-disable-next-line @stylistic/max-len
const queriesMap = new Map();
const createQueryEntry = query => {
  const mql = matchMedia(query);
  const dispatchers = new Set();
  const listener = () => {
    dispatchers.forEach(d => d(mql.matches));
  };
  if (mql.addEventListener) mql.addEventListener('change', listener, {
    passive: true
  });else mql.addListener(listener);
  return {
    mql,
    dispatchers,
    listener
  };
};
const querySubscribe = (query, setState) => {
  let entry = queriesMap.get(query);
  if (!entry) {
    entry = createQueryEntry(query);
    queriesMap.set(query, entry);
  }
  entry.dispatchers.add(setState);
  setState(entry.mql.matches);
};
const queryUnsubscribe = (query, setState) => {
  const entry = queriesMap.get(query);
  if (!entry) {
    return;
  }
  const {
    mql,
    dispatchers,
    listener
  } = entry;
  dispatchers.delete(setState);
  if (!dispatchers.size) {
    queriesMap.delete(query);
    if (mql.removeEventListener) mql.removeEventListener('change', listener);else mql.removeListener(listener);
  }
};
/**
 * Tracks the state of CSS media query.
 *
 * @param query CSS media query to track.
 * @param options Hook options:
 * `initializeWithValue` (default: `true`) - Determine media query match state on first render. Setting
 * this to false will make the hook yield `undefined` on first render.
 */
function useMediaQuery(query, options) {
  function getInitialState() {
    if ((options === null || options === void 0 ? void 0 : options.initializeWithValue) ?? true) {
      let entry = queriesMap.get(query);
      if (!entry) {
        entry = createQueryEntry(query);
        queriesMap.set(query, entry);
      }
      return entry.mql.matches;
    }
    return undefined;
  }
  const [state, setState] = useState(getInitialState());
  teact_useEffect(() => {
    querySubscribe(query, setState);
    return () => queryUnsubscribe(query, setState);
  }, [query]);
  return state;
}
;// ./src/hooks/useDeviceScreen.ts


let isPortrait;
function useDeviceScreen() {
  isPortrait = useMediaQuery(`(max-width: ${src_config/* MOBILE_SCREEN_MAX_WIDTH */.c2m - 0.02}px)`);
  const isSmallHeight = useMediaQuery('(max-height: 43.5rem)');
  return {
    isPortrait: Boolean(isPortrait),
    isSmallHeight,
    isLandscape: !isPortrait,
    screenHeight: window.screen.height
  };
}
function getIsPortrait() {
  return isPortrait;
}
function getIsLandscape() {
  return !isPortrait;
}
;// ./src/hooks/useEffectWithPrevDeps.ts

const useEffectWithPrevDeps = (cb, dependencies, debugKey) => {
  const prevDepsRef = teact_useRef();
  return teact_useEffect(() => {
    const prevDeps = prevDepsRef.current;
    prevDepsRef.current = dependencies;
    return cb(prevDeps || []);
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, dependencies, debugKey);
};
/* harmony default export */ const hooks_useEffectWithPrevDeps = (useEffectWithPrevDeps);
;// ./src/hooks/useDelegatedBottomSheet.ts











const BLUR_TIMEOUT = 50;
const COMPACT_MODAL_CSS_SELECTOR = '.is-compact-modal';
const controlledByMain = new Map();
const textInputTypes = new Set(['color', 'date', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'text', 'time', 'url', 'week']);
let safeAreaCache;
const safeAreaPromise = SafeArea.getSafeAreaInsets().then(_ref => {
  let {
    insets
  } = _ref;
  safeAreaCache = insets;
  return safeAreaCache;
});
let currentKey;
if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
  void esm_BottomSheet.addListener('delegate', _ref2 => {
    var _controlledByMain$get;
    let {
      key,
      globalJson
    } = _ref2;
    currentKey = key;
    (_controlledByMain$get = controlledByMain.get(key)) === null || _controlledByMain$get === void 0 || _controlledByMain$get();
    setGlobal(JSON.parse(globalJson, bigint/* bigintReviver */.bk), {
      forceOutdated: true,
      forceSyncOnIOs: true
    });
  });
  void esm_BottomSheet.addListener('move', () => {
    window.dispatchEvent(new Event('viewportmove'));
  });
}
let isForcedFullSize;
function getIsForcedFullSize() {
  return isForcedFullSize;
}
function useDelegatedBottomSheet(key, isOpen, onClose, dialogRef) {
  let forceFullNative = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  let noResetHeightOnBlur = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  hooks_useEffectWithPrevDeps(_ref3 => {
    let [prevIsOpen] = _ref3;
    if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA || !key || key !== currentKey) return;
    if (isOpen) {
      const dialogEl = dialogRef.current;
      void esm_BottomSheet.openSelf({
        key,
        height: String(dialogEl.offsetHeight),
        backgroundColor: cssColorToHex(getComputedStyle(dialogEl).backgroundColor)
      }).then(() => {
        forceOnHeavyAnimationOnce();
        onClose();
      });
    } else if (prevIsOpen) {
      void esm_BottomSheet.closeSelf({
        key
      });
      setStatusBarStyle({
        forceDarkBackground: false
      });
    }
  }, [isOpen, dialogRef, key, onClose]);
  const isDelegatedAndOpen = windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && key && isOpen;
  const {
    screenHeight
  } = useDeviceScreen();
  const [safeArea, setSafeArea] = useState(safeAreaCache);
  void safeAreaPromise.then(setSafeArea);
  // We use Safe Area plugin instead of CSS `env()` function as it does not depend on modal position
  const maxHeight = screenHeight - ((safeArea === null || safeArea === void 0 ? void 0 : safeArea.top) || 0);
  useLayoutEffect(() => {
    if (!isDelegatedAndOpen) return;
    dialogRef.current.style[forceFullNative ? 'maxHeight' : 'height'] = '';
    dialogRef.current.style[forceFullNative ? 'height' : 'maxHeight'] = `${maxHeight}px`;
  }, [dialogRef, forceFullNative, isDelegatedAndOpen, maxHeight]);
  hooks_useEffectWithPrevDeps(_ref4 => {
    let [prevForceFullNative] = _ref4;
    if (!isDelegatedAndOpen) return;
    isForcedFullSize = forceFullNative;

    // Skip initial opening
    if (forceFullNative !== undefined && prevForceFullNative === undefined) return;
    void esm_BottomSheet.toggleSelfFullSize({
      isFullSize: forceFullNative
    });
  }, [forceFullNative, isDelegatedAndOpen]);
  useLayoutEffect(() => {
    if (!isDelegatedAndOpen) return undefined;
    const dialogEl = dialogRef.current;
    let blurTimeout;
    function onFocus(e) {
      if (!isInput(e.target)) {
        return;
      }
      if (blurTimeout) {
        clearTimeout(blurTimeout);
        blurTimeout = undefined;
        return;
      }
      preventScrollOnFocus(dialogEl);
      void esm_BottomSheet.toggleSelfFullSize({
        isFullSize: true
      });
    }
    function onBlur(e) {
      if (!isInput(e.target) || noResetHeightOnBlur || forceFullNative || isInCompactModal(e.target)) {
        return;
      }
      blurTimeout = window.setTimeout(() => {
        blurTimeout = undefined;
        void esm_BottomSheet.toggleSelfFullSize({
          isFullSize: false
        });
      }, BLUR_TIMEOUT);
    }
    document.addEventListener('focusin', onFocus);
    document.addEventListener('focusout', onBlur);
    return () => {
      document.removeEventListener('focusout', onBlur);
      document.removeEventListener('focusin', onFocus);
    };
  }, [dialogRef, forceFullNative, isDelegatedAndOpen, noResetHeightOnBlur]);
}
function useOpenFromMainBottomSheet(key, open) {
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return undefined;
    controlledByMain.set(key, open);
    if (currentKey === key) {
      open();
    }
    return () => {
      if (controlledByMain.get(key) === open) {
        controlledByMain.delete(key);
      }
    };
  }, [key, open]);
}
function openInMain(key) {
  void BottomSheet.openInMain({
    key
  });
}
function isInput(el) {
  if (!el || !(el instanceof HTMLElement)) return false;
  return el.tagName === 'INPUT' && textInputTypes.has(el.type) || el.tagName === 'TEXTAREA' || el.tagName === 'DIV' && el.isContentEditable;
}
function isInCompactModal(el) {
  if (!el || !(el instanceof HTMLElement)) return false;
  return el.matches(COMPACT_MODAL_CSS_SELECTOR) || !!el.closest('.is-compact-modal');
}
function preventScrollOnFocus(el) {
  el.style.opacity = '0';
  setTimeout(() => {
    el.style.opacity = '1';
  });
  document.documentElement.scrollTop = 0;
}
;// ./src/hooks/useDelegatingBottomSheet.ts







const RACE_TIMEOUT = 1000;
const CLOSING_DURATION = 100;
const controlledByNative = new Map();
if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
  void esm_BottomSheet.prepare();
  void esm_BottomSheet.addListener('openInMain', _ref => {
    var _controlledByNative$g;
    let {
      key
    } = _ref;
    (_controlledByNative$g = controlledByNative.get(key)) === null || _controlledByNative$g === void 0 || _controlledByNative$g();
  });
}
let lastOpenCall = Promise.resolve();
let closeCurrent;
function useDelegatingBottomSheet(key, isPortrait, isOpen, onClose) {
  const isDelegating = windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI && key;
  const shouldOpen = isOpen && isPortrait;
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevShouldOpen] = _ref2;
    if (!isDelegating) return;
    if (shouldOpen) {
      var _closeCurrent;
      (_closeCurrent = closeCurrent) === null || _closeCurrent === void 0 || _closeCurrent();
      const closeNext = () => {
        forceOnHeavyAnimationOnce();
        onClose();
      };
      closeCurrent = closeNext;

      // Wait until previous call resolves to get an up-to-date global
      lastOpenCall = Promise.race([lastOpenCall, (0,schedulers/* pause */.v7)(RACE_TIMEOUT) // Sometimes the last open call is stuck for some unknown reason
      ]).then(() => {
        return esm_BottomSheet.delegate({
          key,
          globalJson: JSON.stringify(getGlobal())
        });
      }).then(() => {
        if (closeCurrent === closeNext) {
          closeCurrent();
          closeCurrent = undefined;
        }
      }).then(() => (0,schedulers/* pause */.v7)(CLOSING_DURATION));
    } else if (prevShouldOpen) {
      void esm_BottomSheet.release({
        key
      });
    }
  }, [shouldOpen, isDelegating, key, onClose]);
  return isDelegating && isPortrait;
}
function useOpenFromNativeBottomSheet(key, open) {
  useEffect(() => {
    if (!IS_DELEGATING_BOTTOM_SHEET) return undefined;
    controlledByNative.set(key, open);
    return () => {
      if (controlledByNative.get(key) === open) {
        controlledByNative.delete(key);
      }
    };
  }, [key, open]);
}
;// ./src/hooks/useHideBrowser.ts





function useHideBrowser(isOpen, isCompact) {
  useSyncEffect(() => {
    if (!src_config/* IS_CAPACITOR */.UMQ || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA || isCompact) return;
    const browser = getInAppBrowser();
    if (!browser) return;
    if (isOpen && browser) {
      void browser.hide().then(async () => {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          await esm_BottomSheet.enable();
        }
      });
    }
  }, [isCompact, isOpen]);
}
;// ./src/util/telegram/backButtonManager.ts



const runDebounce = (0,schedulers/* debounce */.sg)(cb => cb(), 300, false);
const backButtonManager_callbacks = [];
let isGlobalHandlerAttached = false;
let uniqueId = 0;
function getNextId() {
  uniqueId += 1;
  return uniqueId;
}
function updateBackButtonState() {
  const backButton = telegram_getTelegramApp().BackButton;
  if (backButtonManager_callbacks.length > 0 && !isGlobalHandlerAttached) {
    backButton.show();
    backButton.onClick(handleBackButtonClick);
    isGlobalHandlerAttached = true;
  } else if (!backButtonManager_callbacks.length && isGlobalHandlerAttached) {
    backButton.hide();
    backButton.offClick(handleBackButtonClick);
    isGlobalHandlerAttached = false;
  }
}
function registerCallback(cb) {
  const id = getNextId();
  backButtonManager_callbacks.push({
    id,
    callback: cb
  });
  runDebounce(updateBackButtonState);
  return id;
}
function unregisterCallback(id) {
  const index = backButtonManager_callbacks.findIndex(entry => entry.id === id);
  if (index !== -1) {
    backButtonManager_callbacks.splice(index, 1);
    runDebounce(updateBackButtonState);
  }
}
function handleBackButtonClick() {
  if (backButtonManager_callbacks.length > 0) {
    const entry = backButtonManager_callbacks.pop();
    try {
      entry.callback();
    } catch (err) {
      (0,logs/* logDebugError */.SJ)('[handleBackButtonClick]', err);
    }
  }
  runDebounce(updateBackButtonState);
}
;// ./src/hooks/useHistoryBack.ts








const PATH_BASE = `${window.location.pathname}${window.location.search}`;
// Needed to dismiss any 'trashed' history records from the previous page reloads.
const historyUniqueSessionId = Number(new Date());
// Reflects real history state, but also contains information on which records should be replaced by the next record and
// which records are deferred to close on the next operation
let historyState;
// Reflects current real history index
let historyCursor;
// If we alter real history programmatically, the popstate event will be fired, which we don't need
let isAlteringHistory = false;
// Unfortunately Safari doesn't really like when there's 2+ consequent history operations in one frame, so we need
// to delay them to the next raf
let deferredHistoryOperations = [];
let deferredPopstateOperations = [];

// Do not remove: used for history unit tests
if (src_config/* IS_TEST */.W75) {
  window.TEST_getHistoryState = () => historyState;
  window.TEST_getHistoryCursor = () => historyCursor;
}
function applyDeferredHistoryOperations() {
  const goOperations = deferredHistoryOperations.filter(op => op.type === 'go');
  const stateOperations = deferredHistoryOperations.filter(op => op.type !== 'go');
  const goCount = goOperations.reduce((acc, op) => acc + op.delta, 0);
  deferredHistoryOperations = [];
  if (goCount) {
    window.history.go(goCount);

    // If we have some `state` operations after the `go` operations, we need to wait until the popstate event
    // so the order of operations is correctly preserved
    if (stateOperations.length) {
      deferredPopstateOperations.push(...stateOperations);
      return;
    }
  }
  processStateOperations(stateOperations);
}
function processStateOperations(stateOperations) {
  stateOperations.forEach(op => window.history[op.type](op.data, ''));
}
function deferHistoryOperation(historyOperation) {
  if (!deferredHistoryOperations.length) {
    (0,fasterdom/* requestMeasure */.YS)(applyDeferredHistoryOperations);
  }
  deferredHistoryOperations.push(historyOperation);
}

// Resets history to the `root` state
function resetHistory() {
  historyCursor = 0;
  historyState = [{
    index: 0,
    onBack: () => window.history.back()
  }];
  if (!windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe) {
    window.history.replaceState({
      index: 0,
      historyUniqueSessionId
    }, '', PATH_BASE);
  }
}
resetHistory();
function cleanupClosed() {
  let alreadyClosedCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
  let countClosed = alreadyClosedCount;
  for (let i = historyCursor - 1; i > 0; i--) {
    if (!historyState[i].isClosed) break;
    countClosed++;
  }
  if (countClosed) {
    isAlteringHistory = true;
    deferHistoryOperation({
      type: 'go',
      delta: -countClosed
    });
  }
  return countClosed;
}
function cleanupTrashedState() {
  for (let i = historyState.length - 1; i > 0; i--) {
    var _historyState$i$onBac, _historyState$i;
    if (historyState[i].isClosed) {
      continue;
    }
    (_historyState$i$onBac = (_historyState$i = historyState[i]).onBack) === null || _historyState$i$onBac === void 0 || _historyState$i$onBac.call(_historyState$i);
  }
  resetHistory();
}
window.addEventListener('popstate', _ref => {
  let {
    state
  } = _ref;
  if (isAlteringHistory) {
    isAlteringHistory = false;
    if (deferredPopstateOperations.length) {
      processStateOperations(deferredPopstateOperations);
      deferredPopstateOperations = [];
    }
    return;
  }
  if (!state) {
    cleanupTrashedState();
    return;
  }
  const {
    index,
    historyUniqueSessionId: previousUniqueSessionId
  } = state;
  if (previousUniqueSessionId !== historyUniqueSessionId) {
    cleanupTrashedState();
    return;
  }

  // New real history state matches the old virtual one. Not possible in theory, but in practice we have Safari
  if (index === historyCursor) {
    return;
  }
  if (index < historyCursor) {
    // Navigating back
    let alreadyClosedCount = 0;
    for (let i = historyCursor; i > index - alreadyClosedCount; i--) {
      var _historyState$i$onBac2, _historyState$i2;
      if (historyState[i].isClosed) {
        alreadyClosedCount++;
        continue;
      }
      (_historyState$i$onBac2 = (_historyState$i2 = historyState[i]).onBack) === null || _historyState$i$onBac2 === void 0 || _historyState$i$onBac2.call(_historyState$i2);
    }
    const countClosed = cleanupClosed(alreadyClosedCount);
    historyCursor += index - historyCursor - countClosed;

    // Can happen when we have deferred a real back for some element (for example Menu), closed via UI,
    // pressed back button and caused a pushState.
    if (historyCursor < 0) {
      historyCursor = 0;
    }
  } else if (index > historyCursor) {
    // Forward navigation is not yet supported
    isAlteringHistory = true;
    deferHistoryOperation({
      type: 'go',
      delta: -(index - historyCursor)
    });
  }
});
function useHistoryBack(_ref2) {
  let {
    isActive,
    shouldBeReplaced,
    shouldIgnoreForTelegram,
    onBack
  } = _ref2;
  const lastOnBack = useLastCallback(onBack);

  // Active index of the record
  const indexRef = teact_useRef();
  const telegramIdRef = teact_useRef();
  const wasReplaced = teact_useRef(false);
  const isFirstRender = teact_useRef(true);
  const pushState = teact_useCallback(function () {
    let forceReplace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    // Check if the old state should be replaced
    const shouldReplace = forceReplace || historyState[historyCursor].shouldBeReplaced;
    indexRef.current = shouldReplace ? historyCursor : ++historyCursor;
    historyCursor = indexRef.current;

    // Mark the previous record as replaced so effectBack doesn't perform back operation on the new record
    const previousRecord = historyState[indexRef.current];
    if (previousRecord && !previousRecord.isClosed) {
      var _previousRecord$markR;
      (_previousRecord$markR = previousRecord.markReplaced) === null || _previousRecord$markR === void 0 || _previousRecord$markR.call(previousRecord);
    }
    historyState[indexRef.current] = {
      index: indexRef.current,
      onBack: lastOnBack,
      shouldBeReplaced,
      markReplaced: () => {
        wasReplaced.current = true;
      }
    };
    deferHistoryOperation({
      type: shouldReplace ? 'replaceState' : 'pushState',
      data: {
        index: indexRef.current,
        historyUniqueSessionId
      }
    });
  }, [lastOnBack, shouldBeReplaced]);
  const processBack = teact_useCallback(() => {
    // Only process back on open records
    if (indexRef.current && historyState[indexRef.current] && !wasReplaced.current) {
      historyState[indexRef.current].isClosed = true;
      wasReplaced.current = true;
      if (indexRef.current === historyCursor && !shouldBeReplaced) {
        historyCursor -= cleanupClosed();
      }
    }
  }, [shouldBeReplaced]);

  // Process back navigation when element is unmounted
  hooks_useEffectOnce(() => {
    if (windowEnvironment/* IS_IOS */.pz) return undefined;
    isFirstRender.current = false;
    return () => {
      if (!isActive || wasReplaced.current) return;
      processBack();
    };
  });
  useSyncEffect(_ref3 => {
    let [prevIsActive] = _ref3;
    if (windowEnvironment/* IS_IOS */.pz) return;
    if (prevIsActive === isActive) return;
    if (isFirstRender.current && !isActive) return;
    if (isActive) {
      pushState();
    } else {
      processBack();
    }
  }, [isActive, processBack, pushState]);
  teact_useEffect(() => {
    if (!src_config/* IS_TELEGRAM_APP */.tKX || shouldIgnoreForTelegram || !isActive) return undefined;
    telegramIdRef.current = registerCallback(lastOnBack);
    return () => {
      if (telegramIdRef.current !== undefined) {
        unregisterCallback(telegramIdRef.current);
        telegramIdRef.current = undefined;
      }
    };
  }, [isActive, shouldIgnoreForTelegram, onBack]);
}
;// ./src/lib/teact/dom-events.ts

const NON_BUBBLEABLE_EVENTS = new Set(['scroll', 'mouseenter', 'mouseleave', 'load', 'error']);
const documentEventCounters = {};
const delegationRegistryByEventType = {};
const delegatedEventTypesByElement = new Map();
function addEventListener(element, propName, handler) {
  let asCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const eventType = resolveEventType(propName, element);
  if (canUseEventDelegation(eventType, element, asCapture)) {
    addDelegatedListener(eventType, element, handler);
  } else {
    element.addEventListener(eventType, handler, asCapture);
  }
}
function removeEventListener(element, propName, handler) {
  let asCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const eventType = resolveEventType(propName, element);
  if (canUseEventDelegation(eventType, element, asCapture)) {
    removeDelegatedListener(eventType, element);
  } else {
    element.removeEventListener(eventType, handler, asCapture);
  }
}
function resolveEventType(propName, element) {
  const eventType = propName.replace(/^on/, '').replace(/Capture$/, '').toLowerCase();
  if (eventType === 'change' && element.tagName !== 'SELECT') {
    // React behavior repeated here.
    // https://stackoverflow.com/questions/38256332/in-react-whats-the-difference-between-onchange-and-oninput
    return 'input';
  }
  if (eventType === 'doubleclick') {
    return 'dblclick';
  }

  // Replace focus/blur by their "bubbleable" versions
  if (eventType === 'focus') {
    return 'focusin';
  }
  if (eventType === 'blur') {
    return 'focusout';
  }
  return eventType;
}
function canUseEventDelegation(realEventType, element, asCapture) {
  return !asCapture && !NON_BUBBLEABLE_EVENTS.has(realEventType) && element.tagName !== 'VIDEO' && element.tagName !== 'IFRAME';
}
function addDelegatedListener(eventType, element, handler) {
  if (!documentEventCounters[eventType]) {
    documentEventCounters[eventType] = 0;
    document.addEventListener(eventType, handleEvent);
  }
  resolveDelegationRegistry(eventType).set(element, handler);
  resolveDelegatedEventTypes(element).add(eventType);
  documentEventCounters[eventType]++;
}
function removeDelegatedListener(eventType, element) {
  documentEventCounters[eventType]--;
  if (!documentEventCounters[eventType]) {
    // Synchronous deletion on 0 will cause perf degradation in the case of 1 element
    // which is not a real case, so it's ok to do it this way
    document.removeEventListener(eventType, handleEvent);
  }
  delegationRegistryByEventType[eventType].delete(element);
  delegatedEventTypesByElement.get(element).delete(eventType);
}
function removeAllDelegatedListeners(element) {
  const eventTypes = delegatedEventTypesByElement.get(element);
  if (!eventTypes) {
    return;
  }
  eventTypes.forEach(eventType => removeDelegatedListener(eventType, element));
  delegatedEventTypesByElement.delete(element);
}
function handleEvent(realEvent) {
  const events = delegationRegistryByEventType[realEvent.type];
  if (events) {
    let furtherCallsPrevented = false;
    let current = realEvent.target;
    const stopPropagation = () => {
      furtherCallsPrevented = true;
    };
    const preventDefault = () => {
      realEvent.preventDefault();
    };

    // Proxy is a simplest way to provide an access to the event property
    const event = new Proxy(realEvent, {
      get(target, p) {
        if (p === 'currentTarget') {
          return current;
        }
        if (p === 'stopPropagation' || p === 'stopImmediatePropagation') {
          return stopPropagation;
        }
        if (p === 'preventDefault') {
          // "this" is changed to proxy and one can't call methods via it
          return preventDefault;
        }
        return Reflect.get(target, p);
      }
    });

    // This can also be limited by teact root
    while (current && current !== document.body) {
      const handler = events.get(current);
      if (handler) {
        handler(event);
        if (furtherCallsPrevented) {
          return;
        }
      }
      current = current.parentNode;
    }
  }
}
function resolveDelegationRegistry(eventType) {
  if (!delegationRegistryByEventType[eventType]) {
    delegationRegistryByEventType[eventType] = new Map();
  }
  return delegationRegistryByEventType[eventType];
}
function resolveDelegatedEventTypes(element) {
  const existing = delegatedEventTypesByElement.get(element);
  if (existing) {
    return existing;
  }
  const newSet = new Set();
  delegatedEventTypesByElement.set(element, newSet);
  return newSet;
}
if (src_config/* DEBUG */.Oig) {
  document.addEventListener('dblclick', () => {
    const documentListenersCount = Object.keys(documentEventCounters).length;
    const delegatedHandlersCount1 = Object.values(documentEventCounters).reduce((acc, counter) => acc + counter, 0);
    const delegationRegistriesCount = Object.keys(delegationRegistryByEventType).length;
    const delegatedHandlersCount2 = Object.values(delegationRegistryByEventType).reduce((acc, delegationRegistry) => acc + delegationRegistry.size, 0);
    const delegationElementsCount = delegatedEventTypesByElement.size;
    const delegatedEventTypesCount = Array.from(delegatedEventTypesByElement.values()).reduce((acc, eventTypes) => acc + eventTypes.size, 0);

    // eslint-disable-next-line no-console
    console.warn('DELEGATED EVENTS STATS', {
      delegatedHandlersCount1,
      delegatedHandlersCount2,
      delegatedEventTypesCount,
      delegationRegistriesCount,
      delegationElementsCount,
      documentListenersCount
    });
  });
}
;// ./src/lib/teact/teact-dom.ts




const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
const FILTERED_ATTRIBUTES = new Set(['key', 'ref', 'teactFastList', 'teactOrderKey']);
const HTML_ATTRIBUTES = new Set(['dir', 'role', 'form']);
const CONTROLLABLE_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];
const MAPPED_ATTRIBUTES = {
  autoCapitalize: 'autocapitalize',
  autoComplete: 'autocomplete',
  autoCorrect: 'autocorrect',
  autoPlay: 'autoplay',
  spellCheck: 'spellcheck'
};
const INDEX_KEY_PREFIX = '__indexKey#';
const SELECTION_STATE_ATTRIBUTE = '__teactSelectionState';
const headsByElement = new WeakMap();
const extraClasses = new WeakMap();
const extraStyles = new WeakMap();
let DEBUG_virtualTreeSize = 1;
function render($element, parentEl) {
  if (!headsByElement.has(parentEl)) {
    headsByElement.set(parentEl, {
      children: []
    });
  }
  const runImmediateEffects = captureImmediateEffects();
  const $head = headsByElement.get(parentEl);
  const $renderedChild = renderWithVirtual(parentEl, $head.children[0], $element, $head, {}, 0);
  runImmediateEffects === null || runImmediateEffects === void 0 || runImmediateEffects();
  $head.children = $renderedChild ? [$renderedChild] : [];
  if (false) // removed by dead control flow
{}
  return undefined;
}
function renderWithVirtual(parentEl, $current, $new, $parent, currentContext, index) {
  var _$new, _$new2, _$new3;
  let options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
  const {
    skipComponentUpdate,
    fragment
  } = options;
  let {
    nextSibling,
    namespace
  } = options;
  const isCurrentComponent = ($current === null || $current === void 0 ? void 0 : $current.type) === VirtualType.Component;
  const isNewComponent = ((_$new = $new) === null || _$new === void 0 ? void 0 : _$new.type) === VirtualType.Component;
  const $newAsReal = $new;
  const isCurrentFragment = !isCurrentComponent && ($current === null || $current === void 0 ? void 0 : $current.type) === VirtualType.Fragment;
  const isNewFragment = !isNewComponent && ((_$new2 = $new) === null || _$new2 === void 0 ? void 0 : _$new2.type) === VirtualType.Fragment;
  if (((_$new3 = $new) === null || _$new3 === void 0 ? void 0 : _$new3.type) === VirtualType.Tag) {
    if ($new.tag === 'svg') namespace = SVG_NAMESPACE;
    if ($new.props.xmlns) namespace = $new.props.xmlns;
  }
  if (!skipComponentUpdate && isCurrentComponent && isNewComponent && !hasElementChanged($current, $new)) {
    $new = updateComponent($current, $new);
  }

  // Parent element may have changed, so we need to update the listener closure.
  if (!skipComponentUpdate && isNewComponent && $new.componentInstance.mountState === MountState.Mounted) {
    setupComponentUpdateListener(parentEl, $new, $parent, currentContext, index);
  }
  if ($current === $new) {
    return $new;
  }
  if (src_config/* DEBUG */.Oig && $new) {
    const newTarget = 'target' in $new && $new.target;
    if (newTarget && (!$current || 'target' in $current && newTarget !== $current.target)) {
      throw new Error('[Teact] Cached virtual element was moved within tree');
    }
  }
  if (!$current && $new) {
    if (isNewComponent || isNewFragment) {
      if (isNewComponent) {
        $new = initComponent(parentEl, $new, $parent, currentContext, index);
        currentContext = $new.componentInstance.context ?? currentContext;
      }
      mountChildren(parentEl, $new, currentContext, {
        nextSibling,
        fragment,
        namespace
      });
    } else {
      const canSetTextContent = !fragment && !nextSibling && $newAsReal.type === VirtualType.Text && $parent.children.length === 1 && !parentEl.firstChild;
      if (canSetTextContent) {
        parentEl.textContent = $newAsReal.value;
        $newAsReal.target = parentEl.firstChild;
      } else {
        const node = createNode($newAsReal, currentContext, namespace);
        $newAsReal.target = node;
        insertBefore(fragment || parentEl, node, nextSibling);
        if ($newAsReal.type === VirtualType.Tag) {
          setElementRef($newAsReal, node);
        }
      }
    }
  } else if ($current && !$new) {
    remount(parentEl, $current, currentContext, undefined);
  } else if ($current && $new) {
    if (hasElementChanged($current, $new)) {
      if (!nextSibling) {
        nextSibling = getNextSibling($current);
      }
      if (isNewComponent || isNewFragment) {
        if (isNewComponent) {
          $new = initComponent(parentEl, $new, $parent, currentContext, index);
          currentContext = $new.componentInstance.context ?? currentContext;
        }
        remount(parentEl, $current, currentContext, undefined);
        mountChildren(parentEl, $new, currentContext, {
          nextSibling,
          fragment,
          namespace
        });
      } else {
        const node = createNode($newAsReal, currentContext, namespace);
        $newAsReal.target = node;
        remount(parentEl, $current, currentContext, node, nextSibling);
        if ($newAsReal.type === VirtualType.Tag) {
          setElementRef($newAsReal, node);
        }
      }
    } else {
      const isComponent = isCurrentComponent && isNewComponent;
      const isFragment = isCurrentFragment && isNewFragment;
      if (isComponent || isFragment) {
        renderChildren($current, $new, currentContext, parentEl, nextSibling, options.forceMoveToEnd);
      } else {
        const $currentAsReal = $current;
        const currentTarget = $currentAsReal.target;
        $newAsReal.target = currentTarget;
        $currentAsReal.target = undefined; // Help GC

        const isTag = $current.type === VirtualType.Tag;
        if (isTag) {
          const $newAsTag = $new;
          setElementRef($current, undefined);
          setElementRef($newAsTag, currentTarget);
          if (nextSibling || options.forceMoveToEnd) {
            insertBefore(parentEl, currentTarget, nextSibling);
          }
          updateAttributes($current, $newAsTag, currentTarget, namespace);
          renderChildren($current, $newAsTag, currentContext, currentTarget, undefined, undefined, namespace);
        }
      }
    }
  }
  return $new;
}
function initComponent(parentEl, $element, $parent, currentContext, index) {
  const {
    componentInstance
  } = $element;
  $element.componentInstance.context = currentContext;
  if (componentInstance.mountState === MountState.Unmounted) {
    $element = mountComponent(componentInstance);
    setupComponentUpdateListener(parentEl, $element, $parent, currentContext, index);
  }
  return $element;
}
function updateComponent($current, $new) {
  $current.componentInstance.props = $new.componentInstance.props;
  return renderComponent($current.componentInstance);
}
function setupComponentUpdateListener(parentEl, $element, $parent, currentContext, index) {
  const {
    componentInstance
  } = $element;
  componentInstance.onUpdate = () => {
    $parent.children[index] = renderWithVirtual(parentEl, $parent.children[index], componentInstance.$element, $parent, currentContext, index, {
      skipComponentUpdate: true
    });
  };
}
function mountChildren(parentEl, $element, currentContext, options) {
  const {
    children
  } = $element;

  // Add a placeholder comment node for empty fragments to maintain position
  if ($element.type === VirtualType.Fragment && children.length === 0) {
    const fragmentEl = $element;
    fragmentEl.placeholderTarget = document.createComment('empty-fragment');
    insertBefore(options.fragment || parentEl, fragmentEl.placeholderTarget, options.nextSibling);
    return;
  }
  for (let i = 0, l = children.length; i < l; i++) {
    const $child = children[i];
    const $renderedChild = renderWithVirtual(parentEl, undefined, $child, $element, currentContext, i, options);
    if ($renderedChild !== $child) {
      children[i] = $renderedChild;
    }
  }
}
function unmountChildren(parentEl, $element, currentContext) {
  for (const $child of $element.children) {
    renderWithVirtual(parentEl, $child, undefined, $element, currentContext, -1);
  }
}
function createNode($element, currentContext) {
  let namespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : HTML_NAMESPACE;
  if ($element.type === VirtualType.Empty) {
    return document.createTextNode('');
  }
  if ($element.type === VirtualType.Text) {
    return document.createTextNode($element.value);
  }
  const {
    tag,
    props,
    children
  } = $element;
  const element = document.createElementNS(namespace, tag);
  processControlled(tag, props);
  for (const key in props) {
    if (!props.hasOwnProperty(key)) continue;
    if (props[key] !== undefined) {
      setAttribute(element, key, props[key], namespace);
    }
  }
  processUncontrolledOnMount(element, props);
  for (let i = 0, l = children.length; i < l; i++) {
    const $child = children[i];
    const $renderedChild = renderWithVirtual(element, undefined, $child, $element, currentContext, i, {
      namespace
    });
    if ($renderedChild !== $child) {
      children[i] = $renderedChild;
    }
  }
  return element;
}
function remount(parentEl, $current, currentContext, node, componentNextSibling) {
  const isComponent = $current.type === VirtualType.Component;
  const isFragment = !isComponent && $current.type === VirtualType.Fragment;
  if (isComponent || isFragment) {
    if (isComponent) {
      unmountComponent($current.componentInstance);
    }
    unmountChildren(parentEl, $current, currentContext);
    if (node) {
      insertBefore(parentEl, node, componentNextSibling);
    }
  } else {
    if (node) {
      parentEl.replaceChild(node, $current.target);
    } else {
      parentEl.removeChild($current.target);
    }
    unmountRealTree($current);
  }
}
function unmountRealTree($element) {
  if ($element.type === VirtualType.Component) {
    unmountComponent($element.componentInstance);
  } else if ($element.type === VirtualType.Fragment) {
    // Remove placeholder for empty fragments
    const fragment = $element;
    if (fragment.placeholderTarget && fragment.children.length === 0) {
      var _fragment$placeholder;
      (_fragment$placeholder = fragment.placeholderTarget.parentNode) === null || _fragment$placeholder === void 0 || _fragment$placeholder.removeChild(fragment.placeholderTarget);
      fragment.placeholderTarget = undefined;
    }
  } else {
    if ($element.type === VirtualType.Tag) {
      extraClasses.delete($element.target);
      setElementRef($element, undefined);
      removeAllDelegatedListeners($element.target);
    }
    $element.target = undefined; // Help GC

    if ($element.type !== VirtualType.Tag) {
      return;
    }
  }
  for (const $child of $element.children) {
    unmountRealTree($child);
  }
}
function insertBefore(parentEl, node, nextSibling) {
  if (nextSibling) {
    parentEl.insertBefore(node, nextSibling);
  } else {
    parentEl.appendChild(node);
  }
}
function getNextSibling($current) {
  if ($current.type === VirtualType.Component || $current.type === VirtualType.Fragment) {
    if ($current.children.length === 0) {
      // For empty fragments, use the placeholder node to track position
      const fragment = $current;
      if (fragment.placeholderTarget) {
        return fragment.placeholderTarget.nextSibling || undefined;
      }
      return undefined;
    }
    const lastChild = $current.children[$current.children.length - 1];
    return getNextSibling(lastChild);
  }
  return $current.target.nextSibling || undefined;
}
function renderChildren($current, $new, currentContext, currentEl, nextSibling) {
  let forceMoveToEnd = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  let namespace = arguments.length > 6 ? arguments[6] : undefined;
  if (src_config/* DEBUG */.Oig) {
    DEBUG_checkKeyUniqueness($new.children);
  }
  if ('props' in $new && $new.props.teactFastList) {
    renderFastListChildren($current, $new, currentContext, currentEl);
    return;
  }

  // Handle transitions between empty and non-empty fragments
  if ($current.type === VirtualType.Fragment && $new.type === VirtualType.Fragment) {
    const currentFragment = $current;
    const newFragment = $new;

    // If transitioning from empty to non-empty, use the placeholder's position
    if (currentFragment.children.length === 0 && newFragment.children.length > 0 && currentFragment.placeholderTarget) {
      var _currentFragment$plac;
      nextSibling = currentFragment.placeholderTarget.nextSibling || undefined;
      // Remove the placeholder as we're adding real content
      (_currentFragment$plac = currentFragment.placeholderTarget.parentNode) === null || _currentFragment$plac === void 0 || _currentFragment$plac.removeChild(currentFragment.placeholderTarget);
      currentFragment.placeholderTarget = undefined;
    }

    // If transitioning from non-empty to empty, add a placeholder
    if (currentFragment.children.length > 0 && newFragment.children.length === 0) {
      const lastCurrentChild = currentFragment.children[currentFragment.children.length - 1];
      const siblingAfterFragment = getNextSibling(lastCurrentChild);
      newFragment.placeholderTarget = document.createComment('empty-fragment');
      insertBefore(currentEl, newFragment.placeholderTarget, siblingAfterFragment);
    }
  }
  const currentChildren = $current.children;
  const newChildren = $new.children;
  const currentChildrenLength = currentChildren.length;
  const newChildrenLength = newChildren.length;
  const maxLength = Math.max(currentChildrenLength, newChildrenLength);
  const fragment = newChildrenLength > currentChildrenLength ? document.createDocumentFragment() : undefined;
  const lastCurrentChild = $current.children[currentChildrenLength - 1];
  const fragmentNextSibling = fragment && (nextSibling || (lastCurrentChild ? getNextSibling(lastCurrentChild) : undefined));
  for (let i = 0; i < maxLength; i++) {
    const $renderedChild = renderWithVirtual(currentEl, currentChildren[i], newChildren[i], $new, currentContext, i, i >= currentChildrenLength ? {
      fragment,
      namespace
    } : {
      nextSibling,
      forceMoveToEnd,
      namespace
    });
    if ($renderedChild && $renderedChild !== newChildren[i]) {
      newChildren[i] = $renderedChild;
    }
  }
  if (fragment) {
    insertBefore(currentEl, fragment, fragmentNextSibling);
  }
}

// This function allows to prepend/append a bunch of new DOM nodes to the top/bottom of preserved ones.
// It also allows to selectively move particular preserved nodes within their DOM list.
function renderFastListChildren($current, $new, currentContext, currentEl) {
  const currentChildren = $current.children;
  const newChildren = $new.children;
  const newKeys = new Set();
  for (const $newChild of newChildren) {
    const key = 'props' in $newChild ? $newChild.props.key : undefined;
    if (src_config/* DEBUG */.Oig && teact_isParentElement($newChild)) {
      // eslint-disable-next-line no-null/no-null
      if (key === undefined || key === null) {
        // eslint-disable-next-line no-console
        console.warn('Missing `key` in `teactFastList`');
      }
      if ($newChild.type === VirtualType.Fragment) {
        throw new Error('[Teact] Fragment can not be child of container with `teactFastList`');
      }
    }
    newKeys.add(key);
  }

  // Build a collection of old children that also remain in the new list
  let currentRemainingIndex = 0;
  const remainingByKey = {};
  for (let i = 0, l = currentChildren.length; i < l; i++) {
    const $currentChild = currentChildren[i];
    let key = 'props' in $currentChild ? $currentChild.props.key : undefined;
    // eslint-disable-next-line no-null/no-null
    const isKeyPresent = key !== undefined && key !== null;

    // First we process removed children
    if (isKeyPresent && !newKeys.has(key)) {
      renderWithVirtual(currentEl, $currentChild, undefined, $new, currentContext, -1);
      continue;
    } else if (!isKeyPresent) {
      const $newChild = newChildren[i];
      const newChildKey = $newChild && 'props' in $newChild ? $newChild.props.key : undefined;
      // If a non-key element remains at the same index we preserve it with a virtual `key`
      if ($newChild && !newChildKey) {
        key = `${INDEX_KEY_PREFIX}${i}`;
        // Otherwise, we just remove it
      } else {
        renderWithVirtual(currentEl, $currentChild, undefined, $new, currentContext, -1);
        continue;
      }
    }

    // Then we build up info about remaining children
    remainingByKey[key] = {
      $element: $currentChild,
      index: currentRemainingIndex++,
      orderKey: 'props' in $currentChild ? $currentChild.props.teactOrderKey : undefined
    };
  }
  let fragmentIndex;
  let fragmentSize;
  let currentPreservedIndex = 0;
  for (let i = 0, l = newChildren.length; i < l; i++) {
    const $newChild = newChildren[i];
    const key = 'props' in $newChild ? $newChild.props.key : `${INDEX_KEY_PREFIX}${i}`;
    const currentChildInfo = remainingByKey[key];
    if (!currentChildInfo) {
      if (fragmentSize === undefined) {
        fragmentIndex = i;
        fragmentSize = 0;
      }
      fragmentSize++;
      continue;
    }

    // This prepends new children to the top
    if (fragmentSize) {
      renderFragment(fragmentIndex, fragmentSize, currentEl, $new, currentContext);
      fragmentSize = undefined;
      fragmentIndex = undefined;
    }

    // Now we check if a preserved node was moved within preserved list
    const newOrderKey = 'props' in $newChild ? $newChild.props.teactOrderKey : undefined;
    // That is indicated by a changed `teactOrderKey` value
    const shouldMoveNode = currentChildInfo.index !== currentPreservedIndex && (!newOrderKey || currentChildInfo.orderKey !== newOrderKey);
    const isMovingDown = shouldMoveNode && currentPreservedIndex > currentChildInfo.index;
    if (!shouldMoveNode || isMovingDown) {
      currentPreservedIndex++;
    }
    const nextSibling = currentEl.childNodes[isMovingDown ? i + 1 : i];
    const options = shouldMoveNode ? nextSibling ? {
      nextSibling
    } : {
      forceMoveToEnd: true
    } : undefined;
    const $renderedChild = renderWithVirtual(currentEl, currentChildInfo.$element, $newChild, $new, currentContext, i, options);
    if ($renderedChild !== $newChild) {
      newChildren[i] = $renderedChild;
    }
  }

  // This appends new children to the bottom
  if (fragmentSize) {
    renderFragment(fragmentIndex, fragmentSize, currentEl, $new, currentContext);
  }
}
function renderFragment(fragmentIndex, fragmentSize, parentEl, $parent, currentContext) {
  const nextSibling = parentEl.childNodes[fragmentIndex];
  if (fragmentSize === 1) {
    const $child = $parent.children[fragmentIndex];
    const $renderedChild = renderWithVirtual(parentEl, undefined, $child, $parent, currentContext, fragmentIndex, {
      nextSibling
    });
    if ($renderedChild !== $child) {
      $parent.children[fragmentIndex] = $renderedChild;
    }
    return;
  }
  const fragment = document.createDocumentFragment();
  for (let i = fragmentIndex; i < fragmentIndex + fragmentSize; i++) {
    const $child = $parent.children[i];
    const $renderedChild = renderWithVirtual(parentEl, undefined, $child, $parent, currentContext, i, {
      fragment
    });
    if ($renderedChild !== $child) {
      $parent.children[i] = $renderedChild;
    }
  }
  insertBefore(parentEl, fragment, nextSibling);
}
function setElementRef($element, element) {
  const {
    ref
  } = $element.props;
  if (typeof ref === 'object') {
    var _ref$onChange;
    ref.current = element;
    (_ref$onChange = ref.onChange) === null || _ref$onChange === void 0 || _ref$onChange.call(ref);
  } else if (typeof ref === 'function') {
    ref(element);
  }
}
function processControlled(tag, props) {
  const isValueControlled = props.value !== undefined;
  const isCheckedControlled = props.checked !== undefined;
  const isControlled = (isValueControlled || isCheckedControlled) && CONTROLLABLE_TAGS.includes(tag.toUpperCase());
  if (!isControlled) {
    return;
  }
  const {
    value,
    checked,
    onInput,
    onChange,
    onBlur
  } = props;
  props.onChange = undefined;
  props.onInput = e => {
    onInput === null || onInput === void 0 || onInput(e);
    onChange === null || onChange === void 0 || onChange(e);
    if (value !== undefined && value !== e.currentTarget.value) {
      const {
        selectionStart,
        selectionEnd
      } = e.currentTarget;
      const isCaretAtEnd = selectionStart === selectionEnd && selectionEnd === e.currentTarget.value.length;
      e.currentTarget.value = value;
      if (typeof selectionStart === 'number' && typeof selectionEnd === 'number') {
        e.currentTarget.setSelectionRange(selectionStart, selectionEnd);
        const selectionState = {
          selectionStart,
          selectionEnd,
          isCaretAtEnd
        };
        e.currentTarget.dataset[SELECTION_STATE_ATTRIBUTE] = JSON.stringify(selectionState);
      }
    }
    if (checked !== undefined) {
      e.currentTarget.checked = checked;
    }
  };
  props.onBlur = e => {
    delete e.currentTarget.dataset[SELECTION_STATE_ATTRIBUTE];
    onBlur === null || onBlur === void 0 || onBlur(e);
  };
}
function processUncontrolledOnMount(element, props) {
  if (!CONTROLLABLE_TAGS.includes(element.tagName)) {
    return;
  }
  if (props.defaultValue) {
    setAttribute(element, 'value', props.defaultValue);
  }
  if (props.defaultChecked) {
    setAttribute(element, 'checked', props.defaultChecked);
  }
}
function updateAttributes($current, $new, element, namespace) {
  processControlled(element.tagName, $new.props);
  const currentEntries = Object.entries($current.props);
  const newEntries = Object.entries($new.props);
  for (const [key, currentValue] of currentEntries) {
    const newValue = $new.props[key];
    if (currentValue !== undefined && (newValue === undefined || currentValue !== newValue && key.startsWith('on'))) {
      removeAttribute(element, key, currentValue);
    }
  }
  for (const [key, newValue] of newEntries) {
    const currentValue = $current.props[key];
    if (newValue !== undefined && newValue !== currentValue) {
      setAttribute(element, key, newValue, namespace);
    }
  }
}
function setAttribute(element, key, value, namespace) {
  if (key === 'className') {
    updateClassName(element, value, namespace);
  } else if (key === 'value') {
    const inputEl = element;
    if (inputEl.value !== value) {
      inputEl.value = value;
      const selectionStateJson = inputEl.dataset[SELECTION_STATE_ATTRIBUTE];
      if (selectionStateJson) {
        const {
          selectionStart,
          selectionEnd,
          isCaretAtEnd
        } = JSON.parse(selectionStateJson);
        if (isCaretAtEnd) {
          const length = inputEl.value.length;
          inputEl.setSelectionRange(length, length);
        } else if (typeof selectionStart === 'number' && typeof selectionEnd === 'number') {
          inputEl.setSelectionRange(selectionStart, selectionEnd);
        }
      }
    }
  } else if (key === 'style') {
    updateStyle(element, value);
  } else if (key === 'dangerouslySetInnerHTML') {
    element.innerHTML = value.__html;
  } else if (key.startsWith('on')) {
    addEventListener(element, key, value, key.endsWith('Capture'));
  } else if (namespace === SVG_NAMESPACE || key.startsWith('data-') || key.startsWith('aria-') || HTML_ATTRIBUTES.has(key)) {
    element.setAttribute(key, value);
  } else if (!FILTERED_ATTRIBUTES.has(key)) {
    element[MAPPED_ATTRIBUTES[key] || key] = value;
  }
}
function removeAttribute(element, key, value) {
  if (key === 'className') {
    updateClassName(element, '');
  } else if (key === 'value') {
    element.value = '';
  } else if (key === 'style') {
    updateStyle(element, '');
  } else if (key === 'dangerouslySetInnerHTML') {
    element.innerHTML = '';
  } else if (key.startsWith('on')) {
    removeEventListener(element, key, value, key.endsWith('Capture'));
  } else if (!FILTERED_ATTRIBUTES.has(key)) {
    element.removeAttribute(key);
  }
}
function updateClassName(element, value, namespace) {
  if (namespace === SVG_NAMESPACE) {
    element.setAttribute('class', value);
    return;
  }
  const htmlElement = element;
  const extra = extraClasses.get(element);
  if (!extra) {
    htmlElement.className = value;
    return;
  }
  const extraArray = Array.from(extra);
  if (value) {
    extraArray.push(value);
  }
  htmlElement.className = extraArray.join(' ');
}
function updateStyle(element, value) {
  element.style.cssText = value;
  const extraObject = extraStyles.get(element);
  if (extraObject) {
    applyExtraStyles(element);
  }
}
function addExtraClass(element, className) {
  element.classList.add(className);
  const classList = extraClasses.get(element);
  if (classList) {
    classList.add(className);
  } else {
    extraClasses.set(element, new Set([className]));
  }
}
function removeExtraClass(element, className) {
  element.classList.remove(className);
  const classList = extraClasses.get(element);
  if (classList) {
    classList.delete(className);
    if (!classList.size) {
      extraClasses.delete(element);
    }
  }
}
function toggleExtraClass(element, className, force) {
  var _extraClasses$get;
  if (force === true) {
    addExtraClass(element, className);
  } else if (force === false) {
    removeExtraClass(element, className);
  } else if ((_extraClasses$get = extraClasses.get(element)) !== null && _extraClasses$get !== void 0 && _extraClasses$get.has(className)) {
    removeExtraClass(element, className);
  } else {
    addExtraClass(element, className);
  }
}
function setExtraStyles(element, styles) {
  extraStyles.set(element, styles);
  applyExtraStyles(element);
}
function applyExtraStyles(element) {
  const standardStyles = Object.entries(extraStyles.get(element)).reduce((acc, _ref) => {
    let [prop, value] = _ref;
    if (prop.startsWith('--')) {
      element.style.setProperty(prop, value);
    } else {
      acc[prop] = value;
    }
    return acc;
  }, {});
  Object.assign(element.style, standardStyles);
}
function DEBUG_addToVirtualTreeSize($current) {
  DEBUG_virtualTreeSize += $current.children.length;
  $current.children.forEach($child => {
    if (isParentElement($child)) {
      DEBUG_addToVirtualTreeSize($child);
    }
  });
}
function DEBUG_checkKeyUniqueness(children) {
  const firstChild = children[0];
  if (firstChild && 'props' in firstChild && firstChild.props.key !== undefined) {
    const keys = children.reduce((acc, child) => {
      if ('props' in child && child.props.key) {
        acc.push(child.props.key);
      }
      return acc;
    }, []);
    if (keys.length !== (0,iteratees/* unique */.Am)(keys).length) {
      // eslint-disable-next-line no-console
      console.warn('[Teact] Duplicated keys:', keys.filter((e, i, a) => a.indexOf(e) !== i), children);
      throw new Error('[Teact] Children keys are not unique');
    }
  }
}
const TeactDOM = {
  render
};
/* harmony default export */ const teact_dom = (TeactDOM);
;// ./src/hooks/useSignal.ts


function useSignal_useSignal(initial) {
  const signalRef = teact_useRef();
  signalRef.current ??= createSignal(initial);
  return signalRef.current;
}
;// ./src/hooks/useSignalEffect.ts



function useSignalEffect(effect, dependencies) {
  // The is extracted from `useEffectOnce` to run before all effects
  const isFirstRun = teact_useRef(true);
  if (isFirstRun.current) {
    isFirstRun.current = false;
    dependencies === null || dependencies === void 0 || dependencies.forEach(dependency => {
      if (isSignal(dependency)) {
        dependency.subscribe(effect);
      }
    });
  }
  hooks_useEffectOnce(() => {
    return () => {
      cleanupEffect(effect);
    };
  });
}
;// ./src/hooks/useDerivedSignal.ts




function useDerivedSignal_useDerivedSignal(resolverOrDependency, dependencies) {
  let isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const resolver = dependencies ? resolverOrDependency : () => resolverOrDependency;
  dependencies ??= [resolverOrDependency];
  const [getValue, setValue] = useSignal_useSignal();
  const resolverRef = useStateRef(resolver);
  function runCurrentResolver() {
    const currentResolver = resolverRef.current;
    if (isAsync) {
      currentResolver(setValue);
    } else {
      setValue(currentResolver());
    }
  }

  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  useSyncEffect(runCurrentResolver, dependencies);
  useSignalEffect(runCurrentResolver, dependencies);
  return getValue;
}
/* harmony default export */ const hooks_useDerivedSignal = (useDerivedSignal_useDerivedSignal);
;// ./src/hooks/useDerivedState.ts





function useDerivedState(resolverOrSignal, dependencies) {
  let isAsync = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const resolver = dependencies ? resolverOrSignal : () => resolverOrSignal();
  dependencies ??= [resolverOrSignal];
  const valueRef = teact_useRef();
  const forceUpdate = hooks_useForceUpdate();
  const resolverRef = useStateRef(resolver);
  function runCurrentResolver() {
    let isSync = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const currentResolver = resolverRef.current;
    if (isAsync) {
      currentResolver(newValue => {
        if (valueRef.current !== newValue) {
          valueRef.current = newValue;
          forceUpdate();
        }
      });
    } else {
      const newValue = currentResolver();
      if (valueRef.current !== newValue) {
        valueRef.current = newValue;
        if (!isSync) {
          forceUpdate();
        }
      }
    }
  }
  useSyncEffect(() => {
    runCurrentResolver(true);
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, dependencies);
  useSignalEffect(runCurrentResolver, dependencies);
  return valueRef.current;
}
/* harmony default export */ const hooks_useDerivedState = (useDerivedState);
;// ./src/hooks/useSyncEffectWithPrevDeps.ts


const useLayoutEffectWithPrevDeps = (cb, dependencies) => {
  const prevDepsRef = teact_useRef();
  return useSyncEffect(() => {
    const prevDeps = prevDepsRef.current;
    prevDepsRef.current = dependencies;
    return cb(prevDeps || []);
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, dependencies);
};
/* harmony default export */ const useSyncEffectWithPrevDeps = (useLayoutEffectWithPrevDeps);
;// ./src/hooks/useShowTransition.ts









const CLOSE_DURATION = 350;
function useShowTransition(params) {
  const {
    isOpen,
    noMountTransition = false,
    noOpenTransition = false,
    noCloseTransition = false,
    closeDuration = CLOSE_DURATION,
    className = 'fast',
    prefix = '',
    shouldForceOpen,
    onCloseAnimationEnd
  } = params;
  const localRef = teact_useRef();
  const ref = params.ref || localRef;
  const closingTimeoutRef = teact_useRef();
  const [getState, setState] = useSignal();
  const optionsRef = useStateRef({
    closeDuration,
    noMountTransition,
    noOpenTransition,
    noCloseTransition
  });
  const onCloseEndLast = useLastCallback(onCloseAnimationEnd);
  useSyncEffectWithPrevDeps(_ref => {
    let [prevIsOpen] = _ref;
    const options = optionsRef.current;
    if (shouldForceOpen) {
      setState('open');
      return;
    }
    if (isOpen) {
      if (closingTimeoutRef.current) {
        clearTimeout(closingTimeoutRef.current);
        closingTimeoutRef.current = undefined;
      }
      if (options.noOpenTransition || prevIsOpen === undefined && options.noMountTransition) {
        setState('open');
      } else {
        setState('scheduled-open');
        (0,fasterdom/* requestMeasure */.YS)(() => {
          setState('open');
        });
      }
    } else if (prevIsOpen === undefined || options.noCloseTransition) {
      setState('closed');
    } else {
      setState('closing');
      closingTimeoutRef.current = window.setTimeout(() => {
        setState('closed');
        onCloseEndLast();
      }, options.closeDuration);
    }
  }, [isOpen, shouldForceOpen]);
  const applyClassNames = useLastCallback(() => {
    const element = ref.current;
    if (!element) return;
    if (className !== false) {
      addExtraClass(element, 'opacity-transition');
      addExtraClass(element, className);
    }
    const state = getState();
    const shouldRender = state !== 'closed';
    const hasOpenClass = state === 'open';
    const isClosing = state === 'closing';
    toggleExtraClass(element, `${prefix}shown`, shouldRender);
    toggleExtraClass(element, `${prefix}not-shown`, !shouldRender);
    toggleExtraClass(element, `${prefix}open`, hasOpenClass);
    toggleExtraClass(element, `${prefix}not-open`, !hasOpenClass);
    toggleExtraClass(element, `${prefix}closing`, isClosing);
  });

  // Workaround for Chrome causing forced reflow in the middle of mutation phase when unmounting a focused element.
  // Due to such forced reflow setting initial class names in the first layout effect causes transitions to start.
  useSyncEffect(() => {
    ref.onChange = () => {
      ref.onChange = undefined;
      applyClassNames();
    };
  }, [applyClassNames, ref]);
  useLayoutEffect(applyClassNames, [applyClassNames, getState]);
  const withShouldRender = 'withShouldRender' in params && params.withShouldRender;
  const shouldRender = hooks_useDerivedState(() => withShouldRender && getState() !== 'closed', [withShouldRender, getState]);
  const getIsClosing = hooks_useDerivedSignal(() => getState() === 'closing', [getState]);
  if (withShouldRender) {
    return {
      ref,
      shouldRender,
      getIsClosing
    };
  }
  return {
    ref,
    getIsClosing
  };
}
;// ./src/hooks/useToggleClass.ts


function useToggleClass(_ref) {
  let {
    className,
    isActive,
    element = document.documentElement
  } = _ref;
  useLayoutEffect(() => {
    if (!isActive) return;
    addExtraClass(element, className);
    return () => {
      removeExtraClass(element, className);
    };
  }, [className, isActive, element]);
}
;// ./src/components/ui/LoadingDots.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const LoadingDots_module = ({"root":"LoadingDots-module__root","dot":"LoadingDots-module__dot","dots":"LoadingDots-module__dots","doubled":"LoadingDots-module__doubled","dots-doubled":"LoadingDots-module__dots-doubled","dotsDoubled":"LoadingDots-module__dots-doubled"});
;// ./src/components/ui/LoadingDots.tsx




function LoadingDots(_ref) {
  let {
    isActive,
    className,
    isDoubled
  } = _ref;
  const {
    shouldRender,
    ref
  } = useShowTransition({
    isOpen: isActive,
    withShouldRender: true
  });
  if (!shouldRender) {
    // eslint-disable-next-line no-null/no-null
    return null;
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: buildClassName(LoadingDots_module.root, isDoubled && LoadingDots_module.doubled, className)
  }, /*#__PURE__*/teact.createElement("span", {
    className: LoadingDots_module.dot
  }), /*#__PURE__*/teact.createElement("span", {
    className: LoadingDots_module.dot
  }), /*#__PURE__*/teact.createElement("span", {
    className: LoadingDots_module.dot
  }));
}
/* harmony default export */ const ui_LoadingDots = (memo(LoadingDots));
;// ./src/components/ui/Button.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Button_module = ({"button":"Button-module__button","loadingInit":"Button-module__loadingInit","clicked":"Button-module__clicked","isSimple":"Button-module__isSimple","isText":"Button-module__isText","primary":"Button-module__primary","secondary":"Button-module__secondary","transparent":"Button-module__transparent","disabled":"Button-module__disabled","destructive":"Button-module__destructive","sizeSmall":"Button-module__sizeSmall","round":"Button-module__round","loadingStart":"Button-module__loadingStart","loadingDots":"Button-module__loadingDots"});
;// ./src/components/ui/Button.tsx





// Longest animation duration
const CLICKED_TIMEOUT = 400;
function Button(_ref) {
  let {
    ref,
    children,
    id,
    className,
    style,
    ariaLabel,
    forFormId,
    kind,
    isSubmit,
    isPrimary,
    isSecondary,
    isSmall,
    isSimple,
    isText,
    isLoading,
    isDisabled,
    isRound,
    isDestructive,
    shouldStopPropagation,
    onClick,
    onMouseDown,
    onContextMenu
  } = _ref;
  const [isClicked, setIsClicked] = useState(false);
  const handleClick = useLastCallback(event => {
    if (!isDisabled && onClick) {
      if (shouldStopPropagation) {
        event.stopPropagation();
      }
      onClick();
    }
    setIsClicked(true);
    setTimeout(() => {
      setIsClicked(false);
    }, CLICKED_TIMEOUT);
  });
  const loadingClassName = buildClassName(isLoading !== undefined && Button_module.loadingInit, isLoading && Button_module.loadingStart);
  return /*#__PURE__*/teact.createElement("button", {
    id: id,
    ref: ref,
    type: isSubmit || forFormId ? 'submit' : 'button',
    className: buildClassName(Button_module.button, isPrimary && Button_module.primary, isSecondary && Button_module.secondary, isSmall && Button_module.sizeSmall, isSimple && Button_module.isSimple, isText && Button_module.isText, (isDisabled || isLoading) && Button_module.disabled, loadingClassName, isRound && Button_module.round, isDestructive && Button_module.destructive, isClicked && Button_module.clicked, className, kind && Button_module[kind]),
    style: style,
    "aria-label": ariaLabel,
    disabled: isDisabled || isLoading,
    form: forFormId,
    onClick: handleClick,
    onMouseDown: onMouseDown,
    onContextMenu: onContextMenu
  }, children, /*#__PURE__*/teact.createElement(ui_LoadingDots, {
    isActive: isLoading,
    className: Button_module.loadingDots
  }));
}
/* harmony default export */ const ui_Button = (memo(Button));
;// ./src/components/ui/Portal.ts


function Portal(_ref) {
  let {
    containerId,
    className,
    style,
    children
  } = _ref;
  const elementRef = teact_useRef();
  if (!elementRef.current) {
    elementRef.current = document.createElement('div');
  }
  useLayoutEffect(() => {
    const container = document.querySelector(containerId || '#portals');
    if (!container) {
      return undefined;
    }
    const element = elementRef.current;
    if (className) {
      element.className = className;
    }
    if (style) {
      element.style.cssText = style;
    }
    container.appendChild(element);
    return () => {
      teact_dom.render(undefined, element);
      container.removeChild(element);
    };
  }, [className, style, containerId]);
  return teact_dom.render(children, elementRef.current);
}
/* harmony default export */ const ui_Portal = (Portal);
;// ./src/components/ui/Modal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Modal_module = ({"modal":"Modal-module__modal","inAppLock":"Modal-module__inAppLock","error":"Modal-module__error","dialog":"Modal-module__dialog","backdrop":"Modal-module__backdrop","slideUpAnimation":"Modal-module__slideUpAnimation","container":"Modal-module__container","forceBottomSheet":"Modal-module__forceBottomSheet","content":"Modal-module__content","noBackdrop":"Modal-module__noBackdrop","compact":"Modal-module__compact","header":"Modal-module__header","header_wideContent":"Modal-module__header_wideContent","headerWideContent":"Modal-module__header_wideContent","header_back":"Modal-module__header_back","headerBack":"Modal-module__header_back","header_backIcon":"Modal-module__header_backIcon","headerBackIcon":"Modal-module__header_backIcon","menuButton":"Modal-module__menuButton","menuIcon":"Modal-module__menuIcon","closeButton":"Modal-module__closeButton","closeIcon":"Modal-module__closeIcon","title":"Modal-module__title","singleTitle":"Modal-module__singleTitle","contentCompact":"Modal-module__contentCompact","text":"Modal-module__text","text_centered":"Modal-module__text_centered","textCentered":"Modal-module__text_centered","text_noExtraMargin":"Modal-module__text_noExtraMargin","textNoExtraMargin":"Modal-module__text_noExtraMargin","buttons":"Modal-module__buttons","footerButtons":"Modal-module__footerButtons","footerButtonFullWidth":"Modal-module__footerButtonFullWidth","buttonsInsideContentWithScroll":"Modal-module__buttonsInsideContentWithScroll","buttonsNoExtraSpace":"Modal-module__buttonsNoExtraSpace","button":"Modal-module__button","buttonHalfWidth":"Modal-module__buttonHalfWidth","buttonFullWidth":"Modal-module__buttonFullWidth","shortButton":"Modal-module__shortButton","transition":"Modal-module__transition","transitionSlide":"Modal-module__transitionSlide","transitionContentWrapper":"Modal-module__transitionContentWrapper","transitionContent":"Modal-module__transitionContent","transitionContent_simple":"Modal-module__transitionContent_simple","transitionContentSimple":"Modal-module__transitionContent_simple"});
;// ./src/components/ui/Modal.tsx




























const Modal_CLOSE_DURATION = 350;
const CLOSE_DURATION_PORTRAIT = windowEnvironment/* IS_ANDROID */.Ni ? 200 : 500;
const SCROLL_CONTENT_CHECK_THRESHOLD_MS = 500;
const [getModalCloseSignal, setModalCloseSignal] = createSignal(Date.now());
function closeModal() {
  setModalCloseSignal(Date.now());
}

// Track open modals with nativeBottomSheetKey
const openNativeBottomSheetModals = new Set();
function getIsAnyNativeBottomSheetModalOpen() {
  return openNativeBottomSheetModals.size > 0;
}
function Modal(_ref) {
  let {
    dialogRef,
    title,
    className,
    dialogClassName,
    titleClassName,
    contentClassName,
    isOpen: doesWantToBeOpened,
    isTemporarilyClosed,
    isCompact,
    nativeBottomSheetKey,
    forceFullNative,
    forceBottomSheet,
    isInAppLock,
    noResetFullNativeOnBlur,
    noBackdrop,
    noBackdropClose,
    header,
    hasCloseButton,
    children,
    onClose: onCloseProp,
    onCloseAnimationEnd,
    onEnter
  } = _ref;
  const isOpen = doesWantToBeOpened && !isTemporarilyClosed;
  const onClose = useLastCallback(() => {
    if (isTemporarilyClosed && doesWantToBeOpened) {
      return undefined;
    }
    return onCloseProp();
  });
  const lang = hooks_useLang();
  const modalRef = teact_useRef();
  const localDialogRef = teact_useRef();
  const swipeDownDateRef = teact_useRef();
  dialogRef ||= localDialogRef;
  const {
    isPortrait
  } = useDeviceScreen();
  useHideBrowser(isOpen, isCompact);
  const animationDuration = (isPortrait ? CLOSE_DURATION_PORTRAIT : Modal_CLOSE_DURATION) + src_config/* ANIMATION_END_DELAY */.xB5;
  const isSlideUp = !isCompact && isPortrait;
  useHistoryBack({
    isActive: isOpen,
    onBack: onClose,
    shouldIgnoreForTelegram: isCompact
  });
  teact_useEffect(() => {
    if (!src_config/* IS_TELEGRAM_APP */.tKX || !isOpen || isCompact) return undefined;
    disableTelegramMiniAppSwipeToClose();
    return enableTelegramMiniAppSwipeToClose;
  }, [isCompact, isOpen]);
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevIsOpen] = _ref2;
    // Expand NBS to full size for a compact modal inside NBS
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && isCompact && (prevIsOpen || isOpen) && !getIsForcedFullSize()) {
      void esm_BottomSheet.toggleSelfFullSize({
        isFullSize: !!isOpen
      });
    }
  }, [isOpen, isCompact]);
  teact_useEffect(() => {
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA || !isOpen) return undefined;
    return getModalCloseSignal.subscribe(onClose);
  }, [isOpen, onClose]);
  teact_useEffect(() => isOpen ? captureKeyboardListeners({
    onEsc: {
      handler: onClose,
      shouldPreventDefault: src_config/* IS_EXTENSION */.hL1
    },
    ...(onEnter && {
      onEnter
    })
  }) : undefined, [isOpen, onClose, onEnter]);
  teact_useEffect(() => isOpen && modalRef.current ? trapFocus(modalRef.current) : undefined, [isOpen]);
  useToggleClass({
    className: 'is-modal-open',
    isActive: !isCompact && isOpen
  });
  useLayoutEffect(() => isOpen ? beginHeavyAnimation(animationDuration) : undefined, [animationDuration, isOpen]);

  // Track modal state for modals with nativeBottomSheetKey
  teact_useEffect(() => {
    if (!nativeBottomSheetKey) return;
    if (isOpen) {
      openNativeBottomSheetModals.add(nativeBottomSheetKey);
    } else {
      openNativeBottomSheetModals.delete(nativeBottomSheetKey);
    }
    return () => {
      openNativeBottomSheetModals.delete(nativeBottomSheetKey);
    };
  }, [isOpen, nativeBottomSheetKey]);

  // Make sure to hide browser before presenting modals
  const [isBrowserHidden, setIsBrowserHidden] = useState(false);
  teact_useEffect(() => {
    const browser = getInAppBrowser();
    if (!isOpen) {
      setIsBrowserHidden(false); // Reset to re-hide it next time
      // Before showing browser, make sure that closed modals are updated state properly
      requestAnimationFrame(() => {
        browser === null || browser === void 0 || browser.show();
      });
      return;
    }
    void (browser === null || browser === void 0 ? void 0 : browser.hide().then(() => {
      setIsBrowserHidden(true);
    }));
  }, [isOpen]);
  const isDelegatingToNative = useDelegatingBottomSheet(nativeBottomSheetKey, isPortrait, isOpen && (!getInAppBrowser() || isBrowserHidden), onClose);
  useDelegatedBottomSheet(nativeBottomSheetKey, isOpen && (!getInAppBrowser() || isBrowserHidden), onClose, dialogRef, forceFullNative, noResetFullNativeOnBlur);
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF || !isOpen || !isPortrait || !isSlideUp || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA || isDelegatingToNative) {
      return undefined;
    }
    return captureEvents(modalRef.current, {
      excludedClosestSelector: '.capture-scroll',
      onSwipe: (e, direction) => {
        if (direction === SwipeDirection.Down && getCanCloseModal(swipeDownDateRef, e.target)) {
          onClose();
          return true;
        }
        return false;
      }
    });
  }, [isOpen, isPortrait, isSlideUp, isDelegatingToNative, onClose]);
  const {
    shouldRender
  } = useShowTransition({
    ref: modalRef,
    isOpen: isOpen && !isDelegatingToNative,
    onCloseAnimationEnd,
    className: false,
    closeDuration: animationDuration,
    withShouldRender: true
  });
  if (!shouldRender) {
    return undefined;
  }
  function renderHeader() {
    if (header) {
      return header;
    }
    if (!title) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.header, Modal_module.header_wideContent, !hasCloseButton && Modal_module.header_noClose)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.title, Modal_module.singleTitle, titleClassName)
    }, title), hasCloseButton && /*#__PURE__*/teact.createElement(ui_Button, {
      isRound: true,
      className: Modal_module.closeButton,
      ariaLabel: lang('Close'),
      onClick: onClose
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Modal_module.closeIcon, 'icon-close'),
      "aria-hidden": true
    })));
  }
  const fullClassName = buildClassName(Modal_module.modal, className, isSlideUp && Modal_module.slideUpAnimation, isCompact && Modal_module.compact, isCompact && 'is-compact-modal', forceBottomSheet && Modal_module.forceBottomSheet, isInAppLock && Modal_module.inAppLock);
  const backdropFullClass = buildClassName(Modal_module.backdrop, noBackdrop && Modal_module.noBackdrop);
  const contentFullClassName = buildClassName(Modal_module.content, isCompact && Modal_module.contentCompact, 'custom-scroll', contentClassName);
  return /*#__PURE__*/teact.createElement(ui_Portal, null, /*#__PURE__*/teact.createElement("div", {
    ref: modalRef,
    className: fullClassName,
    tabIndex: -1,
    role: "dialog"
  }, /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.container
  }, /*#__PURE__*/teact.createElement("div", {
    className: backdropFullClass,
    onClick: !noBackdropClose ? onClose : undefined
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.dialog, dialogClassName),
    ref: dialogRef
  }, renderHeader(), /*#__PURE__*/teact.createElement("div", {
    className: contentFullClassName
  }, children)))));
}
const FreezeWhenClosedModal = freezeWhenClosed(Modal);
/* harmony default export */ const ui_Modal = (withGlobal((global, _ref3) => {
  let {
    isInAppLock
  } = _ref3;
  return {
    // This behavior is intended to prevent NBS from rendering above the app lock screen,
    // which is an iOS-only issue. We retain this fix on all platforms to unify behavior.
    isTemporarilyClosed: !(isInAppLock || !global.isAppLockActive)
  };
})(FreezeWhenClosedModal));
function getCanCloseModal(lastScrollRef, el) {
  if (windowSize.getIsKeyboardVisible() || getIsSwipeToCloseDisabled()) {
    return false;
  }
  const now = Date.now();
  if (lastScrollRef.current && now - lastScrollRef.current < SCROLL_CONTENT_CHECK_THRESHOLD_MS) {
    return false;
  }
  lastScrollRef.current = now;
  const scrollEl = el === null || el === void 0 ? void 0 : el.closest('.custom-scroll');
  return !scrollEl || scrollEl.scrollTop === 0;
}
;// ./src/components/ui/InAppBrowser.tsx
















// The maximum time the in-app browser will take to close (and a little more as a safe margin)
const CLOSE_MAX_DURATION = 900;

// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
let inAppBrowser;
function InAppBrowser(_ref) {
  let {
    title,
    subtitle,
    url,
    theme,
    animationLevel
  } = _ref;
  const {
    closeBrowser
  } = getActions();
  const lang = hooks_useLang();
  const {
    setupDappBridge,
    cleanupDappBridge
  } = useInAppBrowserBridgeProvider(url);
  const bridgeInjectionCode = teact_useMemo(() => buildInAppBrowserBridgeConnectorCode(), []);
  const handleError = useLastCallback(err => {
    (0,logs/* logDebugError */.SJ)('inAppBrowser error', err);
  });
  const handleBrowserClose = useLastCallback(async () => {
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
      await esm_BottomSheet.enable();
    }
    inAppBrowser.removeEventListener('loaderror', handleError);
    inAppBrowser.removeEventListener('exit', handleBrowserClose);
    inAppBrowser = undefined;
    closeBrowser();
    cleanupDappBridge();
  });
  const openBrowser = useLastCallback(async () => {
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI && !(await esm_BottomSheet.isShown()).value) {
      await esm_BottomSheet.disable();
    }
    const browserTitle = !title && url ? getHostnameFromUrl(url) : title;
    const browserSubtitle = subtitle === browserTitle ? undefined : subtitle;
    const ADDITIONAL_INAPP_BROWSER_OPTIONS = `,${(0,iteratees/* compact */.oE)([windowEnvironment/* IS_IOS */.pz || browserTitle ? `title=${browserTitle || ''}` : undefined, windowEnvironment/* IS_IOS */.pz || browserSubtitle ? `subtitle=${browserSubtitle || ''}` : undefined, url ? `shareurl=${encodeURIComponent(url)}` : undefined, `closebuttoncaption=${windowEnvironment/* IS_IOS */.pz ? lang('Close') : 'x'}`, `backbuttoncaption=${lang('Back')}`, `reloadcaption=${lang('Reload Page')}`, `openinbrowsercaption=${lang(windowEnvironment/* IS_IOS */.pz ? 'Open in Safari' : 'Open in Browser')}`, `copyurlcaption=${lang('CopyURL')}`, `sharecaption=${lang('Share')}`, `theme=${theme}`, `animated=${animationLevel ?? src_config/* ANIMATION_LEVEL_DEFAULT */.i11 > 0 ? 'yes' : 'no'}`]).join(',')}`;
    inAppBrowser = cordova.InAppBrowser.open(url, '_blank', INAPP_BROWSER_OPTIONS + ADDITIONAL_INAPP_BROWSER_OPTIONS, bridgeInjectionCode);
    const originalHide = inAppBrowser.hide;
    inAppBrowser.hide = () => {
      return new Promise(resolve => {
        originalHide === null || originalHide === void 0 || originalHide();
        // On iOS, the animation takes some time. We have to ensure it's completed.
        if (inAppBrowser && windowEnvironment/* IS_IOS_APP */.ZH) {
          listenOnce(inAppBrowser, 'hidecompletion', () => resolve());
        } else {
          resolve();
        }
      });
    };
    const originalShow = inAppBrowser.show;
    inAppBrowser.show = () => {
      if (!getIsAnyNativeBottomSheetModalOpen()) {
        originalShow === null || originalShow === void 0 || originalShow();
      }
    };
    const originalClose = inAppBrowser.close;
    inAppBrowser.close = () => {
      if (!inAppBrowser) {
        return Promise.resolve();
      }
      originalClose();
      const closedPromise = new Promise(resolve => {
        // The `waitFor` is a hack necessary to ensure the browser is fully in the closed state when the promise
        // resolves. This solves a bug: if a push notification, that opens a modal, was clicked while the in-app browser
        // was open, the browser would close, but the modal wouldn't open.
        listenOnce(inAppBrowser, 'exit', async () => {
          await (0,schedulers/* waitFor */.fm)(() => !inAppBrowser, 15, 20);
          resolve();
        });

        // A backup for cases when the `close()` call doesn't cause the browser to close and fire the `exit` event.
        setTimeout(resolve, CLOSE_MAX_DURATION);
      });

      // Calling `show()` while the browser is being closed causes the app to crash. So we disable the `show` method.
      inAppBrowser.show = () => undefined;
      inAppBrowser.hide = () => closedPromise;
      return closedPromise;
    };
    setupDappBridge(inAppBrowser);
    inAppBrowser.addEventListener('loaderror', handleError);
    inAppBrowser.addEventListener('exit', handleBrowserClose);
    inAppBrowser.show();
  });
  teact_useEffect(() => {
    if (!url) return undefined;
    void openBrowser();
    return () => {
      var _inAppBrowser;
      return (_inAppBrowser = inAppBrowser) === null || _inAppBrowser === void 0 ? void 0 : _inAppBrowser.close();
    };
  }, [url]);
  return undefined;
}
/* harmony default export */ const ui_InAppBrowser = (memo(withGlobal(global => {
  const {
    currentBrowserOptions,
    settings
  } = global;
  return {
    url: currentBrowserOptions === null || currentBrowserOptions === void 0 ? void 0 : currentBrowserOptions.url,
    title: currentBrowserOptions === null || currentBrowserOptions === void 0 ? void 0 : currentBrowserOptions.title,
    subtitle: currentBrowserOptions === null || currentBrowserOptions === void 0 ? void 0 : currentBrowserOptions.subtitle,
    theme: settings.theme,
    animationLevel: settings.animationLevel
  };
})(InAppBrowser)));
function getInAppBrowser() {
  return inAppBrowser;
}
;// ./src/global/helpers/misc.ts






/**
 * Parses the transfer parameters from the given QR content, assuming it's a plain address.
 * Returns `undefined` if this is not a valid address or the account doesn't have the corresponding wallet.
 */
function parsePlainAddressQr(global, qrData) {
  var _selectCurrentAccount;
  const availableChains = ((_selectCurrentAccount = selectCurrentAccount(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.addressByChain) ?? {};
  const newChain = getChainFromAddress(qrData, availableChains);
  if (!newChain) {
    return undefined;
  }
  const currentTokenSlug = global.currentTransfer.tokenSlug;
  const currentChain = getChainBySlug(currentTokenSlug);
  const newTokenSlug = newChain !== currentChain ? getNativeToken(newChain).slug : currentTokenSlug;
  return {
    toAddress: qrData,
    tokenSlug: newTokenSlug
  };
}
function getChainFromAddress(address, availableChains) {
  for (const chain of Object.keys(availableChains)) {
    if (isValidAddressOrDomain(address, chain)) {
      return chain;
    }
  }
  return undefined;
}
function closeAllOverlays() {
  var _getInAppBrowser;
  return Promise.all([// It's important to close the in-app browser before closing the modal, because when a modal closes, it calls
  // `show()` on the hidden in-app browser, and calling `close()` right after `show()` causes the app to crash.
  // Meanwhile, calling `close()` before `show()` makes the in-app browser ignore the `show()` call.
  // A situation, where it happens, is pressing an "openUrl" notification while the app shows a TON Connect modal.
  (_getInAppBrowser = getInAppBrowser()) === null || _getInAppBrowser === void 0 ? void 0 : _getInAppBrowser.close(), getActions().closeAnyModal(), getActions().closeMediaViewer()]);
}

/** replaceMap: keys - old (removed) activity ids, value - new (added) activity ids */
function replaceActivityId(oldId, replaceMap) {
  const newId = oldId && replaceMap[oldId];
  return newId || oldId;
}
;// ./src/util/openUrl.ts





const [, SUBPROJECT_HOST_ENDING] = src_config/* SUBPROJECT_URL_MASK */.Xr6.split('*');
async function openUrl(url, options) {
  if (isSubproject(url)) {
    url = `${url}#theme=${getGlobal().settings.theme}`;
  }
  if (!(options !== null && options !== void 0 && options.isExternal) && url.startsWith('http') && (src_config/* IS_CAPACITOR */.UMQ || isSubproject(url) || isInIframeWhitelist(url)) && !isTelegramUrl(url)) {
    await closeAllOverlays();
    getActions().openBrowser({
      url,
      title: options === null || options === void 0 ? void 0 : options.title,
      subtitle: options === null || options === void 0 ? void 0 : options.subtitle
    });
  } else {
    const couldOpenApp = src_config/* IS_CAPACITOR */.UMQ && (await openAppSafe(url));
    if (!couldOpenApp) {
      window.open(url, '_blank', 'noopener');
    }
  }
}
function isSubproject(url) {
  const {
    host
  } = new URL(url);
  return host.endsWith(SUBPROJECT_HOST_ENDING) || host.startsWith('localhost:432');
}
function isInIframeWhitelist(url) {
  return src_config/* IFRAME_WHITELIST */.Jxt.some(allowedOrigin => url.startsWith(allowedOrigin.replace(/\*$/, '')));
}
function handleUrlClick(e) {
  e.preventDefault();
  void openUrl(e.currentTarget.href, {
    isExternal: e.shiftKey || e.ctrlKey || e.metaKey
  });
}
async function openAppSafe(url) {
  try {
    return (await AppLauncher.openUrl({
      url
    })).completed;
  } catch (err) {
    return false;
  }
}
;// ./src/util/renderPromise.ts
let resolveRenderPromise;
const renderPromise = new Promise(resolve => {
  resolveRenderPromise = resolve;
});
function resolveRender() {
  resolveRenderPromise();
}
function waitRender() {
  return renderPromise;
}
;// ./src/util/deeplink/constants.ts
const TON_PROTOCOL = 'ton://';
const TONCONNECT_PROTOCOL = 'tc://';
const TONCONNECT_PROTOCOL_SELF = 'mytonwallet-tc://';
const SELF_PROTOCOL = 'mtw://';
const SELF_UNIVERSAL_URLS = ['https://my.tt', 'https://go.mytonwallet.org'];
const TONCONNECT_UNIVERSAL_URL = 'https://connect.mytonwallet.org';
const CHECKIN_URL = 'https://checkin.mytonwallet.org';
;// ./src/util/deeplink/index.ts














var DeeplinkCommand = /*#__PURE__*/function (DeeplinkCommand) {
  DeeplinkCommand["Air"] = "air";
  DeeplinkCommand["CheckinWithR"] = "r";
  DeeplinkCommand["Swap"] = "swap";
  DeeplinkCommand["BuyWithCrypto"] = "buy-with-crypto";
  DeeplinkCommand["BuyWithCard"] = "buy-with-card";
  DeeplinkCommand["Stake"] = "stake";
  DeeplinkCommand["Giveaway"] = "giveaway";
  DeeplinkCommand["Transfer"] = "transfer";
  DeeplinkCommand["Explore"] = "explore";
  return DeeplinkCommand;
}(DeeplinkCommand || {});
let urlAfterSignIn;
function processDeeplinkAfterSignIn() {
  if (!urlAfterSignIn) return;
  void processDeeplink(urlAfterSignIn);
  urlAfterSignIn = undefined;
}
async function openDeeplinkOrUrl(url, _ref) {
  let {
    isFromInAppBrowser,
    ...urlOptions
  } = _ref;
  if (isTonDeeplink(url) || isTonConnectDeeplink(url) || isSelfDeeplink(url)) {
    await processDeeplink(url, isFromInAppBrowser);
  } else {
    await openUrl(url, urlOptions);
  }
}

// Returns `true` if the link has been processed, ideally resulting to a UI action
function processDeeplink(url) {
  let isFromInAppBrowser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!getGlobal().currentAccountId) {
    urlAfterSignIn = url;
  }
  if (isTonConnectDeeplink(url)) {
    return processTonConnectDeeplink(url, isFromInAppBrowser);
  } else if (isSelfDeeplink(url)) {
    return processSelfDeeplink(url);
  } else {
    return processTonDeeplink(url);
  }
}
function isTonDeeplink(url) {
  return url.startsWith(TON_PROTOCOL);
}

// Returns `true` if the link has been processed, ideally resulting to a UI action
async function processTonDeeplink(url) {
  await waitRender();
  const actions = getActions();
  const global = getGlobal();
  if (!global.currentAccountId) {
    return false;
  }
  const startTransferParams = parseTonDeeplink(url, global);
  if (!startTransferParams) {
    return false;
  }
  if ('error' in startTransferParams) {
    actions.showError({
      error: startTransferParams.error
    });
    return true;
  }
  actions.startTransfer({
    isPortrait: getIsPortrait(),
    ...startTransferParams
  });
  if (getIsLandscape()) {
    actions.setLandscapeActionsActiveTabIndex({
      index: ActiveTab.Transfer
    });
  }
  return true;
}

/**
 * Parses a TON deeplink and checks whether the transfer can be initiated.
 * Returns `undefined` if the URL is not a TON deeplink.
 * If there is `error` in the result, there is a problem with the deeplink (the string is to translate via `lang`).
 * Otherwise, returned the parsed transfer parameters.
 */
function parseTonDeeplink(url, global) {
  const params = rawParseTonDeeplink(url);
  if (!params) return undefined;
  if (params.hasUnsupportedParams) {
    return {
      error: '$unsupported_deeplink_parameter'
    };
  }
  const {
    toAddress,
    amount,
    comment,
    binPayload,
    jettonAddress,
    nftAddress,
    stateInit,
    exp
  } = params;
  const verifiedAddress = isValidAddressOrDomain(toAddress, 'ton') ? toAddress : undefined;
  const transferParams = {
    toAddress: verifiedAddress,
    tokenSlug: src_config/* TONCOIN */.Tu9.slug,
    amount,
    comment,
    binPayload,
    stateInit
  };

  // Check if both text and bin parameters are provided (mutually exclusive)
  if (comment && binPayload) {
    transferParams.error = '$transfer_text_and_bin_exclusive';
  }
  if (jettonAddress) {
    const globalToken = jettonAddress ? selectTokenByMinterAddress(global, jettonAddress) : undefined;
    if (!globalToken) {
      transferParams.error = '$unknown_token_address';
    } else {
      const accountToken = selectAccountTokenBySlug(global, globalToken.slug);
      if (!accountToken) {
        transferParams.error = '$dont_have_required_token';
      } else {
        transferParams.tokenSlug = globalToken.slug;
      }
    }
  }
  if (nftAddress) {
    const accountNft = selectCurrentAccountNftByAddress(global, nftAddress);
    if (!accountNft) {
      transferParams.error = '$dont_have_required_nft';
    } else {
      transferParams.nfts = [accountNft];
    }
  }
  if (exp && Math.floor(Date.now() / 1000) > exp) {
    transferParams.error = '$transfer_link_expired';
  }
  return (0,iteratees/* omitUndefined */.Oy)(transferParams);
}
function rawParseTonDeeplink(value) {
  if (typeof value !== 'string' || !isTonDeeplink(value) || !value.includes('/transfer/')) {
    return undefined;
  }
  try {
    // In some browsers URL module may handle non-standard protocols incorrectly
    const adaptedDeeplink = value.replace(TON_PROTOCOL, 'https://');
    const url = new URL(adaptedDeeplink);
    const toAddress = url.pathname.replace(/\//g, '');
    const amount = getDeeplinkSearchParam(url, 'amount');
    const comment = getDeeplinkSearchParam(url, 'text');
    const binPayload = getDeeplinkSearchParam(url, 'bin');
    const jettonAddress = getDeeplinkSearchParam(url, 'jetton');
    const nftAddress = getDeeplinkSearchParam(url, 'nft');
    const stateInit = getDeeplinkSearchParam(url, 'init') || getDeeplinkSearchParam(url, 'stateInit');
    const exp = getDeeplinkSearchParam(url, 'exp');

    // Check for unsupported parameters
    const supportedParams = new Set(['amount', 'text', 'bin', 'jetton', 'nft', 'init', 'stateInit', 'exp']);
    const urlParams = Array.from(url.searchParams.keys());
    const hasUnsupportedParams = urlParams.some(param => !supportedParams.has(param));
    return {
      hasUnsupportedParams,
      toAddress,
      amount: amount ? BigInt(amount) : undefined,
      comment,
      jettonAddress,
      nftAddress,
      binPayload: binPayload ? replaceAllSpacesWithPlus(binPayload) : undefined,
      stateInit: stateInit ? replaceAllSpacesWithPlus(stateInit) : undefined,
      exp: exp ? Number(exp) : undefined
    };
  } catch (err) {
    return undefined;
  }
}
function isTonConnectDeeplink(url) {
  return url.startsWith(TONCONNECT_PROTOCOL) || url.startsWith(TONCONNECT_PROTOCOL_SELF) || omitProtocol(url).startsWith(omitProtocol(TONCONNECT_UNIVERSAL_URL));
}

// Returns `true` if the link has been processed, ideally resulting to a UI action
async function processTonConnectDeeplink(url) {
  let isFromInAppBrowser = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (!isTonConnectDeeplink(url)) {
    return false;
  }
  const {
    openLoadingOverlay,
    closeLoadingOverlay
  } = getActions();
  openLoadingOverlay();
  const returnUrl = await (0,api/* callApi */.p)('startSseConnection', {
    url,
    isFromInAppBrowser
  });

  // Workaround for long network connection initialization in the Capacitor version
  if (returnUrl === 'empty') {
    return true;
  }
  closeLoadingOverlay();
  if (returnUrl) {
    void openUrl(returnUrl, {
      isExternal: !isFromInAppBrowser
    });
  }
  return true;
}
function isSelfDeeplink(url) {
  url = forceHttpsProtocol(url);
  return url.startsWith(SELF_PROTOCOL) || SELF_UNIVERSAL_URLS.some(u => url.startsWith(u));
}

// Returns `true` if the link has been processed, ideally resulting to a UI action
async function processSelfDeeplink(deeplink) {
  try {
    var _selectCurrentAccount;
    deeplink = convertSelfDeeplinkToSelfUrl(deeplink);
    const {
      pathname,
      searchParams
    } = new URL(deeplink);
    const command = pathname.split('/').find(Boolean);
    const actions = getActions();
    const global = getGlobal();
    const {
      isTestnet
    } = global.settings;
    const isLedger = (_selectCurrentAccount = selectCurrentAccount(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.ledger;
    (0,logs/* logDebug */.MD)('Processing deeplink', deeplink);
    switch (command) {
      case DeeplinkCommand.Air:
        {
          if (!src_config/* IS_CAPACITOR */.UMQ) return false;
          switchToAir();
          return true;
        }
      case DeeplinkCommand.CheckinWithR:
        {
          var _pathname$match;
          const r = (_pathname$match = pathname.match(/r\/(.*)$/)) === null || _pathname$match === void 0 ? void 0 : _pathname$match[1];
          const url = `${CHECKIN_URL}${r ? `?r=${r}` : ''}`;
          void openUrl(url);
          return true;
        }
      case DeeplinkCommand.Giveaway:
        {
          var _pathname$match2;
          const giveawayId = (_pathname$match2 = pathname.match(/giveaway\/([^/]+)/)) === null || _pathname$match2 === void 0 ? void 0 : _pathname$match2[1];
          const url = `${src_config/* GIVEAWAY_CHECKIN_URL */.qsd}${giveawayId ? `?giveawayId=${giveawayId}` : ''}`;
          void openUrl(url);
          return true;
        }
      case DeeplinkCommand.Swap:
        {
          if (isTestnet) {
            actions.showError({
              error: 'Swap is not supported in Testnet.'
            });
          } else if (isLedger) {
            actions.showError({
              error: 'Swap is not yet supported by Ledger.'
            });
          } else {
            actions.startSwap({
              tokenInSlug: searchParams.get('in') || src_config/* TONCOIN */.Tu9.slug,
              tokenOutSlug: searchParams.get('out') || src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC,
              amountIn: toNumberOrEmptyString(searchParams.get('amount')) || '10'
            });
          }
          return true;
        }
      case DeeplinkCommand.BuyWithCrypto:
        {
          if (isTestnet) {
            actions.showError({
              error: 'Swap is not supported in Testnet.'
            });
          } else if (isLedger) {
            actions.showError({
              error: 'Swap is not yet supported by Ledger.'
            });
          } else {
            actions.startSwap({
              tokenInSlug: searchParams.get('in') || src_config/* DEFAULT_CEX_SWAP_SECOND_TOKEN_SLUG */.Czf,
              tokenOutSlug: searchParams.get('out') || src_config/* TONCOIN */.Tu9.slug,
              amountIn: toNumberOrEmptyString(searchParams.get('amount')) || '100'
            });
          }
          return true;
        }
      case DeeplinkCommand.BuyWithCard:
        {
          if (isTestnet) {
            actions.showError({
              error: 'Buying with card is not supported in Testnet.'
            });
          } else {
            actions.openOnRampWidgetModal({
              chain: 'ton'
            });
          }
          return true;
        }
      case DeeplinkCommand.Stake:
        {
          if (isTestnet) {
            actions.showError({
              error: 'Staking is not supported in Testnet.'
            });
          } else {
            actions.startStaking();
          }
          return true;
        }
      case DeeplinkCommand.Transfer:
        {
          return await processTonDeeplink(convertSelfUrlToTonDeeplink(deeplink));
        }
      case DeeplinkCommand.Explore:
        {
          actions.closeSettings();
          actions.openExplore();
          actions.setActiveContentTab({
            tab: ContentTab.Explore
          });
          const host = pathname.split('/').filter(Boolean)[1];
          if (host) {
            var _getGlobal$exploreDat;
            const matchingSite = (_getGlobal$exploreDat = getGlobal().exploreData) === null || _getGlobal$exploreDat === void 0 ? void 0 : _getGlobal$exploreDat.sites.find(_ref2 => {
              let {
                url
              } = _ref2;
              const siteHost = isTelegramUrl(url) ? new URL(url).pathname.split('/').filter(Boolean)[0] : new URL(url).hostname;
              return siteHost === host;
            });
            if (matchingSite) {
              void openUrl(matchingSite.url);
            }
          }
          return true;
        }
    }
  } catch (err) {
    (0,logs/* logDebugError */.SJ)('processSelfDeeplink', err);
  }
  return false;
}

/**
 * Parses a deeplink and checks whether the transfer can be initiated.
 * See `parseTonDeeplink` for information about the returned values.
 */
function parseDeeplinkTransferParams(url, global) {
  let tonDeeplink = url;
  if (isSelfDeeplink(url)) {
    try {
      url = convertSelfDeeplinkToSelfUrl(url);
      const {
        pathname
      } = new URL(url);
      const command = pathname.split('/').find(Boolean);
      if (command === DeeplinkCommand.Transfer) {
        tonDeeplink = convertSelfUrlToTonDeeplink(url);
      }
    } catch (err) {
      (0,logs/* logDebugError */.SJ)('parseDeeplinkTransferParams', err);
    }
  }
  return parseTonDeeplink(tonDeeplink, global);
}
function convertSelfDeeplinkToSelfUrl(deeplink) {
  if (deeplink.startsWith(SELF_PROTOCOL)) {
    return deeplink.replace(SELF_PROTOCOL, `${SELF_UNIVERSAL_URLS[0]}/`);
  }
  return deeplink;
}
function convertSelfUrlToTonDeeplink(deeplink) {
  deeplink = forceHttpsProtocol(deeplink);
  for (const selfUniversalUrl of SELF_UNIVERSAL_URLS) {
    if (deeplink.startsWith(selfUniversalUrl)) {
      return deeplink.replace(`${selfUniversalUrl}/`, TON_PROTOCOL);
    }
  }
  return deeplink;
}
function omitProtocol(url) {
  return url.replace(/^https?:\/\//, '');
}
function forceHttpsProtocol(url) {
  return url.replace(/^http:\/\//, 'https://');
}
function toNumberOrEmptyString(input) {
  return String(Number(input) || '');
}
function replaceAllSpacesWithPlus(value) {
  return value.replace(/ /g, '+');
}
function getDeeplinkSearchParam(url, param) {
  return url.searchParams.get(param) ?? undefined;
}
// EXTERNAL MODULE: ./src/util/windowProvider/methods/index.ts + 3 modules
var methods = __webpack_require__(95550);
;// ./node_modules/@capacitor/push-notifications/dist/esm/index.js

const PushNotifications = (0,dist/* registerPlugin */.F3)('PushNotifications', {});


//# sourceMappingURL=index.js.map
;// ./src/global/selectors/notifications.ts


// This selector is not optimized for usage with React components wrapped by withGlobal
function selectNotificationTonAddressesSlow(global, accountIds) {
  let maxCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
  const result = {};
  let resultCount = 0;
  for (const accountId of accountIds) {
    if (resultCount >= maxCount) {
      break;
    }
    const account = selectAccount(global, accountId);
    const address = account === null || account === void 0 ? void 0 : account.addressByChain.ton;
    if (address) {
      result[accountId] = {
        title: account.title,
        address,
        chain: 'ton'
      };
      resultCount += 1;
    }
  }
  return result;
}
;// ./src/api/constants.ts
const SEC = 1000;
const MINUTE = 60 * SEC;
const DAYS_IN_YEAR = 365;
const FIRST_TRANSACTIONS_LIMIT = 50;
const FAKE_TX_ID = 'fakeTxId';
;// ./src/util/capacitor/platform.ts
let platform;
function setCapacitorPlatform(newPlatform) {
  platform = newPlatform;
}
function getCapacitorPlatform() {
  return platform;
}
;// ./src/util/capacitor/notifications.ts










let nextUpdatePushNotifications = 0;
async function initNotificationsWithGlobal(global) {
  const isPushNotificationsAvailable = dist/* Capacitor */.Ii.isPluginAvailable('PushNotifications');
  setGlobal({
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      isAvailable: isPushNotificationsAvailable
    }
  });
  if (!isPushNotificationsAvailable) {
    return;
  }
  await PushNotifications.addListener('pushNotificationActionPerformed', handlePushNotificationActionPerformed);
  await PushNotifications.addListener('registration', handlePushNotificationRegistration);
  await PushNotifications.addListener('registrationError', err => {
    (0,logs/* logDebugError */.SJ)('Registration error: ', err.error);
  });
  let notificationStatus = await PushNotifications.checkPermissions();
  if (notificationStatus.receive === 'prompt-with-rationale') {
    return;
  }
  if (notificationStatus.receive === 'prompt') {
    notificationStatus = await PushNotifications.requestPermissions();
  }
  if (notificationStatus.receive !== 'granted') {
    // For request iOS returns 'denied', but 'granted' follows immediately without new requests
    return;
  }
  await PushNotifications.register();
}
function handlePushNotificationActionPerformed(notification) {
  const {
    showAnyAccountTx,
    showAnyAccountTokenActivity,
    openAnyAccountStakingInfo,
    switchAccountAndOpenUrl,
    openDomainRenewalModal
  } = getActions();
  const global = getGlobal();
  const notificationData = notification.notification.data;
  const {
    action,
    address
  } = notificationData;
  const accountId = address === undefined ? undefined : selectAccountIdByAddress(global, 'ton', address);
  const network = 'mainnet';
  if (action === 'openUrl') {
    switchAccountAndOpenUrl({
      accountId,
      network,
      ...(0,iteratees/* pick */.Up)(notificationData, ['url', 'isExternal', 'title', 'subtitle'])
    });
    return;
  }
  if (!accountId) return;
  if (action === 'nativeTx' || action === 'swap') {
    const {
      txId
    } = notificationData;
    showAnyAccountTx({
      accountId,
      txId,
      network
    });
  } else if (action === 'jettonTx') {
    const {
      slug
    } = notificationData;
    showAnyAccountTokenActivity({
      accountId,
      slug,
      network
    });
  } else if (action === 'staking') {
    const {
      stakingId
    } = notificationData;
    openAnyAccountStakingInfo({
      accountId,
      network,
      stakingId
    });
  } else if (action === 'expiringDns') {
    const {
      domainAddress
    } = notificationData;
    openDomainRenewalModal({
      accountId,
      network,
      addresses: [domainAddress]
    });
  }
}
function handlePushNotificationRegistration(token) {
  const userToken = token.value;
  getActions().registerNotifications({
    userToken,
    platform: getCapacitorPlatform()
  });
  window.addEventListener('focus', async () => {
    const global = getGlobal();
    const notificationAccounts = Object.keys(global.pushNotifications.enabledAccounts || []);
    if (notificationAccounts.length && nextUpdatePushNotifications <= Date.now()) {
      await (0,api/* callApi */.p)('subscribeNotifications', {
        userToken,
        platform: getCapacitorPlatform(),
        addresses: Object.values(selectNotificationTonAddressesSlow(global, notificationAccounts))
      });
      nextUpdatePushNotifications = Date.now() + 60 * MINUTE;
    }
  }, {
    capture: true
  });
}
;// ./src/util/capacitor/index.ts
















// Full list of options can be found at https://github.com/apache/cordova-plugin-inappbrowser#cordovainappbrowseropen
const INAPP_BROWSER_OPTIONS = [`location=${windowEnvironment/* IS_IOS */.pz ? 'no' : 'yes'}`, `lefttoright=${windowEnvironment/* IS_IOS */.pz ? 'no' : 'yes'}`, 'usewkwebview=yes', 'clearcache=no', 'clearsessioncache=no', 'hidden=yes', 'toolbarposition=top', 'hidenavigationbuttons=yes', 'hideurlbar=no', 'backbuttoncaption=Back', 'allowInlineMediaPlayback=yes'].join(',');
const IOS_SPLASH_SCREEN_HIDE_DELAY = 500;
const IOS_SPLASH_SCREEN_HIDE_DURATION = 600;
const VIBRATE_SUCCESS_END_PAUSE_MS = 1300;
let capacitor_isNativeBiometricAuthSupported = false;
let capacitor_isFaceIdAvailable = false;
let capacitor_isTouchIdAvailable = false;
let statusBarHeight = 0;
let safeAreaTop = 0;
let capacitorAppLaunchDeeplinkProcessedAt = 0;
const CAPACITOR_APP_URL_OPEN_EVENT_IGNORE_DELAY_MS = 500;
function capacitor_updateSafeAreaValues(safeAreaInsets) {
  for (const [key, value] of Object.entries(safeAreaInsets.insets)) {
    document.documentElement.style.setProperty(`--safe-area-${key}`, `${getCapacitorPlatform() === 'android' && key === 'top' ? value + 8 : value}px`);
  }
}
async function initCapacitor() {
  setCapacitorPlatform(dist/* Capacitor */.Ii.getPlatform());
  void SafeArea.getStatusBarHeight().then(_ref => {
    let {
      statusBarHeight: height
    } = _ref;
    statusBarHeight = height;
    document.documentElement.style.setProperty('--status-bar-height', `${height}px`);
  });
  void SafeArea.getSafeAreaInsets().then(_ref2 => {
    let {
      insets: {
        bottom,
        top
      }
    } = _ref2;
    safeAreaTop = top;
    document.documentElement.style.setProperty('--safe-area-bottom', `${bottom}px`);
  });
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    void SplashScreen.hide({
      fadeOutDuration: 0
    });
    return;
  }
  if (getCapacitorPlatform() === 'ios') {
    setTimeout(() => {
      void SplashScreen.hide({
        fadeOutDuration: IOS_SPLASH_SCREEN_HIDE_DURATION
      });
    }, IOS_SPLASH_SCREEN_HIDE_DELAY);
  }
  void App.addListener('appUrlOpen', event => {
    // Prevent processing the same deeplink twice on cold start
    // 1. `app.getLaunchUrl()` returns the deeplink
    // 2. And the `appUrlOpen` event contains the same deeplink
    if (Date.now() - capacitorAppLaunchDeeplinkProcessedAt > CAPACITOR_APP_URL_OPEN_EVENT_IGNORE_DELAY_MS) {
      void processDeeplink(event.url);
    } else {
      (0,logs/* logDebug */.MD)(`[CAPACITOR] appUrlOpen event ignored`, event);
    }
  });
  void App.addListener('backButton', _ref3 => {
    let {
      canGoBack
    } = _ref3;
    if (canGoBack) {
      window.history.back();
    } else {
      void App.exitApp();
    }
  });
  capacitor_updateSafeAreaValues(await SafeArea.getSafeAreaInsets());
  await SafeArea.addListener('safeAreaChanged', data => {
    capacitor_updateSafeAreaValues(data);
  });
}
async function processCapacitorLaunchDeeplink() {
  var _await$App$getLaunchU;
  const launchUrl = (_await$App$getLaunchU = await App.getLaunchUrl()) === null || _await$App$getLaunchU === void 0 ? void 0 : _await$App$getLaunchU.url;
  if (launchUrl) {
    void processDeeplink(launchUrl);
  }
  capacitorAppLaunchDeeplinkProcessedAt = Date.now();
}
async function initCapacitorWithGlobal(authConfig) {
  const isNativeBiometricAuthEnabled = !!authConfig && authConfig.kind === 'native-biometrics';
  const biometricsAvailableResult = await NativeBiometric.isAvailable({
    isWeakAuthenticatorAllowed: isNativeBiometricAuthEnabled,
    useFallback: false
  });
  capacitor_isNativeBiometricAuthSupported = biometricsAvailableResult.isAvailable;
  capacitor_isFaceIdAvailable = biometricsAvailableResult.biometryType === BiometryType.FACE_ID;
  capacitor_isTouchIdAvailable = biometricsAvailableResult.biometryType === BiometryType.TOUCH_ID;
  void initNotificationsWithGlobal(getGlobal());
}
function getStatusBarHeight() {
  return statusBarHeight;
}
function capacitor_getSafeAreaTop() {
  return safeAreaTop;
}
function getIsCapacitorBiometricAuthSupported() {
  return capacitor_isNativeBiometricAuthSupported;
}
function getIsCapacitorFaceIdAvailable() {
  return capacitor_isFaceIdAvailable;
}
function getIsCapacitorTouchIdAvailable() {
  return capacitor_isTouchIdAvailable;
}
async function fixIosAppStorage() {
  await methods.init();
  const isLocalStorageDataExists = Boolean(window.localStorage.getItem(src_config/* GLOBAL_STATE_CACHE_KEY */.pge));
  const isApiStorageDataExists = Boolean(await methods.capacitorStorageGetItem('accounts'));
  if (isLocalStorageDataExists && !isApiStorageDataExists) {
    window.localStorage.clear();
  }
  if (!isLocalStorageDataExists && isApiStorageDataExists) {
    await methods.capacitorStorageClear();
  }
}
function switchToAir() {
  void (0,api/* callApi */.p)('destroy');
  AirAppLauncher.switchToAir();
}
;// ./src/util/biometrics.ts




function getIsBiometricAuthSupported() {
  return windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh || getIsNativeBiometricAuthSupported();
}
function getIsNativeBiometricAuthSupported() {
  return src_config/* IS_CAPACITOR */.UMQ && getIsCapacitorBiometricAuthSupported() || src_config/* IS_TELEGRAM_APP */.tKX && getIsTelegramBiometricAuthSupported();
}
function getIsFaceIdAvailable() {
  return src_config/* IS_CAPACITOR */.UMQ && getIsCapacitorFaceIdAvailable() || src_config/* IS_TELEGRAM_APP */.tKX && getIsTelegramFaceIdAvailable();
}
function getIsTouchIdAvailable() {
  return src_config/* IS_CAPACITOR */.UMQ && getIsCapacitorTouchIdAvailable() || src_config/* IS_TELEGRAM_APP */.tKX && getIsTelegramTouchIdAvailable();
}
function getDoesUsePinPad() {
  return src_config/* IS_CAPACITOR */.UMQ || (0,windowEnvironment/* getIsMobileTelegramApp */.v3)();
}
;// ./node_modules/@capacitor/clipboard/dist/esm/web.js

class ClipboardWeb extends dist/* WebPlugin */.E_ {
    async write(options) {
        if (typeof navigator === 'undefined' || !navigator.clipboard) {
            throw this.unavailable('Clipboard API not available in this browser');
        }
        if (options.string !== undefined) {
            await this.writeText(options.string);
        }
        else if (options.url) {
            await this.writeText(options.url);
        }
        else if (options.image) {
            if (typeof ClipboardItem !== 'undefined') {
                try {
                    const blob = await (await fetch(options.image)).blob();
                    const clipboardItemInput = new ClipboardItem({ [blob.type]: blob });
                    await navigator.clipboard.write([clipboardItemInput]);
                }
                catch (err) {
                    throw new Error('Failed to write image');
                }
            }
            else {
                throw this.unavailable('Writing images to the clipboard is not supported in this browser');
            }
        }
        else {
            throw new Error('Nothing to write');
        }
    }
    async read() {
        if (typeof navigator === 'undefined' || !navigator.clipboard) {
            throw this.unavailable('Clipboard API not available in this browser');
        }
        if (typeof ClipboardItem !== 'undefined') {
            try {
                const clipboardItems = await navigator.clipboard.read();
                const type = clipboardItems[0].types[0];
                const clipboardBlob = await clipboardItems[0].getType(type);
                const data = await this._getBlobData(clipboardBlob, type);
                return { value: data, type };
            }
            catch (err) {
                return this.readText();
            }
        }
        else {
            return this.readText();
        }
    }
    async readText() {
        if (typeof navigator === 'undefined' ||
            !navigator.clipboard ||
            !navigator.clipboard.readText) {
            throw this.unavailable('Reading from clipboard not supported in this browser');
        }
        const text = await navigator.clipboard.readText();
        return { value: text, type: 'text/plain' };
    }
    async writeText(text) {
        if (typeof navigator === 'undefined' ||
            !navigator.clipboard ||
            !navigator.clipboard.writeText) {
            throw this.unavailable('Writting to clipboard not supported in this browser');
        }
        await navigator.clipboard.writeText(text);
    }
    _getBlobData(clipboardBlob, type) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            if (type.includes('image')) {
                reader.readAsDataURL(clipboardBlob);
            }
            else {
                reader.readAsText(clipboardBlob);
            }
            reader.onloadend = () => {
                const r = reader.result;
                resolve(r);
            };
            reader.onerror = e => {
                reject(e);
            };
        });
    }
}
//# sourceMappingURL=web.js.map
;// ./node_modules/@capacitor/clipboard/dist/esm/index.js


const Clipboard = (0,dist/* registerPlugin */.F3)('Clipboard', {
    web: () => new ClipboardWeb(),
});


//# sourceMappingURL=index.js.map
// EXTERNAL MODULE: ./node_modules/@capacitor/haptics/dist/esm/definitions.js
var definitions = __webpack_require__(23693);
;// ./node_modules/@capacitor/haptics/dist/esm/index.js

const Haptics = (0,dist/* registerPlugin */.F3)('Haptics', {
    web: () => __webpack_require__.e(/* import() */ 789).then(__webpack_require__.bind(__webpack_require__, 83789)).then(m => new m.HapticsWeb()),
});


//# sourceMappingURL=index.js.map
;// ./src/util/haptics.ts





async function vibrate() {
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    var _getTelegramApp;
    (_getTelegramApp = telegram_getTelegramApp()) === null || _getTelegramApp === void 0 || _getTelegramApp.HapticFeedback.impactOccurred('soft');
  } else if (src_config/* IS_CAPACITOR */.UMQ) {
    await Haptics.impact({
      style: definitions/* ImpactStyle */.k.Light
    });
  }
}
async function vibrateOnError() {
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    var _getTelegramApp2;
    (_getTelegramApp2 = telegram_getTelegramApp()) === null || _getTelegramApp2 === void 0 || _getTelegramApp2.HapticFeedback.notificationOccurred('error');
  } else if (src_config/* IS_CAPACITOR */.UMQ) {
    await Haptics.impact({
      style: definitions/* ImpactStyle */.k.Medium
    });
    await (0,schedulers/* pause */.v7)(100);
    await Haptics.impact({
      style: definitions/* ImpactStyle */.k.Medium
    });
    await (0,schedulers/* pause */.v7)(75);
    await Haptics.impact({
      style: definitions/* ImpactStyle */.k.Light
    });
  }
}
async function vibrateOnSuccess() {
  let withPauseOnEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  if (!src_config/* IS_CAPACITOR */.UMQ && !src_config/* IS_TELEGRAM_APP */.tKX) return;
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    var _getTelegramApp3;
    (_getTelegramApp3 = telegram_getTelegramApp()) === null || _getTelegramApp3 === void 0 || _getTelegramApp3.HapticFeedback.notificationOccurred('success');
  } else {
    await Haptics.impact({
      style: definitions/* ImpactStyle */.k.Light
    });
  }
  if (withPauseOnEnd) {
    await (0,schedulers/* pause */.v7)(VIBRATE_SUCCESS_END_PAUSE_MS);
  }
}
;// ./src/util/clipboard.ts




const textCopyEl = document.createElement('textarea');
textCopyEl.setAttribute('readonly', '');
textCopyEl.tabIndex = -1;
textCopyEl.className = 'visually-hidden';
const copyTextToClipboard = str => {
  void vibrate();
  if (src_config/* IS_CAPACITOR */.UMQ) {
    return Clipboard.write({
      string: str
    });
  }
  return navigator.clipboard.writeText(str);
};
async function readClipboardContent() {
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    return new Promise(resolve => {
      var _getTelegramApp;
      (_getTelegramApp = telegram_getTelegramApp()) === null || _getTelegramApp === void 0 || _getTelegramApp.readTextFromClipboard(text => {
        void vibrate();
        resolve({
          text,
          type: 'text/plain'
        });
      });
    });
  } else if (src_config/* IS_CAPACITOR */.UMQ) {
    const {
      value,
      type
    } = await Clipboard.read();
    void vibrate();
    return {
      text: value,
      type
    };
  } else {
    const text = await navigator.clipboard.readText();
    return {
      text,
      type: 'text/plain'
    };
  }
}
;// ./src/util/isMnemonicPrivateKey.ts

function isMnemonicPrivateKey(mnemonic) {
  return mnemonic.length === 1 && mnemonic[0].length === src_config/* PRIVATE_KEY_HEX_LENGTH */.PcM;
}
;// ./src/util/deepDiff.ts

const EQUAL = Symbol('EQUAL');
const DELETE = {
  __delete: true
};
const DELETE_ALL_CHILDREN = {
  __deleteAllChildren: true
};
function deepDiff(value1, value2) {
  if (value1 === value2) {
    return EQUAL;
  }
  const type1 = typeof value1;
  const type2 = typeof value2;
  if (type1 !== type2) {
    return value2;
  }
  if (Array.isArray(value1) && Array.isArray(value2) && areSortedArraysDeepEqual(value1, value2)) {
    return EQUAL;
  }
  if (!(0,iteratees/* isLiteralObject */.Vh)(value1) || !(0,iteratees/* isLiteralObject */.Vh)(value2)) {
    return value2;
  }
  const object1 = value1;
  const object2 = value2;
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return !keys1.length ? EQUAL : DELETE_ALL_CHILDREN;
  }
  const allKeys = (0,iteratees/* unique */.Am)(keys1.concat(keys2));
  const diff = allKeys.reduce((acc, key) => {
    const subValue1 = object1[key];
    const subValue2 = object2[key];
    if (!object2.hasOwnProperty(key)) {
      acc[key] = DELETE;
      return acc;
    }
    if (!object1.hasOwnProperty(key)) {
      acc[key] = subValue2;
      return acc;
    }
    const subDiff = deepDiff(subValue1, subValue2);
    if (subDiff !== EQUAL) {
      acc[key] = subDiff;
    }
    return acc;
  }, {});
  if (Object.keys(diff).length === 0) {
    return EQUAL;
  }
  return diff;
}
function areSortedArraysDeepEqual(array1, array2) {
  if (array1.length !== array2.length) {
    return false;
  }
  return array1.every((item, i) => deepDiff(item, array2[i]) === EQUAL);
}
;// ./src/util/deepMerge.ts

function deepMerge(value1, value2) {
  if (value1 === value2) {
    return value2;
  }
  if (!(0,iteratees/* isLiteralObject */.Vh)(value2)) {
    return value2;
  }
  if (!(0,iteratees/* isLiteralObject */.Vh)(value1)) {
    return reduceDiff(value2);
  }
  if (value2.__deleteAllChildren) {
    return {};
  }
  const allKeys = (0,iteratees/* unique */.Am)(Object.keys(value1).concat(Object.keys(value2)));
  return allKeys.reduce((acc, key) => {
    const oldValue = value1[key];
    if (!value2.hasOwnProperty(key)) {
      acc[key] = oldValue;
    } else {
      const newValue = value2[key];
      if (!(newValue !== null && newValue !== void 0 && newValue.__delete)) {
        acc[key] = deepMerge(oldValue, newValue);
      }
    }
    return acc;
  }, {});
}
function reduceDiff(diff) {
  if (diff.__deleteAllChildren) {
    return {};
  }
  return Object.entries(diff).reduce((acc, _ref) => {
    let [key, value] = _ref;
    if (!(value !== null && value !== void 0 && value.__delete)) {
      acc[key] = (0,iteratees/* isLiteralObject */.Vh)(value) ? reduceDiff(value) : value;
    }
    return acc;
  }, {});
}
;// ./src/hooks/useBackgroundMode.ts





const [getIsInBackgroundLocal, setIsInBackground] = createSignal(!document.hasFocus());
const getIsInBackground = getIsInBackgroundLocal;
function handleBlur() {
  setIsInBackground(true);
}
function handleFocus() {
  setIsInBackground(false);
}
if (src_config/* IS_TELEGRAM_APP */.tKX) {
  void getTelegramAppAsync().then(telegramApp => {
    telegramApp.onEvent('activated', handleFocus);
    telegramApp.onEvent('deactivated', handleBlur);
    setIsInBackground(!(telegramApp !== null && telegramApp !== void 0 && telegramApp.isActive));
  });
} else {
  window.addEventListener('blur', handleBlur);
  window.addEventListener('focus', handleFocus);
}
function useBackgroundMode(onBlur, onFocus) {
  let isDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const lastOnBlur = useLastCallback(onBlur);
  const lastOnFocus = useLastCallback(onFocus);
  teact_useEffect(() => {
    if (isDisabled) {
      return undefined;
    }
    if (getIsInBackground()) {
      lastOnBlur();
    }
    return getIsInBackground.subscribe(() => {
      if (getIsInBackground()) {
        lastOnBlur();
      } else {
        lastOnFocus();
      }
    });
  }, [isDisabled, lastOnBlur, lastOnFocus]);
}
function isBackgroundModeActive() {
  return getIsInBackground();
}
;// ./src/util/multitab.ts










const channel = windowEnvironment/* IS_MULTITAB_SUPPORTED */.bs ? new BroadcastChannel(src_config/* MULTITAB_DATA_CHANNEL_NAME */.eoU) : undefined;
let multitab_currentGlobal = getGlobal();
let messageIndex = 0;
function initMultitab() {
  let {
    noPubGlobal
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!channel) return;
  if (!noPubGlobal) {
    addCallback(handleGlobalChange);
  }
  channel.addEventListener('message', handleMultitabMessage);
}
function handleGlobalChange(global) {
  if (global === multitab_currentGlobal) return;

  // One of the goals of this check is preventing the Delegated Bottom Sheet global state initialization (performed by
  // src/global/init.ts) from propagating to the main WebView. Normally this is prevented by `isBackgroundModeActive()`
  // (the Sheet should be out of focus during the initialization), but we suspect that this approach is not fully
  // reliable, because the focus may be in the Sheet during the initialization. So an extra `isInited` check is used -
  // `isInited: false` appears only in the initial Teactn global state (see src/lib/teact/teactn.tsx) and we expect the
  // first global change to be the initialization.
  if (isBackgroundModeActive() || multitab_currentGlobal.isInited === false) {
    multitab_currentGlobal = global;
    return;
  }
  const diff = deepDiff(omitLocalOnlyKeys(multitab_currentGlobal), omitLocalOnlyKeys(global));
  if (typeof diff !== 'symbol') {
    channel.postMessage({
      type: 'globalDiffUpdate',
      diff
    });
  }
  multitab_currentGlobal = global;
}
function omitLocalOnlyKeys(global) {
  return (0,iteratees/* omit */.cJ)(global, ['DEBUG_randomId']);
}
async function handleMultitabMessage(_ref) {
  let {
    data
  } = _ref;
  switch (data.type) {
    case 'globalDiffUpdate':
      {
        if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return;
        multitab_currentGlobal = deepMerge(getGlobal(), data.diff);
        setGlobal(multitab_currentGlobal);
        break;
      }
    case 'callAction':
      {
        const {
          recipient,
          name,
          options
        } = data;
        if (!doesMessageRecipientMatch(recipient)) return;
        getActions()[name](options);
        break;
      }
    case 'callApiRequest':
      {
        const {
          recipient,
          messageId,
          name,
          args
        } = data;
        if (!doesMessageRecipientMatch(recipient)) return;
        const [result] = await Promise.allSettled([(0,api/* callApi */.p)(name, ...args)]);
        channel.postMessage({
          type: 'callApiResponse',
          messageId,
          result
        });
        break;
      }
    case 'getLogsFromNative':
      {
        if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return;
        channel.postMessage({
          type: 'logsFromNative',
          logs: (0,logs/* getLogs */.ao)()
        });
        break;
      }
  }
}
function doesMessageRecipientMatch(recipient) {
  return windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI && recipient === 'main' || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && recipient === 'native';
}
function callActionInMain(name, options) {
  channel.postMessage({
    type: 'callAction',
    recipient: 'main',
    name,
    options
  });
}
function callActionInNative(name, options) {
  channel.postMessage({
    type: 'callAction',
    recipient: 'native',
    name,
    options
  });
}
function callApiInMain(name) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    return (0,api/* callApi */.p)(name, ...args);
  }
  const messageId = ++messageIndex;
  return new Promise((resolve, reject) => {
    const handleMessage = _ref2 => {
      let {
        data
      } = _ref2;
      if (data.type === 'callApiResponse' && data.messageId === messageId) {
        channel.removeEventListener('message', handleMessage);
        if (data.result.status === 'fulfilled') {
          resolve(data.result.value);
        } else {
          reject(data.result.reason);
        }
      }
    };
    channel.addEventListener('message', handleMessage);
    channel.postMessage({
      type: 'callApiRequest',
      recipient: 'main',
      messageId,
      name,
      args
    });
  });
}
function getLogsFromNative() {
  if (!windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) return Promise.resolve([]);
  return new Promise(resolve => {
    const handleMessage = _ref3 => {
      let {
        data
      } = _ref3;
      if (data.type === 'logsFromNative') {
        channel.removeEventListener('message', handleMessage);
        resolve(data.logs);
      }
    };
    channel.addEventListener('message', handleMessage);
    channel.postMessage({
      type: 'getLogsFromNative'
    });
  });
}
;// ./src/global/initialState.ts



const STATE_VERSION = 45;
const INITIAL_STATE = {
  appState: AppState.Auth,
  auth: {
    state: AuthState.none
  },
  biometrics: {
    state: BiometricsState.None
  },
  hardware: {
    hardwareState: HardwareConnectState.Connect
  },
  currentTransfer: {
    state: TransferState.None,
    tokenSlug: src_config/* DEFAULT_TRANSFER_TOKEN_SLUG */.ScF
  },
  currentDomainRenewal: {
    state: DomainRenewalState.None
  },
  currentDomainLinking: {
    state: DomainLinkingState.None
  },
  currentSwap: {
    state: SwapState.None,
    slippage: src_config/* DEFAULT_SLIPPAGE_VALUE */.k9U
  },
  currentDappTransfer: {
    state: TransferState.None
  },
  currentDappSignData: {
    state: SignDataState.None
  },
  currentStaking: {
    state: StakingState.None
  },
  stakingDefault: src_config/* DEFAULT_STAKING_STATE */.USn,
  tokenInfo: {
    bySlug: src_config/* TOKEN_INFO */.lfO
  },
  swapTokenInfo: {
    bySlug: src_config/* INIT_SWAP_ASSETS */.tCm
  },
  swapVersion: src_config/* SWAP_API_VERSION */.AuB,
  tokenPriceHistory: {
    bySlug: {}
  },
  settings: {
    state: SettingsState.Initial,
    theme: src_config/* THEME_DEFAULT */.YnH,
    animationLevel: src_config/* ANIMATION_LEVEL_DEFAULT */.i11,
    areTinyTransfersHidden: !src_config/* SHOULD_SHOW_ALL_ASSETS_AND_ACTIVITY */.K_I,
    canPlaySounds: true,
    langCode: windowEnvironment/* USER_AGENT_LANG_CODE */.$q,
    byAccountId: {},
    areTokensWithNoCostHidden: !src_config/* SHOULD_SHOW_ALL_ASSETS_AND_ACTIVITY */.K_I,
    isSortByValueEnabled: true,
    isAppLockEnabled: true,
    autolockValue: src_config/* DEFAULT_AUTOLOCK_OPTION */.fPM
  },
  byAccountId: {},
  dialogs: [],
  notifications: [],
  stateVersion: STATE_VERSION,
  restrictions: {
    isLimitedRegion: false,
    isSwapDisabled: windowEnvironment/* IS_IOS_APP */.ZH || src_config/* IS_CORE_WALLET */.TI6,
    isOnRampDisabled: windowEnvironment/* IS_IOS_APP */.ZH || src_config/* IS_CORE_WALLET */.TI6,
    isNftBuyingDisabled: windowEnvironment/* IS_IOS_APP */.ZH
  },
  mediaViewer: {},
  pushNotifications: {
    enabledAccounts: {}
  }
};
;// ./src/util/areDeepEqual.ts
function areDeepEqual(value1, value2) {
  const type1 = typeof value1;
  const type2 = typeof value2;
  if (type1 !== type2) {
    return false;
  }

  // eslint-disable-next-line no-null/no-null
  if (type1 !== 'object' || value1 === null || value2 === null) {
    return value1 === value2;
  }
  const isArray1 = Array.isArray(value1);
  const isArray2 = Array.isArray(value2);
  if (isArray1 !== isArray2) {
    return false;
  }
  if (isArray1) {
    const array1 = value1;
    const array2 = value2;
    if (array1.length !== array2.length) {
      return false;
    }
    return array1.every((member1, i) => areDeepEqual(member1, array2[i]));
  }
  const object1 = value1;
  const object2 = value2;
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (!keys1.every(key1 => object2.hasOwnProperty(key1))) {
    return false;
  }
  if (!keys2.every(key2 => object1.hasOwnProperty(key2))) {
    return false;
  }
  return keys1.every(key1 => areDeepEqual(object1[key1], object2[key1]));
}
;// ./src/util/isPartialDeepEqual.ts


function isPartialDeepEqual(node, newPartial) {
  const currentPartial = (0,iteratees/* pick */.Up)(node, Object.keys(newPartial));
  return areDeepEqual(currentPartial, newPartial);
}
;// ./src/global/reducers/misc.ts




function updateAuth(global, authUpdate) {
  return {
    ...global,
    auth: {
      ...global.auth,
      ...authUpdate
    }
  };
}
function updateAccounts(global, state) {
  return {
    ...global,
    accounts: {
      ...(global.accounts || {
        byId: {}
      }),
      ...state
    }
  };
}
function setIsPinAccepted(global) {
  return {
    ...global,
    isPinAccepted: true
  };
}
function clearIsPinAccepted(global) {
  return global.isPinAccepted ? {
    ...global,
    isPinAccepted: undefined
  } : global;
}
function createAccount(_ref) {
  var _global$accounts;
  let {
    global,
    accountId,
    type,
    addressByChain,
    partial,
    titlePostfix,
    network,
    isMnemonicImported
  } = _ref;
  const account = {
    ...partial,
    type,
    addressByChain
  };
  let shouldForceAccountEdit = true;
  if (!account.title) {
    network = network || selectCurrentNetwork(global);
    const accounts = selectNetworkAccounts(global) || {};
    const accountAmount = Object.keys(accounts).length;
    const isMainnet = network === 'mainnet';
    const viewWalletsCount = Object.values(accounts).filter(acc => acc.type === 'view').length;
    const regularWalletsCount = accountAmount - viewWalletsCount;
    const titlePrefix = type === 'view' ? 'View Wallet' : isMainnet ? 'Wallet' : 'Testnet Wallet';
    const postfix = titlePostfix ? ` ${titlePostfix}` : '';
    const count = type === 'view' ? viewWalletsCount + 1 : regularWalletsCount + 1;
    account.title = `${titlePrefix} ${count}${postfix}`;
    if (accountAmount === 0) {
      account.title = isMainnet ? src_config/* APP_NAME */.C39 : `Testnet ${src_config/* APP_NAME */.C39}`;
      shouldForceAccountEdit = false;
    }
  } else if (titlePostfix) {
    var _account$title;
    const title = (_account$title = account.title) === null || _account$title === void 0 ? void 0 : _account$title.replace(new RegExp(`\\b(${src_config/* POPULAR_WALLET_VERSIONS */.eZ2.join('|')})\\b`, 'g'), '');
    account.title = `${title.trim()} ${titlePostfix}`;
  }
  if (!src_config/* IS_CORE_WALLET */.TI6) {
    global = {
      ...global,
      shouldForceAccountEdit
    };
  }
  if (selectAccount(global, accountId)) {
    throw new Error(`Account ${accountId} already exists`);
  }
  return {
    ...global,
    accounts: {
      ...global.accounts,
      byId: {
        ...((_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.byId),
        [accountId]: account
      }
    }
  };
}
function updateAccount(global, accountId, partial) {
  var _global$accounts2;
  const account = selectAccount(global, accountId);
  if (!account) {
    throw new Error(`Account ${accountId} doesn't exist`);
  }
  return {
    ...global,
    accounts: {
      ...global.accounts,
      byId: {
        ...((_global$accounts2 = global.accounts) === null || _global$accounts2 === void 0 ? void 0 : _global$accounts2.byId),
        [accountId]: {
          ...account,
          ...partial
        }
      }
    }
  };
}
function renameAccount(global, accountId, title) {
  return updateAccount(global, accountId, {
    title
  });
}
function createAccountsFromGlobal(global) {
  let isMnemonicImported = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  const {
    firstNetworkAccount,
    secondNetworkAccount
  } = global.auth;
  global = createAccount({
    global,
    type: 'mnemonic',
    ...firstNetworkAccount,
    isMnemonicImported
  });
  if (secondNetworkAccount) {
    global = createAccount({
      global,
      type: 'mnemonic',
      ...secondNetworkAccount,
      isMnemonicImported
    });
  }
  return global;
}
function updateBalances(global, accountId, chain, chainBalances) {
  var _selectAccountState, _selectAccountSetting, _selectAccountOrAuthA;
  const newBalances = {
    ...chainBalances
  };
  const currentBalances = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 || (_selectAccountState = _selectAccountState.balances) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.bySlug) ?? {};
  for (const [slug, currentBalance] of Object.entries(currentBalances)) {
    if (getChainBySlug(slug) !== chain) {
      newBalances[slug] = currentBalance;
    }
  }

  // Force balance value for USDT-TON and manually imported tokens
  const importedSlugs = ((_selectAccountSetting = selectAccountSettings(global, accountId)) === null || _selectAccountSetting === void 0 ? void 0 : _selectAccountSetting.importedSlugs) ?? [];
  // Balance updates may arrive before authentication is complete
  const hasTonWallet = Boolean((_selectAccountOrAuthA = selectAccountOrAuthAccount(global, accountId)) === null || _selectAccountOrAuthA === void 0 || (_selectAccountOrAuthA = _selectAccountOrAuthA.addressByChain) === null || _selectAccountOrAuthA === void 0 ? void 0 : _selectAccountOrAuthA.ton);
  let forcedSlugs = importedSlugs;
  if (hasTonWallet) forcedSlugs = [...forcedSlugs, src_config/* TON_USDT_SLUG */.rUK];
  for (const slug of forcedSlugs) {
    if (!(slug in newBalances)) {
      newBalances[slug] = 0n;
    }
  }
  return misc_updateAccountState(global, accountId, {
    balances: {
      bySlug: newBalances
    }
  });
}
function changeBalance(global, accountId, slug, balance) {
  var _selectAccountState2;
  return misc_updateAccountState(global, accountId, {
    balances: {
      bySlug: {
        ...((_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 || (_selectAccountState2 = _selectAccountState2.balances) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.bySlug),
        [slug]: balance
      }
    }
  });
}
function updateTokens(global, partial) {
  var _global$tokenInfo;
  let withDeepCompare = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const existingTokens = (_global$tokenInfo = global.tokenInfo) === null || _global$tokenInfo === void 0 ? void 0 : _global$tokenInfo.bySlug;

  // If the backend does not work, then we won't delete the old prices
  if (!partial[src_config/* TONCOIN */.Tu9.slug].price) {
    partial = Object.values(partial).reduce((result, token) => {
      const existingToken = existingTokens === null || existingTokens === void 0 ? void 0 : existingTokens[token.slug];
      result[token.slug] = {
        ...token,
        price: (existingToken === null || existingToken === void 0 ? void 0 : existingToken.price) ?? token.price,
        priceUsd: (existingToken === null || existingToken === void 0 ? void 0 : existingToken.priceUsd) ?? token.priceUsd,
        percentChange24h: (existingToken === null || existingToken === void 0 ? void 0 : existingToken.percentChange24h) ?? token.percentChange24h
      };
      return result;
    }, {});
  }
  if (withDeepCompare && existingTokens && isPartialDeepEqual(existingTokens, partial)) {
    return global;
  }
  return {
    ...global,
    tokenInfo: {
      ...global.tokenInfo,
      bySlug: {
        ...existingTokens,
        ...partial
      }
    }
  };
}
function updateSwapTokens(global, partial) {
  var _global$swapTokenInfo;
  const currentTokens = (_global$swapTokenInfo = global.swapTokenInfo) === null || _global$swapTokenInfo === void 0 ? void 0 : _global$swapTokenInfo.bySlug;
  return {
    ...global,
    swapTokenInfo: {
      ...global.swapTokenInfo,
      bySlug: {
        ...currentTokens,
        ...partial
      },
      isLoaded: true
    }
  };
}
function updateCurrentAccountState(global, partial) {
  return misc_updateAccountState(global, global.currentAccountId, partial);
}
function misc_updateAccountState(global, accountId, partial) {
  let withDeepCompare = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // Updates from the API may arrive after the account is removed.
  // This check prevents that useless data from persisting in the global state.
  if (!doesAccountExist(global, accountId)) {
    return global;
  }
  const accountState = accounts_selectAccountState(global, accountId);
  if (withDeepCompare && accountState && isPartialDeepEqual(accountState, partial)) {
    return global;
  }
  return {
    ...global,
    byAccountId: {
      ...global.byAccountId,
      [accountId]: {
        ...accountState,
        ...partial
      }
    }
  };
}
function updateSettings(global, settingsUpdate) {
  return {
    ...global,
    settings: {
      ...global.settings,
      ...settingsUpdate
    }
  };
}
function updateAccountSettings(global, accountId, settingsUpdate) {
  // Updates from the API may arrive after the account is removed.
  // This check prevents that useless data from persisting in the global state.
  if (!doesAccountExist(global, accountId)) {
    return global;
  }
  return {
    ...global,
    settings: {
      ...global.settings,
      byAccountId: {
        ...global.settings.byAccountId,
        [accountId]: {
          ...global.settings.byAccountId[accountId],
          ...settingsUpdate
        }
      }
    }
  };
}
function updateCurrentAccountSettings(global, settingsUpdate) {
  return updateAccountSettings(global, global.currentAccountId, settingsUpdate);
}
function updateBiometrics(global, biometricsUpdate) {
  return {
    ...global,
    biometrics: {
      ...global.biometrics,
      ...biometricsUpdate
    }
  };
}
function updateRestrictions(global, partial) {
  return {
    ...global,
    restrictions: {
      ...global.restrictions,
      ...partial
    }
  };
}
function updateCurrentAccountId(global, accountId) {
  if (!accountId) {
    throw Error('Empty accountId!');
  }
  return {
    ...global,
    currentAccountId: accountId
  };
}
function doesAccountExist(global, accountId) {
  return !!selectAccountOrAuthAccount(global, accountId);
}
;// ./src/global/helpers/swap.ts

function shouldAvoidSwapEstimation(global) {
  // For a better UX, we should leave the fees and the other swap data intact during swap confirmation (for example,
  // to avoid switching from/to gasless mode).
  // `isEstimating` forces estimation, because by design it means that there was a swap parameter change that
  // invalidates the current swap estimation.
  return !global.currentSwap.isEstimating && (global.currentSwap.state === SwapState.Blockchain || global.currentSwap.state === SwapState.Password);
}

/**
 * Returns true if the swap estimate prepared for the global 1 is suitable for the global 2
 */
function isSwapEstimateInputEqual(_ref, _ref2) {
  let {
    currentSwap: swap1
  } = _ref;
  let {
    currentSwap: swap2
  } = _ref2;
  const amountKey = swap1.inputSource === SwapInputSource.In ? 'amountIn' : 'amountOut';
  return swap1.tokenInSlug === swap2.tokenInSlug && swap1.tokenOutSlug === swap2.tokenOutSlug && swap1.slippage === swap2.slippage && swap1.inputSource === swap2.inputSource && swap1.isMaxAmount === swap2.isMaxAmount && (swap2.isMaxAmount || swap1[amountKey] === swap2[amountKey]);
}

/**
 * Returns true is the swap form has enough data to start estimation
 */
function isSwapFormFilled(_ref3) {
  let {
    currentSwap
  } = _ref3;
  const amountKey = currentSwap.inputSource === SwapInputSource.In ? 'amountIn' : 'amountOut';
  return currentSwap.tokenInSlug && currentSwap.tokenOutSlug && Number(currentSwap[amountKey] ?? '0') > 0; // The backend fails if the amount is "0", "0.0", etc
}
function doesSwapChangeRequireEstimation(globalBefore, globalAfter) {
  return isSwapFormFilled(globalAfter) && !isSwapEstimateInputEqual(globalBefore, globalAfter);
}
function doesSwapChangeRequireEstimationReset(globalBefore, globalAfter) {
  return !isSwapFormFilled(globalAfter) || globalBefore.currentSwap.tokenInSlug !== globalAfter.currentSwap.tokenInSlug || globalBefore.currentSwap.tokenOutSlug !== globalAfter.currentSwap.tokenOutSlug;
}
function doesSwapChangeRequireDexUnselect(_ref4, _ref5) {
  let {
    currentSwap: swap1
  } = _ref4;
  let {
    currentSwap: swap2
  } = _ref5;
  const amountKey = swap1.inputSource === SwapInputSource.In ? 'amountIn' : 'amountOut';
  return swap1.tokenInSlug !== swap2.tokenInSlug || swap1.tokenOutSlug !== swap2.tokenOutSlug || swap1.inputSource !== swap2.inputSource || !(swap1.isMaxAmount && swap2.isMaxAmount || swap1[amountKey] === swap2[amountKey]);
}

/**
 * Returns the `currentSwap` parameters that should be set when it's impossible to estimate the current swap or no
 * estimation has been done.
 */
function getSwapEstimateResetParams(global) {
  const amountReset = global.currentSwap.inputSource === SwapInputSource.In ? {
    amountOut: undefined
  } : {
    amountIn: undefined
  };
  return {
    ...amountReset,
    amountOutMin: '0',
    priceImpact: 0,
    errorType: undefined,
    limits: undefined,
    dieselStatus: undefined,
    estimates: undefined,
    bestRateDexLabel: undefined,
    networkFee: undefined,
    realNetworkFee: undefined,
    swapFee: undefined,
    swapFeePercent: undefined,
    ourFee: undefined,
    ourFeePercent: undefined,
    dieselFee: undefined
  };
}
;// ./src/global/reducers/swap.ts




function rawUpdateCurrentSwap(global, update) {
  return {
    ...global,
    currentSwap: {
      ...global.currentSwap,
      ...update
    }
  };
}
function updateCurrentSwap(global, update,
// Set to true if you want to not trigger the swap estimation, and you are sure estimation is not needed
doAvoidEstimation) {
  let newGlobal = rawUpdateCurrentSwap(global, update);
  if (!doAvoidEstimation) {
    if (doesSwapChangeRequireEstimationReset(global, newGlobal)) {
      newGlobal = rawUpdateCurrentSwap(newGlobal, getSwapEstimateResetParams(newGlobal));
    }
    if (doesSwapChangeRequireEstimation(global, newGlobal)) {
      newGlobal = rawUpdateCurrentSwap(newGlobal, {
        isEstimating: true
      });
    }
  }
  if (doesSwapChangeRequireDexUnselect(global, newGlobal)) {
    newGlobal = rawUpdateCurrentSwap(newGlobal, {
      isDexLabelChanged: undefined
    });
  }

  // Applying the update again because the input fields should have a higher priority than the above automatic updates
  return rawUpdateCurrentSwap(newGlobal, update);
}
function clearCurrentSwap(global) {
  return {
    ...global,
    currentSwap: {
      state: SwapState.None,
      slippage: src_config/* DEFAULT_SLIPPAGE_VALUE */.k9U
    }
  };
}

/** replaceMap: keys - old (removed) activity ids, value - new (added) activity ids */
function replaceCurrentSwapId(global, replaceMap) {
  return updateCurrentSwap(global, {
    activityId: replaceActivityId(global.currentSwap.activityId, replaceMap)
  });
}
;// ./src/global/reducers/transfer.ts




function updateCurrentTransferByCheckResult(global, result) {
  const nextGlobal = updateCurrentTransfer(global, {
    toAddressName: result.addressName,
    ...(0,iteratees/* pick */.Up)(result, ['fee', 'realFee', 'isScam', 'isMemoRequired', 'diesel'])
  });
  return preserveMaxTransferAmount(global, nextGlobal);
}
function updateCurrentTransfer(global, update) {
  return {
    ...global,
    currentTransfer: {
      ...global.currentTransfer,
      ...update
    }
  };
}
function clearCurrentTransfer(global) {
  return {
    ...global,
    currentTransfer: INITIAL_STATE.currentTransfer
  };
}

/**
 * Preserves the maximum transfer amount, if it was selected.
 * Returns a modified version of `nextGlobal`.
 */
function preserveMaxTransferAmount(prevGlobal, nextGlobal) {
  const previousMaxAmount = selectCurrentTransferMaxAmount(prevGlobal);
  const wasMaxAmountSelected = previousMaxAmount && prevGlobal.currentTransfer.amount === previousMaxAmount;
  if (!wasMaxAmountSelected) {
    return nextGlobal;
  }
  const nextMaxAmount = selectCurrentTransferMaxAmount(nextGlobal);
  return updateCurrentTransfer(nextGlobal, {
    amount: nextMaxAmount
  });
}
function updateCurrentTransferLoading(global, isLoading) {
  return {
    ...global,
    currentTransfer: {
      ...global.currentTransfer,
      isLoading
    }
  };
}
function setCurrentTransferAddress(global, toAddress) {
  global = updateCurrentTransfer(global, {
    toAddress
  });

  // Unless the user has filled the amount, the token should change to match the "to" address
  if (!global.currentTransfer.amount) {
    global = updateCurrentTransfer(global, {
      tokenSlug: selectTokenMatchingCurrentTransferAddressSlow(global)
    });
  }
  return global;
}

/** replaceMap: keys - old (removed) activity ids, value - new (added) activity ids */
function replaceCurrentTransferId(global, replaceMap) {
  return updateCurrentTransfer(global, {
    txId: replaceActivityId(global.currentTransfer.txId, replaceMap)
  });
}
;// ./src/global/reducers/wallet.ts



function updateCurrentSignature(global, update) {
  return {
    ...global,
    currentSignature: {
      ...global.currentSignature,
      ...update
    }
  };
}
function clearCurrentSignature(global) {
  return {
    ...global,
    currentSignature: undefined
  };
}
function switchAccountAndClearGlobal(global, accountId) {
  let newGlobal = updateCurrentAccountId(global, accountId);
  newGlobal = clearCurrentTransfer(newGlobal);
  return clearCurrentSwap(newGlobal);
}
;// ./src/global/reducers/staking.ts




function updateCurrentStaking(global, update) {
  return {
    ...global,
    currentStaking: {
      ...global.currentStaking,
      ...update
    }
  };
}
function clearCurrentStaking(global) {
  return {
    ...global,
    currentStaking: {
      state: StakingState.None
    }
  };
}
function updateAccountStaking(global, accountId, partial) {
  var _selectAccountState;
  let withDeepCompare = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const currentStaking = (_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.staking;
  if (withDeepCompare && currentStaking && isPartialDeepEqual(currentStaking, partial)) {
    return global;
  }
  return misc_updateAccountState(global, accountId, {
    staking: {
      ...currentStaking,
      ...partial
    }
  });
}
function updateAccountStakingStatePartial(global, accountId, partial) {
  var _selectAccountState2;
  const currentState = (_selectAccountState2 = selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.staking;
  if (!currentState) {
    return global;
  }
  return updateAccountState(global, accountId, {
    staking: {
      ...currentState,
      ...partial
    }
  });
}
function updateStakingDefault(global, state) {
  return {
    ...global,
    stakingDefault: state
  };
}
;// ./src/global/reducers/dapp.ts



function updateDappConnectRequest(global, update) {
  return {
    ...global,
    dappConnectRequest: {
      ...global.dappConnectRequest,
      ...update
    }
  };
}
function clearDappConnectRequestError(global) {
  return {
    ...global,
    dappConnectRequest: {
      ...global.dappConnectRequest,
      error: undefined
    }
  };
}
function clearDappConnectRequest(global) {
  return {
    ...global,
    dappConnectRequest: undefined
  };
}
function updateCurrentDappTransfer(global, update) {
  return {
    ...global,
    currentDappTransfer: {
      ...global.currentDappTransfer,
      ...update
    }
  };
}
function clearCurrentDappTransfer(global) {
  return {
    ...global,
    currentDappTransfer: {
      state: TransferState.None
    }
  };
}
function updateCurrentDappSignData(global, update) {
  return {
    ...global,
    currentDappSignData: {
      ...global.currentDappSignData,
      ...update
    }
  };
}
function clearCurrentDappSignData(global) {
  return {
    ...global,
    currentDappSignData: {
      state: SignDataState.None
    }
  };
}
function updateConnectedDapps(global, update) {
  return updateCurrentAccountState(global, {
    dapps: update
  });
}
function clearConnectedDapps(global) {
  return updateCurrentAccountState(global, {
    dapps: undefined,
    dappLastOpenedDatesByUrl: undefined
  });
}
function removeConnectedDapp(global, url) {
  const {
    dapps: connectedDapps,
    dappLastOpenedDatesByUrl
  } = selectCurrentAccountState(global) || {};
  if (dappLastOpenedDatesByUrl) delete dappLastOpenedDatesByUrl[url];
  return updateCurrentAccountState(global, {
    dapps: connectedDapps.filter(d => d.url !== url),
    dappLastOpenedDatesByUrl
  });
}
;// ./src/util/activities/order.ts



function compareActivities(a, b) {
  let isAsc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  // The activity sorting is tuned to match the Toncenter API sorting as close as possible.
  // Putting the pending activities first, because when they get confirmed, their timestamp gets bigger than any current
  // confirmed activity timestamp. This reduces the movement in the activity list.
  let value = (getIsActivityPending(a) ? 1 : 0) - (getIsActivityPending(b) ? 1 : 0);
  if (value === 0) {
    value = a.timestamp - b.timestamp;
    if (value === 0) {
      value = a.id > b.id ? 1 : a.id < b.id ? -1 : 0;
    }
  }
  return isAsc ? value : -value;
}

/**
 * Use the `mergeSortedActivities` function instead when possible.
 */
function sortActivities(activities, isAsc) {
  return activities.sort((a1, a2) => compareActivities(a1, a2, isAsc));
}

/**
 * Use the `mergeSortedActivityIds` function instead when possible.
 */
function sortActivityIds(activityById, ids, isAsc) {
  return ids.sort((id1, id2) => compareActivities(activityById[id1], activityById[id2], isAsc));
}
function mergeSortedActivities(array1, array2, isAsc) {
  // It's hard to make sure the input is sorted, so we check and sort just in case.
  // Otherwise, there may be unwanted duplicates in the returned array.
  const lists = [array1, array2];
  for (let i = 0; i < lists.length; i++) {
    if (!areActivitiesSorted(lists[i], isAsc)) {
      logDebugError(`Activity list ${i} is not sorted`, {
        stack: new Error().stack
      });
      lists[i] = sortActivities([...lists[i]], isAsc);
    }
  }
  return mergeSortedArrays(array1, array2, (a1, a2) => compareActivities(a1, a2, isAsc), true);
}
function mergeSortedActivityIds(ids1, ids2, activityById, isAsc) {
  // It's hard to make sure the input is sorted, so we check and sort just in case.
  // Otherwise, there may be unwanted duplicates in the returned array.
  const lists = [ids1, ids2];
  for (let i = 0; i < lists.length; i++) {
    if (!areActivityIdsSorted(activityById, lists[i], isAsc)) {
      (0,logs/* logDebugError */.SJ)(`Activity id list ${i} is not sorted`, {
        stack: new Error().stack
      });
      lists[i] = sortActivityIds(activityById, [...lists[i]], isAsc);
    }
  }
  return (0,iteratees/* mergeSortedArrays */.yQ)(ids1, ids2, (id1, id2) => compareActivities(activityById[id1], activityById[id2], isAsc), true);
}
function mergeSortedActivitiesToMaxTime(array1, array2) {
  if (!array1.length) return array2;
  if (!array2.length) return array1;
  const fromTimestamp = Math.max(array1[array1.length - 1].timestamp, array2[array2.length - 1].timestamp);
  const filterPredicate = _ref => {
    let {
      timestamp
    } = _ref;
    return timestamp >= fromTimestamp;
  };
  return mergeSortedActivities(array1.filter(filterPredicate), array2.filter(filterPredicate));
}
function mergeSortedActivityIdsToMaxTime(ids1, ids2, activityById) {
  if (!ids1.length) return ids2;
  if (!ids2.length) return ids1;
  const fromTimestamp = Math.max(activityById[ids1[ids1.length - 1]].timestamp, activityById[ids2[ids2.length - 1]].timestamp);
  const filterPredicate = id => activityById[id].timestamp >= fromTimestamp;
  return mergeSortedActivityIds(ids1.filter(filterPredicate), ids2.filter(filterPredicate), activityById);
}
function areActivitiesSorted(activities, isAsc) {
  for (let i = 1; i < activities.length; i++) {
    if (compareActivities(activities[i - 1], activities[i], isAsc) > 0) {
      return false;
    }
  }
  return true;
}
function areActivityIdsSorted(activityById, ids, isAsc) {
  for (let i = 1; i < ids.length; i++) {
    if (compareActivities(activityById[ids[i - 1]], activityById[ids[i]], isAsc) > 0) {
      return false;
    }
  }
  return true;
}
;// ./src/global/reducers/activities.ts







/**
 * Handles the `initialActivities` update, which delivers the latest activity history after the account is added.
 * The given activity lists must be sorted and contain no pending or local activities.
 */
function addInitialActivities(global, accountId, mainActivities, bySlug, chain) {
  const {
    activities
  } = accounts_selectAccountState(global, accountId) || {};
  let {
    byId,
    idsMain,
    areInitialActivitiesLoaded
  } = activities || {};
  byId = {
    ...byId,
    ...(0,iteratees/* buildCollectionByKey */.dU)(mainActivities, 'id')
  };
  areInitialActivitiesLoaded = {
    ...areInitialActivitiesLoaded,
    [chain]: true
  };

  // Activities from different blockchains arrive separately, which causes the order to be disrupted
  idsMain = mergeSortedActivityIdsToMaxTime((0,iteratees/* extractKey */.JY)(mainActivities, 'id'), idsMain ?? [], byId);

  // Enforcing the requirement to have the id list undefined if it hasn't loaded yet
  if (idsMain.length === 0 && !areAllInitialActivitiesLoaded(global, accountId, areInitialActivitiesLoaded)) {
    idsMain = undefined;
  }
  global = misc_updateAccountState(global, accountId, {
    activities: {
      ...activities,
      idsMain,
      byId,
      areInitialActivitiesLoaded
    }
  });
  for (const [slug, activities] of Object.entries(bySlug)) {
    global = addPastActivities(global, accountId, slug, activities, activities.length === 0);
  }
  return global;
}

/**
 * Should be used to add only newly created activities. Otherwise, there can occur gaps in the history, because the
 * given activities are added to all the matching token histories.
 */
function addNewActivities(global, accountId, newActivities,
// Must be sorted
chain // Necessary when adding pending activities
) {
  if (newActivities.length === 0) {
    return global;
  }
  const {
    activities
  } = accounts_selectAccountState(global, accountId) || {};
  let {
    byId,
    idsBySlug,
    idsMain,
    newestActivitiesBySlug,
    localActivityIds,
    pendingActivityIds
  } = activities || {};
  byId = {
    ...byId,
    ...(0,iteratees/* buildCollectionByKey */.dU)(newActivities, 'id')
  };

  // Activities from different blockchains arrive separately, which causes the order to be disrupted
  idsMain = mergeSortedActivityIds(idsMain ?? [], (0,iteratees/* extractKey */.JY)(newActivities, 'id'), byId);
  const newIdsBySlug = buildActivityIdsBySlug(newActivities);
  idsBySlug = mergeIdsBySlug(idsBySlug, newIdsBySlug, byId);
  newestActivitiesBySlug = getNewestActivitiesBySlug({
    byId,
    idsBySlug,
    newestActivitiesBySlug
  }, Object.keys(newIdsBySlug));
  localActivityIds = (0,iteratees/* unique */.Am)([...(localActivityIds ?? []), ...(0,iteratees/* extractKey */.JY)(newActivities, 'id').filter(getIsTxIdLocal)]);
  if (chain) {
    var _pendingActivityIds;
    pendingActivityIds = {
      ...pendingActivityIds,
      [chain]: (0,iteratees/* unique */.Am)([...(((_pendingActivityIds = pendingActivityIds) === null || _pendingActivityIds === void 0 ? void 0 : _pendingActivityIds[chain]) ?? []), ...(0,iteratees/* extractKey */.JY)(newActivities.filter(activity => getIsActivityPending(activity) && !getIsTxIdLocal(activity.id)), 'id')])
    };
  }
  return misc_updateAccountState(global, accountId, {
    activities: {
      ...activities,
      idsMain,
      byId,
      idsBySlug,
      newestActivitiesBySlug,
      localActivityIds,
      pendingActivityIds
    }
  });
}
function addPastActivities(global, accountId, tokenSlug,
// undefined for main activities
pastActivities,
// Must be sorted and contain no pending or local activities
isEndReached) {
  const {
    activities
  } = accounts_selectAccountState(global, accountId) || {};
  let {
    byId,
    idsBySlug,
    idsMain,
    newestActivitiesBySlug,
    isMainHistoryEndReached,
    isHistoryEndReachedBySlug
  } = activities || {};
  byId = {
    ...byId,
    ...(0,iteratees/* buildCollectionByKey */.dU)(pastActivities, 'id')
  };
  if (tokenSlug) {
    idsBySlug = mergeIdsBySlug(idsBySlug, {
      [tokenSlug]: (0,iteratees/* extractKey */.JY)(pastActivities, 'id')
    }, byId);
    newestActivitiesBySlug = getNewestActivitiesBySlug({
      byId,
      idsBySlug,
      newestActivitiesBySlug
    }, [tokenSlug]);
    if (isEndReached) {
      isHistoryEndReachedBySlug = {
        ...isHistoryEndReachedBySlug,
        [tokenSlug]: true
      };
    }
  } else {
    idsMain = mergeSortedActivityIds(idsMain ?? [], (0,iteratees/* extractKey */.JY)(pastActivities, 'id'), byId);
    if (isEndReached) {
      isMainHistoryEndReached = true;
    }
  }
  return misc_updateAccountState(global, accountId, {
    activities: {
      ...activities,
      idsMain,
      byId,
      idsBySlug,
      newestActivitiesBySlug,
      isMainHistoryEndReached,
      isHistoryEndReachedBySlug
    }
  });
}
function buildActivityIdsBySlug(activities) {
  return activities.reduce((acc, activity) => {
    for (const slug of getActivityTokenSlugs(activity)) {
      acc[slug] ??= [];
      acc[slug].push(activity.id);
    }
    return acc;
  }, {});
}
function removeActivities(global, accountId, _ids) {
  var _idsMain, _localActivityIds;
  const {
    activities
  } = accounts_selectAccountState(global, accountId) || {};
  if (!activities) {
    return global;
  }
  const ids = new Set(_ids); // Don't use `_ids` again, because the iterable may be disposable
  if (ids.size === 0) {
    return global;
  }
  let {
    byId,
    idsBySlug,
    idsMain,
    newestActivitiesBySlug,
    localActivityIds,
    pendingActivityIds
  } = activities;
  const affectedTokenSlugs = getActivityListTokenSlugs(ids, byId);
  idsBySlug = {
    ...idsBySlug
  };
  for (const tokenSlug of affectedTokenSlugs) {
    if (tokenSlug in idsBySlug) {
      idsBySlug[tokenSlug] = idsBySlug[tokenSlug].filter(id => !ids.has(id));
      if (!idsBySlug[tokenSlug].length) {
        delete idsBySlug[tokenSlug];
      }
    }
  }
  newestActivitiesBySlug = getNewestActivitiesBySlug({
    byId,
    idsBySlug,
    newestActivitiesBySlug
  }, affectedTokenSlugs);
  idsMain = (_idsMain = idsMain) === null || _idsMain === void 0 ? void 0 : _idsMain.filter(id => !ids.has(id));
  byId = {
    ...byId
  };
  for (const id of ids) {
    delete byId[id];
  }
  localActivityIds = (_localActivityIds = localActivityIds) === null || _localActivityIds === void 0 ? void 0 : _localActivityIds.filter(id => !ids.has(id));
  pendingActivityIds = pendingActivityIds && (0,iteratees/* mapValues */.LG)(pendingActivityIds, pendingIds => pendingIds.filter(id => !ids.has(id)));
  return misc_updateAccountState(global, accountId, {
    activities: {
      ...activities,
      byId,
      idsBySlug,
      idsMain,
      newestActivitiesBySlug,
      localActivityIds,
      pendingActivityIds
    }
  });
}
function updateActivity(global, accountId, activity) {
  const {
    id
  } = activity;
  const {
    activities
  } = accounts_selectAccountState(global, accountId) || {};
  const {
    byId
  } = activities ?? {};
  if (!byId || !(id in byId)) {
    return global;
  }
  return misc_updateAccountState(global, accountId, {
    activities: {
      ...activities,
      byId: {
        ...byId,
        [id]: activity
      }
    }
  });
}

/** Replaces all pending activities in the given account and chain */
function replacePendingActivities(global, accountId, chain, pendingActivities) {
  var _selectAccountState;
  const {
    pendingActivityIds
  } = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.activities) || {};
  global = removeActivities(global, accountId, (pendingActivityIds === null || pendingActivityIds === void 0 ? void 0 : pendingActivityIds[chain]) ?? []);
  global = addNewActivities(global, accountId, pendingActivities, chain);
  return global;
}
function getNewestActivitiesBySlug(_ref, tokenSlugs) {
  let {
    byId,
    idsBySlug,
    newestActivitiesBySlug
  } = _ref;
  newestActivitiesBySlug = {
    ...newestActivitiesBySlug
  };
  for (const tokenSlug of tokenSlugs) {
    // The `idsBySlug` arrays must be sorted from the newest to the oldest
    const ids = (idsBySlug === null || idsBySlug === void 0 ? void 0 : idsBySlug[tokenSlug]) ?? [];
    const newestActivityId = ids.find(id => getIsActivitySuitableForFetchingTimestamp(byId[id]));
    if (newestActivityId) {
      newestActivitiesBySlug[tokenSlug] = byId[newestActivityId];
    } else {
      delete newestActivitiesBySlug[tokenSlug];
    }
  }
  return newestActivitiesBySlug;
}
function getActivityListTokenSlugs(activityIds, byId) {
  const tokenSlugs = new Set();
  for (const id of activityIds) {
    const activity = byId[id];
    if (activity) {
      for (const tokenSlug of getActivityTokenSlugs(activity)) {
        tokenSlugs.add(tokenSlug);
      }
    }
  }
  return tokenSlugs;
}

/** replaceMap: keys - old (removed) activity ids, value - new (added) activity ids */
function replaceCurrentActivityId(global, accountId, replaceMap) {
  var _selectAccountState2;
  return misc_updateAccountState(global, accountId, {
    currentActivityId: replaceActivityId((_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.currentActivityId, replaceMap)
  });
}
function mergeIdsBySlug(oldIdsBySlug, newIdsBySlug, activityById) {
  return {
    ...oldIdsBySlug,
    ...(0,iteratees/* mapValues */.LG)(newIdsBySlug, (newIds, slug) => {
      // There may be newer local transactions in `idsBySlug`, so a sorting is needed
      return mergeSortedActivityIds(newIds, (oldIdsBySlug === null || oldIdsBySlug === void 0 ? void 0 : oldIdsBySlug[slug]) ?? [], activityById);
    })
  };
}
function areAllInitialActivitiesLoaded(global, accountId, newAreInitialActivitiesLoaded) {
  // The initial activities may be loaded and added before the authentication completes
  const {
    addressByChain
  } = selectAccountOrAuthAccount(global, accountId) ?? {
    addressByChain: {}
  };
  return Object.keys(addressByChain).every(chain => newAreInitialActivitiesLoaded[chain]);
}
function updatePendingActivitiesToTrustedByReplacements(global, accountId, localActivities, replacedIds) {
  const accountState = accounts_selectAccountState(global, accountId);
  const activitiesState = accountState === null || accountState === void 0 ? void 0 : accountState.activities;
  if (!(activitiesState !== null && activitiesState !== void 0 && activitiesState.byId)) return global;
  const newById = {
    ...activitiesState.byId
  };
  for (const localActivity of localActivities) {
    const chainActivityId = replacedIds[localActivity.id];
    if (chainActivityId && localActivity.status === 'pendingTrusted') {
      const chainActivity = activitiesState.byId[chainActivityId];
      if ((chainActivity === null || chainActivity === void 0 ? void 0 : chainActivity.status) === 'pending') {
        newById[chainActivityId] = {
          ...chainActivity,
          status: 'pendingTrusted'
        };
      }
    }
  }
  return misc_updateAccountState(global, accountId, {
    activities: {
      ...activitiesState,
      byId: newById
    }
  });
}
function updatePendingActivitiesWithTrustedStatus(global, accountId, chain, pendingActivities, replacedIds, prevActivitiesForReplacement) {
  if (!chain || pendingActivities === undefined) return global;
  const reversedReplacedIds = (0,iteratees/* swapKeysAndValues */.V6)(replacedIds);
  const prevById = (0,iteratees/* buildCollectionByKey */.dU)(prevActivitiesForReplacement, 'id');

  // For pending activities, we need to check the status of the corresponding local activity
  const adjustedPendingActivities = pendingActivities.map(a => {
    const oldId = reversedReplacedIds[a.id];
    const oldActivity = oldId ? prevById[oldId] : undefined;
    if (oldActivity && oldActivity.status === 'pendingTrusted') {
      return {
        ...a,
        status: 'pendingTrusted'
      };
    }
    return a;
  });
  global = replacePendingActivities(global, accountId, chain, adjustedPendingActivities);
  return global;
}
;// ./src/global/reducers/nfts.ts



function addNft(global, accountId, nft, shouldAppendToEnd) {
  const nftAddress = nft.address;
  const nfts = accounts_selectAccountState(global, accountId).nfts;
  const orderedAddresses = ((nfts === null || nfts === void 0 ? void 0 : nfts.orderedAddresses) ?? []).filter(address => address !== nftAddress);
  return misc_updateAccountState(global, accountId, {
    nfts: {
      ...nfts,
      byAddress: {
        ...(nfts === null || nfts === void 0 ? void 0 : nfts.byAddress),
        [nftAddress]: nft
      },
      orderedAddresses: shouldAppendToEnd ? orderedAddresses.concat(nftAddress) : [nftAddress, ...orderedAddresses]
    }
  });
}
function removeNft(global, accountId, nftAddress) {
  const nfts = accounts_selectAccountState(global, accountId).nfts;
  const orderedAddresses = ((nfts === null || nfts === void 0 ? void 0 : nfts.orderedAddresses) ?? []).filter(address => address !== nftAddress);
  const selectedAddresses = ((nfts === null || nfts === void 0 ? void 0 : nfts.selectedAddresses) ?? []).filter(address => address !== nftAddress);
  const {
    [nftAddress]: removedNft,
    ...byAddress
  } = (nfts === null || nfts === void 0 ? void 0 : nfts.byAddress) ?? {};
  return misc_updateAccountState(global, accountId, {
    nfts: {
      ...nfts,
      byAddress,
      orderedAddresses,
      selectedAddresses
    }
  });
}
function updateNft(global, accountId, nftAddress, partial) {
  var _nfts$byAddress;
  const nfts = accounts_selectAccountState(global, accountId).nfts;
  const nft = nfts === null || nfts === void 0 || (_nfts$byAddress = nfts.byAddress) === null || _nfts$byAddress === void 0 ? void 0 : _nfts$byAddress[nftAddress];
  if (!nfts || !nft) return global;
  return misc_updateAccountState(global, accountId, {
    nfts: {
      ...nfts,
      byAddress: {
        ...nfts.byAddress,
        [nftAddress]: {
          ...nft,
          ...partial
        }
      }
    }
  });
}
function addToSelectedAddresses(global, accountId, nftAddresses) {
  const nfts = accounts_selectAccountState(global, accountId).nfts;
  const selectedAddresses = [...((nfts === null || nfts === void 0 ? void 0 : nfts.selectedAddresses) ?? []), ...nftAddresses];
  return misc_updateAccountState(global, accountId, {
    nfts: {
      ...nfts,
      selectedAddresses
    }
  });
}
function removeFromSelectedAddresses(global, accountId, nftAddress) {
  const nfts = accounts_selectAccountState(global, accountId).nfts;
  const selectedAddresses = ((nfts === null || nfts === void 0 ? void 0 : nfts.selectedAddresses) ?? []).filter(address => address !== nftAddress);
  return misc_updateAccountState(global, accountId, {
    nfts: {
      ...nfts,
      selectedAddresses: selectedAddresses.length ? selectedAddresses : undefined
    }
  });
}

// Updates the account settings to ensure the specified NFT is up-to-date.
function updateAccountSettingsBackgroundNft(global, nft) {
  Object.entries(global.settings.byAccountId).forEach(_ref => {
    var _settings$cardBackgro;
    let [accountId, settings] = _ref;
    if (((_settings$cardBackgro = settings.cardBackgroundNft) === null || _settings$cardBackgro === void 0 ? void 0 : _settings$cardBackgro.address) === nft.address) {
      global = updateAccountSettings(global, accountId, {
        ...settings,
        cardBackgroundNft: nft
      });
    }
  });
  return global;
}
function addUnorderedNfts(global, accountId, updatedNfts) {
  var _selectAccountState;
  if (!updatedNfts || isEmptyObject(updatedNfts)) {
    return global;
  }
  const {
    byAddress
  } = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.nfts) || {
    byAddress: {}
  };
  Object.values(updatedNfts).forEach(nft => {
    const existingNft = byAddress === null || byAddress === void 0 ? void 0 : byAddress[nft.address];
    if (existingNft) {
      global = updateNft(global, accountId, nft.address, nft);
    } else {
      global = addNft(global, accountId, nft, true);
    }
  });
  return global;
}
;// ./src/global/reducers/vesting.ts


function updateVestingInfo(global, accountId, update) {
  return updateVesting(global, accountId, {
    info: update
  });
}
function updateVesting(global, accountId, update) {
  var _selectAccountState;
  return misc_updateAccountState(global, accountId, {
    vesting: {
      ...(((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.vesting) || {
        info: []
      }),
      ...update
    }
  });
}
;// ./src/global/reducers/cards.ts
function updateMintCards(global, update) {
  return {
    ...global,
    currentMintCard: {
      ...global.currentMintCard,
      ...update
    }
  };
}
;// ./src/global/reducers/domains.ts

function updateCurrentDomainRenewal(global, update) {
  return {
    ...global,
    currentDomainRenewal: {
      ...global.currentDomainRenewal,
      ...update
    }
  };
}
function updateCurrentDomainLinking(global, update) {
  return {
    ...global,
    currentDomainLinking: {
      ...global.currentDomainLinking,
      ...update
    }
  };
}

/** replaceMap: keys - old (removed) activity ids, value - new (added) activity ids */
function replaceCurrentDomainRenewalId(global, replaceMap) {
  return updateCurrentDomainRenewal(global, {
    txId: replaceActivityId(global.currentDomainRenewal.txId, replaceMap)
  });
}

/** replaceMap: keys - old (removed) activity ids, value - new (added) activity ids */
function replaceCurrentDomainLinkingId(global, replaceMap) {
  return updateCurrentDomainLinking(global, {
    txId: replaceActivityId(global.currentDomainLinking.txId, replaceMap)
  });
}
;// ./src/global/reducers/hardware.ts

function updateHardware(global, hardwareUpdate) {
  return {
    ...global,
    hardware: {
      ...global.hardware,
      ...hardwareUpdate
    }
  };
}
function resetHardware(global) {
  return {
    ...global,
    hardware: INITIAL_STATE.hardware
  };
}
;// ./src/global/reducers/index.ts












;// ./src/global/actions/api/auth.ts
























const CREATING_DURATION = 3300;
const NATIVE_BIOMETRICS_PAUSE_MS = 750;
async function switchAccount(global, accountId, newNetwork) {
  if (accountId === global.currentAccountId) {
    return;
  }
  const actions = getActions();
  const newestActivityTimestamps = selectNewestActivityTimestamps(global, accountId);
  await (0,api/* callApi */.p)('activateAccount', accountId, newestActivityTimestamps);
  global = getGlobal();
  setGlobal(switchAccountAndClearGlobal(global, accountId));
  clearPoisoningCache();
  if (newNetwork) {
    actions.changeNetwork({
      network: newNetwork
    });
  }
}
addActionHandler('resetAuth', global => {
  if (global.currentAccountId) {
    global = {
      ...global,
      appState: AppState.Main
    };

    // Restore the network when refreshing the page during the switching networks
    global = updateSettings(global, {
      isTestnet: (0,util_account/* parseAccountId */.cK)(global.currentAccountId).network === 'testnet'
    });
  }
  global = {
    ...global,
    auth: (0,iteratees/* cloneDeep */.mg)(INITIAL_STATE.auth)
  };
  setGlobal(global);
});
addActionHandler('startCreatingWallet', async (global, actions) => {
  const accounts = selectAccounts(global) ?? {};
  const isFirstAccount = isEmptyObject(accounts);
  const isPasswordPresent = selectIsPasswordPresent(global);
  const nextAuthState = isPasswordPresent ? AuthState.createBackup : isFirstAccount ? AuthState.createWallet
  // The app only has hardware wallets accounts, which means we need to create a password or biometrics
  : getDoesUsePinPad() ? AuthState.createPin : windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh ? AuthState.createBiometrics : AuthState.createPassword;
  global = getGlobal();
  if (isPasswordPresent && !global.auth.password) {
    setGlobal(updateAuth(global, {
      state: AuthState.checkPassword,
      error: undefined
    }));
    return;
  }
  const promiseCalls = [(0,api/* callApi */.p)('generateMnemonic', src_config/* IS_BIP39_MNEMONIC_ENABLED */.iAh && !global.auth.forceAddingTonOnlyAccount), ...(!isPasswordPresent ? [(0,schedulers/* pause */.v7)(CREATING_DURATION)] : [])];
  setGlobal(updateAuth(global, {
    state: nextAuthState,
    method: 'createAccount',
    error: undefined
  }));
  const [mnemonic] = await Promise.all(promiseCalls);
  global = updateAuth(getGlobal(), {
    mnemonic,
    mnemonicCheckIndexes: selectMnemonicForCheck((mnemonic === null || mnemonic === void 0 ? void 0 : mnemonic.length) ?? src_config/* MNEMONIC_COUNT */.xA_)
  });
  if (isPasswordPresent) {
    setGlobal(global);
    actions.afterCreatePassword({
      password: global.auth.password
    });
    return;
  }
  setGlobal(updateAuth(global, {
    state: getDoesUsePinPad() ? AuthState.createPin : windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh ? AuthState.createBiometrics : AuthState.createPassword
  }));
  if (isFirstAccount) {
    actions.requestConfetti();
    void vibrateOnSuccess();
  }
});
addActionHandler('startCreatingBiometrics', global => {
  global = updateAuth(global, {
    state: global.auth.method !== 'createAccount' ? AuthState.importWalletConfirmBiometrics : AuthState.confirmBiometrics,
    biometricsStep: 1
  });
  setGlobal(global);
});
addActionHandler('cancelCreateBiometrics', global => {
  global = updateAuth(global, {
    state: AuthState.createBiometrics,
    biometricsStep: undefined
  });
  setGlobal(global);
});
addActionHandler('createPin', (global, actions, _ref) => {
  let {
    pin,
    isImporting
  } = _ref;
  global = updateAuth(global, {
    state: isImporting ? AuthState.importWalletConfirmPin : AuthState.confirmPin,
    password: pin
  });
  setGlobal(global);
});
addActionHandler('confirmPin', (global, actions, _ref2) => {
  let {
    isImporting
  } = _ref2;
  if (getIsNativeBiometricAuthSupported()) {
    global = updateAuth(global, {
      state: isImporting ? AuthState.importWalletCreateNativeBiometrics : AuthState.createNativeBiometrics
    });
    setGlobal(global);
  } else {
    actions.skipCreateNativeBiometrics();
  }
});
addActionHandler('cancelConfirmPin', (global, actions, _ref3) => {
  let {
    isImporting
  } = _ref3;
  global = updateAuth(global, {
    state: isImporting ? AuthState.importWalletCreatePin : AuthState.createPin
  });
  setGlobal(global);
});
addActionHandler('cancelDisclaimer', global => {
  setGlobal(updateAuth(global, {
    state: getDoesUsePinPad() ? AuthState.createPin : windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh ? AuthState.createBiometrics : AuthState.createPassword
  }));
});
addActionHandler('afterCreatePassword', (global, actions, _ref4) => {
  let {
    password,
    isPasswordNumeric
  } = _ref4;
  setGlobal(updateAuth(global, {
    isLoading: true
  }));
  const {
    method
  } = getGlobal().auth;
  const isImporting = method !== 'createAccount';
  const isHardware = method === 'importHardwareWallet';
  if (isHardware) {
    actions.createHardwareAccounts();
    return;
  }
  actions.createAccount({
    password,
    isImporting,
    isPasswordNumeric
  });
});
addActionHandler('afterCreateBiometrics', async (global, actions) => {
  const withCredential = !windowEnvironment/* IS_ELECTRON */.cp;
  global = updateAuth(global, {
    isLoading: true,
    error: undefined,
    biometricsStep: withCredential ? 1 : undefined
  });
  setGlobal(global);
  try {
    const credential = withCredential ? await webAuthn.createCredential() : undefined;
    global = getGlobal();
    global = updateAuth(global, {
      biometricsStep: withCredential ? 2 : undefined
    });
    setGlobal(global);
    const result = await authApi.setupBiometrics({
      credential
    });
    global = getGlobal();
    global = updateAuth(global, {
      isLoading: false,
      biometricsStep: undefined
    });
    if (!result) {
      global = updateAuth(global, {
        error: 'Biometric setup failed.'
      });
      setGlobal(global);
      return;
    }
    global = updateSettings(global, {
      authConfig: result.config
    });
    setGlobal(global);
    actions.afterCreatePassword({
      password: result.password
    });
  } catch (err) {
    const error = err !== null && err !== void 0 && err.message.includes('privacy-considerations-client') ? 'Biometric setup failed.' : (err === null || err === void 0 ? void 0 : err.message) || 'Biometric setup failed.';
    global = getGlobal();
    global = updateAuth(global, {
      isLoading: false,
      error,
      biometricsStep: undefined
    });
    setGlobal(global);
  }
});
addActionHandler('skipCreateBiometrics', global => {
  global = updateAuth(global, {
    state: AuthState.createPassword
  });
  setGlobal(global);
});
addActionHandler('afterCreateNativeBiometrics', async (global, actions) => {
  global = updateAuth(global, {
    isLoading: true,
    error: undefined
  });
  setGlobal(global);
  try {
    const {
      password
    } = global.auth;
    const result = await authApi.setupNativeBiometrics(password);
    global = getGlobal();
    global = updateAuth(global, {
      isLoading: false
    });
    global = updateSettings(global, {
      authConfig: result.config
    });
    setGlobal(global);
    actions.afterCreatePassword({
      password: password,
      isPasswordNumeric: true
    });
  } catch (err) {
    const error = err !== null && err !== void 0 && err.message.includes('privacy-considerations-client') ? 'Biometric setup failed.' : (err === null || err === void 0 ? void 0 : err.message) || 'Biometric setup failed.';
    global = getGlobal();
    global = updateAuth(global, {
      isLoading: false,
      error
    });
    setGlobal(global);
  }
});
addActionHandler('skipCreateNativeBiometrics', (global, actions) => {
  const {
    password
  } = global.auth;
  global = updateAuth(global, {
    isLoading: false,
    error: undefined
  });
  global = updateSettings(global, {
    authConfig: {
      kind: 'password'
    },
    isPasswordNumeric: true
  });
  setGlobal(global);
  actions.afterCreatePassword({
    password: password,
    isPasswordNumeric: true
  });
});
addActionHandler('createAccount', async (global, actions, _ref5) => {
  let {
    password,
    isImporting,
    isPasswordNumeric,
    version
  } = _ref5;
  setGlobal(updateAuth(global, {
    isLoading: true
  }));
  const network = selectCurrentNetwork(getGlobal());
  const result = await (0,api/* callApi */.p)(isImporting ? 'importMnemonic' : 'createWallet', network, global.auth.mnemonic, password, version);
  global = getGlobal();
  if (!result || 'error' in result) {
    setGlobal(updateAuth(global, {
      isLoading: undefined
    }));
    actions.showError({
      error: result === null || result === void 0 ? void 0 : result.error
    });
    return;
  }
  const {
    accountId,
    addressByChain,
    secondNetworkAccount
  } = result;
  if (!isImporting) {
    global = {
      ...global,
      appState: AppState.Auth,
      isAddAccountModalOpen: undefined
    };
  }
  global = updateAuth(global, {
    isLoading: undefined,
    password: undefined,
    firstNetworkAccount: {
      addressByChain,
      accountId
    },
    secondNetworkAccount,
    ...(isPasswordNumeric && {
      isPasswordNumeric: true
    })
  });
  global = clearIsPinAccepted(global);
  if (isImporting) {
    const hasAccounts = Object.keys(selectAccounts(global) || {}).length > 0;
    if (hasAccounts) {
      setGlobal(global);
      actions.afterConfirmDisclaimer();
      return;
    } else {
      global = updateAuth(global, {
        state: AuthState.disclaimer
      });
    }
  } else {
    const accounts = selectAccounts(global) ?? {};
    const isFirstAccount = isEmptyObject(accounts);
    global = updateAuth(global, {
      state: isFirstAccount ? AuthState.disclaimerAndBackup : AuthState.createBackup
    });
  }
  setGlobal(global);
});
addActionHandler('createHardwareAccounts', async (global, actions) => {
  const accounts = selectAccounts(global) ?? {};
  const isFirstAccount = isEmptyObject(accounts);
  setGlobal(updateAuth(global, {
    isLoading: true
  }));
  const {
    hardwareSelectedIndices = []
  } = getGlobal().auth;
  const network = selectCurrentNetwork(getGlobal());
  const ledgerApi = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
  const wallets = await Promise.all(hardwareSelectedIndices.map(wallet => ledgerApi.importLedgerWallet(network, wallet)));
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !isFirstAccount) {
    callActionInMain('addHardwareAccounts', {
      wallets
    });
    return;
  }
  actions.addHardwareAccounts({
    wallets
  });
});
addActionHandler('addHardwareAccounts', (global, actions, _ref6) => {
  var _wallets$;
  let {
    wallets
  } = _ref6;
  const isFirstAccount = !global.currentAccountId;
  const nextActiveAccountId = (_wallets$ = wallets[0]) === null || _wallets$ === void 0 ? void 0 : _wallets$.accountId;
  if (nextActiveAccountId) {
    void (0,api/* callApi */.p)('activateAccount', nextActiveAccountId);
  }
  const updatedGlobal = wallets.reduce((currentGlobal, wallet) => {
    if (!wallet) {
      return currentGlobal;
    }
    const {
      accountId,
      address,
      walletInfo
    } = wallet;
    const addressByChain = {
      ton: address
    };
    currentGlobal = updateCurrentAccountId(currentGlobal, accountId);
    currentGlobal = createAccount({
      global: currentGlobal,
      accountId,
      addressByChain,
      type: 'hardware',
      partial: {
        ...(walletInfo && {
          ledger: {
            driver: walletInfo.driver,
            index: walletInfo.index
          }
        })
      }
    });
    return currentGlobal;
  }, getGlobal());
  if (nextActiveAccountId) {
    global = updateCurrentAccountId(updatedGlobal, nextActiveAccountId);
  }
  global = updateAuth(global, {
    isLoading: false
  });
  global = {
    ...global,
    shouldForceAccountEdit: true
  };
  setGlobal(global);
  if (getGlobal().areSettingsOpen) {
    actions.closeSettings();
  }
  wallets.forEach(hardwareWallet => {
    if (hardwareWallet !== null && hardwareWallet !== void 0 && hardwareWallet.accountId) {
      actions.tryAddNotificationAccount({
        accountId: hardwareWallet === null || hardwareWallet === void 0 ? void 0 : hardwareWallet.accountId
      });
    }
  });
  actions.afterSignIn();
  if (isFirstAccount) {
    actions.resetApiSettings();
    actions.requestConfetti();
    void vibrateOnSuccess();
  }
});
addActionHandler('afterCheckMnemonic', (global, actions) => {
  global = createAccountsFromGlobal(global);
  global = updateCurrentAccountId(global, global.auth.firstNetworkAccount.accountId);
  setGlobal(global);
  actions.tryAddNotificationAccount({
    accountId: global.auth.firstNetworkAccount.accountId
  });
  actions.afterSignIn();
  if (selectIsOneAccount(global)) {
    actions.resetApiSettings();
  }
});
addActionHandler('restartCheckMnemonicIndexes', (global, actions, _ref7) => {
  let {
    worldsCount
  } = _ref7;
  setGlobal(updateAuth(global, {
    mnemonicCheckIndexes: selectMnemonicForCheck(worldsCount)
  }));
});
addActionHandler('skipCheckMnemonic', (global, actions) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('skipCheckMnemonic');
    return;
  }
  global = createAccountsFromGlobal(global);
  global = updateCurrentAccountId(global, global.auth.firstNetworkAccount.accountId);
  global = updateCurrentAccountState(global, {
    isBackupRequired: true
  });
  setGlobal(global);
  actions.tryAddNotificationAccount({
    accountId: global.auth.firstNetworkAccount.accountId
  });
  actions.afterSignIn();
  if (selectIsOneAccount(global)) {
    actions.resetApiSettings();
  }
});
addActionHandler('startImportingWallet', global => {
  const isPasswordPresent = selectIsPasswordPresent(global);
  const state = isPasswordPresent && !global.auth.password ? AuthState.importWalletCheckPassword : AuthState.importWallet;
  setGlobal(updateAuth(global, {
    state,
    error: undefined,
    method: 'importMnemonic'
  }));
});
addActionHandler('openAbout', global => {
  setGlobal(updateAuth(global, {
    state: AuthState.about,
    error: undefined
  }));
});
addActionHandler('closeAbout', global => {
  setGlobal(updateAuth(global, {
    state: AuthState.none,
    error: undefined
  }));
});
addActionHandler('afterImportMnemonic', async (global, actions, _ref8) => {
  let {
    mnemonic
  } = _ref8;
  mnemonic = (0,iteratees/* compact */.oE)(mnemonic);
  if (!isMnemonicPrivateKey(mnemonic)) {
    if (!(await (0,api/* callApi */.p)('validateMnemonic', mnemonic))) {
      setGlobal(updateAuth(getGlobal(), {
        error: types/* ApiAuthError */.Nu.InvalidMnemonic
      }));
      return;
    }
  }
  global = getGlobal();
  const isPasswordPresent = selectIsPasswordPresent(global);
  const hasAccounts = Object.keys(selectAccounts(global) || {}).length > 0;
  const state = getDoesUsePinPad() ? AuthState.importWalletCreatePin : windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh ? AuthState.importWalletCreateBiometrics : AuthState.importWalletCreatePassword;
  global = updateAuth(global, {
    mnemonic,
    error: undefined,
    ...(!isPasswordPresent && {
      state
    })
  });
  setGlobal(global);
  if (!isPasswordPresent) {
    if (!hasAccounts) {
      actions.requestConfetti();
    }
    void vibrateOnSuccess();
  } else {
    actions.confirmDisclaimer();
  }
});
addActionHandler('confirmDisclaimer', (global, actions) => {
  const isPasswordPresent = selectIsPasswordPresent(global);
  if (isPasswordPresent) {
    setGlobal(global);
    actions.afterCreatePassword({
      password: global.auth.password
    });
    return;
  }
  actions.afterConfirmDisclaimer();
});
addActionHandler('afterConfirmDisclaimer', (global, actions) => {
  const {
    firstNetworkAccount
  } = global.auth;
  global = createAccountsFromGlobal(global, true);
  global = updateCurrentAccountId(global, firstNetworkAccount.accountId);
  global = updateAuth(global, {
    state: AuthState.ready
  });
  setGlobal(global);
  actions.tryAddNotificationAccount({
    accountId: firstNetworkAccount.accountId
  });
  actions.afterSignIn();
  if (selectIsOneAccount(global)) {
    actions.resetApiSettings();
  }
});
addActionHandler('cleanAuthError', global => {
  setGlobal(updateAuth(global, {
    error: undefined
  }));
});
function selectMnemonicForCheck(worldsCount) {
  return Array(worldsCount).fill(0).map((_, i) => ({
    i,
    rnd: Math.random()
  })).sort((a, b) => a.rnd - b.rnd).map(i => i.i).slice(0, Math.min(src_config/* MNEMONIC_CHECK_COUNT */.ow1, worldsCount)).sort((a, b) => a - b);
}
addActionHandler('startChangingNetwork', (global, actions, _ref9) => {
  let {
    network
  } = _ref9;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('startChangingNetwork', {
      network
    });
  }
  const accountIds = Object.keys(selectNetworkAccountsMemoized(network, global.accounts.byId));
  if (accountIds.length) {
    const accountId = accountIds[0];
    actions.switchAccount({
      accountId,
      newNetwork: network
    });
  } else {
    setGlobal({
      ...global,
      areSettingsOpen: false,
      appState: AppState.Auth
    });
    actions.changeNetwork({
      network
    });
  }
});
addActionHandler('switchAccount', async (global, actions, payload) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('switchAccount', payload);
    return;
  }
  const {
    accountId,
    newNetwork
  } = payload;
  await switchAccount(global, accountId, newNetwork);
});
addActionHandler('afterSelectHardwareWallets', (global, actions, _ref0) => {
  let {
    hardwareSelectedIndices
  } = _ref0;
  setGlobal(updateAuth(global, {
    method: 'importHardwareWallet',
    hardwareSelectedIndices,
    error: undefined
  }));
  actions.afterCreatePassword({
    password: ''
  });
});
addActionHandler('enableBiometrics', async (global, actions, _ref1) => {
  let {
    password
  } = _ref1;
  if (!(await (0,api/* callApi */.p)('verifyPassword', password))) {
    global = getGlobal();
    global = updateBiometrics(global, {
      error: 'Wrong password, please try again.'
    });
    setGlobal(global);
    return;
  }
  global = getGlobal();
  global = updateBiometrics(global, {
    error: undefined,
    state: BiometricsState.TurnOnRegistration
  });
  global = updateAuth(global, {
    isLoading: true
  });
  setGlobal(global);
  try {
    const credential = windowEnvironment/* IS_ELECTRON */.cp ? undefined : await webAuthn.createCredential();
    global = getGlobal();
    global = updateBiometrics(global, {
      state: BiometricsState.TurnOnVerification
    });
    setGlobal(global);
    const result = await authApi.setupBiometrics({
      credential
    });
    global = getGlobal();
    if (!result) {
      global = updateBiometrics(global, {
        error: 'Biometric setup failed.',
        state: BiometricsState.TurnOnPasswordConfirmation
      });
      setGlobal(global);
      return;
    }
    global = updateBiometrics(global, {
      state: BiometricsState.TurnOnComplete
    });
    setGlobal(global);
    await (0,api/* callApi */.p)('changePassword', password, result.password);
    global = getGlobal();
    global = updateSettings(global, {
      authConfig: result.config
    });
    setGlobal(global);
    actions.setInMemoryPassword({
      password: undefined,
      force: true
    });
  } catch (err) {
    const error = err !== null && err !== void 0 && err.message.includes('privacy-considerations-client') ? 'Biometric setup failed.' : (err === null || err === void 0 ? void 0 : err.message) || 'Biometric setup failed.';
    global = getGlobal();
    global = updateBiometrics(global, {
      error,
      state: BiometricsState.TurnOnPasswordConfirmation
    });
    setGlobal(global);
  } finally {
    global = getGlobal();
    global = updateAuth(global, {
      isLoading: undefined
    });
    setGlobal(global);
  }
});
addActionHandler('disableBiometrics', async (global, actions, _ref10) => {
  let {
    password,
    isPasswordNumeric
  } = _ref10;
  const {
    password: oldPassword
  } = global.biometrics;
  if (!password || !oldPassword) {
    global = updateBiometrics(global, {
      error: 'Biometric confirmation failed.'
    });
    setGlobal(global);
    return;
  }
  global = getGlobal();
  global = updateAuth(global, {
    isLoading: true
  });
  setGlobal(global);
  try {
    await (0,api/* callApi */.p)('changePassword', oldPassword, password);
  } catch (err) {
    global = getGlobal();
    global = updateBiometrics(global, {
      error: (err === null || err === void 0 ? void 0 : err.message) || 'Failed to disable biometrics.'
    });
    setGlobal(global);
    return;
  } finally {
    global = getGlobal();
    global = updateAuth(global, {
      isLoading: undefined
    });
    setGlobal(global);
  }
  global = getGlobal();
  global = updateBiometrics(global, {
    state: BiometricsState.TurnOffComplete,
    error: undefined
  });
  global = updateSettings(global, {
    authConfig: {
      kind: 'password'
    },
    isPasswordNumeric
  });
  setGlobal(global);
});
addActionHandler('closeBiometricSettings', global => {
  global = {
    ...global,
    biometrics: (0,iteratees/* cloneDeep */.mg)(INITIAL_STATE.biometrics)
  };
  setGlobal(global);
});
addActionHandler('openBiometricsTurnOn', global => {
  global = updateBiometrics(global, {
    state: BiometricsState.TurnOnPasswordConfirmation
  });
  setGlobal(global);
});
addActionHandler('openBiometricsTurnOffWarning', global => {
  global = updateBiometrics(global, {
    state: BiometricsState.TurnOffWarning
  });
  setGlobal(global);
});
addActionHandler('openBiometricsTurnOff', async global => {
  global = updateBiometrics(global, {
    state: BiometricsState.TurnOffBiometricConfirmation
  });
  setGlobal(global);
  const password = await authApi.getPassword(global.settings.authConfig);
  global = getGlobal();
  if (!password) {
    global = updateBiometrics(global, {
      error: 'Biometric confirmation failed.'
    });
  } else {
    global = updateBiometrics(global, {
      state: BiometricsState.TurnOffCreatePassword,
      password
    });
  }
  setGlobal(global);
});
addActionHandler('disableNativeBiometrics', global => {
  global = updateSettings(global, {
    authConfig: {
      kind: 'password'
    },
    isPasswordNumeric: true
  });
  setGlobal(global);
});
addActionHandler('enableNativeBiometrics', async (global, actions, _ref11) => {
  let {
    password
  } = _ref11;
  if (!(await (0,api/* callApi */.p)('verifyPassword', password))) {
    global = getGlobal();
    global = {
      ...global,
      nativeBiometricsError: 'Incorrect code, please try again.'
    };
    global = clearIsPinAccepted(global);
    setGlobal(global);
    return;
  }
  global = getGlobal();
  global = setIsPinAccepted(global);
  global = {
    ...global,
    nativeBiometricsError: undefined
  };
  setGlobal(global);
  try {
    let isVerified;
    if (src_config/* IS_TELEGRAM_APP */.tKX) {
      const verificationResult = await verifyIdentity();
      isVerified = verificationResult.success;
    } else {
      isVerified = await NativeBiometric.verifyIdentity({
        title: src_config/* APP_NAME */.C39,
        subtitle: '',
        maxAttempts: 1
      }).then(() => true).catch(() => false);
    }
    if (!isVerified) {
      global = getGlobal();
      global = {
        ...global,
        nativeBiometricsError: 'Failed to enable biometrics.'
      };
      global = clearIsPinAccepted(global);
      setGlobal(global);
      void vibrateOnError();
      return;
    }
    const result = await authApi.setupNativeBiometrics(password);
    await (0,schedulers/* pause */.v7)(NATIVE_BIOMETRICS_PAUSE_MS);
    global = getGlobal();
    global = updateSettings(global, {
      authConfig: result.config
    });
    global = {
      ...global,
      nativeBiometricsError: undefined
    };
    setGlobal(global);
    actions.setInMemoryPassword({
      password: undefined,
      force: true
    });
    void vibrateOnSuccess();
  } catch (err) {
    global = getGlobal();
    global = {
      ...global,
      nativeBiometricsError: (err === null || err === void 0 ? void 0 : err.message) || 'Failed to enable biometrics.'
    };
    global = clearIsPinAccepted(global);
    setGlobal(global);
    void vibrateOnError();
  }
});
addActionHandler('clearNativeBiometricsError', global => {
  return {
    ...global,
    nativeBiometricsError: undefined
  };
});
addActionHandler('openAuthBackupWalletModal', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openAuthBackupWalletModal');
    return;
  }
  global = updateAuth(global, {
    state: AuthState.safetyRules
  });
  setGlobal(global);
});
addActionHandler('openMnemonicPage', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openMnemonicPage');
    return;
  }
  global = updateAuth(global, {
    state: AuthState.mnemonicPage
  });
  setGlobal(global);
});
addActionHandler('openCreateBackUpPage', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openCreateBackUpPage');
    return;
  }
  const accounts = selectAccounts(global) ?? {};
  const isFirstAccount = isEmptyObject(accounts);
  global = updateAuth(global, {
    state: isFirstAccount ? AuthState.disclaimerAndBackup : AuthState.createBackup
  });
  setGlobal(global);
});
addActionHandler('openCheckWordsPage', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openCheckWordsPage');
    return;
  }
  global = updateAuth(global, {
    state: AuthState.checkWords
  });
  setGlobal(global);
});
addActionHandler('closeCheckWordsPage', (global, actions, props) => {
  const {
    isBackupCreated
  } = props || {};
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('closeCheckWordsPage', props);
  }
  if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && isBackupCreated) {
    actions.afterCheckMnemonic();
  }
});
addActionHandler('copyStorageData', async (global, actions) => {
  const accountConfigJson = await (0,api/* callApi */.p)('fetchAccountConfigForDebugPurposesOnly');
  if (accountConfigJson) {
    const storageData = JSON.stringify({
      ...JSON.parse(accountConfigJson),
      global: reduceGlobalForDebug()
    });
    await copyTextToClipboard(storageData);
    actions.showNotification({
      message: getTranslation('Copied')
    });
  } else {
    actions.showError({
      error: types/* ApiCommonError */.QD.Unexpected
    });
  }
});
addActionHandler('importAccountByVersion', async (global, actions, _ref12) => {
  let {
    version
  } = _ref12;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('importAccountByVersion', {
      version
    });
    return;
  }
  const accountId = global.currentAccountId;
  const wallet = await (0,api/* callApi */.p)('importNewWalletVersion', accountId, version);
  global = getGlobal();
  if (!wallet.isNew) {
    actions.switchAccount({
      accountId: wallet.accountId
    });
    return;
  }
  const {
    title: currentWalletTitle,
    type
  } = selectAccount(global, accountId);
  const addressByChain = {
    ton: wallet.address
  };
  global = updateCurrentAccountId(global, wallet.accountId);
  const ledgerInfo = wallet.ledger ? {
    ledger: wallet.ledger
  } : undefined;
  global = createAccount({
    global,
    accountId: wallet.accountId,
    type,
    addressByChain,
    partial: {
      ...ledgerInfo,
      title: currentWalletTitle
    },
    titlePostfix: version
  });
  setGlobal(global);
  await (0,api/* callApi */.p)('activateAccount', wallet.accountId);
  actions.tryAddNotificationAccount({
    accountId: wallet.accountId
  });
});
addActionHandler('setIsAuthLoading', (global, actions, _ref13) => {
  let {
    isLoading
  } = _ref13;
  global = updateAuth(global, {
    isLoading
  });
  setGlobal(global);
});
addActionHandler('importViewAccount', async (global, actions, _ref14) => {
  let {
    addressByChain
  } = _ref14;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('importViewAccount', {
      addressByChain
    });
    return;
  }
  const accounts = selectAccounts(global) ?? {};
  const isFirstAccount = isEmptyObject(accounts);
  const network = selectCurrentNetwork(getGlobal());
  if (isFirstAccount) {
    global = updateAuth(global, {
      isLoading: true
    });
  } else {
    global = updateAccounts(global, {
      isLoading: true
    });
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
      callActionInNative('setIsAccountLoading', {
        isLoading: true
      });
    }
  }
  setGlobal(global);
  const result = await (0,api/* callApi */.p)('importViewAccount', network, addressByChain);
  global = getGlobal();
  if (isFirstAccount) {
    global = updateAuth(global, {
      isLoading: undefined
    });
  } else {
    global = updateAccounts(global, {
      isLoading: undefined
    });
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
      callActionInNative('setIsAccountLoading', {
        isLoading: undefined
      });
    }
  }
  setGlobal(global);
  if (!result || 'error' in result) {
    actions.showError({
      error: result === null || result === void 0 ? void 0 : result.error
    });
    return;
  }
  global = getGlobal();
  global = createAccount({
    global,
    accountId: result.accountId,
    addressByChain: result.resolvedAddresses,
    type: 'view',
    partial: {
      title: result.title
    }
  });
  global = updateCurrentAccountId(global, result.accountId);
  setGlobal(global);
  if (getGlobal().areSettingsOpen) {
    actions.closeSettings();
  }
  actions.tryAddNotificationAccount({
    accountId: result.accountId
  });
  actions.afterSignIn();
  if (isFirstAccount) {
    actions.resetApiSettings();
    actions.requestConfetti();
  } else {
    actions.closeAddAccountModal();
  }
  void vibrateOnSuccess();
});
addActionHandler('startImportViewAccount', global => {
  setGlobal(updateAuth(global, {
    state: AuthState.importViewAccount,
    error: undefined
  }));
});
addActionHandler('closeImportViewAccount', global => {
  setGlobal(updateAuth(global, {
    state: AuthState.none,
    error: undefined
  }));
});
addActionHandler('openAuthImportWalletModal', global => {
  global = updateAuth(global, {
    isImportModalOpen: true
  });
  setGlobal(global);
});
addActionHandler('closeAuthImportWalletModal', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('closeAuthImportWalletModal');
  }
  global = updateAuth(global, {
    isImportModalOpen: undefined
  });
  setGlobal(global);
});
function reduceGlobalForDebug() {
  const reduced = (0,iteratees/* cloneDeep */.mg)(getGlobal());
  reduced.tokenInfo = {};
  reduced.swapTokenInfo = {};
  Object.entries(reduced.byAccountId).forEach(_ref15 => {
    let [, state] = _ref15;
    state.activities = {};
  });
  return reduced;
}
;// ./src/global/helpers/index.ts



function getIsTinyOrScamTransaction(transaction, token) {
  if (isScamTransaction(transaction)) return true;
  if (!token || transaction.nft || transaction.type) return false;
  const cost = (0,util_decimals/* toBig */.CF)(transaction.amount, token.decimals).abs().mul(token.priceUsd ?? 0);
  return cost.lt(src_config/* TINY_TRANSFER_MAX_COST */.Wvq);
}
function resolveSwapAssetId(asset) {
  return asset.slug === src_config/* TONCOIN */.Tu9.slug ? asset.symbol : asset.tokenAddress ?? asset.slug;
}
function resolveSwapAsset(bySlug, anyId) {
  return bySlug[anyId] ?? Object.values(bySlug).find(_ref => {
    let {
      tokenAddress
    } = _ref;
    return tokenAddress === anyId;
  });
}
function getIsSupportedChain(chain) {
  return chain in src_config/* CHAIN_CONFIG */.zll;
}
function getIsInternalSwap(_ref2) {
  let {
    from,
    to,
    toAddress,
    addressByChain
  } = _ref2;
  const isMultichain = Boolean(addressByChain === null || addressByChain === void 0 ? void 0 : addressByChain.tron);
  return (from === null || from === void 0 ? void 0 : from.chain) === 'ton' && (to === null || to === void 0 ? void 0 : to.chain) === 'ton' || isMultichain && from && to && addressByChain && getIsSupportedChain(from.chain) && addressByChain[to.chain] === toAddress;
}
;// ./src/global/reducers/tokens.ts
function updateTokenPriceHistory(global, slug, partial) {
  const {
    bySlug
  } = global.tokenPriceHistory;
  return {
    ...global,
    tokenPriceHistory: {
      bySlug: {
        ...bySlug,
        [slug]: {
          ...bySlug[slug],
          ...partial
        }
      }
    }
  };
}
function updateTokenInfo(global, partial) {
  return {
    ...global,
    tokenInfo: {
      ...global.tokenInfo,
      bySlug: {
        ...global.tokenInfo.bySlug,
        ...partial
      }
    }
  };
}
;// ./src/global/actions/api/wallet.ts











const IMPORT_TOKEN_PAUSE = 250;
const PAST_ACTIVITY_DELAY = 200;
const PAST_ACTIVITY_BATCH = 50;
const pastActivityThrottle = {};
const initialActivityWaitingByAccountId = {};
addActionHandler('fetchPastActivities', (global, actions, _ref) => {
  let {
    slug,
    shouldLoadWithBudget
  } = _ref;
  const accountId = global.currentAccountId;
  const throttleKey = `${accountId} ${slug ?? '__main__'}`;

  // Besides the throttling itself, the `throttle` avoids concurrent activity loading
  pastActivityThrottle[throttleKey] ||= (0,schedulers/* throttle */.nF)(fetchPastActivities.bind(undefined, accountId, slug), PAST_ACTIVITY_DELAY, true);
  pastActivityThrottle[throttleKey]();
  if (shouldLoadWithBudget) {
    pastActivityThrottle[throttleKey]();
  }
});
async function fetchPastActivities(accountId, slug) {
  // To avoid gaps in the history, we need to wait until the initial activities are loaded. The worker starts watching
  // for new activities at the moment the initial activities are loaded. This also prevents requesting the activities
  // that the worker is already loading.
  await waitInitialActivityLoading(accountId);
  let global = getGlobal();
  if (selectIsHistoryEndReached(global, accountId, slug)) {
    return;
  }
  const fetchedActivities = [];
  let toTimestamp = selectLastActivityTimestamp(global, accountId, slug);
  let shouldFetchMore = true;
  let isEndReached = false;
  while (shouldFetchMore) {
    const result = await (0,api/* callApi */.p)('fetchPastActivities', accountId, PAST_ACTIVITY_BATCH, slug, toTimestamp);
    if (!result) {
      return;
    }
    global = getGlobal();
    if (!result.length) {
      isEndReached = true;
      break;
    }
    const {
      areTinyTransfersHidden
    } = global.settings;
    const filteredResult = result.filter(tx => {
      const shouldHide = tx.kind === 'transaction' && (getIsTransactionWithPoisoning(tx) || areTinyTransfersHidden && getIsTinyOrScamTransaction(tx));
      return !shouldHide;
    });
    fetchedActivities.push(...result);
    shouldFetchMore = filteredResult.length < PAST_ACTIVITY_BATCH && fetchedActivities.length < PAST_ACTIVITY_BATCH;
    toTimestamp = result[result.length - 1].timestamp;
  }
  global = addPastActivities(global, accountId, slug, fetchedActivities, isEndReached);
  setGlobal(global);
}
addActionHandler('setIsBackupRequired', (global, actions, _ref2) => {
  let {
    isMnemonicChecked
  } = _ref2;
  const {
    isBackupRequired
  } = selectCurrentAccountState(global) ?? {};
  setGlobal(updateCurrentAccountState(global, {
    isBackupRequired: isMnemonicChecked ? undefined : isBackupRequired
  }));
});
addActionHandler('submitSignature', async (global, actions, payload) => {
  const {
    password
  } = payload;
  const {
    promiseId
  } = global.currentSignature;
  if (!(await (0,api/* callApi */.p)('verifyPassword', password))) {
    setGlobal(updateCurrentSignature(getGlobal(), {
      error: 'Wrong password, please try again.'
    }));
    return;
  }
  await (0,api/* callApi */.p)('confirmDappRequest', promiseId, password);
  setGlobal(updateCurrentSignature(getGlobal(), {
    isSigned: true
  }));
});
addActionHandler('clearSignatureError', global => {
  setGlobal(updateCurrentSignature(global, {
    error: undefined
  }));
});
addActionHandler('cancelSignature', global => {
  const {
    promiseId
  } = global.currentSignature || {};
  if (promiseId) {
    void (0,api/* callApi */.p)('cancelDappRequest', promiseId, 'Canceled by the user');
  }
  setGlobal({
    ...global,
    currentSignature: undefined
  });
});
addActionHandler('addToken', (global, actions, _ref3) => {
  var _global$tokenInfo, _accountSettings$alwa, _accountSettings$dele;
  let {
    token
  } = _ref3;
  if (!((_global$tokenInfo = global.tokenInfo) !== null && _global$tokenInfo !== void 0 && (_global$tokenInfo = _global$tokenInfo.bySlug) !== null && _global$tokenInfo !== void 0 && _global$tokenInfo[token.slug])) {
    global = updateTokenInfo(global, {
      [token.slug]: {
        name: token.name,
        symbol: token.symbol,
        slug: token.slug,
        decimals: token.decimals,
        chain: token.chain,
        image: token.image,
        keywords: token.keywords,
        price: token.price ?? 0,
        priceUsd: token.priceUsd ?? 0,
        percentChange24h: token.change24h ?? 0
      }
    });
  }
  const {
    balances
  } = selectCurrentAccountState(global) ?? {};
  if (!(balances !== null && balances !== void 0 && balances.bySlug[token.slug])) {
    global = updateCurrentAccountState(global, {
      balances: {
        ...balances,
        bySlug: {
          ...(balances === null || balances === void 0 ? void 0 : balances.bySlug),
          [token.slug]: 0n
        }
      }
    });
  }
  const settings = selectCurrentAccountSettings(global);
  global = updateCurrentAccountSettings(global, {
    importedSlugs: [...((settings === null || settings === void 0 ? void 0 : settings.importedSlugs) ?? []), token.slug]
  });
  const accountSettings = selectCurrentAccountSettings(global) ?? {};
  global = updateCurrentAccountSettings(global, {
    ...accountSettings,
    orderedSlugs: [...(accountSettings.orderedSlugs ?? []), token.slug],
    alwaysShownSlugs: (0,iteratees/* unique */.Am)([...(accountSettings.alwaysShownSlugs ?? []), token.slug]),
    alwaysHiddenSlugs: (_accountSettings$alwa = accountSettings.alwaysHiddenSlugs) === null || _accountSettings$alwa === void 0 ? void 0 : _accountSettings$alwa.filter(slug => slug !== token.slug),
    deletedSlugs: (_accountSettings$dele = accountSettings.deletedSlugs) === null || _accountSettings$dele === void 0 ? void 0 : _accountSettings$dele.filter(slug => slug !== token.slug)
  });
  return global;
});
addActionHandler('importToken', async (global, actions, _ref4) => {
  var _global$tokenInfo$byS, _selectAccountState;
  let {
    address
  } = _ref4;
  const {
    currentAccountId
  } = global;
  global = updateSettings(global, {
    importToken: {
      isLoading: true,
      token: undefined
    }
  });
  setGlobal(global);
  const slug = await (0,api/* callApi */.p)('buildTokenSlug', 'ton', address);
  global = getGlobal();
  let token = (_global$tokenInfo$byS = global.tokenInfo.bySlug) === null || _global$tokenInfo$byS === void 0 ? void 0 : _global$tokenInfo$byS[slug];
  if (!token) {
    token = await (0,api/* callApi */.p)('fetchToken', global.currentAccountId, address);
    await (0,schedulers/* pause */.v7)(IMPORT_TOKEN_PAUSE);
    global = getGlobal();
    if (!token) {
      global = updateSettings(global, {
        importToken: {
          isLoading: false,
          token: undefined
        }
      });
      setGlobal(global);
      return;
    } else {
      const apiToken = {
        ...token,
        price: 0,
        priceUsd: 0,
        percentChange24h: 0
      };
      global = updateTokenInfo(global, {
        [apiToken.slug]: apiToken
      });
      setGlobal(global);
    }
  }
  const balances = ((_selectAccountState = accounts_selectAccountState(global, currentAccountId)) === null || _selectAccountState === void 0 || (_selectAccountState = _selectAccountState.balances) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.bySlug) ?? {};
  const shouldUpdateBalance = !(token.slug in balances);
  const userToken = buildUserToken(token);
  global = getGlobal();
  global = updateSettings(global, {
    importToken: {
      isLoading: false,
      token: userToken
    }
  });
  if (shouldUpdateBalance) {
    global = changeBalance(global, global.currentAccountId, token.slug, 0n);
  }
  setGlobal(global);
});
addActionHandler('resetImportToken', global => {
  global = updateSettings(global, {
    importToken: {
      isLoading: false,
      token: undefined
    }
  });
  setGlobal(global);
});
addActionHandler('verifyHardwareAddress', async (global, actions) => {
  const accountId = global.currentAccountId;
  const ledgerApi = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
  if (!(await ledgerApi.reconnectLedger())) {
    actions.showError({
      error: '$ledger_not_ready'
    });
    return;
  }
  try {
    actions.showDialog({
      title: 'Ledger',
      message: '$ledger_verify_address_on_device'
    });
    await ledgerApi.verifyAddress(accountId);
  } catch (err) {
    actions.showError({
      error: err
    });
  }
});
addActionHandler('setActiveContentTab', (global, actions, _ref5) => {
  let {
    tab
  } = _ref5;
  return updateCurrentAccountState(global, {
    activeContentTab: tab
  });
});
addActionHandler('addSwapToken', (global, actions, _ref6) => {
  let {
    token
  } = _ref6;
  const isAlreadyExist = token.slug in global.swapTokenInfo.bySlug;
  if (isAlreadyExist) {
    return;
  }
  const apiSwapAsset = {
    name: token.name,
    symbol: token.symbol,
    chain: token.chain,
    slug: token.slug,
    decimals: token.decimals,
    image: token.image,
    tokenAddress: token.tokenAddress,
    keywords: token.keywords,
    isPopular: false,
    price: 0,
    priceUsd: 0
  };
  setGlobal({
    ...global,
    swapTokenInfo: {
      ...global.swapTokenInfo,
      bySlug: {
        ...global.swapTokenInfo.bySlug,
        [apiSwapAsset.slug]: apiSwapAsset
      }
    }
  });
});
addActionHandler('apiUpdateWalletVersions', (global, actions, params) => {
  var _global$walletVersion;
  const {
    accountId,
    versions,
    currentVersion
  } = params;
  global = {
    ...global,
    walletVersions: {
      ...global.walletVersions,
      currentVersion,
      byId: {
        ...((_global$walletVersion = global.walletVersions) === null || _global$walletVersion === void 0 ? void 0 : _global$walletVersion.byId),
        [accountId]: versions
      }
    }
  };
  setGlobal(global);
});
function waitInitialActivityLoading(accountId) {
  initialActivityWaitingByAccountId[accountId] ||= (0,schedulers/* waitFor */.fm)(() => {
    var _selectAccountState2;
    const global = getGlobal();
    return !selectAccount(global, accountId) // The account has been removed, the initial activities will never appear
    || ((_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 || (_selectAccountState2 = _selectAccountState2.activities) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.idsMain) !== undefined;
  }, SEC, 60);
  return initialActivityWaitingByAccountId[accountId];
}
;// ./src/util/fee/getTonOperationFees.ts


function getTonOperationFees(operation) {
  return {
    gas: constants/* TON_GAS */.sl[operation] + src_config/* DEFAULT_FEE */.dqR,
    real: constants/* TON_GAS_REAL */.fv[operation]
  };
}
function getTonStakingFees(type) {
  switch (type) {
    case 'nominators':
      {
        return {
          stake: getTonOperationFees('stakeNominators'),
          unstake: getTonOperationFees('unstakeNominators')
        };
      }
    case 'liquid':
      {
        return {
          stake: getTonOperationFees('stakeLiquid'),
          unstake: getTonOperationFees('unstakeLiquid')
        };
      }
    case 'jetton':
      {
        return {
          stake: getTonOperationFees('stakeJettons'),
          unstake: getTonOperationFees('unstakeJettons'),
          claim: getTonOperationFees('claimJettons')
        };
      }
    case 'ethena':
      {
        return {
          stake: getTonOperationFees('stakeEthena'),
          unstake: getTonOperationFees('unstakeEthena'),
          claim: getTonOperationFees('unstakeEthenaLocked')
        };
      }
  }
  return {
    stake: {
      gas: 0n,
      real: 0n
    },
    unstake: {
      gas: 0n,
      real: 0n
    },
    claim: {
      gas: 0n,
      real: 0n
    }
  };
}
;// ./src/util/staking/index.ts

function getStakingMinAmount(type) {
  switch (type) {
    case 'nominators':
      return src_config/* NOMINATORS_STAKING_MIN_AMOUNT */.pLj;
    case 'ethena':
      return src_config/* ETHENA_STAKING_MIN_AMOUNT */.WUE;
    default:
      return src_config/* STAKING_MIN_AMOUNT */.UAn;
  }
}
function getUnstakeTime(state) {
  switch (state === null || state === void 0 ? void 0 : state.type) {
    case 'nominators':
    case 'liquid':
      return state.end;
    case 'ethena':
      return state.unlockTime;
    default:
      return undefined;
  }
}
function getStakingTitle(stakingType) {
  return stakingType === 'ethena' ? 'How does it work?' : 'Why this is safe';
}
function getStakingStateStatus(state) {
  if (state.unstakeRequestAmount) {
    if (state.type === 'ethena' && state.unlockTime && state.unlockTime <= Date.now()) {
      return 'readyToClaim';
    }
    return 'unstakeRequested';
  }
  if (getIsActiveStakingState(state)) {
    return 'active';
  }
  return 'inactive';
}
function getIsActiveStakingState(state) {
  return Boolean(state.balance || state.unstakeRequestAmount || 'unclaimedRewards' in state && state.unclaimedRewards > src_config/* MIN_ACTIVE_STAKING_REWARDS */.dL4);
}
function getIsLongUnstake(state, amount) {
  switch (state.type) {
    case 'nominators':
      {
        return true;
      }
    case 'liquid':
      {
        return amount === undefined ? false : amount > state.instantAvailable;
      }
    case 'jetton':
      {
        return false;
      }
    case 'ethena':
      {
        return true;
      }
  }
  return undefined;
}
function getFullStakingBalance(state) {
  switch (state.type) {
    case 'jetton':
      {
        return state.balance + state.unclaimedRewards;
      }
    case 'ethena':
      {
        return state.balance + state.unstakeRequestAmount;
      }
  }
  return state.balance;
}
;// ./src/global/helpers/errors.ts


/** Returns `true` if the error should be shown in the <PasswordForm /> or <LedgerConfirmOperation /> screen instead of a dialog */
function isInlineError(error) {
  const _error = error;
  return _error === types/* ApiCommonError */.QD.InvalidPassword || _error === types/* ApiHardwareError */.jc.HardwareOutdated || _error === types/* ApiHardwareError */.jc.BlindSigningNotEnabled || _error === types/* ApiHardwareError */.jc.RejectedByUser;
}
function errorCodeToMessage() {
  let error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : types/* ApiCommonError */.QD.Unexpected;
  const _error = error;
  switch (_error) {
    case types/* ApiTransactionDraftError */.KL.InvalidAmount:
      return 'Invalid amount';
    case types/* ApiAuthError */.Nu.InvalidAddress:
    case types/* ApiTransactionDraftError */.KL.InvalidToAddress:
      return 'Invalid address';
    case types/* ApiTransactionDraftError */.KL.InvalidStateInit:
      return '$state_init_invalid';
    case types/* ApiTransactionDraftError */.KL.InsufficientBalance:
      return 'Insufficient balance';
    case types/* ApiAuthError */.Nu.DomainNotResolved:
    case types/* ApiTransactionDraftError */.KL.DomainNotResolved:
      return 'Domain is not connected to a wallet';
    case types/* ApiTransactionDraftError */.KL.WalletNotInitialized:
      return 'Encryption is not possible. The recipient is not a wallet or has no outgoing transactions.';
    case types/* ApiTransactionDraftError */.KL.InvalidAddressFormat:
      return 'Invalid address format. Only URL Safe Base64 format is allowed.';
    case types/* ApiTransactionError */.jf.PartialTransactionFailure:
      return 'Not all transactions were sent successfully';
    case types/* ApiTransactionError */.jf.IncorrectDeviceTime:
      return 'The time on your device is incorrect, sync it and try again';
    case types/* ApiTransactionError */.jf.UnsuccesfulTransfer:
      return 'Transfer was unsuccessful. Try again later.';
    case types/* ApiTransactionError */.jf.ConcurrentTransaction:
      return 'Another transaction was sent from this wallet simultaneously. Please try again.';
    case types/* ApiTransactionDraftError */.KL.InactiveContract:
      return '$transfer_inactive_contract_error';
    case types/* ApiHardwareError */.jc.HardwareOutdated:
      return '$ledger_outdated';
    case types/* ApiHardwareError */.jc.BlindSigningNotEnabled:
      return '$hardware_blind_sign_not_enabled_internal';
    case types/* ApiHardwareError */.jc.RejectedByUser:
      return 'Canceled by the user';
    case types/* ApiHardwareError */.jc.ProofTooLarge:
      return 'The proof for signing provided by the Dapp is too large';
    case types/* ApiCommonError */.QD.ServerError:
      return window.navigator.onLine ? 'An error on the server side. Please try again.' : 'No internet connection. Please check your connection and try again.';
    case types/* ApiCommonError */.QD.DebugError:
      return 'Unexpected error. Please let the support know.';
    case types/* ApiCommonError */.QD.Unexpected:
      return 'Unexpected';
    case types/* ApiCommonError */.QD.InvalidPassword:
      return 'Wrong password, please try again.';
    default:
      return error;
  }
}
;// ./src/global/helpers/transfer.ts








/** Returns `false` if there is a problem preventing the further progress, which has been shown to the user */
async function prepareTransfer(hardwareConfirmState, updateForm, password) {
  let global = getGlobal();
  const isHardware = selectIsHardwareAccount(global);
  if (!isHardware) {
    const isPasswordCorrect = await (0,api/* callApi */.p)('verifyPassword', password ?? '');
    global = getGlobal();
    if (!isPasswordCorrect) {
      setGlobal(updateForm(global, {
        error: errorCodeToMessage(types/* ApiCommonError */.QD.InvalidPassword)
      }));
      return false;
    }
    if (getDoesUsePinPad()) {
      global = setIsPinAccepted(global);
    }
    void vibrateOnSuccess();
  }
  setGlobal(updateForm(global, {
    isLoading: true,
    error: undefined,
    ...(isHardware && {
      state: hardwareConfirmState
    })
  }));
  return true;
}

/** Returns `false` if the result is unsuccessful and the error has been shown to the user */
function handleTransferResult(result, updateForm) {
  let global = getGlobal();
  global = updateForm(global, {
    isLoading: undefined
  });
  global = clearIsPinAccepted(global);
  setGlobal(global);
  if (isErrorTransferResult(result)) {
    reportErrorTransferResult(result, updateForm);
    return false;
  }
  void vibrateOnSuccess();
  return true;
}

/** Returns `false` if any of the results is unsuccessful and the error has been shown to the user */
function handleTransferResults(results, updateForm) {
  if (!results.length) {
    return true;
  }
  const errorResultIndex = results.findIndex(isErrorTransferResult);
  const result = results[errorResultIndex >= 0 ? errorResultIndex : 0];
  return handleTransferResult(result, updateForm);
}
function isErrorTransferResult(result) {
  return result === undefined || !!result && typeof result === 'object' && 'error' in result;
}
function reportErrorTransferResult(result, updateForm) {
  void vibrateOnError();
  const error = result === null || result === void 0 ? void 0 : result.error;
  let global = getGlobal();
  global = updateForm(global, {
    isLoading: undefined
  });
  if (isInlineError(error)) {
    global = updateForm(global, {
      error: errorCodeToMessage(error)
    });
    setGlobal(global);
  } else {
    setGlobal(global);
    getActions().showError({
      error
    });
  }
}

/** Returns `false` if there is a problem preventing the further progress, which has been shown to the user */
async function prepareDappOperation(accountId, hardwareConfirmState, updateForm, doesNeedSigning, password) {
  let global = getGlobal();
  const isHardware = selectIsHardwareAccount(global, accountId);
  if (!isHardware) {
    const isPasswordCorrect = !doesNeedSigning || (await (0,api/* callApi */.p)('verifyPassword', password ?? ''));
    global = getGlobal();
    if (!isPasswordCorrect) {
      setGlobal(updateForm(global, {
        error: errorCodeToMessage(types/* ApiCommonError */.QD.InvalidPassword)
      }));
      return false;
    }
    if (getDoesUsePinPad()) {
      global = setIsPinAccepted(global);
    }
  }
  setGlobal(updateForm(global, {
    isLoading: true,
    error: undefined,
    ...(isHardware && {
      state: hardwareConfirmState
    })
  }));
  return true;
}

/** Returns `false` if the result is unsuccessful and the error has been shown to the user */
function handleDappSignatureResult(result, updateForm) {
  if (isErrorTransferResult(result)) {
    reportErrorTransferResult(result, updateForm);
    return false;
  }
  void vibrateOnSuccess();
  return true;
}
;// ./src/global/actions/api/staking.ts














const MODAL_CLOSING_DELAY = 50;
addActionHandler('startStaking', (global, actions, payload) => {
  const isOpen = global.currentStaking.state !== StakingState.None;
  const {
    tokenSlug
  } = payload || {};
  if (tokenSlug) {
    const stakingState = selectAccountStakingStatesBySlug(global, global.currentAccountId)[tokenSlug];
    if (stakingState) {
      global = getGlobal();
      global = updateAccountStaking(global, global.currentAccountId, {
        stakingId: stakingState.id
      });
      setGlobal(global);
      global = getGlobal();
    }
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !isOpen) {
    callActionInMain('startStaking', payload);
    return;
  }
  const state = StakingState.StakeInitial;
  setGlobal(updateCurrentStaking(global, {
    state,
    error: undefined
  }));
});
addActionHandler('startUnstaking', (global, actions, payload) => {
  const isOpen = global.currentStaking.state !== StakingState.None;
  const {
    stakingId
  } = payload || {};
  if (stakingId) {
    global = getGlobal();
    global = updateAccountStaking(global, global.currentAccountId, {
      stakingId
    });
    setGlobal(global);
    global = getGlobal();
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !isOpen) {
    callActionInMain('startUnstaking', payload);
    return;
  }
  const state = StakingState.UnstakeInitial;
  setGlobal(updateCurrentStaking(global, {
    state,
    error: undefined
  }));
});
addActionHandler('fetchStakingFee', async (global, actions, payload) => {
  const {
    amount
  } = payload;
  const {
    currentAccountId
  } = global;
  if (!currentAccountId) {
    return;
  }
  const state = selectAccountStakingState(global, currentAccountId);
  const result = await (0,api/* callApi */.p)('checkStakeDraft', currentAccountId, amount, state);
  if (!result || 'error' in result) {
    return;
  }
  global = getGlobal();
  global = updateCurrentStaking(global, {
    fee: result.fee
  });
  setGlobal(global);
});
addActionHandler('submitStakingInitial', async (global, actions, payload) => {
  const {
    isUnstaking,
    amount
  } = payload ?? {};
  const {
    currentAccountId
  } = global;
  if (!currentAccountId) {
    return;
  }
  setGlobal(updateCurrentStaking(global, {
    isLoading: true,
    error: undefined
  }));
  const state = selectAccountStakingState(global, currentAccountId);
  if (isUnstaking) {
    const result = await (0,api/* callApi */.p)('checkUnstakeDraft', currentAccountId, amount, state);
    global = getGlobal();
    global = updateCurrentStaking(global, {
      isLoading: false
    });
    if (result) {
      if ('error' in result) {
        global = updateCurrentStaking(global, {
          error: result.error
        });
      } else {
        if (selectIsHardwareAccount(global)) {
          global = resetHardware(global);
          global = updateCurrentStaking(global, {
            state: StakingState.UnstakeConnectHardware
          });
        } else {
          global = updateCurrentStaking(global, {
            state: StakingState.UnstakePassword
          });
        }
        global = updateCurrentStaking(global, {
          fee: result.fee,
          amount,
          error: undefined,
          tokenAmount: result.tokenAmount
        });
      }
    }
  } else {
    const result = await (0,api/* callApi */.p)('checkStakeDraft', currentAccountId, amount, state);
    global = getGlobal();
    global = updateCurrentStaking(global, {
      isLoading: false
    });
    if (result) {
      if ('error' in result) {
        global = updateCurrentStaking(global, {
          error: result.error
        });
      } else {
        if (selectIsHardwareAccount(global)) {
          global = resetHardware(global);
          global = updateCurrentStaking(global, {
            state: StakingState.StakeConnectHardware
          });
        } else {
          global = updateCurrentStaking(global, {
            state: StakingState.StakePassword
          });
        }
        global = updateCurrentStaking(global, {
          fee: result.fee,
          amount,
          error: undefined
        });
      }
    }
  }
  setGlobal(global);
});
addActionHandler('submitStaking', async function (global, actions) {
  let payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    password,
    isUnstaking
  } = payload;
  const {
    amount,
    tokenAmount
  } = global.currentStaking;
  const {
    currentAccountId
  } = global;
  if (!(await prepareTransfer(isUnstaking ? StakingState.UnstakeConfirmHardware : StakingState.StakeConfirmHardware, updateCurrentStaking, password))) {
    return;
  }
  global = getGlobal();
  const state = selectAccountStakingState(global, currentAccountId);
  if (isUnstaking) {
    const unstakeAmount = state.type === 'nominators' ? state.balance : tokenAmount;
    const result = await (0,api/* callApi */.p)('submitUnstake', global.currentAccountId, password, unstakeAmount, state, getTonStakingFees(state.type).unstake.real);
    if (!handleTransferResult(result, updateCurrentStaking)) {
      return;
    }
    const isLongUnstakeRequested = getIsLongUnstake(state, unstakeAmount);
    global = getGlobal();
    global = misc_updateAccountState(global, currentAccountId, {
      isLongUnstakeRequested
    });
    global = updateCurrentStaking(global, {
      state: StakingState.UnstakeComplete
    });
    setGlobal(global);
  } else {
    const result = await (0,api/* callApi */.p)('submitStake', global.currentAccountId, password, amount, state, getTonStakingFees(state.type).stake.real);
    if (!handleTransferResult(result, updateCurrentStaking)) {
      return;
    }
    global = getGlobal();
    global = updateCurrentStaking(global, {
      state: StakingState.StakeComplete
    });
    setGlobal(global);
  }
});
addActionHandler('clearStakingError', global => {
  setGlobal(updateCurrentStaking(global, {
    error: undefined
  }));
});
addActionHandler('cancelStaking', global => {
  if (getDoesUsePinPad()) {
    global = clearIsPinAccepted(global);
  }
  global = clearCurrentStaking(global);
  setGlobal(global);
});
addActionHandler('setStakingScreen', (global, actions, payload) => {
  const {
    state
  } = payload;
  setGlobal(updateCurrentStaking(global, {
    state
  }));
});
addActionHandler('fetchStakingHistory', async global => {
  const stakingHistory = await (0,api/* callApi */.p)('getStakingHistory', global.currentAccountId);
  if (!stakingHistory) {
    return;
  }
  global = getGlobal();
  global = misc_updateAccountState(global, global.currentAccountId, {
    stakingHistory
  }, true);
  setGlobal(global);
});
addActionHandler('openAnyAccountStakingInfo', async (global, actions, _ref) => {
  let {
    accountId,
    network,
    stakingId
  } = _ref;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openAnyAccountStakingInfo', {
      accountId,
      network,
      stakingId
    });
    return;
  }
  await Promise.all([closeAllOverlays(), switchAccount(global, accountId, network)]);
  actions.changeCurrentStaking({
    stakingId
  });
  actions.openStakingInfo();
});

// Should be called only when you're sure that the staking is active. Otherwise, call `openStakingInfoOrStart`.
addActionHandler('openStakingInfo', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openStakingInfo');
    return;
  }
  global = {
    ...global,
    isStakingInfoModalOpen: true
  };
  setGlobal(global);
});
addActionHandler('closeStakingInfo', global => {
  global = {
    ...global,
    isStakingInfoModalOpen: undefined
  };
  setGlobal(global);
});
addActionHandler('changeCurrentStaking', async (global, actions, _ref2) => {
  let {
    stakingId,
    shouldReopenModal
  } = _ref2;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && shouldReopenModal) {
    callActionInMain('changeCurrentStaking', {
      stakingId,
      shouldReopenModal
    });
    return;
  }
  if (shouldReopenModal) {
    await (0,schedulers/* pause */.v7)(MODAL_CLOSING_DELAY);
  }
  global = getGlobal();
  global = updateAccountStaking(global, global.currentAccountId, {
    stakingId
  });
  setGlobal(global);
  if (shouldReopenModal) {
    actions.openStakingInfoOrStart();
  }
});
addActionHandler('startStakingClaim', (global, actions, payload) => {
  const {
    stakingId
  } = payload || {};
  if (stakingId) {
    global = getGlobal();
    global = updateAccountStaking(global, global.currentAccountId, {
      stakingId
    });
    setGlobal(global);
    global = getGlobal();
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('startStakingClaim', payload);
    return;
  }
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateCurrentStaking(global, {
      state: StakingState.ClaimConnectHardware
    });
  } else {
    global = updateCurrentStaking(global, {
      state: StakingState.ClaimPassword
    });
  }
  setGlobal(global);
});
addActionHandler('cancelStakingClaim', global => {
  global = updateCurrentStaking(global, {
    state: StakingState.None
  });
  setGlobal(global);
});
addActionHandler('submitStakingClaim', async function (global, actions) {
  var _getTonStakingFees$cl;
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const accountId = global.currentAccountId;
  if (!(await prepareTransfer(StakingState.ClaimConfirmHardware, updateCurrentStaking, password))) {
    return;
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('submitStakingClaim', {
      password
    });
    return;
  }
  global = getGlobal();
  const stakingState = selectAccountStakingState(global, accountId);
  const isEthenaStaking = stakingState.type === 'ethena';
  const result = await (0,api/* callApi */.p)('submitStakingClaimOrUnlock', accountId, password, stakingState, (_getTonStakingFees$cl = getTonStakingFees(stakingState.type).claim) === null || _getTonStakingFees$cl === void 0 ? void 0 : _getTonStakingFees$cl.real);
  if (!handleTransferResult(result, updateCurrentStaking)) {
    return;
  }
  global = getGlobal();
  global = updateCurrentStaking(global, {
    state: isEthenaStaking ? StakingState.ClaimComplete : StakingState.None
  });
  setGlobal(global);
  if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
    callActionInNative('setStakingScreen', {
      state: isEthenaStaking ? StakingState.ClaimComplete : StakingState.None
    });
  }
});

// Opens the staking info modal if the modal is available. Otherwise, opens the staking start modal.
addActionHandler('openStakingInfoOrStart', (global, actions) => {
  if (!global.currentAccountId) {
    return;
  }
  const stakingState = selectAccountStakingState(global, global.currentAccountId);
  if (getIsActiveStakingState(stakingState)) {
    actions.openStakingInfo();
  } else {
    actions.startStaking();
  }
});
;// ./src/util/getDappConnectionUniqueId.ts
function getDappConnectionUniqueId(request) {
  var _sseOptions, _sse;
  return ((_sseOptions = request.sseOptions) === null || _sseOptions === void 0 ? void 0 : _sseOptions.appClientId) ?? ((_sse = request.sse) === null || _sse === void 0 ? void 0 : _sse.appClientId) ?? 'jsbridge';
}
;// ./src/global/actions/api/dapps.ts
















const GET_DAPPS_PAUSE = 250;
addActionHandler('submitDappConnectRequestConfirm', async (global, actions, _ref) => {
  let {
    password,
    accountId
  } = _ref;
  const {
    promiseId,
    permissions,
    proof
  } = global.dappConnectRequest;
  if (!(await prepareDappOperation(accountId, DappConnectState.ConfirmHardware, updateDappConnectRequest, !!(permissions !== null && permissions !== void 0 && permissions.isPasswordRequired), password))) {
    return;
  }
  const signingResult = proof ? await (0,api/* callApi */.p)('signTonProof', accountId, proof, password) : {
    signature: undefined
  };
  if (!handleDappSignatureResult(signingResult, updateDappConnectRequest)) {
    return;
  }
  actions.switchAccount({
    accountId
  });

  // It's important to call the API methods including promiseId in the main window, because the Bottom Sheet window
  // knows nothing about that promiseId.
  await callApiInMain('confirmDappRequestConnect', promiseId, {
    accountId,
    proofSignature: signingResult.signature
  });
  global = getGlobal();
  global = clearDappConnectRequest(global);
  setGlobal(global);
  await (0,schedulers/* pause */.v7)(GET_DAPPS_PAUSE);
  actions.getDapps();
});
addActionHandler('cancelDappConnectRequestConfirm', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('clearDappConnectRequestConfirm');
  }
  cancelDappOperation(global => global.dappConnectRequest, clearDappConnectRequest);
});

// Clear state after closing the NBS modal.
// TODO: Remove after fully migrating to Air app.
addActionHandler('clearDappConnectRequestConfirm', global => {
  return clearDappConnectRequest(global);
});
addActionHandler('setDappConnectRequestState', (global, actions, _ref2) => {
  let {
    state
  } = _ref2;
  setGlobal(updateDappConnectRequest(global, {
    state
  }));
});
addActionHandler('cancelDappTransfer', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('clearDappTransfer');
  }
  cancelDappOperation(global => global.currentDappTransfer, clearCurrentDappTransfer);
});

// Clear state after closing the NBS modal.
// TODO: Remove after fully migrating to Air app.
addActionHandler('clearDappTransfer', global => {
  return clearCurrentDappTransfer(global);
});
function cancelDappOperation(getState, clearState) {
  let global = getGlobal();
  const {
    promiseId
  } = getState(global) ?? {};
  if (promiseId) {
    void callApiInMain('cancelDappRequest', promiseId, 'Canceled by the user');
  }
  if (getDoesUsePinPad()) {
    global = clearIsPinAccepted(global);
  }
  global = clearState(global);
  setGlobal(global);
}
addActionHandler('submitDappTransfer', async function (global, actions) {
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    promiseId
  } = global.currentDappTransfer;
  if (!promiseId) {
    return;
  }
  if (!(await prepareDappOperation(global.currentAccountId, TransferState.ConfirmHardware, updateCurrentDappTransfer, true, password))) {
    return;
  }
  global = getGlobal();
  const {
    transactions,
    validUntil,
    vestingAddress
  } = global.currentDappTransfer;
  const accountId = global.currentAccountId;
  const signedTransactions = await (0,api/* callApi */.p)('signTransfers', accountId, transactions, {
    password,
    validUntil,
    vestingAddress
  });
  if (!handleDappSignatureResult(signedTransactions, updateCurrentDappTransfer)) {
    return;
  }
  await callApiInMain('confirmDappRequestSendTransaction', promiseId, signedTransactions);
});
addActionHandler('submitDappSignData', async function (global, actions) {
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    promiseId
  } = global.currentDappSignData;
  if (!promiseId) {
    return;
  }
  if (!(await prepareDappOperation(global.currentAccountId, 0,
  // Ledger doesn't support SignData yet, so this value is never used
  updateCurrentDappSignData, true, password))) {
    return;
  }
  global = getGlobal();
  const {
    dapp,
    payloadToSign
  } = global.currentDappSignData;
  const accountId = global.currentAccountId;
  const signedData = await (0,api/* callApi */.p)('signData', accountId, dapp.url, payloadToSign, password);
  if (!handleDappSignatureResult(signedData, updateCurrentDappSignData)) {
    return;
  }
  await callApiInMain('confirmDappRequestSignData', promiseId, signedData);
});
addActionHandler('getDapps', async (global, actions) => {
  const {
    currentAccountId
  } = global;
  let result = await (0,api/* callApi */.p)('getDapps', currentAccountId);
  if (!result) {
    return;
  }

  // Check for broken dapps without URL
  const brokenDapp = result.find(_ref3 => {
    let {
      url
    } = _ref3;
    return !url;
  });
  if (brokenDapp) {
    actions.deleteDapp({
      url: brokenDapp.url,
      uniqueId: getDappConnectionUniqueId(brokenDapp)
    });
    result = result.filter(_ref4 => {
      let {
        url
      } = _ref4;
      return url;
    });
  }
  global = getGlobal();
  global = updateConnectedDapps(global, result);
  setGlobal(global);
});
addActionHandler('deleteAllDapps', global => {
  const {
    currentAccountId
  } = global;
  void (0,api/* callApi */.p)('deleteAllDapps', currentAccountId);
  global = getGlobal();
  global = clearConnectedDapps(global);
  setGlobal(global);
});
addActionHandler('deleteDapp', (global, actions, _ref5) => {
  let {
    url,
    uniqueId
  } = _ref5;
  const {
    currentAccountId
  } = global;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('deleteDapp', {
      url,
      uniqueId
    });
  } else {
    void (0,api/* callApi */.p)('deleteDapp', currentAccountId, url, uniqueId);
  }
  global = getGlobal();
  global = removeConnectedDapp(global, url);
  setGlobal(global);
});
addActionHandler('cancelDappSignData', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('clearDappSignData');
  }
  cancelDappOperation(global => global.currentDappSignData, clearCurrentDappSignData);
});

// Clear state after closing the NBS modal.
// TODO: Remove after fully migrating to Air app.
addActionHandler('clearDappSignData', global => {
  return clearCurrentDappSignData(global);
});
addActionHandler('apiUpdateDappConnect', async (global, actions, _ref6) => {
  let {
    accountId,
    dapp,
    permissions,
    promiseId,
    proof
  } = _ref6;
  // We only need to apply changes in NBS when Dapp Connect Modal is already open
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    if (!(await (0,schedulers/* waitFor */.fm)(() => Boolean(getGlobal().dappConnectRequest), 300, 5))) {
      return;
    }
    global = getGlobal();
  }
  global = updateDappConnectRequest(global, {
    state: DappConnectState.Info,
    promiseId,
    accountId,
    dapp,
    permissions: {
      isAddressRequired: permissions.address,
      isPasswordRequired: permissions.proof
    },
    proof
  });
  setGlobal(global);
  actions.addSiteToBrowserHistory({
    url: dapp.url
  });
});
addActionHandler('apiUpdateDappSendTransaction', async (global, actions, payload) => {
  const {
    promiseId,
    transactions,
    emulation,
    dapp,
    validUntil,
    vestingAddress
  } = payload;
  await apiUpdateDappOperation(payload, global => global.currentDappTransfer, actions.closeDappTransfer, global => global.currentDappTransfer.state !== TransferState.None, clearCurrentDappTransfer, global => updateCurrentDappTransfer(global, {
    state: selectIsHardwareAccount(global) && transactions.length > 1 ? TransferState.WarningHardware : TransferState.Initial,
    promiseId,
    transactions,
    emulation,
    dapp,
    validUntil,
    vestingAddress
  }));
});
addActionHandler('apiUpdateDappSignData', async (global, actions, payload) => {
  const {
    promiseId,
    dapp,
    payloadToSign
  } = payload;
  await apiUpdateDappOperation(payload, global => global.currentDappSignData, actions.closeDappSignData, global => global.currentDappSignData.state !== SignDataState.None, clearCurrentDappSignData, global => updateCurrentDappSignData(global, {
    state: SignDataState.Initial,
    promiseId,
    dapp,
    payloadToSign
  }));
});
async function apiUpdateDappOperation(payload, getState, close, isStateActive, clearState, updateState) {
  let global = getGlobal();
  const {
    accountId
  } = payload;
  const {
    promiseId: currentPromiseId
  } = getState(global);
  await switchAccount(global, accountId);
  if (currentPromiseId && !windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    close();
    const closeDuration = getIsPortrait() ? CLOSE_DURATION_PORTRAIT : Modal_CLOSE_DURATION;
    await (0,schedulers/* pause */.v7)(closeDuration + src_config/* ANIMATION_END_DELAY */.xB5);
  }

  // We only need to apply changes in NBS when dapp operation modal is already open
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    if (!(await (0,schedulers/* waitFor */.fm)(() => isStateActive(getGlobal()), 300, 5))) {
      return;
    }
  }
  global = getGlobal();
  global = clearState(global);
  global = updateState(global);
  setGlobal(global);
}
addActionHandler('apiUpdateDappLoading', async (global, actions, _ref7) => {
  let {
    connectionType,
    isSse,
    accountId
  } = _ref7;
  // We only need to apply changes in NBS when Dapp Connect Modal is already open
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    if (!(await (0,schedulers/* waitFor */.fm)(() => isAnyDappModalActive(getGlobal(), connectionType), 300, 5))) {
      return;
    }
    global = getGlobal();
  }
  if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && accountId) {
    actions.switchAccount({
      accountId
    });
  }
  if (connectionType === 'connect') {
    global = updateDappConnectRequest(global, {
      state: DappConnectState.Info,
      isSse
    });
  } else if (connectionType === 'sendTransaction') {
    global = updateCurrentDappTransfer(global, {
      state: TransferState.Initial,
      isSse
    });
  } else if (connectionType === 'signData') {
    global = updateCurrentDappSignData(global, {
      state: SignDataState.Initial,
      isSse
    });
  }
  setGlobal(global);
});
addActionHandler('apiUpdateDappCloseLoading', async (global, actions, _ref8) => {
  var _global$dappConnectRe;
  let {
    connectionType
  } = _ref8;
  // We only need to apply changes in NBS when Dapp Modal is already open
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    if (!(await (0,schedulers/* waitFor */.fm)(() => isAnyDappModalActive(getGlobal(), connectionType), 300, 5))) {
      return;
    }
    global = getGlobal();
  }

  // But clear the state if a skeleton is displayed in the Modal
  if (connectionType === 'connect' && ((_global$dappConnectRe = global.dappConnectRequest) === null || _global$dappConnectRe === void 0 ? void 0 : _global$dappConnectRe.state) === DappConnectState.Info) {
    global = clearDappConnectRequest(global);
  } else if (connectionType === 'sendTransaction' && global.currentDappTransfer.state === TransferState.Initial) {
    global = clearCurrentDappTransfer(global);
  } else if (connectionType === 'signData' && global.currentDappSignData.state === SignDataState.Initial) {
    global = clearCurrentDappSignData(global);
  }
  setGlobal(global);
});
addActionHandler('loadExploreSites', async (global, _, _ref9) => {
  let {
    isLandscape
  } = _ref9;
  const exploreData = await (0,api/* callApi */.p)('loadExploreSites', {
    isLandscape
  });
  global = getGlobal();
  if (areDeepEqual(exploreData, global.exploreData)) {
    return;
  }
  global = {
    ...global,
    exploreData
  };
  setGlobal(global);
});
function isAnyDappModalActive(global, connectionType) {
  return connectionType === 'connect' && !!global.dappConnectRequest || connectionType === 'sendTransaction' && global.currentDappTransfer.state !== TransferState.None || connectionType === 'signData' && global.currentDappSignData.state !== SignDataState.None;
}
;// ./src/util/bigNumber.ts

function bigMin(value0, value1) {
  return (0,big_js/* Big */.z)(value0).lt(value1) ? value0 : value1;
}
function bigMax(value0, value1) {
  return (0,big_js/* Big */.z)(value0).gt(value1) ? value0 : value1;
}
;// ./src/util/fee/swapFee.ts








/**
 * Converts the swap fee data returned from API into data that is ready to be displayed in the swap form UI.
 */
function explainSwapFee(input) {
  return shouldSwapBeGasless(input) ? explainGaslessSwapFee(input) : explainGasfullSwapFee(input);
}

/**
 * Calculates the maximum amount available for the swap.
 * Returns undefined when it can't be calculated because of insufficient input data.
 */
function getMaxSwapAmount(_ref) {
  let {
    swapType,
    tokenInBalance,
    tokenIn,
    fullNetworkFee,
    ourFeePercent
  } = _ref;
  if (swapType === SwapType.CrosschainToWallet || tokenInBalance === undefined) {
    return undefined;
  }
  let maxAmount = tokenInBalance;

  // For a better UX, assuming the fee is 0 when it's unknown
  if (fullNetworkFee) {
    if (!tokenIn) {
      return undefined;
    }
    maxAmount -= (0,util_decimals/* fromDecimal */.UH)(fullNetworkFee.token ?? '0', tokenIn.decimals);
    if (getIsNativeToken(tokenIn.slug)) {
      // When the "in" token is native, both `token` and `native` refer to the same currency, so we consider them both
      maxAmount -= (0,util_decimals/* fromDecimal */.UH)(fullNetworkFee.native ?? '0', tokenIn.decimals);
    }
  }
  ourFeePercent ??= swapType === SwapType.OnChain ? src_config/* DEFAULT_OUR_SWAP_FEE */.YDh : 0;
  maxAmount = (0,bigint/* bigintDivideToNumber */.fC)(maxAmount, 1 + ourFeePercent / 100);
  return (0,bigint/* bigintMax */._O)(maxAmount, 0n);
}

/**
 * Decides whether the balance is sufficient to swap the amount and pay the fees.
 * Returns undefined when it can't be calculated because of insufficient input data.
 */
function isBalanceSufficientForSwap(input) {
  var _findChainConfig;
  const {
    swapType,
    amountIn,
    tokenInBalance,
    nativeTokenInBalance,
    tokenIn,
    fullNetworkFee
  } = input;
  if (swapType === SwapType.CrosschainToWallet) {
    return true;
  }
  if (amountIn === undefined || !tokenIn || tokenInBalance === undefined || nativeTokenInBalance === undefined || !fullNetworkFee) {
    return undefined;
  }
  const nativeTokenIn = (_findChainConfig = findChainConfig(getChainBySlug(tokenIn.slug))) === null || _findChainConfig === void 0 ? void 0 : _findChainConfig.nativeToken;
  if (!nativeTokenIn) {
    return undefined;
  }
  const maxAmount = getMaxSwapAmount(input);
  if (maxAmount === undefined) {
    return undefined;
  }
  const swapAmountInBigint = (0,util_decimals/* fromDecimal */.UH)(amountIn, tokenIn.decimals);
  const networkNativeFeeBigint = (0,util_decimals/* fromDecimal */.UH)(fullNetworkFee.native ?? '0', nativeTokenIn.decimals);
  return swapAmountInBigint <= maxAmount && networkNativeFeeBigint <= nativeTokenInBalance;
}

/**
 * Decides whether the balance is sufficient for the given swap estimate variant (DEX).
 * Returns undefined when it can't be calculated because of insufficient input data.
 */
function canAffordSwapEstimateVariant(input) {
  var _findChainConfig2;
  if (!input.tokenIn || input.nativeTokenInBalance === undefined) {
    return undefined;
  }
  const nativeTokenIn = (_findChainConfig2 = findChainConfig(getChainBySlug(input.tokenIn.slug))) === null || _findChainConfig2 === void 0 ? void 0 : _findChainConfig2.nativeToken;
  if (!nativeTokenIn) {
    return undefined;
  }

  // Try to pay with gas
  const networkFeeBigint = (0,util_decimals/* fromDecimal */.UH)(input.variant.networkFee, nativeTokenIn.decimals);
  if (input.nativeTokenInBalance >= networkFeeBigint) {
    return true;
  }

  // Otherwise, try to pay with diesel
  if (input.variant.dieselFee) {
    if (input.tokenInBalance === undefined) {
      return undefined;
    }
    const dieselFeeBigint = (0,util_decimals/* fromDecimal */.UH)(input.variant.dieselFee, input.tokenIn.decimals);
    if (input.tokenInBalance >= dieselFeeBigint) {
      return true;
    }
  }
  return false;
}
function shouldSwapBeGasless(input) {
  const isNativeIn = getIsNativeToken(input.tokenInSlug);
  const nativeTokenBalance = getBigNativeTokenInBalance(input);
  const isInsufficientNative = input.networkFee !== undefined && nativeTokenBalance !== undefined && nativeTokenBalance.lt(input.networkFee);
  return input.swapType === SwapType.OnChain && isInsufficientNative && !isNativeIn && Boolean(input.dieselStatus) && input.dieselStatus !== 'not-available';
}

/**
 * Converts the data of a swap not involving diesel
 */
function explainGasfullSwapFee(input) {
  const result = {
    isGasless: false,
    excessFee: getExcessFee(input),
    shouldShowOurFee: shouldShowOurFee(input)
  };
  const isNativeIn = getIsNativeToken(input.tokenInSlug);
  const isExact = result.excessFee === '0';
  if (input.networkFee !== undefined) {
    const networkTerms = {
      native: input.networkFee
    };
    result.fullFee = {
      precision: isExact ? 'exact' : 'lessThan',
      terms: addOurFeeToTerms(networkTerms, input.ourFee ?? '0', isNativeIn),
      networkTerms
    };
    result.realFee = result.fullFee;
  }
  if (input.realNetworkFee !== undefined) {
    const networkTerms = {
      native: input.realNetworkFee
    };
    result.realFee = {
      precision: isExact ? 'exact' : 'approximate',
      terms: addOurFeeToTerms(networkTerms, input.ourFee ?? '0', isNativeIn),
      networkTerms
    };
  }
  return result;
}

/**
 * Converts the diesel of semi-diesel swap data
 */
function explainGaslessSwapFee(input) {
  const nativeTokenBalance = getBigNativeTokenInBalance(input);
  const result = {
    isGasless: true,
    excessFee: getExcessFee(input),
    shouldShowOurFee: shouldShowOurFee(input)
  };
  if (input.networkFee === undefined || input.dieselFee === undefined || nativeTokenBalance === undefined) {
    return result;
  }
  const isExact = result.excessFee === '0';
  const isStarsDiesel = input.dieselStatus === 'stars-fee';
  const dieselKey = isStarsDiesel ? 'stars' : 'token';
  const networkTerms = {
    [dieselKey]: input.dieselFee,
    native: nativeTokenBalance.toString()
  };
  result.fullFee = {
    precision: isExact ? 'exact' : 'lessThan',
    terms: addOurFeeToTerms(networkTerms, input.ourFee ?? '0', false),
    networkTerms
  };
  result.realFee = result.fullFee;
  if (input.realNetworkFee !== undefined) {
    // We are sure this amount is > 0 because `shouldBeGasless` would return `false` otherwise and this function
    // wouldn't be called.
    const networkFeeCoveredByDiesel = (0,big_js/* Big */.z)(input.networkFee).sub(nativeTokenBalance);
    const realFeeInDiesel = (0,big_js/* Big */.z)(input.dieselFee).div(networkFeeCoveredByDiesel).mul(input.realNetworkFee);
    // Cover as much displayed real fee as possible with diesel, because in the excess it will return as the native token.
    const dieselRealFee = bigMin(input.dieselFee, realFeeInDiesel);
    // Cover the remaining real fee with the native token.
    const nativeRealFee = bigMax(0, (0,big_js/* Big */.z)(input.realNetworkFee).sub(networkFeeCoveredByDiesel));
    const realNetworkTerms = {
      [dieselKey]: dieselRealFee.toString(),
      native: nativeRealFee.toString()
    };
    result.realFee = {
      precision: isExact ? 'exact' : 'approximate',
      terms: addOurFeeToTerms(realNetworkTerms, input.ourFee ?? '0', false),
      networkTerms: realNetworkTerms
    };
  }
  return result;
}
function getBigNativeTokenInBalance(input) {
  var _findChainConfig3;
  if (!input.tokenInSlug || input.nativeTokenInBalance === undefined) {
    return undefined;
  }
  const nativeToken = (_findChainConfig3 = findChainConfig(getChainBySlug(input.tokenInSlug))) === null || _findChainConfig3 === void 0 ? void 0 : _findChainConfig3.nativeToken;
  return nativeToken ? (0,util_decimals/* toBig */.CF)(input.nativeTokenInBalance, nativeToken.decimals) : undefined;
}
function getExcessFee(_ref2) {
  let {
    networkFee,
    realNetworkFee
  } = _ref2;
  return networkFee !== undefined && realNetworkFee !== undefined ? (0,big_js/* Big */.z)(networkFee).sub(realNetworkFee).toString() : undefined;
}
function addOurFeeToTerms(terms, ourFee, isOurFeeNative) {
  return {
    ...terms,
    native: isOurFeeNative ? (0,big_js/* Big */.z)(terms.native ?? '0').add(ourFee).toString() : terms.native,
    token: isOurFeeNative ? terms.token : (0,big_js/* Big */.z)(terms.token ?? '0').add(ourFee).toString()
  };
}
function shouldShowOurFee(input) {
  return input.swapType === SwapType.OnChain;
}
;// ./src/global/actions/api/swap.ts






















const pairsCache = {};
const CACHE_DURATION = 15 * 60 * 1000; // 15 minutes
const WAIT_FOR_CHANGELLY = 5 * 1000;
const CLOSING_BOTTOM_SHEET_DURATION = 100; // Like in `useDelegatingBottomSheet`

const SERVER_ERRORS_MAP = {
  'Insufficient liquidity': SwapErrorType.NotEnoughLiquidity,
  'Tokens must be different': SwapErrorType.InvalidPair,
  'Asset not found': SwapErrorType.InvalidPair,
  'Pair not found': SwapErrorType.InvalidPair,
  'Too small amount': SwapErrorType.TooSmallAmount
};
function buildSwapBuildRequest(global) {
  var _findChainConfig, _estimates$;
  const {
    currentDexLabel,
    amountIn,
    amountOut,
    amountOutMin,
    slippage,
    networkFee,
    swapFee,
    ourFee,
    dieselFee,
    realNetworkFee,
    estimates
  } = global.currentSwap;
  const tokenIn = selectCurrentSwapTokenIn(global);
  const tokenOut = selectCurrentSwapTokenOut(global);
  const from = resolveSwapAssetId(tokenIn);
  const to = resolveSwapAssetId(tokenOut);
  const fromAmount = amountIn;
  const toAmount = amountOut;
  const account = selectAccount(global, global.currentAccountId);
  const nativeTokenIn = (_findChainConfig = findChainConfig(getChainBySlug(tokenIn.slug))) === null || _findChainConfig === void 0 ? void 0 : _findChainConfig.nativeToken;
  const nativeTokenInBalance = nativeTokenIn ? selectCurrentAccountTokenBalance(global, nativeTokenIn.slug) : undefined;
  const swapType = selectSwapType(global);
  return {
    from,
    to,
    fromAmount,
    toAmount,
    toMinAmount: amountOutMin,
    slippage,
    fromAddress: (account === null || account === void 0 ? void 0 : account.addressByChain[tokenIn.chain]) || (account === null || account === void 0 ? void 0 : account.addressByChain.ton),
    shouldTryDiesel: shouldSwapBeGasless({
      ...global.currentSwap,
      swapType,
      nativeTokenInBalance
    }),
    dexLabel: currentDexLabel,
    networkFee: realNetworkFee ?? networkFee,
    swapFee: swapFee,
    ourFee: ourFee,
    dieselFee,
    routes: estimates === null || estimates === void 0 || (_estimates$ = estimates[0]) === null || _estimates$ === void 0 ? void 0 : _estimates$.routes
  };
}
function buildSwapEstimates(estimate) {
  const bestEstimate = {
    ...(0,iteratees/* pick */.Up)(estimate, ['fromAmount', 'toAmount', 'toMinAmount', 'impact', 'dexLabel', 'networkFee', 'realNetworkFee', 'swapFee', 'swapFeePercent', 'ourFee', 'dieselFee', 'networkFee', 'routes'])
  };
  const result = [bestEstimate, ...(estimate.other ?? [])];
  return result.sort((a, b) => a.dexLabel.localeCompare(b.dexLabel));
}
function processNativeMaxSwap(global) {
  const tokenIn = selectCurrentSwapTokenIn(global);
  let fromAmount = global.currentSwap.amountIn ?? '0';
  let isFromAmountMax = false;
  if (global.currentSwap.amountIn && selectSwapType(global) === SwapType.OnChain && global.currentSwap.inputSource === SwapInputSource.In && global.currentSwap.isMaxAmount) {
    const tokenBalance = selectCurrentAccountTokenBalance(global, tokenIn.slug);
    fromAmount = (0,util_decimals/* toDecimal */.nI)(tokenBalance, tokenIn.decimals);
    isFromAmountMax = true;
  }
  return {
    fromAmount,
    isFromAmountMax
  };
}
function getSupportedChains(global) {
  var _selectAccount;
  return Object.keys(((_selectAccount = selectAccount(global, global.currentAccountId)) === null || _selectAccount === void 0 ? void 0 : _selectAccount.addressByChain) || {
    ton: true
  });
}
addActionHandler('startSwap', async (global, actions, payload) => {
  const isOpen = global.currentSwap.state !== SwapState.None;
  if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI && isOpen) {
    callActionInNative('cancelSwap');
    await (0,schedulers/* pause */.v7)(CLOSING_BOTTOM_SHEET_DURATION);
    global = getGlobal();
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('startSwap', payload);
    return;
  }
  const {
    state
  } = payload ?? {};
  const isPortrait = getIsPortrait();
  const requiredState = state || (isPortrait ? SwapState.Initial : SwapState.None);
  global = updateCurrentSwap(global, {
    ...payload,
    state: requiredState,
    swapId: (0,generateUniqueId/* default */.A)(),
    inputSource: SwapInputSource.In
  });
  setGlobal(global);
  if (!isPortrait) {
    actions.setLandscapeActionsActiveTabIndex({
      index: ActiveTab.Swap
    });
  }
});
addActionHandler('setDefaultSwapParams', (global, actions, payload) => {
  let {
    tokenInSlug: requiredTokenInSlug,
    tokenOutSlug: requiredTokenOutSlug
  } = payload ?? {};
  const {
    withResetAmount
  } = payload ?? {};
  requiredTokenInSlug = requiredTokenInSlug || src_config/* DEFAULT_SWAP_FIRST_TOKEN_SLUG */.JhS;
  requiredTokenOutSlug = requiredTokenOutSlug || src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC;
  if (global.currentSwap.tokenInSlug === requiredTokenInSlug && global.currentSwap.tokenOutSlug === requiredTokenOutSlug && !withResetAmount) {
    return;
  }
  global = updateCurrentSwap(global, {
    tokenInSlug: requiredTokenInSlug,
    tokenOutSlug: requiredTokenOutSlug,
    inputSource: SwapInputSource.In,
    ...(withResetAmount ? {
      amountIn: undefined,
      amountOut: undefined
    } : undefined)
  });
  setGlobal(global);
});
addActionHandler('cancelSwap', function (global, actions) {
  let {
    shouldReset
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (shouldReset) {
    const {
      tokenInSlug,
      tokenOutSlug
    } = global.currentSwap;
    global = clearCurrentSwap(global);
    global = updateCurrentSwap(global, {
      tokenInSlug,
      tokenOutSlug,
      amountIn: undefined,
      amountOut: undefined,
      inputSource: SwapInputSource.In
    });
    setGlobal(global);
    return;
  }
  if (getDoesUsePinPad()) {
    global = clearIsPinAccepted(global);
  }
  global = updateCurrentSwap(global, {
    state: SwapState.None,
    swapId: undefined
  });
  setGlobal(global);
});
addActionHandler('submitSwap', async (global, actions, _ref) => {
  let {
    password
  } = _ref;
  if (!(await prepareTransfer(0,
  // Swap isn't available for hardware accounts yet, so this argument value doesn't matter
  updateCurrentSwap, password))) {
    return;
  }
  setGlobal(updateCurrentSwap(getGlobal(), {
    shouldResetOnClose: undefined
  }));
  const swapBuildRequest = buildSwapBuildRequest(global);
  const buildResult = await (0,api/* callApi */.p)('swapBuildTransfer', global.currentAccountId, password, swapBuildRequest);
  if (!handleTransferResult(buildResult, updateCurrentSwap)) {
    setGlobal(updateCurrentSwap(getGlobal(), {
      shouldResetOnClose: true
    }));
    return;
  }
  const swapHistoryItem = {
    id: buildResult.id,
    timestamp: Date.now(),
    status: 'pendingTrusted',
    from: swapBuildRequest.from,
    fromAmount: swapBuildRequest.fromAmount,
    to: swapBuildRequest.to,
    toAmount: swapBuildRequest.toAmount,
    networkFee: global.currentSwap.realNetworkFee ?? global.currentSwap.networkFee,
    swapFee: global.currentSwap.swapFee,
    ourFee: global.currentSwap.ourFee,
    hashes: []
  };
  setGlobal(updateCurrentSwap(getGlobal(), {
    tokenInSlug: undefined,
    tokenOutSlug: undefined,
    amountIn: undefined,
    amountOut: undefined,
    state: SwapState.Complete,
    shouldResetOnClose: true
  }));
  const result = await (0,api/* callApi */.p)('swapSubmit', global.currentAccountId, password, buildResult.transfers, swapHistoryItem, swapBuildRequest.shouldTryDiesel);
  if (isErrorTransferResult(result)) {
    reportErrorTransferResult(result, updateCurrentSwap);
    setGlobal(updateCurrentSwap(getGlobal(), {
      shouldResetOnClose: true
    }));
    return;
  }
  setGlobal(updateCurrentSwap(getGlobal(), {
    activityId: result.activityId
  }));
});
addActionHandler('submitSwapCex', async (global, actions, _ref2) => {
  let {
    password
  } = _ref2;
  if (!(await prepareTransfer(0,
  // Swap isn't available for hardware accounts yet, so this argument value doesn't matter
  updateCurrentSwap, password))) {
    return;
  }
  global = getGlobal();
  setGlobal(updateCurrentSwap(global, {
    shouldResetOnClose: undefined
  }));
  const isMutlichainAccount = selectIsMultichainAccount(global, global.currentAccountId);
  const account = selectCurrentAccount(global);
  const supportedChains = getSupportedChains(global);
  const tokenIn = global.swapTokenInfo.bySlug[global.currentSwap.tokenInSlug];
  const tokenOut = global.swapTokenInfo.bySlug[global.currentSwap.tokenOutSlug];
  const shouldSendTonTransaction = tokenIn.chain === 'ton';
  const shouldSendTronTransaction = isMutlichainAccount && tokenIn.chain === 'tron';
  const shouldSendTransaction = shouldSendTonTransaction || shouldSendTronTransaction;
  const shouldSendTokenToExternalWallet = isMutlichainAccount ? supportedChains.includes(tokenIn.chain) : tokenIn.chain === 'ton';
  const tonAddress = account.addressByChain.ton;
  const toAddress = (account === null || account === void 0 ? void 0 : account.addressByChain[tokenOut.chain]) ?? global.currentSwap.toAddress;
  const swapBuildRequest = buildSwapBuildRequest(global);
  const swapTransactionRequest = {
    ...(0,iteratees/* pick */.Up)(swapBuildRequest, ['from', 'fromAmount', 'to', 'swapFee', 'networkFee']),
    fromAddress: tonAddress,
    toAddress
  };
  const swapItem = await (0,api/* callApi */.p)('swapCexCreateTransaction', global.currentAccountId, password, swapTransactionRequest);
  if (!handleTransferResult(swapItem, updateCurrentSwap)) {
    setGlobal(updateCurrentSwap(getGlobal(), {
      shouldResetOnClose: true
    }));
    return;
  }
  global = getGlobal();
  global = updateCurrentSwap(global, {
    state: shouldSendTokenToExternalWallet ? SwapState.Complete : SwapState.WaitTokens,
    activityId: swapItem.activity.id,
    payinAddress: swapItem.swap.cex.payinAddress,
    payoutAddress: swapItem.swap.cex.payoutAddress,
    payinExtraId: swapItem.swap.cex.payinExtraId,
    shouldResetOnClose: true
  });
  setGlobal(global);
  if (shouldSendTransaction) {
    const transferOptions = {
      password,
      accountId: global.currentAccountId,
      fee: (0,util_decimals/* fromDecimal */.UH)(swapItem.swap.networkFee, tokenIn.decimals),
      amount: (0,util_decimals/* fromDecimal */.UH)(swapItem.swap.fromAmount, tokenIn.decimals),
      toAddress: swapItem.swap.cex.payinAddress,
      tokenAddress: isMutlichainAccount ? tokenIn.tokenAddress : undefined
    };
    await (0,schedulers/* pause */.v7)(WAIT_FOR_CHANGELLY);
    let transferResult;
    if (shouldSendTonTransaction) {
      transferResult = await (0,api/* callApi */.p)('swapCexSubmit', 'ton', transferOptions, swapItem.swap.id);
    } else if (shouldSendTronTransaction) {
      transferResult = await (0,api/* callApi */.p)('swapCexSubmit', 'tron', transferOptions, swapItem.swap.id);
    }
    if (isErrorTransferResult(transferResult)) {
      reportErrorTransferResult(transferResult, updateCurrentSwap);
      setGlobal(updateCurrentSwap(getGlobal(), {
        shouldResetOnClose: true
      }));
      return;
    }
  }
});
addActionHandler('switchSwapTokens', global => {
  const {
    tokenInSlug,
    tokenOutSlug,
    amountIn,
    amountOut
  } = global.currentSwap;
  global = updateCurrentSwap(global, {
    isMaxAmount: false,
    amountIn: amountOut,
    amountOut: amountIn,
    tokenInSlug: tokenOutSlug,
    tokenOutSlug: tokenInSlug,
    inputSource: SwapInputSource.In
  });
  setGlobal(global);
});
addActionHandler('setSwapTokenIn', (global, actions, _ref3) => {
  let {
    tokenSlug: newTokenInSlug
  } = _ref3;
  const {
    amountIn,
    amountOut,
    tokenInSlug,
    tokenOutSlug
  } = global.currentSwap;
  const newTokenIn = global.swapTokenInfo.bySlug[newTokenInSlug];
  const adjustedAmountIn = amountIn ? (0,util_decimals/* roundDecimal */.QQ)(amountIn, newTokenIn.decimals) : amountIn;

  // Don't set the same token in both inputs
  const newTokenOutSlug = newTokenInSlug === tokenOutSlug ? tokenInSlug : tokenOutSlug;
  const newTokenOut = newTokenOutSlug ? global.swapTokenInfo.bySlug[newTokenOutSlug] : undefined;
  const adjustedAmountOut = amountOut && newTokenOut ? (0,util_decimals/* roundDecimal */.QQ)(amountOut, newTokenOut.decimals) : amountOut;
  global = updateCurrentSwap(global, {
    amountIn: adjustedAmountIn === '0' ? undefined : adjustedAmountIn,
    amountOut: adjustedAmountOut === '0' ? undefined : adjustedAmountOut,
    tokenInSlug: newTokenInSlug,
    tokenOutSlug: newTokenOutSlug
  });
  setGlobal(global);
});
addActionHandler('setSwapTokenOut', (global, actions, _ref4) => {
  let {
    tokenSlug: newTokenOutSlug
  } = _ref4;
  const {
    amountIn,
    amountOut,
    tokenInSlug,
    tokenOutSlug
  } = global.currentSwap;
  const newTokenOut = global.swapTokenInfo.bySlug[newTokenOutSlug];
  const adjustedAmountOut = amountOut ? (0,util_decimals/* roundDecimal */.QQ)(amountOut, newTokenOut.decimals) : amountOut;

  // Don't set the same token in both inputs
  const newTokenInSlug = newTokenOutSlug === tokenInSlug ? tokenOutSlug : tokenInSlug;
  const newTokenIn = newTokenInSlug ? global.swapTokenInfo.bySlug[newTokenInSlug] : undefined;
  const adjustedAmountIn = amountIn && newTokenIn ? (0,util_decimals/* roundDecimal */.QQ)(amountIn, newTokenIn.decimals) : amountIn;
  global = updateCurrentSwap(global, {
    amountOut: adjustedAmountOut === '0' ? undefined : adjustedAmountOut,
    amountIn: adjustedAmountIn === '0' ? undefined : adjustedAmountIn,
    tokenOutSlug: newTokenOutSlug,
    tokenInSlug: newTokenInSlug
  });
  setGlobal(global);
});
addActionHandler('setSwapAmountIn', (global, actions, _ref5) => {
  let {
    amount,
    isMaxAmount = false
  } = _ref5;
  global = updateCurrentSwap(global, {
    amountIn: amount,
    isMaxAmount,
    inputSource: SwapInputSource.In
  });
  setGlobal(global);
});
addActionHandler('setSwapAmountOut', (global, actions, _ref6) => {
  let {
    amount
  } = _ref6;
  global = updateCurrentSwap(global, {
    amountOut: amount,
    isMaxAmount: false,
    inputSource: SwapInputSource.Out
  });
  setGlobal(global);
});
addActionHandler('setSlippage', (global, actions, _ref7) => {
  let {
    slippage
  } = _ref7;
  return updateCurrentSwap(global, {
    slippage
  });
});
addActionHandler('estimateSwap', async () => {
  await estimateSwapConcurrently(async (global, shouldStop) => {
    const {
      tokenInSlug,
      tokenOutSlug
    } = global.currentSwap;
    const isTonOnlySwap = (tokenInSlug ? getIsTonToken(tokenInSlug, true) : true) && (tokenOutSlug ? getIsTonToken(tokenOutSlug, true) : true) && !!(tokenInSlug || tokenOutSlug);
    const shouldShowAllPairs = global.swapVersion === 3 && isTonOnlySwap;

    // Set shouldShowAllPairs for TON-only swaps
    if (shouldShowAllPairs !== Boolean(global.currentSwap.shouldShowAllPairs)) {
      global = updateCurrentSwap(global, {
        shouldShowAllPairs: shouldShowAllPairs || undefined
      });
      setGlobal(global);
    }
    if (tokenInSlug && !shouldShowAllPairs) {
      await loadSwapPairs(tokenInSlug);
      if (shouldStop()) return;
      global = getGlobal();
    }
    if (tokenInSlug && tokenOutSlug) {
      var _global$swapPairs;
      const isPairValid = ((_global$swapPairs = global.swapPairs) === null || _global$swapPairs === void 0 || (_global$swapPairs = _global$swapPairs.bySlug) === null || _global$swapPairs === void 0 || (_global$swapPairs = _global$swapPairs[tokenInSlug]) === null || _global$swapPairs === void 0 ? void 0 : _global$swapPairs[tokenOutSlug]) || shouldShowAllPairs;
      if (!isPairValid) {
        return {
          ...getSwapEstimateResetParams(global),
          errorType: SwapErrorType.InvalidPair
        };
      }
    }
    if (!isSwapFormFilled(global)) {
      return getSwapEstimateResetParams(global);
    }
    if (selectSwapType(global) === SwapType.OnChain) {
      return estimateDexSwap(global);
    } else {
      return estimateCexSwap(global, shouldStop);
    }
  });
});
async function estimateDexSwap(global) {
  const tokenIn = global.swapTokenInfo.bySlug[global.currentSwap.tokenInSlug];
  const tokenOut = global.swapTokenInfo.bySlug[global.currentSwap.tokenOutSlug];
  const nativeTokenIn = getChainConfig(getChainBySlug(tokenIn.slug)).nativeToken;
  const from = tokenIn.slug === src_config/* TONCOIN */.Tu9.slug ? tokenIn.symbol : tokenIn.tokenAddress;
  const to = tokenOut.slug === src_config/* TONCOIN */.Tu9.slug ? tokenOut.symbol : tokenOut.tokenAddress;
  const {
    fromAmount,
    isFromAmountMax
  } = processNativeMaxSwap(global);
  const toAmount = global.currentSwap.amountOut ?? '0';
  const fromAddress = selectCurrentAccount(global).addressByChain.ton;
  const estimateAmount = global.currentSwap.inputSource === SwapInputSource.In ? {
    fromAmount
  } : {
    toAmount
  };
  const toncoinBalance = selectCurrentToncoinBalance(global);
  const shouldTryDiesel = toncoinBalance < (0,util_decimals/* fromDecimal */.UH)(global.currentSwap.networkFee ?? '0', nativeTokenIn.decimals);
  const estimate = await (0,api/* callApi */.p)('swapEstimate', global.currentAccountId, {
    ...estimateAmount,
    from,
    to,
    slippage: global.currentSwap.slippage,
    fromAddress,
    shouldTryDiesel,
    isFromAmountMax,
    toncoinBalance: (0,util_decimals/* toDecimal */.nI)(toncoinBalance ?? 0n, src_config/* TONCOIN */.Tu9.decimals)
  });
  global = getGlobal();
  if (!estimate || 'error' in estimate) {
    const errorType = SERVER_ERRORS_MAP[estimate === null || estimate === void 0 ? void 0 : estimate.error] ?? SwapErrorType.UnexpectedError;
    return {
      ...getSwapEstimateResetParams(global),
      errorType
    };
  }
  const errorType = estimate.toAmount === '0' && shouldTryDiesel ? SwapErrorType.NotEnoughForFee : undefined;
  const estimates = buildSwapEstimates(estimate);
  const currentEstimate = chooseSwapEstimate(global, estimates, estimate.dexLabel);
  return {
    ...getSwapEstimateResetParams(global),
    ...(global.currentSwap.inputSource === SwapInputSource.In ? {
      amountOut: currentEstimate.toAmount
    } : {
      amountIn: currentEstimate.fromAmount
    }),
    ...(isFromAmountMax ? {
      amountIn: currentEstimate.fromAmount
    } : undefined),
    bestRateDexLabel: estimate.dexLabel,
    amountOutMin: currentEstimate.toMinAmount,
    priceImpact: currentEstimate.impact,
    errorType,
    dieselStatus: estimate.dieselStatus,
    estimates,
    currentDexLabel: currentEstimate.dexLabel,
    // Fees
    networkFee: currentEstimate.networkFee,
    realNetworkFee: currentEstimate.realNetworkFee,
    swapFee: currentEstimate.swapFee,
    swapFeePercent: currentEstimate.swapFeePercent,
    ourFee: currentEstimate.ourFee,
    ourFeePercent: estimate.ourFeePercent,
    dieselFee: currentEstimate.dieselFee
  };
}
async function estimateCexSwap(global, shouldStop) {
  var _global$accounts;
  const tokenIn = global.swapTokenInfo.bySlug[global.currentSwap.tokenInSlug];
  const tokenOut = global.swapTokenInfo.bySlug[global.currentSwap.tokenOutSlug];
  const from = resolveSwapAssetId(tokenIn);
  const to = resolveSwapAssetId(tokenOut);
  const fromAmount = global.currentSwap.amountIn ?? '0';
  const swapType = selectSwapType(global);
  const estimate = await (0,api/* callApi */.p)('swapCexEstimate', {
    fromAmount,
    from,
    to
  });
  if (shouldStop()) return undefined;
  global = getGlobal();
  if (!estimate) {
    return {
      ...getSwapEstimateResetParams(global),
      errorType: window.navigator.onLine ? SwapErrorType.InvalidPair : SwapErrorType.UnexpectedError
    };
  }
  if ('error' in estimate) {
    const {
      error
    } = estimate;
    if (error.includes('requests limit')) {
      return 'rateLimited';
    }
    return {
      ...getSwapEstimateResetParams(global),
      errorType: SwapErrorType.UnexpectedError
    };
  }
  const account = (_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.byId[global.currentAccountId];
  let networkFee;
  let realNetworkFee;
  if (swapType === SwapType.CrosschainFromWallet) {
    if (tokenIn.chain !== 'ton' && tokenIn.chain !== 'tron') {
      throw new Error(`Unexpected chain ${tokenIn.chain}`);
    }
    const toAddress = {
      ton: account.addressByChain.ton,
      tron: src_config/* TRX_SWAP_COUNT_FEE_ADDRESS */.jt9
    }[tokenIn.chain];
    const txDraft = await (0,api/* callApi */.p)('checkTransactionDraft', tokenIn.chain, {
      accountId: global.currentAccountId,
      toAddress,
      tokenAddress: tokenIn.tokenAddress
    });
    if (txDraft) {
      ({
        networkFee,
        realNetworkFee
      } = convertTransferFeesToSwapFees(txDraft, tokenIn.chain));
    }
  }
  let amountIn = estimate.fromAmount;

  // Auto-adjust amountIn for crosschain swaps when fee becomes known
  if (global.currentSwap.isMaxAmount && networkFee) {
    const tokenBalance = selectCurrentAccountTokenBalance(global, tokenIn.slug);
    const amountInBigint = tokenBalance - (0,util_decimals/* fromDecimal */.UH)(networkFee, tokenIn.decimals);
    amountIn = (0,util_decimals/* toDecimal */.nI)(amountInBigint, tokenIn.decimals);
  }
  return {
    ...getSwapEstimateResetParams(global),
    amountOut: estimate.toAmount === '0' ? undefined : estimate.toAmount,
    amountIn,
    limits: {
      fromMin: estimate.fromMin,
      fromMax: estimate.fromMax
    },
    swapFee: estimate.swapFee,
    networkFee,
    realNetworkFee,
    ourFee: '0',
    ourFeePercent: 0,
    dieselStatus: 'not-available',
    amountOutMin: estimate.toAmount,
    errorType: (0,big_js/* Big */.z)(fromAmount).lt(estimate.fromMin) ? SwapErrorType.ChangellyMinSwap : (0,big_js/* Big */.z)(fromAmount).gt(estimate.fromMax) ? SwapErrorType.ChangellyMaxSwap : undefined
  };
}
addActionHandler('setSwapScreen', (global, actions, _ref8) => {
  let {
    state
  } = _ref8;
  if (state === SwapState.Initial) {
    global = updateCurrentSwap(global, {
      swapId: (0,generateUniqueId/* default */.A)()
    });
  }
  global = updateCurrentSwap(global, {
    state
  });
  setGlobal(global);
});
addActionHandler('clearSwapError', global => {
  global = updateCurrentSwap(global, {
    error: undefined
  });
  setGlobal(global);
});
async function loadSwapPairs(tokenSlug) {
  var _global$swapPairs2;
  await (0,schedulers/* waitFor */.fm)(() => {
    const {
      swapTokenInfo: {
        isLoaded,
        bySlug
      }
    } = getGlobal();
    return !!(isLoaded || bySlug[tokenSlug]);
  }, 500, 100);
  let global = getGlobal();
  const tokenIn = global.swapTokenInfo.bySlug[tokenSlug];
  if (!tokenIn) {
    return;
  }
  const assetId = resolveSwapAssetId(tokenIn);
  const cache = pairsCache[tokenSlug];
  const isCacheValid = cache && Date.now() - cache.timestamp <= CACHE_DURATION;
  if (isCacheValid) {
    return;
  }
  const pairs = await (0,api/* callApi */.p)('swapGetPairs', assetId);
  global = getGlobal();
  let bySlug;
  if (pairs) {
    const isTonTokenIn = tokenIn.chain === 'ton';
    bySlug = pairs.reduce((acc, pair) => {
      const isTonTokenOut = getIsTonToken(pair.slug, true);
      const countTonTokens = Number(isTonTokenIn) + (isTonTokenOut ? 1 : 0);
      const isMultichain = !(countTonTokens === 2 || countTonTokens === 1 && [tokenIn.slug, pair.slug].includes(src_config/* TONCOIN */.Tu9.slug));
      acc[pair.slug] = {
        ...(isMultichain && {
          isMultichain
        }),
        ...(pair.isReverseProhibited && {
          isReverseProhibited: pair.isReverseProhibited
        })
      };
      return acc;
    }, {});
    pairsCache[tokenSlug] = {
      timestamp: Date.now()
    };
  } else {
    bySlug = {};
  }
  setGlobal({
    ...global,
    swapPairs: {
      bySlug: {
        ...((_global$swapPairs2 = global.swapPairs) === null || _global$swapPairs2 === void 0 ? void 0 : _global$swapPairs2.bySlug),
        [tokenSlug]: bySlug
      }
    }
  });
}
addActionHandler('setSwapCexAddress', (global, actions, _ref9) => {
  let {
    toAddress
  } = _ref9;
  global = updateCurrentSwap(global, {
    toAddress
  });
  setGlobal(global);
});
addActionHandler('updatePendingSwaps', async global => {
  const accountId = global.currentAccountId;
  if (!accountId) return;
  let {
    activities
  } = accounts_selectAccountState(global, accountId) ?? {};
  if (!activities) return;
  const ids = Object.values(activities.byId).filter(activity => Boolean(activity.kind === 'swap' && (activity.status === 'pending' || activity.status === 'pendingTrusted') && activity.cex)).map(_ref0 => {
    let {
      id
    } = _ref0;
    return parseTxId(id).hash;
  });
  if (!ids.length) return;
  const result = await (0,api/* callApi */.p)('fetchSwaps', accountId, ids);
  if (!(result !== null && result !== void 0 && result.swaps.length)) return;
  const {
    swaps,
    nonExistentIds
  } = result;
  global = getGlobal();
  if (global.currentAccountId !== accountId) return;
  ({
    activities
  } = accounts_selectAccountState(global, accountId) ?? {});
  for (const swap of result.swaps) {
    if (swap.isCanceled) {
      swap.shouldHide = true;
    }
  }
  const nonExistentSwaps = {};
  for (const id of nonExistentIds) {
    nonExistentSwaps[id] = {
      ...activities.byId[id],
      status: 'expired',
      shouldHide: true
    };
  }
  global = misc_updateAccountState(global, accountId, {
    activities: {
      ...activities,
      byId: {
        ...activities.byId,
        ...nonExistentSwaps,
        ...(0,iteratees/* buildCollectionByKey */.dU)(swaps, 'id')
      }
    }
  });
  setGlobal(global);
});
addActionHandler('setSwapDex', (global, actions, _ref1) => {
  let {
    dexLabel
  } = _ref1;
  const {
    estimates,
    bestRateDexLabel
  } = global.currentSwap;
  const newEstimate = (estimates || []).find(estimate => estimate.dexLabel === dexLabel);
  if (!newEstimate) return;
  global = updateCurrentSwap(global, {
    amountIn: newEstimate.fromAmount,
    amountOut: newEstimate.toAmount,
    amountOutMin: newEstimate.toMinAmount,
    networkFee: newEstimate.networkFee,
    realNetworkFee: newEstimate.realNetworkFee,
    swapFee: newEstimate.swapFee,
    swapFeePercent: newEstimate.swapFeePercent,
    ourFee: newEstimate.ourFee,
    dieselFee: newEstimate.dieselFee,
    priceImpact: newEstimate.impact,
    currentDexLabel: dexLabel,
    // The "Best Rate" selection should enable automatic best dex selection mode
    isDexLabelChanged: dexLabel !== bestRateDexLabel ? true : undefined
  }, true);
  setGlobal(global);
});
function convertTransferFeesToSwapFees(txDraft, chain) {
  const nativeToken = getNativeToken(chain);
  let networkFee;
  let realNetworkFee;
  if ((txDraft === null || txDraft === void 0 ? void 0 : txDraft.fee) !== undefined) {
    networkFee = (0,util_decimals/* toDecimal */.nI)(txDraft.fee, nativeToken.decimals);
  }
  if ((txDraft === null || txDraft === void 0 ? void 0 : txDraft.realFee) !== undefined) {
    realNetworkFee = (0,util_decimals/* toDecimal */.nI)(txDraft.realFee, nativeToken.decimals);
  }
  return {
    networkFee,
    realNetworkFee
  };
}
let isEstimatingSwap = false;

/**
 * A boilerplate of swap estimation, ensuring consistent behavior in concurrent usage scenarios.
 * This function is expected to be called periodically, and you may call it as often as you like.
 *
 * You may call the `shouldStop` function to check whether it makes sense to continue estimating (because the result
 * is likely to be ignored). If `shouldStop` returns true, `estimate` may return any value (it will be ignored).
 */
async function estimateSwapConcurrently(estimate) {
  const initialGlobal = getGlobal();
  if (shouldAvoidSwapEstimation(initialGlobal)) return;

  // There should be only 1 swap estimation at a time. A timer in SwapInitial will trigger another estimation attempt.
  if (isEstimatingSwap) {
    return;
  }
  try {
    isEstimatingSwap = true;
    const isEstimateInputIntact = isSwapEstimateInputEqual.bind(undefined, initialGlobal);
    const swapUpdate = await estimate(initialGlobal, () => {
      const currentGlobal = getGlobal();
      return shouldAvoidSwapEstimation(currentGlobal) || !isEstimateInputIntact(currentGlobal);
    });
    const finalGlobal = getGlobal();

    // If the dependencies were changed during the estimation, the estimation result should be ignored and the loading
    // indicator should stay (in order to avoid showing the outdated fee). A timer in SwapInitial will trigger another
    // estimation attempt to get the up-to-date fee.
    if (!isEstimateInputIntact(finalGlobal)) {
      return;
    }

    // If the swap estimation request has been rate-limited, we should keep showing the loading indicator
    if (swapUpdate === 'rateLimited') {
      return;
    }
    setGlobal(updateCurrentSwap(finalGlobal, {
      isEstimating: false,
      ...(shouldAvoidSwapEstimation(finalGlobal) ? undefined : swapUpdate)
    }));
  } finally {
    isEstimatingSwap = false;
  }
}
function chooseSwapEstimate(global, newEstimates, proposedBestDexLabel) {
  var _findChainConfig2;
  if (newEstimates.length === 0) {
    throw new Error('Unexpected empty `newEstimates` array');
  }
  const {
    tokenInSlug,
    currentDexLabel,
    isDexLabelChanged
  } = global.currentSwap;

  // If the user has chosen a Dex manually, respect that choice
  if (currentDexLabel && isDexLabelChanged) {
    const selectedEstimate = newEstimates.find(_ref10 => {
      let {
        dexLabel
      } = _ref10;
      return dexLabel === currentDexLabel;
    });
    if (selectedEstimate) {
      return selectedEstimate;
    }
  }

  // Otherwise, select automatically
  const tokenIn = tokenInSlug ? global.swapTokenInfo.bySlug[tokenInSlug] : undefined;
  const tokenInBalance = tokenInSlug ? selectCurrentAccountTokenBalance(global, tokenInSlug) : undefined;
  const nativeTokenIn = tokenInSlug ? (_findChainConfig2 = findChainConfig(getChainBySlug(tokenInSlug))) === null || _findChainConfig2 === void 0 ? void 0 : _findChainConfig2.nativeToken : undefined;
  const nativeTokenInBalance = nativeTokenIn && selectCurrentAccountTokenBalance(global, nativeTokenIn.slug);
  let availableEstimates = newEstimates.filter(variant => canAffordSwapEstimateVariant({
    variant,
    tokenIn,
    tokenInBalance,
    nativeTokenInBalance
  }));
  if (availableEstimates.length === 0) {
    availableEstimates = newEstimates;
  }
  return availableEstimates.find(_ref11 => {
    let {
      dexLabel
    } = _ref11;
    return dexLabel === proposedBestDexLabel;
  }) ?? availableEstimates[0];
}
;// ./src/global/actions/api/tokens.ts



addActionHandler('loadPriceHistory', async (global, actions, payload) => {
  const {
    slug,
    period,
    currency = global.settings.baseCurrency
  } = payload ?? {};
  const history = await (0,api/* callApi */.p)('fetchPriceHistory', slug, period, currency);
  if (!history) {
    return;
  }
  global = getGlobal();
  global = updateTokenPriceHistory(global, slug, {
    [period]: history
  });
  setGlobal(global);
});
;// ./src/util/scamDetection.ts

const SCAM_DOMAIN_ADDRESS_REGEX = /^\w{26,}\./;
function shouldShowSeedPhraseScamWarning(account, accountTokens, transferTokenChain) {
  var _account$isMultisigBy;
  // For multisig accounts a warning should always be shown
  if (account !== null && account !== void 0 && (_account$isMultisigBy = account.isMultisigByChain) !== null && _account$isMultisigBy !== void 0 && _account$isMultisigBy[transferTokenChain]) {
    return true;
  }

  // Only show when trying to transfer TRON tokens
  if (transferTokenChain !== 'tron') {
    return false;
  }

  // Check if account has TRON tokens (like USDT)
  return accountTokens.some(token => token.slug === src_config/* TRC20_USDT_MAINNET_SLUG */.QSz || token.chain === 'tron' && token.amount > 0n && token.slug !== src_config/* TRX */.X7T.slug);
}
function shouldShowDomainScamWarning(address) {
  return SCAM_DOMAIN_ADDRESS_REGEX.test(address);
}
;// ./src/global/actions/api/transfer.ts
















addActionHandler('submitTransferInitial', async (global, actions, payload) => {
  if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
    callActionInNative('submitTransferInitial', payload);
    return;
  }
  const {
    tokenSlug,
    toAddress,
    amount,
    comment,
    shouldEncrypt,
    nfts,
    withDiesel,
    stateInit,
    isGaslessWithStars,
    binPayload
  } = payload;
  setGlobal(updateCurrentTransferLoading(global, true));
  const isNftTransfer = Boolean(nfts === null || nfts === void 0 ? void 0 : nfts.length);
  let result;
  if (isNftTransfer) {
    result = await (0,api/* callApi */.p)('checkNftTransferDraft', {
      accountId: global.currentAccountId,
      nfts,
      toAddress,
      comment
    });
  } else {
    const {
      tokenAddress,
      chain
    } = selectToken(global, tokenSlug);
    result = await (0,api/* callApi */.p)('checkTransactionDraft', chain, {
      accountId: global.currentAccountId,
      tokenAddress,
      toAddress,
      amount,
      data: binPayload ?? comment,
      shouldEncrypt,
      stateInit,
      isBase64Data: Boolean(binPayload),
      allowGasless: true
    });
  }
  global = getGlobal();
  global = updateCurrentTransferLoading(global, false);
  if (result) {
    global = updateCurrentTransferByCheckResult(global, result);
  }
  if (!result || 'error' in result) {
    var _result;
    setGlobal(global);
    if (((_result = result) === null || _result === void 0 ? void 0 : _result.error) === types/* ApiTransactionDraftError */.KL.InsufficientBalance && !isNftTransfer) {
      actions.showDialog({
        message: 'The network fee has slightly changed, try sending again.'
      });
    } else {
      var _result2;
      actions.showError({
        error: (_result2 = result) === null || _result2 === void 0 ? void 0 : _result2.error
      });
    }
    return;
  }
  setGlobal(updateCurrentTransfer(global, {
    state: TransferState.Confirm,
    error: undefined,
    toAddress,
    resolvedAddress: result.resolvedAddress,
    amount,
    comment,
    shouldEncrypt,
    tokenSlug,
    isToNewAddress: result.isToAddressNew,
    withDiesel,
    isGaslessWithStars
  }));
});
addActionHandler('fetchTransferFee', async (global, actions, payload) => {
  var _global$currentTransf;
  global = updateCurrentTransfer(global, {
    isLoading: true,
    error: undefined
  });
  setGlobal(global);
  const {
    tokenSlug,
    toAddress,
    comment,
    shouldEncrypt,
    binPayload,
    stateInit
  } = payload;
  const {
    tokenAddress,
    chain
  } = selectToken(global, tokenSlug);
  const result = await (0,api/* callApi */.p)('checkTransactionDraft', chain, {
    accountId: global.currentAccountId,
    toAddress,
    data: binPayload ?? comment,
    tokenAddress,
    shouldEncrypt,
    isBase64Data: Boolean(binPayload),
    stateInit,
    allowGasless: true
  });
  global = getGlobal();
  if (tokenSlug !== global.currentTransfer.tokenSlug || (_global$currentTransf = global.currentTransfer.nfts) !== null && _global$currentTransf !== void 0 && _global$currentTransf.length) {
    // For cases when the user switches the token before the result arrives
    return;
  }
  global = updateCurrentTransfer(global, {
    isLoading: false
  });
  if (result) {
    global = updateCurrentTransferByCheckResult(global, result);
  }
  setGlobal(global);
  if (result !== null && result !== void 0 && result.error && result.error !== types/* ApiTransactionDraftError */.KL.InsufficientBalance) {
    actions.showError({
      error: result.error
    });
  }
  if ((result === null || result === void 0 ? void 0 : result.error) === types/* ApiTransactionDraftError */.KL.InsufficientBalance) {
    const currentAccount = selectCurrentAccount(global);
    const accountTokens = selectCurrentAccountTokens(global);
    const {
      chain
    } = selectToken(global, tokenSlug);
    if (shouldShowSeedPhraseScamWarning(currentAccount, accountTokens, chain)) {
      global = getGlobal();
      global = updateCurrentTransfer(global, {
        scamWarningType: ScamWarningType.SeedPhrase
      });
      setGlobal(global);
    }
  }
  if ((result === null || result === void 0 ? void 0 : result.error) !== types/* ApiTransactionDraftError */.KL.DomainNotResolved && shouldShowDomainScamWarning(toAddress)) {
    global = getGlobal();
    global = updateCurrentTransfer(global, {
      scamWarningType: ScamWarningType.DomainLike
    });
    setGlobal(global);
  }
});
addActionHandler('fetchNftFee', async (global, actions, payload) => {
  var _global$currentTransf2;
  const {
    toAddress,
    nfts,
    comment
  } = payload;
  global = updateCurrentTransfer(global, {
    isLoading: true,
    error: undefined
  });
  setGlobal(global);
  const result = await (0,api/* callApi */.p)('checkNftTransferDraft', {
    accountId: global.currentAccountId,
    nfts,
    toAddress,
    comment
  });
  global = getGlobal();
  if (!((_global$currentTransf2 = global.currentTransfer.nfts) !== null && _global$currentTransf2 !== void 0 && _global$currentTransf2.length)) {
    // For cases when the user switches the token transfer mode before the result arrives
    return;
  }
  global = updateCurrentTransfer(global, {
    isLoading: false
  });
  if (result) {
    global = updateCurrentTransferByCheckResult(global, result);
  }
  if (shouldShowDomainScamWarning(toAddress)) {
    global = updateCurrentTransfer(global, {
      scamWarningType: ScamWarningType.DomainLike
    });
  }
  setGlobal(global);
  if (result !== null && result !== void 0 && result.error) {
    actions.showError({
      error: (result === null || result === void 0 ? void 0 : result.error) === types/* ApiTransactionDraftError */.KL.InsufficientBalance ? 'Insufficient TON for fee.' : result.error
    });
  }
});
addActionHandler('submitTransfer', async function (global, actions) {
  var _explainedFee$fullFee, _explainedFee$realFee;
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    resolvedAddress,
    comment,
    amount,
    promiseId,
    tokenSlug,
    shouldEncrypt,
    binPayload,
    nfts,
    withDiesel,
    diesel,
    stateInit,
    isGaslessWithStars
  } = global.currentTransfer;
  if (!(await prepareTransfer(TransferState.ConfirmHardware, updateCurrentTransfer, password))) {
    return;
  }

  // This is a part of the legacy dapp transaction mechanism. See `promiseId` in `src/global/types.ts` for more details.
  if (promiseId) {
    await (0,api/* callApi */.p)('confirmDappRequest', promiseId, password);
    return;
  }
  global = getGlobal();
  const explainedFee = explainApiTransferFee(global.currentTransfer);
  const fullNativeFee = (_explainedFee$fullFee = explainedFee.fullFee) === null || _explainedFee$fullFee === void 0 ? void 0 : _explainedFee$fullFee.nativeSum;
  const realNativeFee = (_explainedFee$realFee = explainedFee.realFee) === null || _explainedFee$realFee === void 0 ? void 0 : _explainedFee$realFee.nativeSum;
  let result;
  if (nfts !== null && nfts !== void 0 && nfts.length) {
    const chunks = (0,iteratees/* split */.lD)(nfts, selectIsHardwareAccount(global) ? 1 : src_config/* NFT_BATCH_SIZE */.gR8);
    for (const chunk of chunks) {
      const batchResult = await (0,api/* callApi */.p)('submitNftTransfers', global.currentAccountId, password, chunk, resolvedAddress, comment, realNativeFee && (0,bigint/* bigintDivideToNumber */.fC)(realNativeFee, nfts.length / chunk.length));
      global = getGlobal();
      global = updateCurrentTransfer(global, {
        sentNftsCount: (global.currentTransfer.sentNftsCount || 0) + chunk.length
      });
      setGlobal(global);
      // TODO - process all responses from the API
      result = batchResult;
    }
  } else {
    const {
      tokenAddress,
      chain
    } = selectToken(global, tokenSlug);
    const options = {
      accountId: global.currentAccountId,
      password,
      toAddress: resolvedAddress,
      amount: amount,
      comment: binPayload ?? comment,
      tokenAddress,
      fee: fullNativeFee,
      realFee: realNativeFee,
      shouldEncrypt,
      isBase64Data: Boolean(binPayload),
      withDiesel,
      dieselAmount: diesel && getDieselTokenAmount(diesel),
      stateInit,
      isGaslessWithStars,
      noFeeCheck: true
    };
    result = await (0,api/* callApi */.p)('submitTransfer', chain, options);
  }
  if (!handleTransferResult(result, updateCurrentTransfer)) {
    return;
  }
  setGlobal(updateCurrentTransfer(getGlobal(), {
    state: TransferState.Complete,
    txId: 'activityIds' in result && result.activityIds[0] || 'activityId' in result && result.activityId || undefined
  }));
  if (getIsTonToken(tokenSlug)) {
    actions.fetchTransferDieselState({
      tokenSlug
    });
  }
});
addActionHandler('cancelTransfer', function (global, actions) {
  let {
    shouldReset
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    promiseId,
    tokenSlug
  } = global.currentTransfer;
  if (shouldReset) {
    if (promiseId) {
      void (0,api/* callApi */.p)('cancelDappRequest', promiseId, 'Canceled by the user');
    }
    global = clearCurrentTransfer(global);
    global = updateCurrentTransfer(global, {
      tokenSlug
    });
    setGlobal(global);
    return;
  }
  if (getDoesUsePinPad()) {
    global = clearIsPinAccepted(global);
  }
  global = updateCurrentTransfer(global, {
    state: TransferState.None
  });
  setGlobal(global);
});
addActionHandler('fetchTransferDieselState', async (global, actions, _ref) => {
  let {
    tokenSlug
  } = _ref;
  const tokenAddress = selectTokenAddress(global, tokenSlug);
  if (!tokenAddress) return;
  const diesel = await (0,api/* callApi */.p)('fetchEstimateDiesel', global.currentAccountId, tokenAddress);
  if (!diesel) return;
  global = getGlobal();
  const accountState = accounts_selectAccountState(global, global.currentAccountId);
  global = preserveMaxTransferAmount(global, updateCurrentTransfer(global, {
    diesel
  }));
  if (accountState !== null && accountState !== void 0 && accountState.isDieselAuthorizationStarted && diesel.status !== 'not-authorized') {
    global = misc_updateAccountState(global, global.currentAccountId, {
      isDieselAuthorizationStarted: undefined
    });
  }
  setGlobal(global);
});
addActionHandler('checkTransferAddress', async (global, actions, _ref2) => {
  let {
    address
  } = _ref2;
  if (!address) {
    global = updateCurrentTransfer(global, {
      toAddressName: undefined,
      resolvedAddress: undefined
    });
    setGlobal(global);
    return;
  }
  const network = selectCurrentNetwork(global);
  const result = await (0,api/* callApi */.p)('getAddressInfo', network, address);
  global = getGlobal();
  if (!result || 'error' in result) {
    global = updateCurrentTransfer(global, {
      toAddressName: undefined,
      resolvedAddress: undefined
    });
  } else {
    global = updateCurrentTransfer(global, {
      toAddressName: result.addressName,
      resolvedAddress: result.resolvedAddress
    });
  }
  setGlobal(global);
});
;// ./src/global/actions/api/nfts.ts








const NBS_INIT_TIMEOUT = windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI ? 100 : 0;
addActionHandler('fetchNftsFromCollection', (global, actions, _ref) => {
  let {
    collectionAddress
  } = _ref;
  void (0,api/* callApi */.p)('fetchNftsFromCollection', global.currentAccountId, collectionAddress);
});
addActionHandler('burnNfts', (global, actions, _ref2) => {
  let {
    nfts
  } = _ref2;
  actions.startTransfer({
    isPortrait: getIsPortrait(),
    nfts
  });
  const isNotcoinVouchers = nfts.some(n => n.collectionAddress === src_config/* NOTCOIN_VOUCHERS_ADDRESS */.KmP);
  setTimeout(() => {
    actions.submitTransferInitial({
      tokenSlug: src_config/* TONCOIN */.Tu9.slug,
      amount: 0n,
      toAddress: isNotcoinVouchers ? src_config/* NOTCOIN_EXCHANGERS */.WVU[0] : src_config/* BURN_ADDRESS */.pV9,
      nfts
    });
  }, NBS_INIT_TIMEOUT);
});
addActionHandler('addNftsToBlacklist', (global, actions, _ref3) => {
  let {
    addresses: nftAddresses
  } = _ref3;
  // Force hide NFT - remove it from whitelist and add to blacklist
  let {
    blacklistedNftAddresses = [],
    whitelistedNftAddresses = []
  } = selectCurrentAccountState(global) || {};
  blacklistedNftAddresses = (0,iteratees/* findDifference */.Hl)(blacklistedNftAddresses, nftAddresses);
  whitelistedNftAddresses = (0,iteratees/* findDifference */.Hl)(whitelistedNftAddresses, nftAddresses);
  return updateCurrentAccountState(global, {
    blacklistedNftAddresses: [...blacklistedNftAddresses, ...nftAddresses],
    whitelistedNftAddresses
  });
});
addActionHandler('addNftsToWhitelist', (global, actions, _ref4) => {
  let {
    addresses: nftAddresses
  } = _ref4;
  // Force show NFT - remove it from blacklist and add to whitelist
  let {
    blacklistedNftAddresses = [],
    whitelistedNftAddresses = []
  } = selectCurrentAccountState(global) || {};
  blacklistedNftAddresses = (0,iteratees/* findDifference */.Hl)(blacklistedNftAddresses, nftAddresses);
  whitelistedNftAddresses = (0,iteratees/* findDifference */.Hl)(whitelistedNftAddresses, nftAddresses);
  return updateCurrentAccountState(global, {
    blacklistedNftAddresses,
    whitelistedNftAddresses: [...whitelistedNftAddresses, ...nftAddresses]
  });
});
addActionHandler('removeNftSpecialStatus', (global, actions, _ref5) => {
  let {
    address: nftAddress
  } = _ref5;
  // Stop forcing to show/hide NFT if it was in whitelist/blacklist
  let {
    blacklistedNftAddresses = [],
    whitelistedNftAddresses = []
  } = selectCurrentAccountState(global) || {};
  blacklistedNftAddresses = blacklistedNftAddresses.filter(address => address !== nftAddress);
  whitelistedNftAddresses = whitelistedNftAddresses.filter(address => address !== nftAddress);
  return updateCurrentAccountState(global, {
    blacklistedNftAddresses,
    whitelistedNftAddresses
  });
});
addActionHandler('openUnhideNftModal', (global, actions, _ref6) => {
  let {
    address,
    name
  } = _ref6;
  return updateCurrentAccountState(global, {
    isUnhideNftModalOpen: true,
    selectedNftToUnhide: {
      address,
      name
    }
  });
});
addActionHandler('closeUnhideNftModal', global => {
  return updateCurrentAccountState(global, {
    isUnhideNftModalOpen: undefined,
    selectedNftToUnhide: undefined
  });
});
addActionHandler('openHideNftModal', (global, actions, _ref7) => {
  let {
    addresses,
    isCollection
  } = _ref7;
  return updateCurrentAccountState(global, {
    selectedNftsToHide: {
      addresses,
      isCollection
    }
  });
});
addActionHandler('closeHideNftModal', global => {
  return updateCurrentAccountState(global, {
    selectedNftsToHide: undefined
  });
});
addActionHandler('openNftAttributesModal', (global, actions, _ref8) => {
  let {
    nft
  } = _ref8;
  return updateCurrentAccountState(global, {
    currentNftForAttributes: nft
  });
});
addActionHandler('closeNftAttributesModal', global => {
  return updateCurrentAccountState(global, {
    currentNftForAttributes: undefined
  });
});
;// ./src/global/actions/api/vesting.ts










addActionHandler('submitClaimingVesting', async function (global, actions) {
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const accountId = global.currentAccountId;
  const updateVestingState = (global, update) => {
    return updateVesting(global, accountId, update);
  };
  if (!(await prepareTransfer(VestingUnfreezeState.ConfirmHardware, updateVestingState, password))) {
    return;
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('submitClaimingVesting', {
      password
    });
    return;
  }
  global = getGlobal();
  const unfreezeRequestedIds = selectVestingPartsReadyToUnfreeze(global, accountId);
  const options = {
    accountId: global.currentAccountId,
    password,
    toAddress: src_config/* CLAIM_ADDRESS */.OKZ,
    amount: src_config/* CLAIM_AMOUNT */.aEZ,
    comment: src_config/* CLAIM_COMMENT */.ZYg
  };
  const result = await (0,api/* callApi */.p)('submitTransfer', 'ton', options);
  if (!handleTransferResult(result, updateVestingState)) {
    return;
  }
  global = getGlobal();
  global = updateVesting(global, accountId, {
    isConfirmRequested: undefined,
    unfreezeRequestedIds
  });
  setGlobal(global);
  actions.openVestingModal();
});
addActionHandler('loadMycoin', (global, actions) => {
  const {
    isTestnet
  } = global.settings;
  actions.importToken({
    address: isTestnet ? src_config/* MYCOIN_TESTNET */.GX2.minterAddress : src_config/* MYCOIN */.oUU.minterAddress
  });
});
;// ./src/global/actions/api/cards.ts









addActionHandler('submitMintCard', async function (global, actions) {
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const accountId = global.currentAccountId;
  if (!(await prepareTransfer(MintCardState.ConfirmHardware, updateMintCards, password))) {
    return;
  }
  const options = createTransferOptions(getGlobal(), password);
  const result = await (0,api/* callApi */.p)('submitTransfer', 'ton', options);
  if (!handleTransferResult(result, updateMintCards)) {
    return;
  }
  global = getGlobal();
  global = updateMintCards(global, {
    state: MintCardState.Done
  });
  global = misc_updateAccountState(global, accountId, {
    isCardMinting: true
  });
  setGlobal(global);
});
function createTransferOptions(globalState, password) {
  const {
    currentAccountId,
    currentMintCard
  } = globalState;
  const {
    config
  } = accounts_selectAccountState(globalState, currentAccountId);
  const {
    cardsInfo
  } = config;
  const type = currentMintCard.type;
  const cardInfo = cardsInfo[type];
  return {
    accountId: currentAccountId,
    password,
    toAddress: src_config/* MINT_CARD_ADDRESS */.lnc,
    amount: (0,util_decimals/* fromDecimal */.UH)(cardInfo.price, src_config/* TONCOIN */.Tu9.decimals),
    comment: src_config/* MINT_CARD_COMMENT */.sml
  };
}
addActionHandler('checkCardNftOwnership', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA || src_config/* IS_CORE_WALLET */.TI6) return;
  const {
    byAccountId
  } = global.settings;
  Object.entries(byAccountId).forEach(async _ref => {
    var _settings$cardBackgro, _settings$accentColor;
    let [accountId, settings] = _ref;
    const cardBackgroundNftAddress = (_settings$cardBackgro = settings.cardBackgroundNft) === null || _settings$cardBackgro === void 0 ? void 0 : _settings$cardBackgro.address;
    const accentColorNftAddress = (_settings$accentColor = settings.accentColorNft) === null || _settings$accentColor === void 0 ? void 0 : _settings$accentColor.address;
    if (!cardBackgroundNftAddress && !accentColorNftAddress) return;
    const promises = [cardBackgroundNftAddress ? (0,api/* callApi */.p)('checkNftOwnership', accountId, cardBackgroundNftAddress) : undefined, accentColorNftAddress && accentColorNftAddress !== cardBackgroundNftAddress ? (0,api/* callApi */.p)('checkNftOwnership', accountId, accentColorNftAddress) : undefined];
    const [isCardBackgroundNftOwned, isAccentColorNftOwned] = await Promise.all(promises);
    let newGlobal = getGlobal();
    if (cardBackgroundNftAddress && isCardBackgroundNftOwned === false) {
      newGlobal = updateAccountSettings(newGlobal, accountId, {
        cardBackgroundNft: undefined
      });
    }
    if (accentColorNftAddress && (accentColorNftAddress === cardBackgroundNftAddress && isCardBackgroundNftOwned === false || accentColorNftAddress !== cardBackgroundNftAddress && isAccentColorNftOwned === false)) {
      newGlobal = updateAccountSettings(newGlobal, accountId, {
        accentColorNft: undefined,
        accentColorIndex: undefined
      });
    }
    setGlobal(newGlobal);
  });
});
// EXTERNAL MODULE: ./src/util/Deferred.ts
var src_Deferred = __webpack_require__(9705);
;// ./src/util/createAbortableFunction.ts

function createAbortableFunction(toReturnOnAbort, fn) {
  let abort = new src_Deferred/* default */.A();
  return function abortableFunction() {
    abort.resolve(toReturnOnAbort);
    abort = new src_Deferred/* default */.A();
    return Promise.race([fn(...arguments), abort.promise]);
  };
}
;// ./src/global/reducers/notifications.ts
function deleteNotificationAccount(global, accountId) {
  const currentEnabledAccounts = global.pushNotifications.enabledAccounts;
  const {
    [accountId]: deleted,
    ...newEnabledAccounts
  } = currentEnabledAccounts;
  return {
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      enabledAccounts: newEnabledAccounts
    }
  };
}
function deleteAllNotificationAccounts(global) {
  return {
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      enabledAccounts: {}
    }
  };
}
function createNotificationAccount(global, accountId) {
  let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const currentEnabledAccounts = global.pushNotifications.enabledAccounts;
  const newEnabledAccounts = {
    ...currentEnabledAccounts,
    [accountId]: value
  };
  return {
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      enabledAccounts: newEnabledAccounts
    }
  };
}
function updateNotificationAccount(global, accountId, value) {
  const newEnabledAccounts = global.pushNotifications.enabledAccounts;
  newEnabledAccounts[accountId] = {
    ...newEnabledAccounts[accountId],
    ...value
  };
  return {
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      enabledAccounts: newEnabledAccounts
    }
  };
}
;// ./src/global/actions/api/notifications.ts








const abortableSubscribeNotifications = createAbortableFunction({
  aborted: true
}, request => {
  return (0,api/* callApi */.p)('subscribeNotifications', request);
});
const abortableUnsubscribeNotifications = createAbortableFunction({
  aborted: true
}, request => {
  return (0,api/* callApi */.p)('unsubscribeNotifications', request);
});
addActionHandler('registerNotifications', async (global, actions, _ref) => {
  let {
    userToken,
    platform
  } = _ref;
  const {
    pushNotifications
  } = global;
  let createResult;
  let enabledAccounts = Object.keys(pushNotifications.enabledAccounts);
  const accounts = selectAccounts(global) || {};
  if (!pushNotifications.userToken && !isEmptyObject(accounts)) {
    const notificationAddresses = selectNotificationTonAddressesSlow(global, Object.keys(accounts), src_config/* MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT */.vdF);
    enabledAccounts = Object.keys(notificationAddresses);
    createResult = await (0,api/* callApi */.p)('subscribeNotifications', {
      userToken,
      platform,
      addresses: Object.values(notificationAddresses)
    });
  } else if (pushNotifications.userToken !== userToken && enabledAccounts.length) {
    [createResult] = await Promise.all([(0,api/* callApi */.p)('subscribeNotifications', {
      userToken,
      platform,
      addresses: Object.values(selectNotificationTonAddressesSlow(global, enabledAccounts))
    }), (0,api/* callApi */.p)('unsubscribeNotifications', {
      userToken: pushNotifications.userToken,
      addresses: Object.values(selectNotificationTonAddressesSlow(global, enabledAccounts))
    })]);
  }
  global = getGlobal();
  global = {
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      userToken,
      platform
    }
  };
  if (!createResult || 'error' in createResult) {
    setGlobal(global);
    return;
  }
  const newEnabledAccounts = enabledAccounts.reduce((acc, accountId) => {
    const tonAddress = accounts[accountId].addressByChain.ton;
    if (tonAddress) {
      acc[accountId] = createResult.addressKeys[tonAddress];
    }
    return acc;
  }, {});
  setGlobal({
    ...global,
    pushNotifications: {
      ...global.pushNotifications,
      enabledAccounts: newEnabledAccounts
    }
  });
});
addActionHandler('deleteNotificationAccount', async (global, actions, _ref2) => {
  let {
    accountId,
    withAbort
  } = _ref2;
  const {
    userToken,
    enabledAccounts
  } = global.pushNotifications;
  const pushNotificationsAccount = enabledAccounts[accountId];
  if (!userToken) {
    return;
  }
  setGlobal(deleteNotificationAccount(global, accountId));
  const addresses = Object.values(selectNotificationTonAddressesSlow(global, [accountId]));
  if (addresses.length === 0) {
    return;
  }
  const props = {
    userToken,
    addresses
  };
  const result = withAbort ? await abortableUnsubscribeNotifications(props) : await (0,api/* callApi */.p)('unsubscribeNotifications', props);
  if (result && 'aborted' in result) {
    return;
  }
  global = getGlobal();
  if (!result || !('ok' in result)) {
    setGlobal(createNotificationAccount(global, accountId, pushNotificationsAccount));
    return;
  }
  setGlobal(deleteNotificationAccount(global, accountId));
});
addActionHandler('createNotificationAccount', async (global, actions, _ref3) => {
  let {
    accountId,
    withAbort
  } = _ref3;
  const {
    userToken,
    platform
  } = global.pushNotifications;
  if (!userToken || !platform) {
    return;
  }
  const addresses = Object.values(selectNotificationTonAddressesSlow(global, [accountId]));
  if (!addresses.length) {
    return;
  }
  setGlobal(createNotificationAccount(global, accountId, {}));
  const props = {
    userToken,
    platform,
    addresses
  };
  const result = withAbort ? await abortableSubscribeNotifications(props) : await (0,api/* callApi */.p)('subscribeNotifications', props);
  if (result && 'aborted' in result) {
    return;
  }
  global = getGlobal();
  if (!result || !('ok' in result)) {
    setGlobal(deleteNotificationAccount(global, accountId));
    return;
  }
  setGlobal(updateNotificationAccount(global, accountId, result.addressKeys[addresses[0].address]));
});
addActionHandler('toggleNotifications', async (global, actions, _ref4) => {
  let {
    isEnabled
  } = _ref4;
  const {
    enabledAccounts = {},
    userToken = '',
    platform,
    isAvailable
  } = global.pushNotifications;
  if (!isAvailable) {
    return;
  }
  let notificationAccounts;
  if (isEnabled) {
    notificationAccounts = selectNotificationTonAddressesSlow(global, Object.keys(selectAccounts(global) || {}), src_config/* MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT */.vdF);
    for (const newAccountId of Object.keys(notificationAccounts)) {
      global = createNotificationAccount(global, newAccountId, {});
    }
  } else {
    notificationAccounts = selectNotificationTonAddressesSlow(global, Object.keys(enabledAccounts));
    global = deleteAllNotificationAccounts(global);
  }
  setGlobal(global);
  if (isEmptyObject(notificationAccounts)) {
    return;
  }
  const props = {
    userToken,
    addresses: Object.values(notificationAccounts),
    platform: platform
  };
  const result = isEnabled ? await abortableSubscribeNotifications(props) : await abortableUnsubscribeNotifications(props);
  if (result && 'aborted' in result) {
    return;
  }
  global = getGlobal();
  if (!result || !('ok' in result)) {
    if (isEnabled) {
      global = deleteAllNotificationAccounts(global);
    } else {
      for (const accountId of Object.keys(notificationAccounts)) {
        global = createNotificationAccount(global, accountId, enabledAccounts[accountId]);
      }
    }
    setGlobal(global);
    return;
  }
  if (isEnabled && 'addressKeys' in result) {
    const addressKeys = result.addressKeys;
    for (const [accountId, {
      address
    }] of Object.entries(notificationAccounts)) {
      if (addressKeys[address]) {
        global = createNotificationAccount(global, accountId, addressKeys[address]);
      }
    }
  }
  setGlobal(global);
});
;// ./src/global/actions/api/activity.ts




addActionHandler('fetchActivityDetails', async (global, actions, _ref) => {
  var _selectAccountState;
  let {
    id
  } = _ref;
  const accountId = global.currentAccountId;
  const activity = (_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 || (_selectAccountState = _selectAccountState.activities) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.byId[id];
  if (!(activity !== null && activity !== void 0 && activity.shouldLoadDetails)) {
    return;
  }
  const newActivity = await (0,api/* callApi */.p)('fetchTonActivityDetails', accountId, activity);
  if (!newActivity) {
    return;
  }
  global = updateActivity(getGlobal(), accountId, newActivity);
  setGlobal(global);
});
;// ./src/global/actions/api/domains.ts






function handleDomainOperationResult(results, updateState, state) {
  if (!handleTransferResults(results, updateState)) {
    return;
  }
  setGlobal(updateState(getGlobal(), {
    state,
    ...(results.length === 1 ? {
      txId: results[0]
    } : undefined)
  }));
}
addActionHandler('checkDomainsRenewalDraft', async (global, actions, _ref) => {
  let {
    nfts
  } = _ref;
  const accountId = global.currentAccountId;
  const result = await (0,api/* callApi */.p)('checkDnsRenewalDraft', accountId, nfts);
  if (!result || 'error' in result) {
    actions.showError({
      error: result === null || result === void 0 ? void 0 : result.error
    });
    return;
  }
  global = getGlobal();
  global = updateCurrentDomainRenewal(global, {
    realFee: result.realFee
  });
  setGlobal(global);
});
addActionHandler('submitDomainsRenewal', async function (global, actions) {
  var _selectCurrentAccount;
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const accountId = global.currentAccountId;
  const nftsByAddress = (_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 || (_selectCurrentAccount = _selectCurrentAccount.nfts) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.byAddress;
  if (!nftsByAddress) return;
  const nftAddresses = global.currentDomainRenewal.addresses;
  const realFee = global.currentDomainRenewal.realFee;
  const nfts = nftAddresses.map(address => nftsByAddress[address]).filter(Boolean);
  if (!nfts.length) return;
  if (!(await prepareTransfer(DomainRenewalState.ConfirmHardware, updateCurrentDomainRenewal, password))) {
    return;
  }
  const result = (await (0,api/* callApi */.p)('submitDnsRenewal', accountId, password, nfts, realFee)) ?? [undefined];
  handleDomainOperationResult(result.map(subResult => subResult && 'activityIds' in subResult ? subResult.activityIds[0] : subResult), updateCurrentDomainRenewal, DomainRenewalState.Complete);
});
addActionHandler('checkDomainLinkingDraft', async (global, actions, _ref2) => {
  let {
    nft
  } = _ref2;
  const accountId = global.currentAccountId;
  const currentAddress = selectCurrentAccount(global).addressByChain.ton;
  const result = await (0,api/* callApi */.p)('checkDnsChangeWalletDraft', accountId, nft, currentAddress);
  if (!result || 'error' in result) {
    actions.showError({
      error: result === null || result === void 0 ? void 0 : result.error
    });
    return;
  }
  global = getGlobal();
  global = updateCurrentDomainLinking(global, {
    realFee: result.realFee
  });
  setGlobal(global);
});
addActionHandler('submitDomainLinking', async function (global, actions) {
  var _selectCurrentAccount2;
  let {
    password
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const accountId = global.currentAccountId;
  const network = selectCurrentNetwork(global);
  const nftsByAddress = (_selectCurrentAccount2 = selectCurrentAccountState(global)) === null || _selectCurrentAccount2 === void 0 || (_selectCurrentAccount2 = _selectCurrentAccount2.nfts) === null || _selectCurrentAccount2 === void 0 ? void 0 : _selectCurrentAccount2.byAddress;
  const nftAddress = global.currentDomainLinking.address;
  const realFee = global.currentDomainLinking.realFee;
  const nft = nftsByAddress === null || nftsByAddress === void 0 ? void 0 : nftsByAddress[nftAddress];
  const currentAddress = global.currentDomainLinking.walletAddress;
  const checkAddressResult = await (0,api/* callApi */.p)('getAddressInfo', network, currentAddress);
  if (checkAddressResult && 'error' in checkAddressResult) {
    actions.showError({
      error: checkAddressResult.error
    });
    return;
  }
  if (!nft || !checkAddressResult || 'resolvedAddress' in checkAddressResult && !checkAddressResult.resolvedAddress) return;
  if (!(await prepareTransfer(DomainLinkingState.ConfirmHardware, updateCurrentDomainLinking, password))) {
    return;
  }
  const result = await (0,api/* callApi */.p)('submitDnsChangeWallet', accountId, password, nft, checkAddressResult.resolvedAddress, realFee);
  handleDomainOperationResult([result && 'activityId' in result ? result.activityId : result], updateCurrentDomainLinking, DomainLinkingState.Complete);
});
addActionHandler('checkLinkingAddress', async (global, actions, _ref3) => {
  let {
    address
  } = _ref3;
  if (!address) {
    global = updateCurrentDomainLinking(global, {
      walletAddressName: undefined,
      resolvedWalletAddress: undefined
    });
    setGlobal(global);
    return;
  }
  const network = selectCurrentNetwork(global);
  const result = await (0,api/* callApi */.p)('getAddressInfo', network, address);
  global = getGlobal();
  if (!result || 'error' in result) {
    global = updateCurrentDomainLinking(global, {
      walletAddressName: undefined,
      resolvedWalletAddress: undefined
    });
  } else {
    global = updateCurrentDomainLinking(global, {
      walletAddressName: result.addressName,
      resolvedWalletAddress: result.resolvedAddress
    });
  }
  setGlobal(global);
});
;// ./src/global/actions/apiUpdates/initial.ts









addActionHandler('apiUpdate', (global, actions, update) => {
  switch (update.type) {
    case 'updateBalances':
      {
        global = updateBalances(global, update.accountId, update.chain, update.balances);
        setGlobal(global);
        break;
      }
    case 'updateStaking':
      {
        var _selectAccountState;
        const {
          accountId,
          states,
          totalProfit,
          shouldUseNominators
        } = update;
        const stateById = (0,iteratees/* buildCollectionByKey */.dU)(states, 'id');
        global = updateStakingDefault(global, {
          ...stateById[src_config/* DEFAULT_STAKING_STATE */.USn.id],
          balance: 0n,
          unstakeRequestAmount: 0n,
          tokenBalance: 0n
        });
        global = updateAccountStaking(global, accountId, {
          stateById,
          shouldUseNominators,
          totalProfit
        });
        const {
          stakingId
        } = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.staking) ?? {};
        if (!stakingId) {
          const stateWithBiggestBalance = [...states].sort((state0, state1) => Number(state1.balance - state0.balance))[0];
          if (stateWithBiggestBalance && stateWithBiggestBalance.balance > 0n) {
            global = updateAccountStaking(global, accountId, {
              stakingId: stateWithBiggestBalance.id
            });
          } else if (shouldUseNominators && stateById.nominators) {
            global = updateAccountStaking(global, accountId, {
              stakingId: stateById.nominators.id
            });
          }
        }
        setGlobal(global);
        break;
      }
    case 'updateTokens':
      {
        const {
          tokens,
          baseCurrency
        } = update;
        global = updateTokens(global, tokens, true);
        global = updateSettings(global, {
          baseCurrency
        });
        setGlobal(global);
        break;
      }
    case 'updateSwapTokens':
      {
        global = updateSwapTokens(global, update.tokens);
        setGlobal(global);
        break;
      }
    case 'updateNfts':
      {
        var _selectAccountState2;
        const {
          accountId,
          shouldAppend
        } = update;
        const nfts = (0,iteratees/* buildCollectionByKey */.dU)(update.nfts, 'address');
        const currentNfts = (_selectAccountState2 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState2 === void 0 ? void 0 : _selectAccountState2.nfts;
        const newOrderedAddresses = Object.keys(nfts);
        global = misc_updateAccountState(global, accountId, {
          nfts: {
            ...currentNfts,
            byAddress: {
              ...nfts,
              ...(currentNfts === null || currentNfts === void 0 ? void 0 : currentNfts.byAddress)
            },
            orderedAddresses: (0,iteratees/* unique */.Am)(shouldAppend ? [].concat((currentNfts === null || currentNfts === void 0 ? void 0 : currentNfts.orderedAddresses) ?? [], newOrderedAddresses) : [].concat(newOrderedAddresses, (currentNfts === null || currentNfts === void 0 ? void 0 : currentNfts.orderedAddresses) ?? []))
          }
        });
        if (!src_config/* IS_CORE_WALLET */.TI6) {
          update.nfts.forEach(nft => {
            if (nft.collectionAddress === src_config/* MTW_CARDS_COLLECTION */.qL) {
              global = updateAccountSettingsBackgroundNft(global, nft);
            }
          });
        }
        const hasTelegramGifts = update.nfts.some(nft => nft.isTelegramGift);
        if (hasTelegramGifts) {
          actions.addCollectionTab({
            collectionAddress: src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R,
            isAuto: true
          });
        }
        setGlobal(global);
        actions.checkCardNftOwnership();
        break;
      }
    case 'nftSent':
      {
        const {
          accountId,
          nftAddress,
          newOwnerAddress
        } = update;
        const sentNft = selectAccountNftByAddress(global, accountId, nftAddress);
        global = removeNft(global, accountId, nftAddress);
        if ((sentNft === null || sentNft === void 0 ? void 0 : sentNft.collectionAddress) === src_config/* MTW_CARDS_COLLECTION */.qL) {
          sentNft.ownerAddress = newOwnerAddress;
          global = updateAccountSettingsBackgroundNft(global, sentNft);
        }
        setGlobal(global);
        actions.checkCardNftOwnership();
        break;
      }
    case 'nftReceived':
      {
        const {
          accountId,
          nft
        } = update;
        global = addNft(global, accountId, nft);
        setGlobal(global);
        if (!src_config/* IS_CORE_WALLET */.TI6) {
          actions.checkCardNftOwnership();
          // If a user received an NFT card from the MyTonWallet collection, it is applied immediately
          if (nft.collectionAddress === src_config/* MTW_CARDS_COLLECTION */.qL) {
            actions.setCardBackgroundNft({
              nft
            });
            actions.installAccentColorFromNft({
              nft
            });
          }
        }
        break;
      }
    case 'nftPutUpForSale':
      {
        const {
          accountId,
          nftAddress
        } = update;
        global = updateNft(global, accountId, nftAddress, {
          isOnSale: true
        });
        setGlobal(global);
        break;
      }
    case 'updateAccount':
      {
        const {
          accountId,
          chain,
          domain,
          address,
          isMultisig
        } = update;
        const account = selectAccount(global, accountId);
        if (!account) {
          break;
        }
        const accountUpdate = {};
        if (address) {
          accountUpdate.addressByChain = {
            ...account.addressByChain,
            [chain]: address
          };
        }
        if (domain !== undefined) {
          accountUpdate.domainByChain = {
            ...account.domainByChain,
            [chain]: domain || undefined
          };
        }
        if (isMultisig !== undefined) {
          accountUpdate.isMultisigByChain = {
            ...account.isMultisigByChain,
            [chain]: isMultisig
          };
        }
        global = updateAccount(global, accountId, accountUpdate);
        setGlobal(global);
        break;
      }
    case 'updateConfig':
      {
        const {
          isLimited: isLimitedRegion,
          isCopyStorageEnabled,
          supportAccountsCount,
          countryCode,
          isAppUpdateRequired,
          swapVersion
        } = update;
        const shouldRestrictSwapsAndOnRamp = windowEnvironment/* IS_IOS_APP */.ZH && isLimitedRegion || src_config/* IS_CORE_WALLET */.TI6;
        global = updateRestrictions(global, {
          isLimitedRegion,
          isSwapDisabled: shouldRestrictSwapsAndOnRamp,
          isOnRampDisabled: shouldRestrictSwapsAndOnRamp,
          isNftBuyingDisabled: shouldRestrictSwapsAndOnRamp,
          isCopyStorageEnabled,
          supportAccountsCount,
          countryCode
        });
        global = {
          ...global,
          isAppUpdateRequired: src_config/* IS_CORE_WALLET */.TI6 ? undefined : isAppUpdateRequired,
          swapVersion: swapVersion ?? src_config/* SWAP_API_VERSION */.AuB
        };
        setGlobal(global);
        break;
      }
    case 'updateWalletVersions':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdateWalletVersions', update);
        }
        actions.apiUpdateWalletVersions(update);
        break;
      }
    case 'openUrl':
      {
        void openUrl(update.url, {
          isExternal: update.isExternal,
          title: update.title,
          subtitle: update.subtitle
        });
        break;
      }
    case 'requestReconnectApi':
      {
        actions.initApi();
        break;
      }
    case 'incorrectTime':
      {
        if (!global.isIncorrectTimeNotificationReceived) {
          actions.showIncorrectTimeError();
        }
        break;
      }
    case 'updateVesting':
      {
        const {
          accountId,
          vestingInfo
        } = update;
        const unfreezeRequestedIds = selectVestingPartsReadyToUnfreeze(global, accountId);
        global = updateVestingInfo(global, accountId, vestingInfo);
        const newUnfreezeRequestedIds = selectVestingPartsReadyToUnfreeze(global, accountId);
        if (!areDeepEqual(unfreezeRequestedIds, newUnfreezeRequestedIds)) {
          global = updateVesting(global, accountId, {
            unfreezeRequestedIds: undefined
          });
        }
        setGlobal(global);
        break;
      }
    case 'updatingStatus':
      {
        const {
          kind,
          accountId,
          isUpdating
        } = update;
        const key = kind === 'balance' ? 'balanceUpdateStartedAt' : 'activitiesUpdateStartedAt';
        const accountState = accounts_selectAccountState(global, accountId);
        if (isUpdating && accountState !== null && accountState !== void 0 && accountState[key]) break;
        setGlobal(misc_updateAccountState(global, accountId, {
          [key]: isUpdating ? Date.now() : undefined
        }));
        break;
      }

    // Should be removed in future versions
    case 'migrateCoreApplication':
      {
        const {
          accountId,
          isTestnet,
          address,
          secondAddress,
          secondAccountId,
          isTonProxyEnabled,
          isTonMagicEnabled
        } = update;
        global = updateSettings(global, {
          isTestnet
        });
        global = createAccount({
          global,
          accountId,
          type: 'mnemonic',
          addressByChain: {
            ton: address
          }
        });
        global = createAccount({
          global,
          accountId: secondAccountId,
          type: 'mnemonic',
          addressByChain: {
            ton: secondAddress
          },
          network: isTestnet ? 'mainnet' : 'testnet' // Second account should be created on opposite network
        });
        setGlobal(global);

        // Run the application only after the post-migration GlobalState has been applied
        requestAnimationFrame(() => {
          actions.tryAddNotificationAccount({
            accountId
          });
          actions.switchAccount({
            accountId,
            newNetwork: isTestnet ? 'testnet' : 'mainnet'
          });
          actions.afterSignIn();
          if (isTonMagicEnabled) {
            actions.toggleTonMagic({
              isEnabled: true
            });
          }
          if (isTonProxyEnabled) {
            actions.toggleTonProxy({
              isEnabled: true
            });
          }
        });
        break;
      }
    case 'updateAccountConfig':
      {
        const {
          accountConfig,
          accountId
        } = update;
        global = misc_updateAccountState(global, accountId, {
          config: accountConfig
        });
        setGlobal(global);
        break;
      }
    case 'updateAccountDomainData':
      {
        var _selectAccountState3;
        const {
          accountId,
          expirationByAddress,
          linkedAddressByAddress,
          nfts: updatedNfts
        } = update;
        const nfts = ((_selectAccountState3 = accounts_selectAccountState(global, accountId)) === null || _selectAccountState3 === void 0 ? void 0 : _selectAccountState3.nfts) || {
          byAddress: {}
        };
        global = misc_updateAccountState(global, accountId, {
          nfts: {
            ...nfts,
            dnsExpiration: expirationByAddress,
            linkedAddressByAddress
          }
        });
        global = addUnorderedNfts(global, accountId, updatedNfts);
        setGlobal(global);
        break;
      }
  }
});
;// ./node_modules/@capgo/native-audio/dist/esm/index.js

const NativeAudio = (0,dist/* registerPlugin */.F3)("NativeAudio", {
    web: () => __webpack_require__.e(/* import() */ 477).then(__webpack_require__.bind(__webpack_require__, 4477)).then((m) => new m.NativeAudioWeb()),
});


//# sourceMappingURL=index.js.map
;// ./src/assets/incoming-transaction.mp3
const incoming_transaction_namespaceObject = __webpack_require__.p + "incoming-transaction.4ddd93d8f1ec1c4e2651.mp3";
;// ./src/util/notificationSound.ts







const DEBOUNCE_MS = dateFormat/* SECOND */.Z2;
const AudioContextConstructor = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContextConstructor();
let audioBuffer;
let isSoundInitialized = src_config/* IS_CAPACITOR */.UMQ || audioContext.state === 'running';

// Workaround: this function is called once on the first user interaction.
// After that, it will be possible to play the notification without problems.
// https://developer.chrome.com/blog/autoplay?hl=ru#webaudio
function initializeSounds() {
  if (isSoundInitialized) return;
  audioContext.resume().then(() => {
    isSoundInitialized = true;
  }).catch(err => {
    (0,logs/* logDebugError */.SJ)('appSounds:initializeSounds', err);
  });
}
async function loadSound() {
  const audioSettings = {
    assetId: 'incomingTransactionSound',
    assetPath: 'public/incoming-transaction.mp3',
    audioChannelNum: 1,
    isUrl: false
  };
  if (src_config/* IS_CAPACITOR */.UMQ) {
    if (await NativeAudio.isPreloaded(audioSettings)) {
      return;
    }
    NativeAudio.preload(audioSettings).catch(err => {
      (0,logs/* logDebugError */.SJ)('appSounds:loadSound', err);
    });
  } else {
    fetch(incoming_transaction_namespaceObject).then(response => response.arrayBuffer()).then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer)).then(decodedAudioBuffer => {
      audioBuffer = decodedAudioBuffer;
    }).catch(err => {
      (0,logs/* logDebugError */.SJ)('appSounds:loadSound', err);
    });
  }
}
void loadSound();
const playIncomingTransactionSound = (0,schedulers/* debounce */.sg)(() => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return;
  if (!isSoundInitialized) {
    (0,logs/* logDebug */.MD)('appSounds:playIncomingTransactionSound', 'sound is not initialized');
    return;
  }
  if (src_config/* IS_CAPACITOR */.UMQ) {
    NativeAudio.play({
      assetId: 'incomingTransactionSound'
    }).catch(err => {
      (0,logs/* logDebugError */.SJ)('appSounds:playIncomingTransactionSound', err);
    });
    return;
  }
  if (!audioBuffer) {
    (0,logs/* logDebug */.MD)('playIncomingTransactionSound', 'audioBuffer is not loaded');
    return;
  }
  const source = audioContext.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(audioContext.destination);
  source.start(0);
}, DEBOUNCE_MS, true, false);
;// ./src/global/actions/apiUpdates/activities.ts













const TX_AGE_TO_PLAY_SOUND = 60000; // 1 min
const PRELOAD_ACTIVITY_TOKEN_COUNT = 10;
addActionHandler('apiUpdate', (global, actions, update) => {
  switch (update.type) {
    case 'initialActivities':
      {
        const {
          accountId,
          mainActivities,
          bySlug,
          chain
        } = update;
        global = addInitialActivities(global, accountId, mainActivities, bySlug, chain);
        setGlobal(global);
        void preloadTopTokenHistory(accountId, chain);
        break;
      }
    case 'newLocalActivities':
      {
        const {
          accountId,
          activities
        } = update;

        // Find matches between local and chain activities
        const replacedIds = findLocalToChainActivityMatches(global, accountId, activities);
        hideOutdatedLocalActivities(activities, replacedIds);

        // Update pending chain activities to trusted status where applicable
        global = updatePendingActivitiesToTrustedByReplacements(global, accountId, activities, replacedIds);
        global = addNewActivities(global, accountId, activities);
        setGlobal(global);
        break;
      }
    case 'newActivities':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI && !update.noForward) {
          // Local transaction in NBS was not updated after nft/transfer sending was completed
          callActionInNative('apiUpdate', {
            ...update,
            noForward: true
          });
        }
        if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !update.noForward) {
          // A local swap transaction is not created if the NBS is closed before the exchange is completed
          callActionInMain('apiUpdate', {
            ...update,
            noForward: true
          });
        }
        const {
          accountId,
          activities: newConfirmedActivities,
          pendingActivities,
          chain
        } = update;
        const prevActivitiesForReplacement = [...selectLocalActivitiesSlow(global, accountId), ...(chain ? selectPendingActivitiesSlow(global, accountId, chain) : [])];
        const incomingActivities = [...(pendingActivities ?? []), ...newConfirmedActivities];
        const replacedIds = getActivityIdReplacements(prevActivitiesForReplacement, incomingActivities);

        // A good TON address for testing: UQD5mxRgCuRNLxKxeOjG6r14iSroLF5FtomPnet-sgP5xI-e
        global = removeActivities(global, accountId, Object.keys(replacedIds));
        global = updatePendingActivitiesWithTrustedStatus(global, accountId, chain, pendingActivities, replacedIds, prevActivitiesForReplacement);
        global = addNewActivities(global, accountId, newConfirmedActivities);
        global = replaceCurrentTransferId(global, replacedIds);
        global = replaceCurrentDomainLinkingId(global, replacedIds);
        global = replaceCurrentDomainRenewalId(global, replacedIds);
        global = replaceCurrentSwapId(global, replacedIds);
        global = replaceCurrentActivityId(global, accountId, replacedIds);
        notifyAboutNewActivities(global, newConfirmedActivities);
        if (!src_config/* IS_CORE_WALLET */.TI6) {
          // NFT polling is executed at long intervals, so it is more likely that a user will see a new transaction
          // rather than receiving a card in the collection. Therefore, when a new activity occurs,
          // we check for a card from the MyTonWallet collection and apply it.
          global = processCardMintingActivity(global, accountId, newConfirmedActivities);
        }
        setGlobal(global);
        break;
      }
  }
});
function notifyAboutNewActivities(global, newActivities) {
  if (!global.settings.canPlaySounds) {
    return;
  }
  const shouldPlaySound = newActivities.some(activity => {
    var _global$tokenInfo;
    return activity.kind === 'transaction' && activity.isIncoming && activity.status === 'completed' && Date.now() - activity.timestamp < TX_AGE_TO_PLAY_SOUND && !(global.settings.areTinyTransfersHidden && getIsTinyOrScamTransaction(activity, (_global$tokenInfo = global.tokenInfo) === null || _global$tokenInfo === void 0 ? void 0 : _global$tokenInfo.bySlug[activity.slug])) && !getIsTransactionWithPoisoning(activity);
  });
  if (shouldPlaySound) {
    playIncomingTransactionSound();
  }
}
function processCardMintingActivity(global, accountId, activities) {
  const {
    isCardMinting
  } = accounts_selectAccountState(global, accountId) || {};
  if (!isCardMinting || !activities.length) {
    return global;
  }
  const mintCardActivity = activities.find(activity => {
    var _activity$nft;
    return activity.kind === 'transaction' && activity.isIncoming && (activity === null || activity === void 0 || (_activity$nft = activity.nft) === null || _activity$nft === void 0 ? void 0 : _activity$nft.collectionAddress) === src_config/* MTW_CARDS_COLLECTION */.qL;
  });
  const refundActivity = activities.find(activity => {
    return activity.kind === 'transaction' && activity.isIncoming && activity.fromAddress === src_config/* MINT_CARD_ADDRESS */.lnc && (activity === null || activity === void 0 ? void 0 : activity.comment) === src_config/* MINT_CARD_REFUND_COMMENT */.pyN;
  });
  if (mintCardActivity) {
    const nft = mintCardActivity.nft;
    global = misc_updateAccountState(global, accountId, {
      isCardMinting: undefined
    });
    global = addNft(global, accountId, nft);
    getActions().setCardBackgroundNft({
      nft
    });
    getActions().installAccentColorFromNft({
      nft
    });
  } else if (refundActivity) {
    global = misc_updateAccountState(global, accountId, {
      isCardMinting: undefined
    });
  }
  return global;
}
function findLocalToChainActivityMatches(global, accountId, localActivities) {
  const maxCheckDepth = localActivities.length + 20;
  const chainActivities = selectRecentNonLocalActivitiesSlow(global, accountId, maxCheckDepth);
  return getActivityIdReplacements(localActivities, chainActivities);
}

/**
 * Thanks to the socket, there is a possibility that a pending activity will arrive before the corresponding local
 * activity. Such local activities duplicate the pending activities, which is unwanted. They shouldn't be removed,
 * because other parts of the global state may point to their ids, so they get hidden instead.
 */
function hideOutdatedLocalActivities(localActivities, replacements) {
  for (const localActivity of localActivities) {
    if (localActivity.id in replacements) {
      localActivity.shouldHide = true;
    }
  }
}
async function preloadTopTokenHistory(accountId, chain) {
  var _selectAccountState;
  await (0,schedulers/* waitFor */.fm)(() => !!selectAccountTokens(getGlobal(), accountId), SEC, 10);
  const global = getGlobal();
  const tokens = (selectAccountTokens(global, accountId) ?? []).slice(0, PRELOAD_ACTIVITY_TOKEN_COUNT).filter(token => getChainBySlug(token.slug) === chain);
  const {
    idsBySlug
  } = ((_selectAccountState = accounts_selectAccountState(global, accountId)) === null || _selectAccountState === void 0 ? void 0 : _selectAccountState.activities) || {};
  const {
    fetchPastActivities
  } = getActions();
  for (const {
    slug
  } of tokens) {
    if ((idsBySlug === null || idsBySlug === void 0 ? void 0 : idsBySlug[slug]) === undefined) {
      fetchPastActivities({
        slug
      });
    }
  }
}
;// ./src/global/actions/apiUpdates/dapp.ts







addActionHandler('apiUpdate', (global, actions, update) => {
  switch (update.type) {
    case 'tonConnectOnline':
      {
        actions.closeLoadingOverlay();
        break;
      }
    case 'createTransaction':
      {
        const {
          promiseId,
          amount,
          toAddress,
          comment,
          rawPayload,
          stateInit,
          checkResult
        } = update;
        global = clearCurrentTransfer(global);
        global = updateCurrentTransfer(global, {
          state: TransferState.Confirm,
          toAddress,
          resolvedAddress: checkResult.resolvedAddress,
          isToNewAddress: checkResult.isToAddressNew,
          amount,
          comment,
          promiseId,
          tokenSlug: src_config/* TONCOIN */.Tu9.slug,
          rawPayload,
          stateInit
        });
        global = updateCurrentTransferByCheckResult(global, checkResult);
        setGlobal(global);
        break;
      }
    case 'completeTransaction':
      {
        const {
          activityId
        } = update;
        setGlobal(updateCurrentTransfer(global, {
          state: TransferState.Complete,
          txId: activityId
        }));
        break;
      }
    case 'createSignature':
      {
        const {
          promiseId,
          dataHex
        } = update;
        global = clearCurrentSignature(global);
        global = updateCurrentSignature(global, {
          promiseId,
          dataHex
        });
        setGlobal(global);
        break;
      }
    case 'showError':
      {
        const {
          error
        } = update;
        actions.showError({
          error
        });
        break;
      }
    case 'dappConnect':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdateDappConnect', update);
        }
        actions.apiUpdateDappConnect(update);
        break;
      }
    case 'dappConnectComplete':
      {
        global = clearDappConnectRequest(global);
        setGlobal(global);
        break;
      }
    case 'dappDisconnect':
      {
        var _global$currentDappTr;
        const {
          url
        } = update;
        if (((_global$currentDappTr = global.currentDappTransfer.dapp) === null || _global$currentDappTr === void 0 ? void 0 : _global$currentDappTr.url) === url) {
          global = clearCurrentDappTransfer(global);
          setGlobal(global);
        }
        break;
      }
    case 'dappLoading':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdateDappLoading', update);
        }
        actions.apiUpdateDappLoading(update);
        break;
      }
    case 'dappCloseLoading':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdateDappCloseLoading', update);
        }
        actions.apiUpdateDappCloseLoading(update);
        break;
      }
    case 'dappSendTransactions':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdateDappSendTransaction', update);
        }
        actions.apiUpdateDappSendTransaction(update);
        break;
      }
    case 'dappSignData':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdateDappSignData', update);
        }
        actions.apiUpdateDappSignData(update);
        break;
      }
    case 'updateDapps':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('getDapps');
        }
        actions.getDapps();
        break;
      }
    case 'prepareTransaction':
      {
        const {
          amount,
          toAddress,
          comment,
          binPayload
        } = update;
        global = clearCurrentTransfer(global);
        global = updateCurrentTransfer(global, {
          state: TransferState.Initial,
          toAddress,
          amount: amount ?? 0n,
          comment,
          tokenSlug: src_config/* TONCOIN */.Tu9.slug,
          binPayload
        });
        setGlobal(global);
        break;
      }
    case 'processDeeplink':
      {
        const {
          url
        } = update;
        void processDeeplink(url);
        break;
      }
    case 'dappTransferComplete':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdate', update);
        }
        if (global.currentDappTransfer.state !== TransferState.None) {
          global = updateCurrentDappTransfer(global, {
            state: TransferState.Complete,
            isLoading: false
          });
          setGlobal(global);
        }
        break;
      }
    case 'dappSignDataComplete':
      {
        if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
          callActionInNative('apiUpdate', update);
        }
        if (global.currentDappSignData.state !== SignDataState.None) {
          global = updateCurrentDappSignData(global, {
            state: SignDataState.Complete,
            isLoading: false
          });
          setGlobal(global);
        }
        break;
      }
  }
});
;// ./src/util/switchAnimationLevel.ts

const ANIMATION_LEVEL_OPTIONS = [src_config/* ANIMATION_LEVEL_MIN */.dnp, src_config/* ANIMATION_LEVEL_MED */.zHL, src_config/* ANIMATION_LEVEL_MAX */.zP3];
function switchAnimationLevel(level) {
  const levelClassName = `animation-level-${level}`;
  if (document.documentElement.classList.contains(levelClassName)) {
    return;
  }
  ANIMATION_LEVEL_OPTIONS.forEach(currentLevel => {
    document.documentElement.classList.toggle(`animation-level-${currentLevel}`, currentLevel === level);
  });
}
;// ./src/global/actions/ui/initial.ts




















const ANIMATION_DELAY_MS = 320;
addActionHandler('init', (_, actions) => {
  (0,fasterdom/* requestMutation */.RK)(() => {
    const {
      documentElement
    } = document;
    if (windowEnvironment/* IS_IOS */.pz) {
      documentElement.classList.add('is-ios', 'is-mobile');
    } else if (windowEnvironment/* IS_ANDROID */.Ni) {
      documentElement.classList.add('is-android', 'is-mobile');
      if (windowEnvironment/* IS_ANDROID_APP */.xy) {
        documentElement.classList.add('is-android-app');
      }
    } else if (windowEnvironment/* IS_MAC_OS */.MP) {
      documentElement.classList.add('is-macos');
    } else if (windowEnvironment/* IS_WINDOWS */.H8) {
      documentElement.classList.add('is-windows');
    } else if (windowEnvironment/* IS_LINUX */.ig) {
      documentElement.classList.add('is-linux');
    }
    if (windowEnvironment/* IS_SAFARI */.Yw) {
      documentElement.classList.add('is-safari');
    }
    if (windowEnvironment/* IS_OPERA */.By) {
      documentElement.classList.add('is-opera');
    }
    if (src_config/* IS_EXTENSION */.hL1) {
      documentElement.classList.add('is-extension');
    }
    if (windowEnvironment/* IS_ELECTRON */.cp) {
      documentElement.classList.add('is-electron');
    }
    if (src_config/* IS_TELEGRAM_APP */.tKX) {
      documentElement.classList.add('is-telegram-app');
    }
    if ((0,windowEnvironment/* getIsMobileTelegramApp */.v3)()) {
      documentElement.classList.add('is-mobile-telegram-app');
    }
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
      documentElement.classList.add('is-native-bottom-sheet');
    }
    (0,windowEnvironment/* setScrollbarWidthProperty */.Kc)();
    actions.afterInit();
  });
});
addActionHandler('afterInit', global => {
  const {
    theme,
    animationLevel,
    langCode,
    authConfig
  } = global.settings;
  switchTheme(theme);
  switchAnimationLevel(animationLevel);
  setStatusBarStyle({
    forceDarkBackground: false
  });
  void setLanguage(langCode);
  clearPreviousLangpacks();
  if (src_config/* IS_CAPACITOR */.UMQ) {
    void initCapacitorWithGlobal(authConfig);
  } else {
    if (src_config/* IS_TELEGRAM_APP */.tKX) {
      initTelegramWithGlobal(global);
    }
    document.addEventListener('click', initializeSounds, {
      once: true
    });
  }
});
addActionHandler('afterSignIn', (global, actions) => {
  setGlobal({
    ...global,
    appState: AppState.Main
  });
  setTimeout(() => {
    actions.resetAuth();
    processDeeplinkAfterSignIn();
  }, ANIMATION_DELAY_MS);
});
addActionHandler('afterSignOut', (global, actions, payload) => {
  if (payload !== null && payload !== void 0 && payload.shouldReset) {
    var _global$settings$auth;
    if (((_global$settings$auth = global.settings.authConfig) === null || _global$settings$auth === void 0 ? void 0 : _global$settings$auth.kind) === 'native-biometrics') {
      void authApi.removeNativeBiometrics();
    }
    actions.setInMemoryPassword({
      password: undefined,
      force: true
    });
    actions.resetApiSettings({
      areAllDisabled: true
    });
  }
});
addActionHandler('showDialog', (global, actions, payload) => {
  const newDialogs = [...global.dialogs];
  const existingMessageIndex = newDialogs.findIndex(dialog => dialog.message === payload.message);
  if (existingMessageIndex !== -1) {
    newDialogs.splice(existingMessageIndex, 1);
  }
  newDialogs.push(payload);
  return {
    ...global,
    dialogs: newDialogs
  };
});
addActionHandler('dismissDialog', global => {
  if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
    callActionInNative('dismissDialog');
  }
  const newDialogs = [...global.dialogs];
  newDialogs.pop();
  return {
    ...global,
    dialogs: newDialogs
  };
});
addActionHandler('selectToken', function (global, actions) {
  let {
    slug
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (slug) {
    const isToncoin = slug === src_config/* TONCOIN */.Tu9.slug;
    const tokens = selectSwapTokens(global);
    if (isToncoin || tokens !== null && tokens !== void 0 && tokens.some(token => token.slug === slug)) {
      if (isToncoin) {
        actions.setDefaultSwapParams({
          tokenInSlug: src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC,
          tokenOutSlug: slug
        });
      } else {
        actions.setDefaultSwapParams({
          tokenOutSlug: slug
        });
      }
      actions.changeTransferToken({
        tokenSlug: slug
      });
    }
  } else {
    var _global$currentTransf;
    const currentActivityToken = global.byAccountId[global.currentAccountId].currentTokenSlug;
    const isDefaultFirstTokenOutSwap = global.currentSwap.tokenOutSlug === src_config/* DEFAULT_SWAP_FIRST_TOKEN_SLUG */.JhS && global.currentSwap.tokenInSlug === src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC;
    const shouldResetSwap = global.currentSwap.tokenOutSlug === currentActivityToken && (global.currentSwap.tokenInSlug === src_config/* DEFAULT_SWAP_FIRST_TOKEN_SLUG */.JhS && global.currentSwap.tokenOutSlug !== src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC || isDefaultFirstTokenOutSwap);
    if (shouldResetSwap) {
      actions.setDefaultSwapParams({
        tokenInSlug: undefined,
        tokenOutSlug: undefined,
        withResetAmount: true
      });
    }
    const shouldResetTransfer = global.currentTransfer.tokenSlug === currentActivityToken && global.currentTransfer.tokenSlug !== src_config/* DEFAULT_TRANSFER_TOKEN_SLUG */.ScF && !((_global$currentTransf = global.currentTransfer.nfts) !== null && _global$currentTransf !== void 0 && _global$currentTransf.length);
    if (shouldResetTransfer) {
      actions.changeTransferToken({
        tokenSlug: src_config/* DEFAULT_TRANSFER_TOKEN_SLUG */.ScF,
        withResetAmount: true
      });
    }
  }
  return updateCurrentAccountState(global, {
    currentTokenSlug: slug
  });
});
addActionHandler('showError', function (global, actions) {
  let {
    error
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('showError', {
      error
    });
    return;
  }
  actions.showDialog({
    message: errorCodeToMessage(error)
  });
});
addActionHandler('showNotification', (global, actions, payload) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('showNotification', payload);
    return undefined;
  }
  const {
    message,
    icon
  } = payload;
  const newNotifications = [...global.notifications];
  const existingNotificationIndex = newNotifications.findIndex(n => n.message === message);
  if (existingNotificationIndex !== -1) {
    newNotifications.splice(existingNotificationIndex, 1);
  }
  newNotifications.push({
    message,
    icon
  });
  return {
    ...global,
    notifications: newNotifications
  };
});
addActionHandler('dismissNotification', global => {
  const newNotifications = [...global.notifications];
  newNotifications.pop();
  return {
    ...global,
    notifications: newNotifications
  };
});
addActionHandler('toggleTonProxy', (global, actions, _ref) => {
  let {
    isEnabled
  } = _ref;
  void (0,api/* callApi */.p)('doProxy', isEnabled);
  return {
    ...global,
    settings: {
      ...global.settings,
      isTonProxyEnabled: isEnabled
    }
  };
});
addActionHandler('toggleTonMagic', (global, actions, _ref2) => {
  let {
    isEnabled
  } = _ref2;
  void (0,api/* callApi */.p)('doMagic', isEnabled);
  return {
    ...global,
    settings: {
      ...global.settings,
      isTonMagicEnabled: isEnabled
    }
  };
});
addActionHandler('toggleDeeplinkHook', (global, actions, _ref3) => {
  let {
    isEnabled
  } = _ref3;
  if (windowEnvironment/* IS_ELECTRON */.cp) {
    var _window$electron;
    void ((_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.toggleDeeplinkHandler(isEnabled));
  } else {
    void (0,api/* callApi */.p)('doDeeplinkHook', isEnabled);
  }
  return {
    ...global,
    settings: {
      ...global.settings,
      isDeeplinkHookEnabled: isEnabled
    }
  };
});
addActionHandler('signOut', async (global, actions, payload) => {
  var _global$accounts;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('signOut', payload);
  }
  const {
    level
  } = payload;
  const network = selectCurrentNetwork(global);
  const accounts = selectNetworkAccounts(global);
  const accountIds = Object.keys(accounts);
  const isFromAllAccounts = level !== 'account';
  const otherNetwork = network === 'mainnet' ? 'testnet' : 'mainnet';
  let otherNetworkAccountIds = Object.keys(selectNetworkAccountsMemoized(otherNetwork, (_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.byId));
  if (level === 'all' && otherNetworkAccountIds.length > 0) {
    await (0,api/* callApi */.p)('removeNetworkAccounts', otherNetwork);
    otherNetworkAccountIds = [];
  }
  if (isFromAllAccounts || accountIds.length === 1) {
    actions.deleteAllNotificationAccounts({
      accountIds
    });
    if (otherNetworkAccountIds.length) {
      await (0,api/* callApi */.p)('removeNetworkAccounts', network);
      global = getGlobal();
      const nextAccountId = otherNetworkAccountIds[0];
      const accountsById = Object.entries(global.accounts.byId).reduce((byId, _ref4) => {
        let [accountId, account] = _ref4;
        if ((0,util_account/* parseAccountId */.cK)(accountId).network !== network) {
          byId[accountId] = account;
        }
        return byId;
      }, {});
      const byAccountId = Object.entries(global.byAccountId).reduce((byId, _ref5) => {
        let [accountId, state] = _ref5;
        if ((0,util_account/* parseAccountId */.cK)(accountId).network !== network) {
          byId[accountId] = state;
        }
        return byId;
      }, {});
      const settingsById = Object.entries(global.settings.byAccountId).reduce((byId, _ref6) => {
        let [accountId, settings] = _ref6;
        if ((0,util_account/* parseAccountId */.cK)(accountId).network !== network) {
          byId[accountId] = settings;
        }
        return byId;
      }, {});
      global = updateCurrentAccountId(global, nextAccountId);
      global = {
        ...global,
        accounts: {
          ...global.accounts,
          byId: accountsById
        },
        byAccountId,
        settings: {
          ...global.settings,
          byAccountId: settingsById
        }
      };
      setGlobal(global);
      actions.switchAccount({
        accountId: nextAccountId,
        newNetwork: otherNetwork
      });
      actions.closeSettings();
      actions.afterSignOut();
    } else {
      await (0,api/* callApi */.p)('resetAccounts');
      actions.afterSignOut({
        shouldReset: true
      });
      actions.init();
    }
  } else {
    const prevAccountId = global.currentAccountId;
    const nextAccountId = accountIds.find(id => id !== prevAccountId);
    const nextNewestActivityTimestamps = selectNewestActivityTimestamps(global, nextAccountId);
    await (0,api/* callApi */.p)('removeAccount', prevAccountId, nextAccountId, nextNewestActivityTimestamps);
    actions.deleteNotificationAccount({
      accountId: prevAccountId
    });
    global = getGlobal();
    const accountsById = (0,iteratees/* omit */.cJ)(global.accounts.byId, [prevAccountId]);
    const byAccountId = (0,iteratees/* omit */.cJ)(global.byAccountId, [prevAccountId]);
    const settingsByAccountId = (0,iteratees/* omit */.cJ)(global.settings.byAccountId, [prevAccountId]);
    global = updateCurrentAccountId(global, nextAccountId);
    global = {
      ...global,
      accounts: {
        ...global.accounts,
        byId: accountsById
      },
      byAccountId,
      settings: {
        ...global.settings,
        byAccountId: settingsByAccountId
      }
    };
    setGlobal(global);
    actions.afterSignOut();
  }
});
// EXTERNAL MODULE: ./node_modules/@capacitor-mlkit/barcode-scanning/dist/esm/definitions.js
var esm_definitions = __webpack_require__(51);
;// ./node_modules/@capacitor-mlkit/barcode-scanning/dist/esm/index.js

const BarcodeScanner = (0,dist/* registerPlugin */.F3)('BarcodeScanner', {
    web: () => __webpack_require__.e(/* import() */ 215).then(__webpack_require__.bind(__webpack_require__, 29215)).then(m => new m.BarcodeScannerWeb()),
});


//# sourceMappingURL=index.js.map
;// ./src/util/getIsAppUpdateNeeded.ts
const APP_VERSION_REGEX = /^\d+\.\d+(\.\d+)?$/;
function getIsAppUpdateNeeded(remoteVersion, appVersion, isStrict) {
  const sanitizedRemoteVersion = remoteVersion.trim();
  if (!APP_VERSION_REGEX.test(sanitizedRemoteVersion)) {
    return false;
  }
  if (isStrict) {
    return sanitizedRemoteVersion.localeCompare(appVersion, undefined, {
      numeric: true,
      sensitivity: 'base'
    }) === 1;
  }
  return sanitizedRemoteVersion !== appVersion;
}
;// ./src/hooks/useFlag.ts

const useFlag = function () {
  let initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  let debugKey = arguments.length > 1 ? arguments[1] : undefined;
  const [value, setValue] = useState(initial, debugKey);
  const setTrue = teact_useCallback(() => {
    setValue(true);
  }, []);
  const setFalse = teact_useCallback(() => {
    setValue(false);
  }, []);
  return [value, setTrue, setFalse];
};
/* harmony default export */ const hooks_useFlag = (useFlag);
;// ./src/util/parseHotkey.ts
// Original source from Mantine
// https://github.com/mantinedev/mantine/blob/master/src/mantine-hooks/src/use-hotkeys/parse-hotkey.ts

function parseHotkey(hotkey) {
  const keys = hotkey.toLowerCase().split('+').map(part => part.trim());
  const modifiers = {
    alt: keys.includes('alt'),
    ctrl: keys.includes('ctrl'),
    meta: keys.includes('meta'),
    mod: keys.includes('mod'),
    shift: keys.includes('shift')
  };
  const reservedKeys = ['alt', 'ctrl', 'meta', 'shift', 'mod'];
  const freeKey = keys.find(key => !reservedKeys.includes(key));
  return {
    ...modifiers,
    key: freeKey
  };
}
function isExactHotkey(hotkey, event) {
  const {
    alt,
    ctrl,
    meta,
    mod,
    shift,
    key
  } = hotkey;
  const {
    altKey,
    ctrlKey,
    metaKey,
    shiftKey,
    key: pressedKey
  } = event;
  if (alt !== altKey) {
    return false;
  }
  if (mod) {
    if (!ctrlKey && !metaKey) {
      return false;
    }
  } else {
    if (ctrl !== ctrlKey) {
      return false;
    }
    if (meta !== metaKey) {
      return false;
    }
  }
  if (shift !== shiftKey) {
    return false;
  }
  return Boolean(key && (pressedKey.toLowerCase() === key.toLowerCase() || event.code.replace('Key', '').toLowerCase() === key.toLowerCase()));
}
function getHotkeyMatcher(hotkey) {
  return event => isExactHotkey(parseHotkey(hotkey), event);
}
;// ./src/hooks/useHotkeys.ts



const IGNORE_TAGS = new Set(['INPUT', 'TEXTAREA', 'SELECT']);
const useHotkeys_handlers = createCallbackManager();
document.documentElement.addEventListener('keydown', useHotkeys_handlers.runCallbacks);
function useHotkeys(hotkeys) {
  teact_useEffect(() => {
    if (!hotkeys) {
      return undefined;
    }
    const entries = Object.entries(hotkeys);
    function handleKeyDown(e) {
      if (!shouldFireEvent(e)) {
        return;
      }
      entries.forEach(_ref => {
        let [hotkey, handler] = _ref;
        if (getHotkeyMatcher(hotkey)(e)) {
          handler(e);
        }
      });
    }
    return useHotkeys_handlers.addCallback(handleKeyDown);
  }, [hotkeys]);
}
function shouldFireEvent(e) {
  if (e.target instanceof HTMLElement) {
    return !IGNORE_TAGS.has(e.target.tagName);
  }
  return true;
}
;// ./src/hooks/useThrottledCallback.ts


function useThrottledCallback(fn, deps, msOrSchedulerFn) {
  let noFirst = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  const fnMemo = teact_useCallback(fn, deps);
  return teact_useMemo(() => {
    if (typeof msOrSchedulerFn === 'number') {
      return (0,schedulers/* throttle */.nF)(fnMemo, msOrSchedulerFn, !noFirst);
    } else {
      return (0,schedulers/* throttleWith */.nb)(msOrSchedulerFn, fnMemo);
    }
  }, [fnMemo, msOrSchedulerFn, noFirst]);
}
;// ./src/hooks/useDebouncedCallback.ts


function useDebouncedCallback_useDebouncedCallback(fn, deps, ms) {
  let noFirst = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let noLast = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  const fnMemo = teact_useCallback(fn, deps);
  return teact_useMemo(() => {
    return (0,schedulers/* debounce */.sg)(fnMemo, ms, !noFirst, !noLast);
  }, [fnMemo, ms, noFirst, noLast]);
}
;// ./src/hooks/useWindowSize.ts




const THROTTLE = 250;
function useWindowSize() {
  const {
    width: initialWidth,
    height: initialHeight,
    screenHeight: initialScreenHeight
  } = windowSize.get();
  const [width, setWidth] = useState(initialWidth);
  const [height, setHeight] = useState(initialHeight);
  const [screenHeight, setScreenHeight] = useState(initialScreenHeight);
  const [isResizing, setIsResizing] = useState(false);
  const setIsResizingDebounced = useDebouncedCallback_useDebouncedCallback(setIsResizing, [setIsResizing], THROTTLE, true);
  teact_useEffect(() => {
    const throttledSetIsResizing = (0,schedulers/* throttle */.nF)(() => {
      setIsResizing(true);
    }, THROTTLE, true);
    const throttledSetSize = (0,schedulers/* throttle */.nF)(() => {
      const {
        width: newWidth,
        height: newHeight,
        screenHeight: newScreenHeight
      } = windowSize.get();
      setWidth(newWidth);
      setHeight(newHeight);
      setScreenHeight(newScreenHeight);
      setIsResizingDebounced(false);
    }, THROTTLE, false);
    const handleResize = () => {
      throttledSetIsResizing();
      throttledSetSize();
    };
    window.addEventListener('resize', handleResize);
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [setIsResizingDebounced]);
  return teact_useMemo(() => ({
    width,
    height,
    screenHeight,
    isResizing
  }), [height, isResizing, screenHeight, width]);
}
;// ./src/util/setReliableTimeout.ts
const CHECK_INTERVAL = 5000;
function setReliableTimeout(callback, delay) {
  if (delay <= 0) {
    callback();
    return () => {};
  }
  const startTime = Date.now();
  let intervalId;
  let isCleared = false;
  const clear = () => {
    if (isCleared) return;
    isCleared = true;
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = undefined;
    }
  };
  intervalId = window.setInterval(() => {
    if (isCleared) return;
    if (Date.now() - startTime >= delay) {
      clear();
      callback();
    }
  }, CHECK_INTERVAL);
  return clear;
}
;// ./src/util/authApi/inMemoryPasswordStore.ts






const [getEncryptedPasswordSignal, setEncryptedPasswordSignal] = createSignal(undefined);
let encryptionKey;
const isMainStore = windowEnvironment/* IS_IOS_APP */.ZH ? windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI : true;
let inMemoryPasswordStore_clearTimeout;
function resetTimeout() {
  var _clearTimeout;
  if (!isMainStore) return;
  (_clearTimeout = inMemoryPasswordStore_clearTimeout) === null || _clearTimeout === void 0 || _clearTimeout();
  inMemoryPasswordStore_clearTimeout = setReliableTimeout(() => {
    getActions().setInMemoryPassword({
      password: undefined
    });
  }, src_config/* AUTO_CONFIRM_DURATION_MINUTES */.gbw * dateFormat/* MINUTE */.pY);
}
async function initEncryptionKey() {
  if (encryptionKey) return encryptionKey;
  encryptionKey = await window.crypto.subtle.generateKey({
    name: 'AES-GCM',
    length: 256
  }, false, ['encrypt', 'decrypt']);
  return encryptionKey;
}
void initEncryptionKey();
async function encryptPassword(password) {
  const key = await initEncryptionKey();
  const encoder = new TextEncoder();
  const passwordData = encoder.encode(password);
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const ciphertext = await window.crypto.subtle.encrypt({
    name: 'AES-GCM',
    iv
  }, key, passwordData);
  return {
    ciphertext,
    iv
  };
}
async function decryptPassword(encryptedData) {
  const key = await initEncryptionKey();
  const decryptedData = await window.crypto.subtle.decrypt({
    name: 'AES-GCM',
    iv: encryptedData.iv
  }, key, encryptedData.ciphertext);
  const decoder = new TextDecoder();
  return decoder.decode(decryptedData);
}
function getHasInMemoryPassword() {
  return getEncryptedPasswordSignal() !== undefined;
}
async function getInMemoryPassword() {
  const encryptedData = getEncryptedPasswordSignal();
  if (!encryptedData) return undefined;
  try {
    return await decryptPassword(encryptedData);
  } catch (error) {
    return undefined;
  }
}
function setInMemoryPasswordSignal(password) {
  resetTimeout();
  if (password === undefined) {
    setEncryptedPasswordSignal(undefined);
    return;
  }
  void encryptPassword(password).then(encrypted => {
    setEncryptedPasswordSignal(encrypted);
  });
}
;// ./src/assets/lottie/add_dark.tgs
const add_dark_namespaceObject = __webpack_require__.p + "add_dark.8aaf6cc3b06c8c29c0b8.tgs";
;// ./src/assets/lottie/add_light.tgs
const add_light_namespaceObject = __webpack_require__.p + "add_light.be170b963afd3d68fffa.tgs";
;// ./src/assets/lottie/clock_dark.tgs
const clock_dark_namespaceObject = __webpack_require__.p + "clock_dark.67c2082b0ca3be15abf5.tgs";
;// ./src/assets/lottie/clock_dark_blue.tgs
const clock_dark_blue_namespaceObject = __webpack_require__.p + "clock_dark_blue.dcdade09cdb1018439a5.tgs";
;// ./src/assets/lottie/clock_dark_gray.tgs
const clock_dark_gray_namespaceObject = __webpack_require__.p + "clock_dark_gray.2f8e5bd8283b1b6fbc8b.tgs";
;// ./src/assets/lottie/clock_dark_green.tgs
const clock_dark_green_namespaceObject = __webpack_require__.p + "clock_dark_green.30d56a71568b4a6c2265.tgs";
;// ./src/assets/lottie/clock_dark_orange.tgs
const clock_dark_orange_namespaceObject = __webpack_require__.p + "clock_dark_orange.1b7e7886b361ac3ea6dd.tgs";
;// ./src/assets/lottie/clock_dark_purple.tgs
const clock_dark_purple_namespaceObject = __webpack_require__.p + "clock_dark_purple.44d7e54c80d7bfcdc066.tgs";
;// ./src/assets/lottie/clock_dark_purple_white.tgs
const clock_dark_purple_white_namespaceObject = __webpack_require__.p + "clock_dark_purple_white.b5df424559c900b23895.tgs";
;// ./src/assets/lottie/clock_dark_red.tgs
const clock_dark_red_namespaceObject = __webpack_require__.p + "clock_dark_red.67cef0a9056652cc9fc4.tgs";
;// ./src/assets/lottie/clock_light.tgs
const clock_light_namespaceObject = __webpack_require__.p + "clock_light.0f820ef9df9307b005b3.tgs";
;// ./src/assets/lottie/clock_light_blue.tgs
const clock_light_blue_namespaceObject = __webpack_require__.p + "clock_light_blue.5e4780c003d1e4b827e4.tgs";
;// ./src/assets/lottie/clock_light_gray.tgs
const clock_light_gray_namespaceObject = __webpack_require__.p + "clock_light_gray.4826990b5758e7e75dc0.tgs";
;// ./src/assets/lottie/clock_light_green.tgs
const clock_light_green_namespaceObject = __webpack_require__.p + "clock_light_green.81cd8075f0eea6108c88.tgs";
;// ./src/assets/lottie/clock_light_orange.tgs
const clock_light_orange_namespaceObject = __webpack_require__.p + "clock_light_orange.f5958c528759646c52c6.tgs";
;// ./src/assets/lottie/clock_light_purple.tgs
const clock_light_purple_namespaceObject = __webpack_require__.p + "clock_light_purple.38ce19dce815fecda5d9.tgs";
;// ./src/assets/lottie/clock_light_purple_white.tgs
const clock_light_purple_white_namespaceObject = __webpack_require__.p + "clock_light_purple_white.5f9e760bc1f22f84b046.tgs";
;// ./src/assets/lottie/clock_light_red.tgs
const clock_light_red_namespaceObject = __webpack_require__.p + "clock_light_red.55b1cfeadab5652b419e.tgs";
;// ./src/assets/lottie/core_wallet_logo.tgs
const core_wallet_logo_namespaceObject = __webpack_require__.p + "core_wallet_logo.2055ba52598574ce57c1.tgs";
;// ./src/assets/lottie/duck_bill.tgs
const duck_bill_namespaceObject = __webpack_require__.p + "duck_bill.f055b12619440839e0be.tgs";
;// ./src/assets/lottie/duck_forges.tgs
const duck_forges_namespaceObject = __webpack_require__.p + "duck_forges.8b2d0ebddaa6d89f49f9.tgs";
;// ./src/assets/lottie/duck_guard.tgs
const duck_guard_namespaceObject = __webpack_require__.p + "duck_guard.80ca79a0dd4e872c97de.tgs";
;// ./src/assets/lottie/duck_happy.tgs
const duck_happy_namespaceObject = __webpack_require__.p + "duck_happy.341e288409ae85100bda.tgs";
;// ./src/assets/lottie/duck_hello.tgs
const duck_hello_namespaceObject = __webpack_require__.p + "duck_hello.40447128d7d2e35c9513.tgs";
;// ./src/assets/lottie/duck_no-data.tgs
const duck_no_data_namespaceObject = __webpack_require__.p + "duck_no-data.235bf383a43e5d277cc7.tgs";
;// ./src/assets/lottie/duck_run.tgs
const duck_run_namespaceObject = __webpack_require__.p + "duck_run.4f00386469e72bd5f970.tgs";
;// ./src/assets/lottie/duck_snitch.tgs
const duck_snitch_namespaceObject = __webpack_require__.p + "duck_snitch.1de91932b48b813238a6.tgs";
;// ./src/assets/lottie/duck_thumb.tgs
const duck_thumb_namespaceObject = __webpack_require__.p + "duck_thumb.4ae249f4ed4f4a37176a.tgs";
;// ./src/assets/lottie/duck_ton.tgs
const duck_ton_namespaceObject = __webpack_require__.p + "duck_ton.6583e2880c36d10daee2.tgs";
;// ./src/assets/lottie/duck_wait.tgs
const duck_wait_namespaceObject = __webpack_require__.p + "duck_wait.94faee2d1128c376e8d9.tgs";
;// ./src/assets/lottie/duck_yeee.tgs
const duck_yeee_namespaceObject = __webpack_require__.p + "duck_yeee.883032cf50944d474730.tgs";
;// ./src/assets/lottie/earn_dark.tgs
const earn_dark_namespaceObject = __webpack_require__.p + "earn_dark.cc3100d59f35656a0d80.tgs";
;// ./src/assets/lottie/earn_dark_purple.tgs
const earn_dark_purple_namespaceObject = __webpack_require__.p + "earn_dark_purple.ef283884f712c29765f8.tgs";
;// ./src/assets/lottie/earn_light.tgs
const earn_light_namespaceObject = __webpack_require__.p + "earn_light.ba7d6daf7c43c22f37c5.tgs";
;// ./src/assets/lottie/earn_light_purple.tgs
const earn_light_purple_namespaceObject = __webpack_require__.p + "earn_light_purple.f5bf3ef47824c05e92a7.tgs";
;// ./src/assets/lottie/send_dark.tgs
const send_dark_namespaceObject = __webpack_require__.p + "send_dark.a03d74d5dbf4d09aa6cd.tgs";
;// ./src/assets/lottie/send_light.tgs
const send_light_namespaceObject = __webpack_require__.p + "send_light.5056ea189e9f728cbf1c.tgs";
;// ./src/assets/lottie/swap_dark.tgs
const swap_dark_namespaceObject = __webpack_require__.p + "swap_dark.0cca83400e60322ddc57.tgs";
;// ./src/assets/lottie/swap_light.tgs
const swap_light_namespaceObject = __webpack_require__.p + "swap_light.f484bcd0bc90ab8c5f43.tgs";
;// ./src/assets/lottiePreview/clock_dark.svg
const lottiePreview_clock_dark_namespaceObject = __webpack_require__.p + "clock_dark.82ee95a865a9838d58e7.svg";
;// ./src/assets/lottiePreview/clock_dark_blue.svg
const lottiePreview_clock_dark_blue_namespaceObject = __webpack_require__.p + "clock_dark_blue.fdfd239a3616ce16e0b1.svg";
;// ./src/assets/lottiePreview/clock_dark_gray.svg
const lottiePreview_clock_dark_gray_namespaceObject = __webpack_require__.p + "clock_dark_gray.1b1d9010ecebb08c3903.svg";
;// ./src/assets/lottiePreview/clock_dark_green.svg
const lottiePreview_clock_dark_green_namespaceObject = __webpack_require__.p + "clock_dark_green.93f238675a9074c4fd47.svg";
;// ./src/assets/lottiePreview/clock_dark_orange.svg
const lottiePreview_clock_dark_orange_namespaceObject = __webpack_require__.p + "clock_dark_orange.b27f276018f845f7f89b.svg";
;// ./src/assets/lottiePreview/clock_dark_purple.svg
const lottiePreview_clock_dark_purple_namespaceObject = __webpack_require__.p + "clock_dark_purple.e08f76411ffbefe55602.svg";
;// ./src/assets/lottiePreview/clock_dark_purple_white.svg
const lottiePreview_clock_dark_purple_white_namespaceObject = __webpack_require__.p + "clock_dark_purple_white.fbc63a9cd9546cfb5f54.svg";
;// ./src/assets/lottiePreview/clock_dark_red.svg
const lottiePreview_clock_dark_red_namespaceObject = __webpack_require__.p + "clock_dark_red.8510b2dd2f25c2a0dcf1.svg";
;// ./src/assets/lottiePreview/clock_light.svg
const lottiePreview_clock_light_namespaceObject = __webpack_require__.p + "clock_light.ce57368517d1f91b344b.svg";
;// ./src/assets/lottiePreview/clock_light_blue.svg
const lottiePreview_clock_light_blue_namespaceObject = __webpack_require__.p + "clock_light_blue.5fc267d1b83799b2f923.svg";
;// ./src/assets/lottiePreview/clock_light_gray.svg
const lottiePreview_clock_light_gray_namespaceObject = __webpack_require__.p + "clock_light_gray.ee7e9a2398565386ec7a.svg";
;// ./src/assets/lottiePreview/clock_light_green.svg
const lottiePreview_clock_light_green_namespaceObject = __webpack_require__.p + "clock_light_green.71f692ac565e957d540a.svg";
;// ./src/assets/lottiePreview/clock_light_orange.svg
const lottiePreview_clock_light_orange_namespaceObject = __webpack_require__.p + "clock_light_orange.3ac5c7e58edf71c39522.svg";
;// ./src/assets/lottiePreview/clock_light_purple.svg
const lottiePreview_clock_light_purple_namespaceObject = __webpack_require__.p + "clock_light_purple.171b47626b50eac4fe77.svg";
;// ./src/assets/lottiePreview/clock_light_purple_white.svg
const lottiePreview_clock_light_purple_white_namespaceObject = __webpack_require__.p + "clock_light_purple_white.fc89347ebf34b9556bfc.svg";
;// ./src/assets/lottiePreview/clock_light_red.svg
const lottiePreview_clock_light_red_namespaceObject = __webpack_require__.p + "clock_light_red.04c3e975306f5ff8d73f.svg";
;// ./src/assets/lottiePreview/core_wallet_logo.png
const lottiePreview_core_wallet_logo_namespaceObject = __webpack_require__.p + "core_wallet_logo.e5460356e39ce9c0ba0e.png";
;// ./src/assets/lottiePreview/duck_bill.png
const lottiePreview_duck_bill_namespaceObject = __webpack_require__.p + "duck_bill.966ff858d718072aae75.png";
;// ./src/assets/lottiePreview/duck_forges.png
const lottiePreview_duck_forges_namespaceObject = __webpack_require__.p + "duck_forges.52c157bd0cc621f324e1.png";
;// ./src/assets/lottiePreview/duck_guard.png
const lottiePreview_duck_guard_namespaceObject = __webpack_require__.p + "duck_guard.d4ebb8f84ebdd68f3da2.png";
;// ./src/assets/lottiePreview/duck_happy.png
const lottiePreview_duck_happy_namespaceObject = __webpack_require__.p + "duck_happy.b8afd923624d1ef9061d.png";
;// ./src/assets/lottiePreview/duck_hello.png
const lottiePreview_duck_hello_namespaceObject = __webpack_require__.p + "duck_hello.c865862ea6c03bf4088b.png";
;// ./src/assets/lottiePreview/duck_no-data.png
const lottiePreview_duck_no_data_namespaceObject = __webpack_require__.p + "duck_no-data.21cf5ad05a9a06aebcff.png";
;// ./src/assets/lottiePreview/duck_run.png
const lottiePreview_duck_run_namespaceObject = __webpack_require__.p + "duck_run.a70c5e12b26ee1d82b73.png";
;// ./src/assets/lottiePreview/duck_snitch.png
const lottiePreview_duck_snitch_namespaceObject = __webpack_require__.p + "duck_snitch.b567535e9c071b993b06.png";
;// ./src/assets/lottiePreview/duck_thumb.png
const lottiePreview_duck_thumb_namespaceObject = __webpack_require__.p + "duck_thumb.8d21bd4f32485ac2c2a2.png";
;// ./src/assets/lottiePreview/duck_ton.png
const lottiePreview_duck_ton_namespaceObject = __webpack_require__.p + "duck_ton.c26fd7a7467b637009fe.png";
;// ./src/assets/lottiePreview/duck_wait.png
const lottiePreview_duck_wait_namespaceObject = __webpack_require__.p + "duck_wait.b0fe6ec6993586b30e65.png";
;// ./src/assets/lottiePreview/duck_yeee.png
const lottiePreview_duck_yeee_namespaceObject = __webpack_require__.p + "duck_yeee.6a3e6f89a1e9cdb20fc7.png";
;// ./src/components/ui/helpers/animatedAssets.ts





































































const ANIMATED_STICKERS_PATHS = {
  hello: duck_hello_namespaceObject,
  snitch: duck_snitch_namespaceObject,
  bill: duck_bill_namespaceObject,
  thumbUp: duck_thumb_namespaceObject,
  holdTon: duck_ton_namespaceObject,
  happy: duck_happy_namespaceObject,
  noData: duck_no_data_namespaceObject,
  forge: duck_forges_namespaceObject,
  wait: duck_wait_namespaceObject,
  run: duck_run_namespaceObject,
  yeee: duck_yeee_namespaceObject,
  guard: duck_guard_namespaceObject,
  helloPreview: lottiePreview_duck_hello_namespaceObject,
  snitchPreview: lottiePreview_duck_snitch_namespaceObject,
  billPreview: lottiePreview_duck_bill_namespaceObject,
  thumbUpPreview: lottiePreview_duck_thumb_namespaceObject,
  holdTonPreview: lottiePreview_duck_ton_namespaceObject,
  happyPreview: lottiePreview_duck_happy_namespaceObject,
  noDataPreview: lottiePreview_duck_no_data_namespaceObject,
  forgePreview: lottiePreview_duck_forges_namespaceObject,
  waitPreview: lottiePreview_duck_wait_namespaceObject,
  runPreview: lottiePreview_duck_run_namespaceObject,
  yeeePreview: lottiePreview_duck_yeee_namespaceObject,
  guardPreview: lottiePreview_duck_guard_namespaceObject,
  ...(src_config/* IS_CORE_WALLET */.TI6 && {
    coreWalletLogo: core_wallet_logo_namespaceObject,
    coreWalletLogoPreview: lottiePreview_core_wallet_logo_namespaceObject
  }),
  light: {
    iconAdd: add_light_namespaceObject,
    iconClock: clock_light_namespaceObject,
    iconClockBlue: clock_light_blue_namespaceObject,
    iconClockGray: clock_light_gray_namespaceObject,
    iconClockGreen: clock_light_green_namespaceObject,
    iconClockOrange: clock_light_orange_namespaceObject,
    iconClockPurple: clock_light_purple_namespaceObject,
    iconClockPurpleWhite: clock_light_purple_white_namespaceObject,
    iconClockRed: clock_light_red_namespaceObject,
    iconEarn: earn_light_namespaceObject,
    iconEarnPurple: earn_light_purple_namespaceObject,
    iconSend: send_light_namespaceObject,
    iconSwap: swap_light_namespaceObject,
    preview: {
      iconClock: lottiePreview_clock_light_namespaceObject,
      iconClockBlue: lottiePreview_clock_light_blue_namespaceObject,
      iconClockGray: lottiePreview_clock_light_gray_namespaceObject,
      iconClockGreen: lottiePreview_clock_light_green_namespaceObject,
      iconClockOrange: lottiePreview_clock_light_orange_namespaceObject,
      iconClockPurple: lottiePreview_clock_light_purple_namespaceObject,
      iconClockPurpleWhite: lottiePreview_clock_light_purple_white_namespaceObject,
      iconClockRed: lottiePreview_clock_light_red_namespaceObject
    }
  },
  dark: {
    iconAdd: add_dark_namespaceObject,
    iconClock: clock_dark_namespaceObject,
    iconClockBlue: clock_dark_blue_namespaceObject,
    iconClockGray: clock_dark_gray_namespaceObject,
    iconClockGreen: clock_dark_green_namespaceObject,
    iconClockOrange: clock_dark_orange_namespaceObject,
    iconClockPurple: clock_dark_purple_namespaceObject,
    iconClockPurpleWhite: clock_dark_purple_white_namespaceObject,
    iconClockRed: clock_dark_red_namespaceObject,
    iconEarn: earn_dark_namespaceObject,
    iconEarnPurple: earn_dark_purple_namespaceObject,
    iconSend: send_dark_namespaceObject,
    iconSwap: swap_dark_namespaceObject,
    preview: {
      iconClock: lottiePreview_clock_dark_namespaceObject,
      iconClockBlue: lottiePreview_clock_dark_blue_namespaceObject,
      iconClockGray: lottiePreview_clock_dark_gray_namespaceObject,
      iconClockGreen: lottiePreview_clock_dark_green_namespaceObject,
      iconClockOrange: lottiePreview_clock_dark_orange_namespaceObject,
      iconClockPurple: lottiePreview_clock_dark_purple_namespaceObject,
      iconClockPurpleWhite: lottiePreview_clock_dark_purple_white_namespaceObject,
      iconClockRed: lottiePreview_clock_dark_red_namespaceObject
    }
  }
};
;// ./src/hooks/useFocusAfterAnimation.tsx


const DEFAULT_DURATION = 400;
function useFocusAfterAnimation(ref) {
  let isDisabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let animationDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_DURATION;
  teact_useEffect(() => {
    if (windowEnvironment/* IS_TOUCH_ENV */.TF || isDisabled) {
      return;
    }
    setTimeout(() => {
      var _ref$current;
      (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
    }, animationDuration);
  }, [ref, animationDuration, isDisabled]);
}
;// ./src/hooks/useMatchCount.ts

function useMatchCount(predicate, times) {
  const countRef = teact_useRef(0);
  const prevPredicateRef = teact_useRef(false);
  if (!prevPredicateRef.current && predicate && countRef.current < times) {
    countRef.current += 1;
  }
  prevPredicateRef.current = predicate;
  return countRef.current >= times;
}
;// ./src/components/ui/Checkbox.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Checkbox_module = ({"wrapper":"Checkbox-module__wrapper","input":"Checkbox-module__input","content":"Checkbox-module__content"});
;// ./src/components/ui/Checkbox.tsx




function Checkbox(_ref) {
  let {
    id,
    className,
    contentClassName,
    children,
    checked,
    isDisabled,
    onChange
  } = _ref;
  const handleChange = useLastCallback(e => {
    e.preventDefault();
    onChange(e.currentTarget.checked);
  });
  return /*#__PURE__*/teact.createElement("label", {
    className: buildClassName(Checkbox_module.wrapper, className)
  }, /*#__PURE__*/teact.createElement("input", {
    id: id,
    type: "checkbox",
    className: Checkbox_module.input,
    checked: checked,
    disabled: isDisabled,
    tabIndex: 0,
    onChange: !isDisabled ? handleChange : undefined
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Checkbox_module.content, contentClassName)
  }, children));
}
/* harmony default export */ const ui_Checkbox = (memo(Checkbox));
;// ./src/components/main/modals/LogOutModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const LogOutModal_module = ({"checkbox":"LogOutModal-module__checkbox","warning":"LogOutModal-module__warning","accountLink":"LogOutModal-module__accountLink","accountLink_inner":"LogOutModal-module__accountLink_inner","accountLinkInner":"LogOutModal-module__accountLink_inner","penultimate":"LogOutModal-module__penultimate"});
;// ./src/components/main/modals/LogOutModal.tsx















function LogOutModal(_ref) {
  let {
    isOpen,
    currentAccountId,
    hasManyAccounts,
    accounts,
    accountStates,
    isBackupRequired,
    onClose,
    isInAppLock
  } = _ref;
  const {
    signOut,
    switchAccount
  } = getActions();
  const lang = hooks_useLang();
  const [isLogOutFromAllAccounts, setIsLogOutFromAllAccounts] = useState(src_config/* IS_CORE_WALLET */.TI6 || !!isInAppLock);
  const accountsWithoutBackups = teact_useMemo(() => {
    if (!hasManyAccounts) {
      return [];
    }
    return Object.entries(accounts).reduce((acc, _ref2) => {
      var _accountStates$id;
      let [id, account] = _ref2;
      if (id !== currentAccountId && (_accountStates$id = accountStates[id]) !== null && _accountStates$id !== void 0 && _accountStates$id.isBackupRequired) {
        acc.push({
          id,
          title: (0,util_account/* getAccountTitle */.S)(account) ?? ''
        });
      }
      return acc;
    }, []);
  }, [accounts, accountStates, currentAccountId, hasManyAccounts]);
  teact_useEffect(() => {
    if (isOpen) {
      setIsLogOutFromAllAccounts(src_config/* IS_CORE_WALLET */.TI6 || !!isInAppLock);
    }
  }, [isOpen, isInAppLock]);
  const handleSwitchAccount = accountId => {
    onClose(false);
    switchAccount({
      accountId
    });
  };
  const handleLogOut = useLastCallback(() => {
    onClose(!isLogOutFromAllAccounts && hasManyAccounts);
    signOut({
      level: src_config/* IS_CORE_WALLET */.TI6 ? 'all' : isLogOutFromAllAccounts ? 'network' : 'account'
    });
  });
  const handleClose = useLastCallback(() => {
    onClose(false);
  });
  function renderAccountLink(account, idx) {
    const {
      id,
      title
    } = account;
    const fullClassName = buildClassName(!isInAppLock && LogOutModal_module.accountLink, idx + 2 === accountsWithoutBackups.length && LogOutModal_module.penultimate);
    if (isInAppLock) {
      return /*#__PURE__*/teact.createElement("span", {
        className: fullClassName
      }, /*#__PURE__*/teact.createElement("strong", null, title));
    }
    return /*#__PURE__*/teact.createElement("span", {
      className: fullClassName
    }, /*#__PURE__*/teact.createElement("a", {
      key: id,
      href: "#",
      className: LogOutModal_module.accountLink_inner,
      onClick: e => {
        e.preventDefault();
        handleSwitchAccount(id);
      }
    }, title));
  }
  function renderBackupWarning() {
    return /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, /*#__PURE__*/teact.createElement("b", {
      className: LogOutModal_module.warning
    }, lang('Warning!')), " ", lang('$logout_without_backup_warning'));
  }
  function renderBackupForAccountsWarning() {
    return /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, /*#__PURE__*/teact.createElement("b", {
      className: LogOutModal_module.warning
    }, lang('Warning!')), ' ', lang('$logout_accounts_without_backup_warning', {
      links: /*#__PURE__*/teact.createElement(teact.Fragment, null, accountsWithoutBackups.map(renderAccountLink))
    }));
  }
  const shouldRenderWarningForAnotherAccounts = isLogOutFromAllAccounts && accountsWithoutBackups.length > 0;
  const shouldRenderWarningForCurrentAccount = isBackupRequired && !shouldRenderWarningForAnotherAccounts;
  // Sibling button has wider text on iOS due to App Store "Remove Wallet" requirements
  const cancelButtonClassNames = buildClassName(Modal_module.button, windowEnvironment/* IS_IOS_APP */.ZH && Modal_module.shortButton);
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    isCompact: true,
    title: windowEnvironment/* IS_IOS_APP */.ZH ? lang('Remove Wallet') : lang('Log Out'),
    onClose: handleClose,
    isInAppLock: isInAppLock
  }, /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(Modal_module.text, Modal_module.text_noExtraMargin)
  }, renderText(lang('$logout_warning', '12/24'))), !(src_config/* IS_CORE_WALLET */.TI6 || !!isInAppLock) && hasManyAccounts && /*#__PURE__*/teact.createElement(ui_Checkbox, {
    id: "logount_all_accounts",
    className: LogOutModal_module.checkbox,
    checked: isLogOutFromAllAccounts,
    onChange: setIsLogOutFromAllAccounts
  }, renderText(lang('$logout_confirm'))), shouldRenderWarningForCurrentAccount && renderBackupWarning(), shouldRenderWarningForAnotherAccounts && renderBackupForAccountsWarning(), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: cancelButtonClassNames,
    onClick: handleClose
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    onClick: handleLogOut,
    className: Modal_module.button
  }, windowEnvironment/* IS_IOS_APP */.ZH ? lang('Remove Wallet') : lang('Exit'))));
}
/* harmony default export */ const modals_LogOutModal = (memo(withGlobal(global => {
  const accounts = selectNetworkAccounts(global) || {};
  const currentAccountState = selectCurrentAccountState(global);
  const accountIds = Object.keys(accounts);
  const hasManyAccounts = accountIds.length > 1;
  return {
    currentAccountId: global.currentAccountId,
    hasManyAccounts,
    accounts,
    accountStates: global.byAccountId,
    isBackupRequired: currentAccountState === null || currentAccountState === void 0 ? void 0 : currentAccountState.isBackupRequired
  };
})(LogOutModal)));
;// ./src/util/buildStyle.ts
function buildStyle() {
  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
    parts[_key] = arguments[_key];
  }
  return parts.filter(Boolean).join(';');
}
;// ./src/hooks/useMediaTransition.ts

function useMediaTransition(mediaData, options) {
  const isMediaReady = Boolean(mediaData);
  const {
    ref
  } = useShowTransition({
    isOpen: isMediaReady,
    noMountTransition: isMediaReady,
    className: 'slow',
    ...options
  });
  return ref;
}
;// ./src/lib/rlottie/RLottie.async.ts
let promise;
let RLottie;

// Time for the main interface to completely load
const LOTTIE_LOAD_DELAY = 3000;
async function ensureRLottie() {
  if (!promise) {
    promise = __webpack_require__.e(/* import() */ 949).then(__webpack_require__.bind(__webpack_require__, 70949)).then(module => module.default);
    RLottie = await promise;
  }
  return promise;
}
function getRLottie() {
  return RLottie;
}
setTimeout(ensureRLottie, LOTTIE_LOAD_DELAY);
;// ./src/util/colors.ts
function hex2rgb(param) {
  const hex = param.replace('#', '');
  return [parseInt(hex.substring(0, 2), 16), parseInt(hex.substring(2, 4), 16), parseInt(hex.substring(4, 6), 16)];
}
function rgbToHex(rgb) {
  return `#${rgb.map(x => {
    const hex = x.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  }).join('')}`;
}
function euclideanDistance(color1, color2) {
  const r = 0.3 * (color1[0] - color2[0]) ** 2;
  const g = 0.59 * (color1[1] - color2[1]) ** 2;
  const b = 0.11 * (color1[2] - color2[2]) ** 2;
  return Math.sqrt(r + g + b);
}
function rgbToLab(rgb) {
  let [r, g, b] = rgb.map(value => value / 255);
  [r, g, b] = [r, g, b].map(value => value > 0.04045 ? ((value + 0.055) / 1.055) ** 2.4 : value / 12.92);
  let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
  let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
  let z = r * 0.0193 + g * 0.1192 + b * 0.9505;
  [x, y, z] = [x / 0.95047, y, z / 1.08883].map(value => value > 0.008856 ? value ** (1 / 3) : 7.787 * value + 16 / 116);
  return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
}

/**
 * Calculates the perceptual difference between two RGB colors.
 *
 * Delta E is a metric for understanding how the human eye perceives color difference.
 * The following table provides a general guideline:
 *
 * Delta E  |  Perception
 * ---------|-------------------------------------------
 * <= 1.0   | Not perceptible by human eyes.
 * 1 - 2    | Perceptible through close observation.
 * 2 - 10   | Perceptible at a glance.
 * 11 - 49  | Colors are more similar than opposite.
 * 100      | Colors are exact opposite.
 *
 * @param rgbA The first color as an RGB array.
 * @param rgbB The second color as an RGB array.
 * @returns The Delta E value representing the color difference.
 */
function deltaE(rgbA, rgbB) {
  const [l1, a1, b1] = rgbToLab(rgbA);
  const [l2, a2, b2] = rgbToLab(rgbB);
  const c1 = Math.sqrt(a1 * a1 + b1 * b1);
  const c2 = Math.sqrt(a2 * a2 + b2 * b2);
  const deltaC = c1 - c2;
  const deltaL = l1 - l2;
  const deltaA = a1 - a2;
  const deltaB = b1 - b2;
  const deltaH = Math.sqrt(deltaA * deltaA + deltaB * deltaB - deltaC * deltaC);
  const sl = 1.0;
  const sc = 1.0 + 0.045 * c1;
  const sh = 1.0 + 0.015 * c1;
  const deltaLKlsl = deltaL / sl;
  const deltaCkcsc = deltaC / sc;
  const deltaHkhsh = deltaH / sh;
  return Math.sqrt(deltaLKlsl * deltaLKlsl + deltaCkcsc * deltaCkcsc + deltaHkhsh * deltaHkhsh);
}
;// ./src/hooks/useHeavyAnimation.ts



const startCallbacks = createCallbackManager();
const endCallbacks = createCallbackManager();
heavyAnimation_getIsHeavyAnimating.subscribe(() => {
  if (heavyAnimation_getIsHeavyAnimating()) {
    startCallbacks.runCallbacks();
  } else {
    endCallbacks.runCallbacks();
  }
});
function useHeavyAnimation(onStart, onEnd) {
  let isDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const lastOnStart = useLastCallback(onStart);
  const lastOnEnd = useLastCallback(onEnd);
  teact_useEffect(() => {
    if (isDisabled) {
      return undefined;
    }
    if (heavyAnimation_getIsHeavyAnimating()) {
      lastOnStart();
    }
    startCallbacks.addCallback(lastOnStart);
    endCallbacks.addCallback(lastOnEnd);
    return () => {
      endCallbacks.removeCallback(lastOnEnd);
      startCallbacks.removeCallback(lastOnStart);
    };
  }, [isDisabled, lastOnEnd, lastOnStart]);
}

// TODO â†’ `onFullyIdle`?
function useThrottleForHeavyAnimation(afterHeavyAnimation, deps) {
  // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  const fnMemo = useCallback(afterHeavyAnimation, deps);
  const isScheduledRef = useRef(false);
  return useMemo(() => {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (!isScheduledRef.current) {
        if (!getIsHeavyAnimating()) {
          fnMemo(...args);
          return;
        }
        isScheduledRef.current = true;
        const removeCallback = endCallbacks.addCallback(() => {
          fnMemo(...args);
          removeCallback();
          isScheduledRef.current = false;
        });
      }
    };
  }, [fnMemo]);
}
;// ./src/hooks/usePriorityPlaybackCheck.ts



const usePriorityPlaybackCheck_startCallbacks = createCallbackManager();
const usePriorityPlaybackCheck_endCallbacks = createCallbackManager();
let timeout;
let isActive = false;
const usePriorityPlaybackCheck = function (onStart, onEnd) {
  let isDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const lastOnStart = useLastCallback(onStart);
  const lastOnEnd = useLastCallback(onEnd);
  teact_useEffect(() => {
    if (isDisabled) {
      return undefined;
    }
    if (isActive) {
      lastOnStart();
    }
    usePriorityPlaybackCheck_startCallbacks.addCallback(lastOnStart);
    usePriorityPlaybackCheck_endCallbacks.addCallback(lastOnEnd);
    return () => {
      usePriorityPlaybackCheck_endCallbacks.removeCallback(lastOnEnd);
      usePriorityPlaybackCheck_startCallbacks.removeCallback(lastOnStart);
    };
  }, [isDisabled, lastOnStart, lastOnEnd]);
};
function isPriorityPlaybackActive() {
  return isActive;
}
function dispatchPriorityPlaybackEvent() {
  if (!isActive) {
    isActive = true;
    usePriorityPlaybackCheck_startCallbacks.runCallbacks();
  }
  if (timeout) {
    clearTimeout(timeout);
    timeout = undefined;
  }

  // Race condition may happen if another `dispatchPriorityPlaybackEvent` is called before `onEnd`
  function onEnd() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = undefined;
    }
    isActive = false;
    usePriorityPlaybackCheck_endCallbacks.runCallbacks();
  }
  return onEnd;
}
/* harmony default export */ const hooks_usePriorityPlaybackCheck = (usePriorityPlaybackCheck);
;// ./src/hooks/useSharedIntersectionObserver.ts



const elementObserverMap = new Map();
function useSharedIntersectionObserver(refOrElement, onIntersectionChange) {
  let isDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const onIntersectionChangeRef = useStateRef(onIntersectionChange);
  teact_useEffect(() => {
    const el = refOrElement && 'current' in refOrElement ? refOrElement.current : refOrElement;
    if (!el || isDisabled) {
      return undefined;
    }
    const callback = _ref => {
      let [entry] = _ref;
      // Ignore updates when element is not properly mounted (`display: none`)
      if (!entry.target.offsetWidth || !entry.target.offsetHeight) {
        return;
      }
      onIntersectionChangeRef.current(entry);
    };
    let [observer, callbackManager] = elementObserverMap.get(el) || [undefined, undefined];
    if (!observer) {
      callbackManager = createCallbackManager();
      observer = new IntersectionObserver(callbackManager.runCallbacks);
      elementObserverMap.set(el, [observer, callbackManager]);
      observer.observe(el);
    }
    callbackManager.addCallback(callback);
    return () => {
      callbackManager.removeCallback(callback);
      if (!callbackManager.hasCallbacks()) {
        observer.unobserve(el);
        observer.disconnect();
        elementObserverMap.delete(el);
      }
    };
  }, [isDisabled, onIntersectionChangeRef, refOrElement]);
}
;// ./src/components/ui/AnimatedSticker.tsx

















const THROTTLE_MS = 150;
const AnimatedSticker = _ref => {
  let {
    ref,
    renderId,
    className,
    style,
    tgsUrl,
    play,
    playSegment,
    speed,
    noLoop,
    size,
    shouldStretch,
    quality,
    isLowPriority,
    color,
    forceOnHeavyAnimation,
    forceInBackground,
    sharedCanvas,
    sharedCanvasCoords,
    onClick,
    onLoad,
    onEnded,
    onLoop
  } = _ref;
  let containerRef = teact_useRef();
  if (ref) {
    containerRef = ref;
  }
  const viewId = useUniqueId();
  const [animation, setAnimation] = useState();
  const animationRef = teact_useRef();
  const isFirstRender = teact_useRef(true);
  const playKey = play || (play === false ? false : playSegment);
  const playRef = useStateRef(play);
  const playSegmentRef = useStateRef(playSegment);
  const rgbColor = teact_useRef();
  const isUnmountedRef = teact_useRef(false);
  teact_useEffect(() => {
    return () => {
      isUnmountedRef.current = true;
    };
  }, []);
  useSyncEffect(() => {
    if (color) {
      const [r, g, b] = hex2rgb(color);
      rgbColor.current = [r, g, b];
    } else {
      rgbColor.current = undefined;
    }
  }, [color]);
  const init = useLastCallback(() => {
    if (animationRef.current || isUnmountedRef.current || !tgsUrl || sharedCanvas && (!sharedCanvasCoords || !sharedCanvas.offsetWidth || !sharedCanvas.offsetHeight)) {
      return;
    }
    const container = containerRef.current || sharedCanvas;
    if (!container) {
      return;
    }
    const newAnimation = getRLottie().init(tgsUrl, container, renderId || (0,generateUniqueId/* default */.A)(), {
      size,
      shouldStretch,
      noLoop,
      quality,
      isLowPriority,
      coords: sharedCanvasCoords
    }, viewId, rgbColor.current, onLoad, onEnded, onLoop);
    if (speed) {
      newAnimation.setSpeed(speed);
    }
    setAnimation(newAnimation);
    animationRef.current = newAnimation;
  });
  teact_useEffect(() => {
    if (getRLottie()) {
      init();
    } else {
      void ensureRLottie().then(init);
    }
  }, [init, tgsUrl, sharedCanvas, sharedCanvasCoords]);
  const throttledInit = useThrottledCallback(init, [init], THROTTLE_MS);
  useSharedIntersectionObserver(sharedCanvas, throttledInit);
  teact_useEffect(() => {
    if (!animation) return;
    animation.setColor(rgbColor.current);
  }, [color, animation]);
  teact_useEffect(() => {
    return () => {
      var _animationRef$current;
      (_animationRef$current = animationRef.current) === null || _animationRef$current === void 0 || _animationRef$current.removeView(viewId);
    };
  }, [viewId]);
  const playAnimation = useLastCallback(function () {
    let shouldRestart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    if (!animation || !(playRef.current || playSegmentRef.current) || isFrozen(forceOnHeavyAnimation, forceInBackground)) {
      return;
    }
    if (playSegmentRef.current) {
      animation.playSegment(playSegmentRef.current, shouldRestart, viewId);
    } else {
      animation.play(shouldRestart, viewId);
    }
  });
  const playAnimationOnRaf = useLastCallback(() => {
    (0,fasterdom/* requestMeasure */.YS)(playAnimation);
  });
  const pauseAnimation = useLastCallback(() => {
    if (animation !== null && animation !== void 0 && animation.isPlaying()) {
      animation.pause(viewId);
    }
  });
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevNoLoop] = _ref2;
    if (prevNoLoop !== undefined && noLoop !== prevNoLoop) {
      animation === null || animation === void 0 || animation.setNoLoop(noLoop);
    }
  }, [noLoop, animation]);
  hooks_useEffectWithPrevDeps(_ref3 => {
    let [prevSharedCanvasCoords] = _ref3;
    if (prevSharedCanvasCoords !== undefined && sharedCanvasCoords !== prevSharedCanvasCoords) {
      void (animation === null || animation === void 0 ? void 0 : animation.setSharedCanvasCoords(viewId, sharedCanvasCoords));
    }
  }, [sharedCanvasCoords, viewId, animation]);
  teact_useEffect(() => {
    if (!animation) {
      return;
    }
    if (playKey) {
      if (!isFrozen(forceOnHeavyAnimation, forceInBackground)) {
        playAnimation(noLoop);
      }
    } else {
      pauseAnimation();
    }
  }, [animation, playKey, noLoop, playAnimation, pauseAnimation, forceOnHeavyAnimation, forceInBackground]);
  teact_useEffect(() => {
    if (!animation) return;
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else if (tgsUrl) {
      animation.changeData(tgsUrl);
      playAnimation(noLoop);
    }
  }, [playAnimation, animation, tgsUrl, noLoop]);
  useHeavyAnimation(pauseAnimation, playAnimation, forceOnHeavyAnimation || windowEnvironment/* IS_IOS */.pz || !playKey);
  hooks_usePriorityPlaybackCheck(pauseAnimation, playAnimation, !playKey);
  // Pausing frame may not happen in background,
  // so we need to make sure it happens right after focusing,
  // then we can play again.
  useBackgroundMode(pauseAnimation, playAnimationOnRaf, !playKey || forceInBackground);
  if (sharedCanvas) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    className: className,
    style: buildStyle(size !== undefined && !shouldStretch && `width: ${size}px; height: ${size}px;`, onClick && !windowEnvironment/* IS_ELECTRON */.cp && 'cursor: pointer', style),
    onClick: onClick
  });
};
/* harmony default export */ const ui_AnimatedSticker = (memo(AnimatedSticker));
function isFrozen() {
  let forceOnHeavyAnimation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  let forceInBackground = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return !forceOnHeavyAnimation && !windowEnvironment/* IS_IOS */.pz && heavyAnimation_getIsHeavyAnimating() || isPriorityPlaybackActive() || !forceInBackground && isBackgroundModeActive();
}
;// ./src/components/ui/AnimatedIcon.tsx
function AnimatedIcon_extends() { return AnimatedIcon_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, AnimatedIcon_extends.apply(null, arguments); }





function AnimatedIcon(props) {
  const {
    size,
    play = true,
    noLoop = true,
    className,
    noTransition,
    nonInteractive,
    onLoad,
    onClick,
    ...otherProps
  } = props;
  const [isAnimationLoaded, markAnimationLoaded] = hooks_useFlag(false);
  const ref = useMediaTransition(noTransition || isAnimationLoaded);
  const handleLoad = useLastCallback(() => {
    markAnimationLoaded();
    onLoad === null || onLoad === void 0 || onLoad();
  });
  const [playKey, setPlayKey] = useState(String(Math.random()));
  const handleClick = useLastCallback(() => {
    if (play === true) {
      setPlayKey(String(Math.random()));
    }
    onClick === null || onClick === void 0 || onClick();
  });
  return /*#__PURE__*/teact.createElement(ui_AnimatedSticker, AnimatedIcon_extends({
    ref: ref,
    className: className,
    size: size,
    play: play === true ? playKey : play,
    noLoop: noLoop,
    onClick: !nonInteractive ? handleClick : undefined,
    onLoad: handleLoad
  }, otherProps));
}
/* harmony default export */ const ui_AnimatedIcon = (memo(AnimatedIcon));
;// ./src/components/ui/AnimatedIconWithPreview.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AnimatedIconWithPreview_module = ({"root":"AnimatedIconWithPreview-module__root","preview":"AnimatedIconWithPreview-module__preview"});
;// ./src/components/ui/AnimatedIconWithPreview.tsx
function AnimatedIconWithPreview_extends() { return AnimatedIconWithPreview_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, AnimatedIconWithPreview_extends.apply(null, arguments); }










const loadedPreviewUrls = new Set();
const DEFAULT_SIZE = 150;
function AnimatedIconWithPreview(props) {
  const {
    size = DEFAULT_SIZE,
    previewUrl,
    iconPreviewClass,
    thumbDataUri,
    className,
    noAnimation,
    noPreviewTransition,
    ...otherProps
  } = props;
  const [isPreviewLoaded, markPreviewLoaded] = hooks_useFlag(Boolean(iconPreviewClass) || Boolean(thumbDataUri) || loadedPreviewUrls.has(previewUrl));
  const ref = useMediaTransition(isPreviewLoaded || noPreviewTransition);
  const [isAnimationReady, markAnimationReady, markAnimationNotReady] = hooks_useFlag(false);
  teact_useEffect(() => {
    if (noAnimation) {
      markAnimationNotReady();
    }
  }, [markAnimationNotReady, noAnimation]);
  const handlePreviewLoad = useLastCallback(() => {
    markPreviewLoaded();
    loadedPreviewUrls.add(previewUrl);
  });
  return /*#__PURE__*/teact.createElement("div", {
    ref: !noPreviewTransition ? ref : undefined,
    className: buildClassName(className, AnimatedIconWithPreview_module.root),
    style: buildStyle(size !== undefined && !otherProps.shouldStretch && `width: ${size}px; height: ${size}px;`),
    "data-preview-url": previewUrl
  }, thumbDataUri && !previewUrl && !isAnimationReady &&
  /*#__PURE__*/
  // eslint-disable-next-line jsx-a11y/alt-text
  teact.createElement("img", {
    src: thumbDataUri,
    className: AnimatedIconWithPreview_module.preview
  }), previewUrl && !isAnimationReady &&
  /*#__PURE__*/
  // eslint-disable-next-line jsx-a11y/alt-text
  teact.createElement("img", {
    src: previewUrl,
    className: AnimatedIconWithPreview_module.preview,
    onLoad: handlePreviewLoad
  }), iconPreviewClass && !isAnimationReady && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(AnimatedIconWithPreview_module.preview, iconPreviewClass),
    "aria-hidden": true
  }), !noAnimation && /*#__PURE__*/teact.createElement(ui_AnimatedIcon, AnimatedIconWithPreview_extends({
    size: size
  }, otherProps, {
    onLoad: markAnimationReady,
    noTransition: true
  })));
}
/* harmony default export */ const ui_AnimatedIconWithPreview = (memo(withGlobal(global => {
  return {
    noAnimation: global.settings.animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp
  };
})(AnimatedIconWithPreview)));
;// ./src/components/ui/Input.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Input_module = ({"wrapper":"Input-module__wrapper","input":"Input-module__input","error":"Input-module__error","disabled":"Input-module__disabled","input_password":"Input-module__input_password","inputPassword":"Input-module__input_password","rich":"Input-module__rich","rich__value":"Input-module__rich__value","richValue":"Input-module__rich__value","rich__placeholder":"Input-module__rich__placeholder","richPlaceholder":"Input-module__rich__placeholder","isLoading":"Input-module__isLoading","large":"Input-module__large","inputWrapperStatic":"Input-module__inputWrapperStatic","input__wrapper":"Input-module__input__wrapper","inputWrapper":"Input-module__input__wrapper","input__wrapper_hasFocus":"Input-module__input__wrapper_hasFocus","inputWrapperHasFocus":"Input-module__input__wrapper_hasFocus","visibilityToggle":"Input-module__visibilityToggle","visibilityToggle_push":"Input-module__visibilityToggle_push","visibilityTogglePush":"Input-module__visibilityToggle_push","fractional":"Input-module__fractional","label":"Input-module__label","label_error":"Input-module__label_error","labelError":"Input-module__label_error","label_forPassword":"Input-module__label_forPassword","labelForPassword":"Input-module__label_forPassword","label_errorUnderInput":"Input-module__label_errorUnderInput","labelErrorUnderInput":"Input-module__label_errorUnderInput","label_errorBottom":"Input-module__label_errorBottom","labelErrorBottom":"Input-module__label_errorBottom","swapCorner":"Input-module__swapCorner","swapCorner_error":"Input-module__swapCorner_error","swapCornerError":"Input-module__swapCorner_error","mask":"Input-module__mask","inputContainer":"Input-module__inputContainer","input_withValueOverlay":"Input-module__input_withValueOverlay","inputWithValueOverlay":"Input-module__input_withValueOverlay","valueOverlay":"Input-module__valueOverlay","static":"Input-module__static"});
;// ./src/components/ui/Input.tsx






function Input(_ref) {
  let {
    ref,
    id,
    label,
    placeholder,
    valueOverlay,
    inputMode,
    isRequired,
    isDisabled,
    isMultiline,
    hasError,
    type = 'text',
    error,
    value = '',
    maxLength,
    inputArg,
    className,
    wrapperClassName,
    autoCapitalize,
    autoComplete,
    autoCorrect,
    isStatic,
    enterKeyHint,
    children,
    onInput,
    onKeyDown,
    onFocus,
    onBlur
  } = _ref;
  const lang = hooks_useLang();
  const [isPasswordVisible, setIsPasswordVisible] = useState(false);
  const [hasFocus, markHasFocus, unmarkHasFocus] = hooks_useFlag(false);
  const showValueOverlay = Boolean(valueOverlay && !hasFocus);
  const handleInput = e => {
    onInput(e.currentTarget.value, inputArg);
  };
  const handleTogglePasswordVisibility = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };
  const handleChange = e => {
    const {
      currentTarget
    } = e;
    const {
      scrollHeight
    } = currentTarget;
    (0,fasterdom/* requestMutation */.RK)(() => {
      currentTarget.style.height = '0';
      currentTarget.style.height = `${scrollHeight}px`;
    });
  };
  const handleFocus = e => {
    markHasFocus();
    onFocus === null || onFocus === void 0 || onFocus(e);
  };
  const handleBlur = e => {
    unmarkHasFocus();
    onBlur === null || onBlur === void 0 || onBlur(e);
  };
  const finalType = type === 'text' || isPasswordVisible ? 'text' : 'password';
  const inputFullClass = buildClassName(Input_module.input, className, type === 'password' && Input_module.input_password, (hasError || error) && Input_module.error, isDisabled && Input_module.disabled, valueOverlay && Input_module.input_withvalueOverlay);
  const labelFullClass = buildClassName(Input_module.label, (hasError || error) && Input_module.error, (hasError || error) && type === 'password' && Input_module.label_forPassword);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Input_module.wrapper, wrapperClassName)
  }, error && !!label && /*#__PURE__*/teact.createElement("label", {
    className: buildClassName(Input_module.label, Input_module.label_error, Input_module.error),
    htmlFor: id
  }, error), !!label && /*#__PURE__*/teact.createElement("label", {
    className: labelFullClass,
    htmlFor: id
  }, label), /*#__PURE__*/teact.createElement("div", {
    className: Input_module.inputContainer
  }, isMultiline ? /*#__PURE__*/teact.createElement("textarea", {
    ref: ref,
    id: id,
    className: inputFullClass,
    value: value,
    disabled: isDisabled,
    maxLength: maxLength,
    autoComplete: autoComplete,
    onInput: handleInput,
    onChange: handleChange,
    onKeyDown: onKeyDown,
    onFocus: handleFocus,
    onBlur: handleBlur,
    tabIndex: 0,
    required: isRequired,
    placeholder: valueOverlay ? undefined : placeholder
  }) : /*#__PURE__*/teact.createElement("input", {
    ref: ref,
    id: id,
    className: inputFullClass,
    type: finalType,
    value: value,
    disabled: isDisabled,
    inputMode: inputMode,
    maxLength: maxLength,
    autoCapitalize: autoCapitalize,
    autoComplete: autoComplete,
    autoCorrect: autoCorrect,
    spellCheck: autoCorrect,
    onInput: handleInput,
    onKeyDown: onKeyDown,
    onFocus: handleFocus,
    onBlur: handleBlur,
    tabIndex: 0,
    required: isRequired,
    placeholder: valueOverlay ? undefined : placeholder,
    enterKeyHint: enterKeyHint
  }), showValueOverlay && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Input_module.valueOverlay, isStatic && Input_module.static)
  }, valueOverlay)), type === 'password' && /*#__PURE__*/teact.createElement("button", {
    className: buildClassName(Input_module.visibilityToggle, label && Input_module.visibilityToggle_push),
    type: "button",
    onClick: handleTogglePasswordVisibility,
    "aria-label": lang('Change password visibility'),
    tabIndex: -1
  }, /*#__PURE__*/teact.createElement("i", {
    className: isPasswordVisible ? 'icon-eye' : 'icon-eye-closed',
    "aria-hidden": true
  })), children, error && !label && /*#__PURE__*/teact.createElement("label", {
    className: buildClassName(Input_module.label, Input_module.label_errorBottom, Input_module.error),
    htmlFor: id
  }, error));
}
/* harmony default export */ const ui_Input = (memo(Input));
;// ./src/util/cssAnimationEndListeners.ts
// Sometimes event is fired earlier than animation completes
const ANIMATION_END_DELAY = 50;
function waitForTransitionEnd(node, handler, propertyName, fallbackMs) {
  return waitForEndEvent('transitionend', node, handler, propertyName, fallbackMs);
}
function waitForAnimationEnd(node, handler, animationName, fallbackMs) {
  return waitForEndEvent('animationend', node, handler, animationName, fallbackMs);
}
function waitForEndEvent(eventType, node, handler, detailedName, fallbackMs) {
  let isHandled = false;
  function cleanup() {
    node.removeEventListener(eventType, handleAnimationEnd);
  }
  function handleAnimationEnd(e) {
    if (isHandled || e.target !== e.currentTarget) {
      return;
    }
    if (detailedName && (e instanceof TransitionEvent && e.propertyName === detailedName || e instanceof AnimationEvent && e.animationName === detailedName)) {
      return;
    }
    isHandled = true;
    cleanup();
    setTimeout(() => {
      handler();
    }, ANIMATION_END_DELAY);
  }
  node.addEventListener(eventType, handleAnimationEnd);
  if (fallbackMs) {
    setTimeout(() => {
      if (isHandled) return;
      cleanup();
      handler();
    }, fallbackMs);
  }
  return cleanup;
}
;// ./src/util/swipeController.ts






const INERTIA_DURATION = 300;
const INERTIA_EASING = animation/* timingFunctions */.qM.easeOutCubic;
const SWIPE_DISABLED_CLASS_NAME = 'swipe-disabled';
let isSwipeActive = false;
let swipeOffsets;
let onDrag;
let onRelease;
let cancelCurrentReleaseAnimation;
function captureControlledSwipe(element, options) {
  return captureEvents(element, {
    swipeThreshold: 10,
    withNativeDrag: true,
    excludedClosestSelector: `.${SWIPE_DISABLED_CLASS_NAME}`,
    onSwipe(e, direction, offsets) {
      if (direction === SwipeDirection.Left) {
        var _options$onSwipeLeftS;
        (_options$onSwipeLeftS = options.onSwipeLeftStart) === null || _options$onSwipeLeftS === void 0 || _options$onSwipeLeftS.call(options);
      } else if (direction === SwipeDirection.Right) {
        var _options$onSwipeRight;
        (_options$onSwipeRight = options.onSwipeRightStart) === null || _options$onSwipeRight === void 0 || _options$onSwipeRight.call(options);
      } else {
        return false;
      }
      if (windowEnvironment/* IS_IOS */.pz) {
        isSwipeActive = true;
        swipeOffsets = offsets;
      }
      return true;
    },
    onDrag(e, captureEvent, offsets) {
      var _onDrag;
      if (!isSwipeActive) return;
      (_onDrag = onDrag) === null || _onDrag === void 0 || _onDrag(offsets);
    },
    onRelease() {
      var _onRelease;
      if (!isSwipeActive) return;
      isSwipeActive = false;
      (_onRelease = onRelease) === null || _onRelease === void 0 || _onRelease(options.onCancel);
      onDrag = undefined;
      onRelease = undefined;
    }
  });
}
function allowSwipeControlForTransition(currentSlide, nextSlide, onCancelForTransition) {
  var _cancelCurrentRelease;
  (_cancelCurrentRelease = cancelCurrentReleaseAnimation) === null || _cancelCurrentRelease === void 0 || _cancelCurrentRelease();
  if (!isSwipeActive) return;
  const targetPosition = extractAnimationEndPosition(currentSlide);
  if (!targetPosition) return;
  currentSlide.getAnimations().forEach(a => a.pause());
  nextSlide.getAnimations().forEach(a => a.pause());
  currentSlide.style.animationTimingFunction = 'linear';
  nextSlide.style.animationTimingFunction = 'linear';
  let currentDirection;
  (0,fasterdom/* requestMeasure */.YS)(() => {
    const computedStyle = getComputedStyle(currentSlide);
    const initialPositionPx = extractPositionFromMatrix(computedStyle.transform, targetPosition.axis);
    const targetPositionPx = targetPosition.units === 'px' ? targetPosition.value : targetPosition.value / 100 * (targetPosition.axis === 'X' ? currentSlide.offsetWidth : currentSlide.offsetHeight);
    const distance = targetPositionPx - initialPositionPx;
    let progress = 0;
    onDrag = _ref => {
      let {
        dragOffsetX,
        dragOffsetY
      } = _ref;
      const dragOffset = targetPosition.axis === 'X' ? dragOffsetX - swipeOffsets.dragOffsetX : dragOffsetY - swipeOffsets.dragOffsetY;
      const newProgress = clamp(dragOffset / distance, 0, 1);
      currentDirection = newProgress > progress ? 1 : -1;
      progress = newProgress;
      updateAnimationProgress([currentSlide, nextSlide], progress);
    };
    onRelease = onCancelForClient => {
      const isRevertSwipe = currentDirection === -1;
      function cleanup() {
        currentSlide.getAnimations().forEach(a => a.cancel());
        nextSlide.getAnimations().forEach(a => a.cancel());
        (0,fasterdom/* requestMutation */.RK)(() => {
          currentSlide.style.animationTimingFunction = '';
          nextSlide.style.animationTimingFunction = '';
        });
      }
      if (!isRevertSwipe) {
        // For some reason animations are not cleared when CSS class is removed
        waitForAnimationEnd(currentSlide, cleanup);
      }
      cancelCurrentReleaseAnimation = (0,animation/* animateNumber */.Hd)({
        from: progress,
        to: isRevertSwipe ? 0 : 1,
        duration: INERTIA_DURATION,
        timing: INERTIA_EASING,
        onUpdate(releaseProgress) {
          updateAnimationProgress([currentSlide, nextSlide], releaseProgress);
        },
        onEnd() {
          let isCanceled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          cancelCurrentReleaseAnimation = undefined;
          if (isCanceled || isRevertSwipe) {
            cleanup();
            onCancelForTransition();
            onCancelForClient();
          }
        }
      });
    };
  });
}
function updateAnimationProgress(elements, progress) {
  elements.map(e => e.getAnimations()).flat().forEach(animation => {
    animation.currentTime = animation.effect.getTiming().duration * progress;
  });
}
function extractAnimationEndPosition(element) {
  for (const animation of element.getAnimations()) {
    if (!(animation.effect instanceof KeyframeEffect)) continue;
    for (const keyframe of animation.effect.getKeyframes()) {
      if (keyframe.offset !== 1 || !keyframe.transform) continue;
      const position = extractPositionFromTransform(keyframe.transform);
      if (position) {
        return position;
      }
    }
  }
  return undefined;
}
function extractPositionFromTransform(transformRule) {
  const match = transformRule.match(/([XY])\((-?\d+)(%|px)\)/);
  if (!match) return undefined;
  return {
    axis: match[1],
    value: Number(match[2]),
    units: match[3]
  };
}
function extractPositionFromMatrix(transform, axis) {
  const matrix = transform.slice(7, -1).split(',').map(Number);
  return matrix[axis === 'X' ? 4 : 5];
}
;// ./src/hooks/usePrevDuringAnimationSimple.ts


// Use previous value during animation without checking for presence
function usePrevDuringAnimationSimple(current) {
  let durationMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
  const [prev, setPrev] = useState(current);
  teact_useEffect(() => {
    if (current === prev) return undefined;
    const timeoutId = window.setTimeout(() => {
      setPrev(current);
    }, durationMs);
    return () => {
      window.clearTimeout(timeoutId);
    };
  }, [current, durationMs, prev]);
  return prev;
}
;// ./src/components/ui/PinPad.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const PinPad_module = ({"root":"PinPad-module__root","title":"PinPad-module__title","dots":"PinPad-module__dots","dotsError":"PinPad-module__dotsError","shakeAnimation":"PinPad-module__shakeAnimation","dotsLoading":"PinPad-module__dotsLoading","spin":"PinPad-module__spin","appear":"PinPad-module__appear","dot":"PinPad-module__dot","dotLoadingAnimation":"PinPad-module__dotLoadingAnimation","firstDotLoadingAnimation":"PinPad-module__firstDotLoadingAnimation","secondDotLoadingAnimation":"PinPad-module__secondDotLoadingAnimation","thirdDotLoadingAnimation":"PinPad-module__thirdDotLoadingAnimation","fourthDotLoadingAnimation":"PinPad-module__fourthDotLoadingAnimation","dotFilled":"PinPad-module__dotFilled","scaleAnimation":"PinPad-module__scaleAnimation","grid":"PinPad-module__grid","button":"PinPad-module__button","minified":"PinPad-module__minified","buttonActive":"PinPad-module__buttonActive","buttonHidden":"PinPad-module__buttonHidden","buttonDanger":"PinPad-module__buttonDanger","error":"PinPad-module__error","success":"PinPad-module__success"});
;// ./src/components/ui/PinPadButton.tsx




const CLICKED_TIMEOUT_MS = 200;
function PinPadButton(_ref) {
  let {
    value,
    children,
    className,
    isDisabled,
    onClick
  } = _ref;
  const [isClicked, setIsClicked] = useState(false);
  const handleClick = () => {
    void vibrate();
    onClick === null || onClick === void 0 || onClick(value);
    setIsClicked(true);
    setTimeout(() => {
      setIsClicked(false);
    }, CLICKED_TIMEOUT_MS);
  };
  return /*#__PURE__*/teact.createElement("div", {
    onMouseDown: !isDisabled ? handleClick : undefined,
    className: buildClassName(PinPad_module.button, isClicked && PinPad_module.buttonActive, className),
    role: "button",
    tabIndex: 0
  }, value || children);
}
/* harmony default export */ const ui_PinPadButton = (memo(PinPadButton));
;// ./src/util/forceReflow.ts
// Used before applying CSS transition
function forceReflow(element) {
  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
  element.offsetWidth;
}
;// ./src/components/ui/Transition.tsx













const FALLBACK_ANIMATION_END = dateFormat/* SECOND */.Z2;
const CLASSES = {
  slide: 'Transition_slide',
  active: 'Transition_slide-active',
  from: 'Transition_slide-from',
  to: 'Transition_slide-to',
  inactive: 'Transition_slide-inactive'
};
const ACTIVE_SLIDE_CLASS_NAME = CLASSES.active;
const TO_SLIDE_CLASS_NAME = CLASSES.to;
function Transition(_ref) {
  let {
    ref,
    activeKey,
    nextKey,
    prevKey,
    name,
    direction = 'auto',
    renderCount,
    shouldRestoreHeight,
    shouldCleanup,
    cleanupExceptionKey,
    shouldWrap,
    wrapExceptionKey,
    id,
    className,
    slideClassName,
    withSwipeControl,
    onStart,
    onStop,
    onContainerClick,
    onScroll,
    children
  } = _ref;
  const currentKeyRef = teact_useRef();
  // No need for a container to update on change
  const {
    animationLevel
  } = getGlobal().settings;
  const shouldDisableAnimation = animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp;
  let containerRef = teact_useRef();
  if (ref) {
    containerRef = ref;
  }
  const rendersRef = teact_useRef({});
  const prevActiveKey = hooks_usePrevious(activeKey);
  const forceUpdate = hooks_useForceUpdate();
  const isAnimatingRef = teact_useRef(false);
  const isSwipeJustCancelledRef = teact_useRef(false);
  const hasActiveKeyChanged = prevActiveKey !== undefined && activeKey !== prevActiveKey;
  if (!renderCount && hasActiveKeyChanged) {
    rendersRef.current = {
      [prevActiveKey]: rendersRef.current[prevActiveKey]
    };
  }
  rendersRef.current[activeKey] = children;
  if (prevKey) {
    rendersRef.current[prevKey] = children;
  }
  if (nextKey) {
    rendersRef.current[nextKey] = children;
  }
  const isBackwards = direction === -1 || direction === 'auto' && prevActiveKey > activeKey || direction === 'inverse' && prevActiveKey < activeKey;
  useLayoutEffect(() => {
    function cleanup() {
      if (!shouldCleanup) {
        return;
      }
      const preservedRender = cleanupExceptionKey !== undefined ? rendersRef.current[cleanupExceptionKey] : undefined;
      rendersRef.current = preservedRender ? {
        [cleanupExceptionKey]: preservedRender
      } : {};
      forceUpdate();
    }
    const isSlideOptimized = name === 'slideOptimized' || name === 'slideOptimizedRtl';
    const container = containerRef.current;
    const keys = Object.keys(rendersRef.current).map(Number);
    const prevActiveIndex = renderCount ? prevActiveKey : keys.indexOf(prevActiveKey);
    const activeIndex = renderCount ? activeKey : keys.indexOf(activeKey);
    const childNodes = Array.from(container.childNodes);
    if (!childNodes.length) {
      return;
    }
    const childElements = Array.from(container.children);
    childElements.forEach(el => {
      addExtraClass(el, CLASSES.slide);
      if (slideClassName) {
        slideClassName.split(/\s+/).forEach(token => {
          addExtraClass(el, token);
        });
      }
    });
    if (!hasActiveKeyChanged) {
      if (isAnimatingRef.current) {
        return;
      }
      childElements.forEach(childElement => {
        if (childElement === childNodes[activeIndex]) {
          addExtraClass(childElement, CLASSES.active);
          if (isSlideOptimized) {
            setExtraStyles(childElement, {
              transition: 'none',
              transform: 'translate3d(0, 0, 0)'
            });
          }
        } else if (!isSlideOptimized) {
          addExtraClass(childElement, CLASSES.inactive);
        }
      });
      return;
    }
    currentKeyRef.current = activeKey;
    if (isSlideOptimized) {
      if (!childNodes[activeIndex]) {
        return;
      }
      performSlideOptimized(shouldDisableAnimation, name, isBackwards, cleanup, activeKey, currentKeyRef, isAnimatingRef, container, childNodes[activeIndex], childNodes[prevActiveIndex], shouldRestoreHeight, onStart, onStop);
      return;
    }
    if (name === 'none' || shouldDisableAnimation || isSwipeJustCancelledRef.current) {
      if (isSwipeJustCancelledRef.current) {
        isSwipeJustCancelledRef.current = false;
      }
      childNodes.forEach((node, i) => {
        if (node instanceof HTMLElement) {
          removeExtraClass(node, CLASSES.from);
          removeExtraClass(node, CLASSES.to);
          toggleExtraClass(node, CLASSES.active, i === activeIndex);
          toggleExtraClass(node, CLASSES.inactive, i !== activeIndex);
        }
      });
      cleanup();
      return;
    }
    childNodes.forEach((node, i) => {
      if (node instanceof HTMLElement) {
        removeExtraClass(node, CLASSES.active);
        toggleExtraClass(node, CLASSES.from, i === prevActiveIndex);
        toggleExtraClass(node, CLASSES.to, i === activeIndex);
        toggleExtraClass(node, CLASSES.inactive, i !== prevActiveIndex && i !== activeIndex);
      }
    });
    isAnimatingRef.current = true;
    const endHeavyAnimation = beginHeavyAnimation();
    onStart === null || onStart === void 0 || onStart();
    toggleExtraClass(container, `Transition-${name}`, !isBackwards);
    toggleExtraClass(container, `Transition-${name}Backwards`, isBackwards);
    function onAnimationEnd() {
      const activeElement = container.querySelector(`.${CLASSES.active}`);
      const {
        clientHeight
      } = activeElement || {};
      (0,fasterdom/* requestMutation */.RK)(() => {
        if (activeKey !== currentKeyRef.current) {
          endHeavyAnimation();
          return;
        }
        removeExtraClass(container, `Transition-${name}`);
        removeExtraClass(container, `Transition-${name}Backwards`);
        childNodes.forEach((node, i) => {
          if (node instanceof HTMLElement) {
            removeExtraClass(node, CLASSES.from);
            removeExtraClass(node, CLASSES.to);
            toggleExtraClass(node, CLASSES.active, i === activeIndex);
            toggleExtraClass(node, CLASSES.inactive, i !== activeIndex);
          }
        });
        if (shouldRestoreHeight) {
          if (activeElement) {
            setExtraStyles(activeElement, {
              height: 'auto'
            });
            setExtraStyles(container, {
              height: `${clientHeight}px`
            });
          }
        }
        onStop === null || onStop === void 0 || onStop();
        endHeavyAnimation();
        isAnimatingRef.current = false;
        cleanup();
      });
    }
    const watchedNode = (name === 'reveal' || name === 'slideFadeAndroid') && isBackwards ? childNodes[prevActiveIndex] : childNodes[activeIndex];
    if (watchedNode) {
      if (withSwipeControl && childNodes[prevActiveIndex]) {
        const giveUpAnimationEnd = waitForAnimationEnd(watchedNode, onAnimationEnd);
        allowSwipeControlForTransition(childNodes[prevActiveIndex], childNodes[activeIndex], () => {
          giveUpAnimationEnd();
          isSwipeJustCancelledRef.current = true;
          onStop === null || onStop === void 0 || onStop();
          endHeavyAnimation();
          isAnimatingRef.current = false;
        });
      } else {
        waitForAnimationEnd(watchedNode, onAnimationEnd, undefined, FALLBACK_ANIMATION_END);
      }
    } else {
      onAnimationEnd();
    }
  }, [activeKey, nextKey, prevActiveKey, hasActiveKeyChanged, isBackwards, name, onStart, onStop, renderCount, shouldRestoreHeight, shouldCleanup, slideClassName, cleanupExceptionKey, shouldDisableAnimation, forceUpdate, withSwipeControl]);
  teact_useEffect(() => {
    if (!shouldRestoreHeight) {
      return;
    }
    const container = containerRef.current;
    const activeElement = container.querySelector(`.${CLASSES.active}`) || container.querySelector(`.${CLASSES.from}`);
    if (!activeElement) {
      return;
    }
    const {
      clientHeight
    } = activeElement || {};
    if (!clientHeight) {
      return;
    }
    (0,fasterdom/* requestMutation */.RK)(() => {
      setExtraStyles(activeElement, {
        height: 'auto'
      });
      setExtraStyles(container, {
        height: `${clientHeight}px`,
        flexBasis: `${clientHeight}px`
      });
    });
  }, [shouldRestoreHeight, children]);
  const asFastList = !renderCount;
  const renders = rendersRef.current;
  const renderKeys = Object.keys(renderCount ? new Array(renderCount).fill(undefined) : renders).map(Number);
  const contents = renderKeys.map(key => {
    const render = renders[key];
    if (!render) {
      return undefined;
    }
    const rendered = typeof render === 'function' ? render(key === activeKey, key === prevActiveKey, key, activeKey) : render;
    return shouldWrap && key !== wrapExceptionKey || asFastList ? /*#__PURE__*/teact.createElement("div", {
      key: key,
      teactOrderKey: key
    }, rendered) : rendered;
  });
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    onScroll: onScroll,
    onClick: onContainerClick,
    id: id,
    className: buildClassName('Transition', className),
    teactFastList: asFastList
  }, contents);
}
/* harmony default export */ const ui_Transition = (Transition);
function performSlideOptimized(shouldDisableAnimation, name, isBackwards, cleanup, activeKey, currentKeyRef, isAnimatingRef, container, toSlide, fromSlide, shouldRestoreHeight, onStart, onStop) {
  if (shouldDisableAnimation) {
    toggleExtraClass(container, `Transition-${name}`, !isBackwards);
    toggleExtraClass(container, `Transition-${name}Backwards`, isBackwards);
    if (fromSlide instanceof HTMLElement) {
      removeExtraClass(fromSlide, CLASSES.active);
      setExtraStyles(fromSlide, {
        transition: 'none',
        transform: ''
      });
    }
    if (toSlide instanceof HTMLElement) {
      addExtraClass(toSlide, CLASSES.active);
      setExtraStyles(toSlide, {
        transition: 'none',
        transform: 'translate3d(0, 0, 0)'
      });
    }
    cleanup();
    return;
  }
  if (name === 'slideOptimizedRtl') {
    isBackwards = !isBackwards;
  }
  isAnimatingRef.current = true;
  const endHeavyAnimation = beginHeavyAnimation();
  onStart === null || onStart === void 0 || onStart();
  toggleExtraClass(container, `Transition-${name}`, !isBackwards);
  toggleExtraClass(container, `Transition-${name}Backwards`, isBackwards);
  if (fromSlide instanceof HTMLElement) {
    setExtraStyles(fromSlide, {
      transition: 'none',
      transform: 'translate3d(0, 0, 0)'
    });
  }
  if (toSlide instanceof HTMLElement) {
    setExtraStyles(toSlide, {
      transition: 'none',
      transform: `translate3d(${isBackwards ? '-' : ''}100%, 0, 0)`
    });
  }
  (0,fasterdom/* requestForcedReflow */.gm)(() => {
    if (toSlide instanceof HTMLElement) {
      forceReflow(toSlide);
    }
    return () => {
      if (fromSlide instanceof HTMLElement) {
        removeExtraClass(fromSlide, CLASSES.active);
        setExtraStyles(fromSlide, {
          transition: '',
          transform: `translate3d(${isBackwards ? '' : '-'}100%, 0, 0)`
        });
      }
      if (toSlide instanceof HTMLElement) {
        addExtraClass(toSlide, CLASSES.active);
        setExtraStyles(toSlide, {
          transition: '',
          transform: 'translate3d(0, 0, 0)'
        });
      }
    };
  });
  waitForTransitionEnd(toSlide, () => {
    const clientHeight = toSlide instanceof HTMLElement ? toSlide.clientHeight : undefined;
    (0,fasterdom/* requestMutation */.RK)(() => {
      if (activeKey !== currentKeyRef.current) {
        endHeavyAnimation();
        return;
      }
      if (fromSlide instanceof HTMLElement) {
        setExtraStyles(fromSlide, {
          transition: 'none',
          transform: ''
        });
      }
      if (shouldRestoreHeight && clientHeight && toSlide instanceof HTMLElement) {
        setExtraStyles(toSlide, {
          height: 'auto'
        });
        setExtraStyles(container, {
          height: `${clientHeight}px`
        });
      }
      onStop === null || onStop === void 0 || onStop();
      endHeavyAnimation();
      isAnimatingRef.current = false;
      cleanup();
    });
  });
}
;// ./src/components/ui/PinPad.tsx


















const DEFAULT_PIN_LENGTH = 4;
const RESET_STATE_DELAY_MS = 1500;
// Should match duration from `--layer-transition` CSS variable
const STATE_ANIMATION_DURATION_MS = windowEnvironment/* IS_IOS */.pz ? 650 : 300;
function PinPad(_ref) {
  let {
    isActive,
    title,
    type,
    value,
    resetStateDelayMs = RESET_STATE_DELAY_MS,
    length = DEFAULT_PIN_LENGTH,
    isPinAccepted,
    className,
    isMinified,
    topContent,
    onBiometricsClick,
    onChange,
    onClearError,
    onSubmit,
    onLogOutClick
  } = _ref;
  const {
    clearIsPinAccepted
  } = getActions();
  const isFaceId = getIsFaceIdAvailable();
  const canRenderBackspace = value.length > 0;
  const isSuccess = type === 'success' || isPinAccepted;
  const isSuccessDuringAnimation = usePrevDuringAnimationSimple(isSuccess, STATE_ANIMATION_DURATION_MS);
  const prevIsPinAccepted = hooks_usePrevious(isPinAccepted);
  const arePinButtonsDisabled = isSuccess || value.length === length && type !== 'error'; // Allow pincode entry in case of an error

  const titleClassName = buildClassName(PinPad_module.title, type === 'error' && PinPad_module.error, (isSuccess || isSuccessDuringAnimation) && PinPad_module.success);
  const shouldSuggestLogout = useMatchCount(type === 'error', src_config/* WRONG_ATTEMPTS_BEFORE_LOG_OUT_SUGGESTION */.Avc);
  teact_useEffect(() => {
    if (prevIsPinAccepted && !isPinAccepted && length === value.length) {
      onChange('');
    }
  }, [isPinAccepted, length, onChange, prevIsPinAccepted, value.length]);
  teact_useEffect(() => clearIsPinAccepted, []);

  // Fix for iOS, enable fast pinpad button presses
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevIsActive] = _ref2;
    if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return;
    if (isActive) {
      void esm_BottomSheet.clearScrollPatch();
    } else if (prevIsActive) {
      void esm_BottomSheet.applyScrollPatch();
    }
  }, [isActive]);
  teact_useEffect(() => {
    if (type !== 'error') return undefined;
    const timeoutId = window.setTimeout(() => {
      if (value.length === length) {
        onChange('');
      }
      onClearError === null || onClearError === void 0 || onClearError();
    }, resetStateDelayMs);
    void vibrateOnError();
    return () => {
      window.clearTimeout(timeoutId);
    };
  }, [length, onChange, onClearError, resetStateDelayMs, type, value.length]);
  teact_useEffect(() => {
    if (!isActive) return undefined;
    disableSwipeToClose();
    return () => {
      enableSwipeToClose();
    };
  }, [isActive]);
  const handleClick = useLastCallback(char => {
    if (value.length === length || value.length === 0) {
      onClearError === null || onClearError === void 0 || onClearError();
    }
    if (value.length === length) {
      onChange(char);
      return;
    }
    const newValue = `${value}${char}`;
    onChange(newValue);
    if (newValue.length === length) {
      onSubmit(newValue);
    }
  });
  const handleBackspaceClick = useLastCallback(() => {
    onClearError === null || onClearError === void 0 || onClearError();
    if (!value.length) return;
    onChange(value.slice(0, -1));
  });
  function renderDots() {
    const dotsClassName = buildClassName(PinPad_module.dots, type === 'error' && PinPad_module.dotsError, (isSuccess || isSuccessDuringAnimation) && PinPad_module.dotsLoading);
    return /*#__PURE__*/teact.createElement("div", {
      className: dotsClassName,
      "aria-hidden": true
    }, Array.from({
      length
    }, (_, i) => /*#__PURE__*/teact.createElement("div", {
      key: i,
      className: buildClassName(PinPad_module.dot, i < value.length && PinPad_module.dotFilled, type === 'error' && PinPad_module.error, (isSuccess || isSuccessDuringAnimation) && PinPad_module.success)
    })));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(PinPad_module.root, className, SWIPE_DISABLED_CLASS_NAME)
  }, topContent ?? /*#__PURE__*/teact.createElement("div", {
    className: titleClassName
  }, title), renderDots(), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(PinPad_module.grid, isMinified && PinPad_module.minified)
  }, /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "1",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "2",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "3",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "4",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "5",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "6",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "7",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "8",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "9",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), !onBiometricsClick ? /*#__PURE__*/teact.createElement("span", null) : /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    onClick: onBiometricsClick,
    isDisabled: isSuccess
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon', isFaceId ? 'icon-face-id' : 'icon-touch-id'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    value: "0",
    onClick: handleClick,
    isDisabled: arePinButtonsDisabled
  }), /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "zoomFade",
    activeKey: shouldSuggestLogout && !value.length ? 0 : 1
  }, onLogOutClick && shouldSuggestLogout && !value.length ? /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    className: PinPad_module.buttonDanger,
    onClick: onLogOutClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon icon-exit",
    "aria-hidden": true
  })) : /*#__PURE__*/teact.createElement(ui_PinPadButton, {
    className: !canRenderBackspace && PinPad_module.buttonHidden,
    isDisabled: !canRenderBackspace || isSuccess,
    onClick: handleBackspaceClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon icon-backspace",
    "aria-hidden": true
  })))));
}
/* harmony default export */ const ui_PinPad = (memo(withGlobal(global => {
  const {
    isPinAccepted
  } = global;
  return {
    isPinAccepted
  };
})(PinPad)));
;// ./src/components/ui/PasswordForm.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const PasswordForm_module = ({"sticker":"PasswordForm-module__sticker","label":"PasswordForm-module__label","title":"PasswordForm-module__title","errorMessage":"PasswordForm-module__errorMessage","verify":"PasswordForm-module__verify","error":"PasswordForm-module__error","pinPadHeader":"PasswordForm-module__pinPadHeader","closeButton":"PasswordForm-module__closeButton","autoConfirmCheckbox":"PasswordForm-module__autoConfirmCheckbox","logOutWrapper":"PasswordForm-module__logOutWrapper","logOutButton":"PasswordForm-module__logOutButton"});
;// ./src/components/ui/PasswordForm.tsx
































const STICKER_SIZE = 180;
const APPEAR_ANIMATION_DURATION_MS = 300;
const [getHandleBiometricsSignal, setHandleBiometricsSignal] = createSignal(Date.now());
function triggerPasswordFormHandleBiometrics(e) {
  if (e) {
    stopEvent(e);
  }
  setHandleBiometricsSignal(Date.now());
}
function useInMemoryPassword(inMemoryPasswordRef) {
  const hasInMemoryPassword = teact_useMemo(() => getHasInMemoryPassword(), []);
  if (hasInMemoryPassword && !inMemoryPasswordRef.current) {
    void getInMemoryPassword().then(password => {
      inMemoryPasswordRef.current = password;
    });
  }
  return hasInMemoryPassword;
}
function useStorageClearedDialog(operationType) {
  const {
    showDialog
  } = getActions();
  return useLastCallback(() => {
    showDialog({
      title: '$storage_cleared_title',
      message: getTranslation('$storage_cleared_message', {
        support_link: /*#__PURE__*/teact.createElement("a", {
          href: `https://t.me/${src_config/* SUPPORT_USERNAME */.Fkn}`,
          target: "_blank",
          rel: "noreferrer"
        }, "@", src_config/* SUPPORT_USERNAME */.Fkn)
      }),
      buttons: {
        cancel: {
          title: 'Cancel'
        },
        confirm: {
          title: 'Log Out',
          isDestructive: true,
          action: 'signOutAll'
        }
      },
      noBackdropClose: true,
      isInAppLock: operationType === 'unlock'
    });
  });
}
function PasswordForm(_ref) {
  let {
    isActive,
    isLoading,
    operationType,
    isPasswordNumeric,
    isBiometricAuthEnabled,
    isNativeBiometricAuthEnabled,
    authConfig,
    cancelLabel,
    submitLabel,
    stickerSize = STICKER_SIZE,
    placeholder = 'Enter your password',
    error,
    help,
    resetStateDelayMs,
    containerClassName,
    pinPadClassName,
    children,
    withCloseButton,
    noAnimatedIcon,
    inputWrapperClassName,
    forceBiometricsInMain,
    skipAuthScreen,
    isAutoConfirmEnabled,
    onUpdate,
    onCancel,
    onSubmit
  } = _ref;
  const {
    openSettings,
    setInMemoryPassword,
    setIsAutoConfirmEnabled
  } = getActions();
  const lang = hooks_useLang();
  const memoizedPasswordRef = teact_useRef();
  const hasInMemoryPassword = useInMemoryPassword(memoizedPasswordRef);
  const showOnlyConfirmScreen = skipAuthScreen && hasInMemoryPassword;
  const passwordRef = teact_useRef();
  const [password, setPassword] = useState('');
  const [localError, setLocalError] = useState('');
  const [wrongAttempts, setWrongAttempts] = useState(0);
  const [isResetBiometricsWarningOpen, openResetBiometricsWarning, closeResetBiometricsWarning] = hooks_useFlag(false);
  const {
    isSmallHeight,
    isPortrait
  } = useDeviceScreen();
  const isSubmitDisabled = !password.length && !showOnlyConfirmScreen;
  const canUsePinPad = getDoesUsePinPad();
  const [isLogOutModalOpened, openLogOutModal, closeLogOutModal] = hooks_useFlag(false);
  const shouldSuggestLogout = useMatchCount(!!error || !!localError, src_config/* WRONG_ATTEMPTS_BEFORE_LOG_OUT_SUGGESTION */.Avc);
  const showStorageClearedDialog = useStorageClearedDialog(operationType);
  teact_useEffect(() => {
    if (isActive) {
      setLocalError('');
      setPassword('');
      setWrongAttempts(0);
    }
  }, [isActive]);
  const submitCallback = useLastCallback(async enteredPassword => {
    const passwordToReturn = showOnlyConfirmScreen ? memoizedPasswordRef.current : enteredPassword;
    onSubmit(passwordToReturn);
    if (showOnlyConfirmScreen) return;
    const passwordVerified = await (0,api/* callApi */.p)('verifyPassword', passwordToReturn);
    if (!passwordVerified) {
      // Password verification failed - check if it's due to storage corruption
      const isStorageOk = await (0,api/* callApi */.p)('checkWorkerStorageIntegrity');
      if (!isStorageOk) {
        return showStorageClearedDialog();
      }
      // Storage is intact, so it's just a wrong password - let normal error handling proceed
    }
    if (passwordVerified) {
      setInMemoryPassword({
        password: passwordToReturn
      });
    }
  });
  const handleSubmit = useLastCallback(() => {
    void submitCallback(password);
  });
  const handleBiometrics = useLastCallback(async () => {
    try {
      setLocalError('');
      const biometricPassword = await authApi.getPassword(authConfig);
      if (!biometricPassword) {
        setWrongAttempts(wrongAttempts + 1);
        setLocalError('Biometric confirmation failed');
        if (windowEnvironment/* IS_ANDROID_APP */.xy && wrongAttempts > 2) {
          openResetBiometricsWarning();
        }
      } else {
        void submitCallback(biometricPassword);
      }
    } catch (err) {
      setLocalError(err.message || lang('Something went wrong.'));
    }
  });
  teact_useEffect(() => {
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI && !forceBiometricsInMain || !isActive || !isBiometricAuthEnabled || showOnlyConfirmScreen) {
      return;
    }
    void (0,schedulers/* pause */.v7)(APPEAR_ANIMATION_DURATION_MS).then(handleBiometrics);
  }, [forceBiometricsInMain, handleBiometrics, isActive, isBiometricAuthEnabled, showOnlyConfirmScreen]);
  hooks_useEffectOnce(() => {
    return getHandleBiometricsSignal.subscribe(handleBiometrics);
  });
  useFocusAfterAnimation(passwordRef, !isActive || isBiometricAuthEnabled);
  const handleClearError = useLastCallback(() => {
    setLocalError('');
    onUpdate();
  });
  const handleOpenSettings = useLastCallback(() => {
    closeResetBiometricsWarning();
    onCancel === null || onCancel === void 0 || onCancel();
    openSettings();
  });
  const handleInput = useLastCallback(value => {
    setPassword(value);
    if (error) {
      onUpdate();
    }
  });
  const handleAutoConfirmChange = useLastCallback(isEnabled => {
    setIsAutoConfirmEnabled({
      isEnabled
    });
  });
  const handleOpenLogOutModal = useLastCallback(e => {
    stopEvent(e);
    openLogOutModal();
  });
  teact_useEffect(() => {
    return isSubmitDisabled || isLoading ? undefined : captureKeyboardListeners({
      onEnter: handleSubmit
    });
  }, [handleSubmit, isLoading, isSubmitDisabled]);
  function getPinPadTitle() {
    switch (operationType) {
      case 'unfreeze':
        return 'Confirm Unfreezing';
      case 'passcode':
      case 'turnOnBiometrics':
        return 'Confirm Passcode';
      case 'transfer':
      case 'sending':
        return 'Confirm Sending';
      case 'staking':
        return 'Confirm Staking';
      case 'unstaking':
        return 'Confirm Unstaking';
      case 'swap':
        return 'Confirm Swap';
      case 'unlock':
        return undefined;
      case 'claim':
        return 'Confirm Rewards Claim';
      case 'mintCard':
        return 'Confirm Upgrading';
      default:
        return 'Confirm Action';
    }
  }
  const shouldRenderFullWidthButton = operationType === 'unlock';
  const footerButtonsClassName = buildClassName(Modal_module.footerButtons, shouldRenderFullWidthButton && Modal_module.footerButtonFullWidth);
  function renderFooterButtons() {
    return /*#__PURE__*/teact.createElement("div", {
      className: footerButtonsClassName
    }, onCancel && /*#__PURE__*/teact.createElement(ui_Button, {
      isLoading: isLoading && isBiometricAuthEnabled,
      isDisabled: isLoading && !isBiometricAuthEnabled,
      className: Modal_module.buttonHalfWidth,
      onClick: onCancel
    }, cancelLabel || lang('Cancel')), isBiometricAuthEnabled && Boolean(localError) && /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isLoading: isLoading,
      isDisabled: isLoading,
      className: Modal_module.buttonHalfWidth,
      onClick: !isLoading ? handleBiometrics : undefined,
      shouldStopPropagation: true
    }, lang('Try Again')), (!isBiometricAuthEnabled || showOnlyConfirmScreen) && /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isLoading: isLoading,
      isDisabled: isSubmitDisabled,
      className: !shouldRenderFullWidthButton ? Modal_module.buttonHalfWidth : Modal_module.buttonFullWidth,
      onClick: !isLoading ? handleSubmit : undefined
    }, submitLabel || lang('Send')));
  }
  function renderAutoConfirmCheckbox() {
    return /*#__PURE__*/teact.createElement(ui_Checkbox, {
      checked: !!isAutoConfirmEnabled,
      onChange: handleAutoConfirmChange,
      className: PasswordForm_module.autoConfirmCheckbox
    }, lang('Remember for %1$d minutes', src_config/* AUTO_CONFIRM_DURATION_MINUTES */.gbw));
  }
  const shouldRenderAutoConfirmCheckbox = operationType !== 'turnOnBiometrics' && !isBiometricAuthEnabled;
  if (canUsePinPad) {
    const hasError = Boolean(localError || error);
    const title = getPinPadTitle();
    const actionName = lang(!isNativeBiometricAuthEnabled ? 'Enter code' : getIsFaceIdAvailable() ? 'Enter code or use Face ID' : getIsTouchIdAvailable() ? 'Enter code or use Touch ID' : 'Enter code or use biometrics');
    const content = /*#__PURE__*/teact.createElement(teact.Fragment, null, withCloseButton && /*#__PURE__*/teact.createElement(ui_Button, {
      isRound: true,
      className: buildClassName(Modal_module.closeButton, PasswordForm_module.closeButton),
      ariaLabel: lang('Close'),
      onClick: onCancel
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Modal_module.closeIcon, 'icon-close'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("div", {
      className: PasswordForm_module.pinPadHeader
    }, isPortrait && !noAnimatedIcon && /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      tgsUrl: ANIMATED_STICKERS_PATHS.guard,
      previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
      noLoop: false,
      nonInteractive: true
    }), !isSmallHeight && title && /*#__PURE__*/teact.createElement("div", {
      className: PasswordForm_module.title
    }, lang(title)), children), showOnlyConfirmScreen ? renderFooterButtons() : /*#__PURE__*/teact.createElement(ui_PinPad, {
      isActive: isActive,
      title: lang(hasError ? localError || error : isSmallHeight && title ? title : actionName),
      type: hasError ? 'error' : undefined,
      length: src_config/* PIN_LENGTH */.NEx,
      resetStateDelayMs: resetStateDelayMs,
      value: password,
      topContent: shouldRenderAutoConfirmCheckbox ? renderAutoConfirmCheckbox() : undefined,
      className: pinPadClassName,
      onBiometricsClick: isNativeBiometricAuthEnabled ? handleBiometrics : undefined,
      onLogOutClick: operationType === 'unlock' ? openLogOutModal : undefined,
      onChange: setPassword,
      onClearError: handleClearError,
      onSubmit: submitCallback
    }), operationType === 'unlock' && /*#__PURE__*/teact.createElement(modals_LogOutModal, {
      isOpen: isLogOutModalOpened,
      onClose: closeLogOutModal,
      isInAppLock: true
    }));
    return showOnlyConfirmScreen ? /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, content) : content;
  }
  function renderBiometricPrompt() {
    const renderingError = localError || error;
    if (renderingError) {
      return /*#__PURE__*/teact.createElement("div", {
        className: PasswordForm_module.error
      }, lang(renderingError));
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: PasswordForm_module.verify
    }, lang(operationType === 'transfer' ? 'Please confirm transaction using biometrics' : 'Please confirm operation using biometrics'));
  }
  function renderPasswordForm() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Input, {
      ref: passwordRef,
      type: "password",
      isRequired: true,
      id: "first-password",
      wrapperClassName: inputWrapperClassName,
      inputMode: isPasswordNumeric ? 'numeric' : undefined,
      error: error ? lang(error) : localError,
      placeholder: lang(placeholder),
      value: password,
      onInput: handleInput,
      maxLength: isPasswordNumeric ? src_config/* PIN_LENGTH */.NEx : undefined
    }), localError && /*#__PURE__*/teact.createElement("div", {
      className: PasswordForm_module.errorMessage
    }, lang(localError)), help && !error && /*#__PURE__*/teact.createElement("div", {
      className: PasswordForm_module.label
    }, help), shouldRenderAutoConfirmCheckbox && renderAutoConfirmCheckbox());
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.transitionContent, containerClassName)
  }, !noAnimatedIcon && /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    tgsUrl: ANIMATED_STICKERS_PATHS.holdTon,
    previewUrl: ANIMATED_STICKERS_PATHS.holdTonPreview,
    play: isActive,
    size: stickerSize,
    nonInteractive: true,
    noLoop: false,
    className: PasswordForm_module.sticker
  }), children, !showOnlyConfirmScreen && (isBiometricAuthEnabled ? renderBiometricPrompt() : renderPasswordForm()), shouldSuggestLogout && operationType === 'unlock' && /*#__PURE__*/teact.createElement("div", {
    className: PasswordForm_module.logOutWrapper
  }, lang('Can\'t confirm?'), /*#__PURE__*/teact.createElement("span", {
    role: "button",
    tabIndex: 0,
    className: PasswordForm_module.logOutButton,
    onClick: handleOpenLogOutModal
  }, lang('Exit all wallets'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-chevron-right', PasswordForm_module.detailsIcon),
    "aria-hidden": true
  }))), renderFooterButtons(), /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isResetBiometricsWarningOpen,
    isCompact: true,
    title: lang('Biometric authentication failed'),
    onClose: closeResetBiometricsWarning
  }, /*#__PURE__*/teact.createElement("p", {
    className: Modal_module.text
  }, lang('Reinstall biometrics in your device\'s system settings, or use a passcode.')), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Modal_module.button,
    onClick: closeResetBiometricsWarning
  }, lang('Close')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: Modal_module.button,
    onClick: handleOpenSettings
  }, lang('Settings')))), operationType === 'unlock' && /*#__PURE__*/teact.createElement(modals_LogOutModal, {
    isOpen: isLogOutModalOpened,
    onClose: closeLogOutModal,
    isInAppLock: true
  }));
}
/* harmony default export */ const ui_PasswordForm = (memo(withGlobal(global => {
  const {
    isPasswordNumeric,
    authConfig,
    isAutoConfirmEnabled
  } = global.settings;
  const isBiometricAuthEnabled = selectIsBiometricAuthEnabled(global);
  const isNativeBiometricAuthEnabled = selectIsNativeBiometricAuthEnabled(global);
  return {
    isPasswordNumeric,
    isBiometricAuthEnabled,
    isNativeBiometricAuthEnabled,
    authConfig,
    isAutoConfirmEnabled
  };
})(PasswordForm)));
;// ./src/hooks/useAppTheme.ts


const useAppTheme_prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
function useAppTheme(currentTheme) {
  const [theme, setTheme] = useState(currentTheme === 'system' ? useAppTheme_prefersDark.matches ? 'dark' : 'light' : currentTheme);
  const handlePrefersColorSchemeChange = useLastCallback(() => {
    setTheme(() => {
      if (currentTheme === 'system') {
        return useAppTheme_prefersDark.matches ? 'dark' : 'light';
      }
      return currentTheme;
    });
  });
  teact_useEffect(() => {
    if (currentTheme !== 'system') return undefined;
    useAppTheme_prefersDark.addEventListener('change', handlePrefersColorSchemeChange);
    return () => {
      useAppTheme_prefersDark.removeEventListener('change', handlePrefersColorSchemeChange);
    };
  }, [currentTheme]);
  handlePrefersColorSchemeChange();
  return theme;
}
/* harmony default export */ const hooks_useAppTheme = (useAppTheme);
;// ./src/util/preloadImage.ts
const preloadedImageUrls = new Set();
function preloadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      preloadedImageUrls.add(url);
      resolve(img);
    };
    img.onerror = reject;
    img.src = url;
  });
}
;// ./src/components/ui/Image.tsx




function ImageComponent(_ref) {
  let {
    url,
    alt,
    loading,
    isSlow,
    className,
    imageClassName,
    children,
    fallback
  } = _ref;
  const ref = teact_useRef();
  const [isLoaded, markIsLoaded] = hooks_useFlag(preloadedImageUrls.has(url));
  const [hasError, markHasError] = hooks_useFlag();
  const handleLoad = () => {
    markIsLoaded();
    preloadedImageUrls.add(url);
  };
  const shouldShowFallback = (hasError || !url) && !!fallback;
  const divRef = useMediaTransition(isLoaded || shouldShowFallback);
  return /*#__PURE__*/teact.createElement("div", {
    ref: divRef,
    className: className,
    style: isSlow ? 'transition-duration: 0.5s;' : undefined
  }, !shouldShowFallback ? /*#__PURE__*/teact.createElement("img", {
    ref: ref,
    src: url,
    alt: alt,
    loading: loading,
    className: imageClassName,
    draggable: false,
    referrerPolicy: "same-origin",
    onLoad: !isLoaded ? handleLoad : undefined,
    onError: markHasError
  }) : fallback, children);
}
/* harmony default export */ const ui_Image = (memo(ImageComponent));
;// ./src/components/appLocked/AppLocked.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AppLocked_module = ({"appLocked":"AppLocked-module__appLocked","innerContent":"AppLocked-module__innerContent","withPinPad":"AppLocked-module__withPinPad","appLockedFixed":"AppLocked-module__appLockedFixed","title":"AppLocked-module__title","passwordFormContent":"AppLocked-module__passwordFormContent","pinPadContent":"AppLocked-module__pinPadContent","logo":"AppLocked-module__logo","passwordInputWrapper":"AppLocked-module__passwordInputWrapper","appLockedWrapper":"AppLocked-module__appLockedWrapper"});
;// ./src/assets/logoCoreWallet.svg
const logoCoreWallet_namespaceObject = __webpack_require__.p + "logoCoreWallet.7209423c2390840b4a91.svg";
;// ./src/assets/logoDark.svg
const logoDark_namespaceObject = __webpack_require__.p + "logoDark.db78fa7a76eea19a30e7.svg";
;// ./src/assets/logoLight.svg
const logoLight_namespaceObject = __webpack_require__.p + "logoLight.c9797ad4583a416a16c9.svg";
;// ./src/components/appLocked/Logo.tsx









function Logo(_ref) {
  let {
    theme
  } = _ref;
  const lang = hooks_useLang();
  const appTheme = hooks_useAppTheme(theme);
  const logoPath = src_config/* IS_CORE_WALLET */.TI6 ? logoCoreWallet_namespaceObject : appTheme === 'light' ? logoLight_namespaceObject : logoDark_namespaceObject;
  return /*#__PURE__*/teact.createElement("div", {
    className: AppLocked_module.logo
  }, /*#__PURE__*/teact.createElement(ui_Image, {
    className: AppLocked_module.logo,
    imageClassName: AppLocked_module.logo,
    url: logoPath,
    alt: lang('Logo')
  }));
}
/* harmony default export */ const appLocked_Logo = (memo(Logo));
;// ./src/components/appLocked/PasswordFormSlide.tsx












const PINPAD_RESET_DELAY = 300;
function PasswordFormSlide(_ref) {
  let {
    isActive,
    ref,
    theme,
    innerContentTopPosition = 0,
    shouldHideBiometrics,
    onSubmit
  } = _ref;
  const lang = hooks_useLang();
  const {
    setIsPinAccepted
  } = getActions();
  const [passwordError, setPasswordError] = useState('');
  const handleSubmitPassword = useLastCallback(async password => {
    const result = await (0,api/* callApi */.p)('verifyPassword', password);
    if (!result) {
      setPasswordError('Wrong password, please try again.');
      return;
    }
    if (getDoesUsePinPad()) {
      setIsPinAccepted();
      await vibrateOnSuccess(true);
    }
    onSubmit();
  });
  const handlePasswordChange = useLastCallback(() => setPasswordError(''));
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: AppLocked_module.innerContent,
    style: `--position-top: ${innerContentTopPosition}px;`
  }, /*#__PURE__*/teact.createElement(ui_PasswordForm, {
    isActive: !isActive ? false : getIsNativeBiometricAuthSupported() ? !shouldHideBiometrics : true,
    noAnimatedIcon: true,
    forceBiometricsInMain: true,
    error: passwordError,
    resetStateDelayMs: PINPAD_RESET_DELAY,
    operationType: "unlock",
    containerClassName: buildClassName(AppLocked_module.passwordFormContent, 'custom-scroll'),
    pinPadClassName: AppLocked_module.pinPadContent,
    inputWrapperClassName: AppLocked_module.passwordInputWrapper,
    submitLabel: lang('Unlock'),
    onSubmit: handleSubmitPassword,
    onUpdate: handlePasswordChange
  }, /*#__PURE__*/teact.createElement(appLocked_Logo, {
    theme: theme
  }), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(AppLocked_module.title, 'rounded-font')
  }, src_config/* APP_NAME */.C39)));
}
/* harmony default export */ const appLocked_PasswordFormSlide = (memo(PasswordFormSlide));
;// ./src/components/appLocked/UnlockButtonSlide.tsx







function UnlockButtonSlide(_ref) {
  let {
    ref,
    theme,
    innerContentTopPosition = 0,
    handleChangeSlideForBiometricAuth
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: AppLocked_module.innerContent,
    style: `--position-top: ${innerContentTopPosition}px;`
  }, /*#__PURE__*/teact.createElement(appLocked_Logo, {
    theme: theme
  }), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(AppLocked_module.title, 'rounded-font')
  }, src_config/* APP_NAME */.C39), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    onClick: handleChangeSlideForBiometricAuth
  }, lang('Unlock')));
}
/* harmony default export */ const appLocked_UnlockButtonSlide = (memo(UnlockButtonSlide));
;// ./src/components/appLocked/AppLocked.tsx


























const WINDOW_EVENTS_LATENCY = 5000;
const INTERVAL_CHECK_PERIOD = 5000;
const ACTIVATION_EVENT_NAMES = ['focus',
// For Web
'mousemove',
// For Web
'touch',
// For Capacitor
'wheel', 'keydown'];
// `capture: true` is necessary because otherwise a `stopPropagation` call inside the main UI will prevent the event
// from getting to the listeners inside `AppLocked`.
const ACTIVATION_EVENT_OPTIONS = {
  capture: true
};
var SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["button"] = 0] = "button";
  SLIDES[SLIDES["passwordForm"] = 1] = "passwordForm";
  return SLIDES;
}(SLIDES || {});
const [getActivitySignal, setActivitySignal] = createSignal(Date.now());
function reportAppLockActivityEvent() {
  setActivitySignal(Date.now());
}
function useAppLockState(autolockValue, isManualLockActive, canRender) {
  const isFirstRunRef = teact_useRef(true);
  const isLockedRef = teact_useRef(autolockValue !== 'never' || isManualLockActive);
  const lockReasonRef = teact_useRef();
  const forceUpdate = hooks_useForceUpdate();

  // For cases when `canRender` changes from `true` -> `false`, e.g. when all accounts are deleted
  if (isLockedRef.current && !canRender) {
    isLockedRef.current = false;
  }
  const lock = useLastCallback(() => {
    isLockedRef.current = true;
    forceUpdate();
  });
  const unlock = useLastCallback(() => {
    isLockedRef.current = false;
    lockReasonRef.current = undefined;
    forceUpdate();
  });

  // For case when on cold start the app was manually locked at the previous session, this should be treated as a auto lock.
  lockReasonRef.current = isManualLockActive && !(isFirstRunRef.current && autolockValue !== 'never') ? 'manual' : 'autolock';
  isFirstRunRef.current = false;
  return [!!isLockedRef.current, lock, unlock, lockReasonRef.current];
}
function useContentSlide(isNonNativeBiometricAuthEnabled, isLocked, lockReason) {
  const ref = teact_useRef();
  function getDefaultSlideForBiometricAuth() {
    return (isBackgroundModeActive() || lockReason === 'manual') && isNonNativeBiometricAuthEnabled ? SLIDES.button : SLIDES.passwordForm;
  }
  const [slideForBiometricAuth, setSlideForBiometricAuth] = useState(getDefaultSlideForBiometricAuth());

  // After the first rendering of the password form, it is necessary to remember the `top` position
  // so that when changing the height of the container, there is no shift in content.
  // This logic is only applicable to the two-slides mode except for TMA as it has a pin pad.
  const [innerContentTopPosition, setInnerContentTopPosition] = useState();
  const isFixedState = innerContentTopPosition !== undefined;
  const isFixingSlideEnv = !getDoesUsePinPad() && isNonNativeBiometricAuthEnabled;
  function fixSlide(force) {
    const innerContent = ref.current;
    if (innerContent && (!isFixedState || force) && isLocked && isFixingSlideEnv) {
      const top = innerContent.getBoundingClientRect().top;
      setInnerContentTopPosition(top);
    }
  }
  function unfixSlide() {
    setInnerContentTopPosition(undefined);
  }
  function refixSlide() {
    unfixSlide();
    requestAnimationFrame(() => fixSlide(true));
  }
  teact_useEffect(() => {
    fixSlide();
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, [isLocked]);
  const {
    height
  } = useWindowSize();
  teact_useEffect(() => {
    if (!isFixingSlideEnv) return;
    refixSlide();
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, [height]);
  return {
    ref,
    innerContentTopPosition,
    unfixSlide,
    slideForBiometricAuth,
    setSlideForBiometricAuth,
    getDefaultSlideForBiometricAuth
  };
}
function AppLocked(_ref) {
  let {
    isNonNativeBiometricAuthEnabled,
    autolockValue = 'never',
    theme,
    isManualLockActive,
    isAppLockEnabled,
    shouldHideBiometrics,
    canRender
  } = _ref;
  const {
    clearIsPinAccepted,
    submitAppLockActivityEvent,
    setIsManualLockActive,
    setIsAppLockActive
  } = getActions();
  const [isLocked, lock, unlock, lockReason] = useAppLockState(autolockValue, !!isManualLockActive, canRender);
  const [shouldRenderUi, showUi, hideUi] = hooks_useFlag(isLocked);
  const lastActivityTime = teact_useRef(Date.now());
  const {
    ref,
    innerContentTopPosition,
    unfixSlide,
    slideForBiometricAuth,
    setSlideForBiometricAuth,
    getDefaultSlideForBiometricAuth
  } = useContentSlide(isNonNativeBiometricAuthEnabled, isLocked, lockReason);
  const handleActivity = useLastCallback(() => {
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
      submitAppLockActivityEvent();
      return;
    }
    lastActivityTime.current = Date.now();
  });
  const handleActivityThrottled = useThrottledCallback(handleActivity, [handleActivity], WINDOW_EVENTS_LATENCY);
  const afterUnlockCallback = useLastCallback(() => {
    var _getInAppBrowser;
    hideUi();
    setSlideForBiometricAuth(getDefaultSlideForBiometricAuth());
    (_getInAppBrowser = getInAppBrowser()) === null || _getInAppBrowser === void 0 || _getInAppBrowser.show();
    clearIsPinAccepted();
    handleActivity();
    setIsManualLockActive({
      isActive: undefined,
      shouldHideBiometrics: undefined
    });
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) void esm_BottomSheet.show();
    unfixSlide();
    setIsAppLockActive({
      isActive: false
    });
    void vibrate();
  });
  const autolockPeriod = teact_useMemo(() => src_config/* AUTOLOCK_OPTIONS_LIST */.zTb.find(option => option.value === autolockValue).period, [autolockValue]);
  const {
    ref: transitionRef
  } = useShowTransition({
    isOpen: isLocked,
    noMountTransition: true,
    className: 'slow',
    onCloseAnimationEnd: afterUnlockCallback
  });
  teact_useEffect(() => {
    if (isLocked !== getGlobal().isAppLockActive) {
      setIsAppLockActive({
        isActive: !!isLocked
      });
    }
  }, [isLocked]);
  const forceLockApp = useLastCallback(() => {
    var _getInAppBrowser2;
    lock();
    showUi();
    if (document.activeElement) {
      document.activeElement.blur();
    }
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) void esm_BottomSheet.hide();
    void ((_getInAppBrowser2 = getInAppBrowser()) === null || _getInAppBrowser2 === void 0 ? void 0 : _getInAppBrowser2.hide());
    setSlideForBiometricAuth(getDefaultSlideForBiometricAuth());
    setIsAppLockActive({
      isActive: true
    });
  });
  const handleLock = useLastCallback(() => {
    if ((autolockValue !== 'never' || isManualLockActive) && canRender) forceLockApp();
  });
  if (src_config/* DEBUG */.Oig) window.lock = handleLock;
  if (isManualLockActive && !isLocked && !shouldRenderUi) handleLock();
  const handleChangeSlideForBiometricAuth = useLastCallback(() => {
    setSlideForBiometricAuth(SLIDES.passwordForm);
  });
  hooks_useEffectOnce(() => {
    for (const eventName of ACTIVATION_EVENT_NAMES) {
      window.addEventListener(eventName, handleActivityThrottled, ACTIVATION_EVENT_OPTIONS);
    }
    return () => {
      for (const eventName of ACTIVATION_EVENT_NAMES) {
        window.removeEventListener(eventName, handleActivityThrottled, ACTIVATION_EVENT_OPTIONS);
      }
    };
  });
  hooks_useEffectOnce(() => {
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return undefined;
    return getActivitySignal.subscribe(handleActivityThrottled);
  });
  const handleLockScreenHotkey = useLastCallback(e => {
    stopEvent(e);
    setIsManualLockActive({
      isActive: true,
      shouldHideBiometrics: true
    });
  });
  useHotkeys(teact_useMemo(() => isAppLockEnabled && !isLocked ? {
    'Ctrl+Shift+L': handleLockScreenHotkey,
    'Alt+Shift+L': handleLockScreenHotkey,
    'Meta+Shift+L': handleLockScreenHotkey,
    ...(windowEnvironment/* IS_ELECTRON */.cp && {
      'Mod+L': handleLockScreenHotkey
    })
  } : undefined, [isAppLockEnabled, isLocked]));
  teact_useEffect(() => {
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return undefined;
    const interval = setInterval(() => {
      if (isAppLockEnabled && !isLocked && Date.now() - lastActivityTime.current > autolockPeriod) {
        handleLock();
      }
    }, INTERVAL_CHECK_PERIOD);
    return () => clearInterval(interval);
  }, [isLocked, autolockPeriod, handleLock, isAppLockEnabled]);
  useBackgroundMode(undefined, handleChangeSlideForBiometricAuth);
  function renderTransitionContent(isActive) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(AppLocked_module.appLocked, innerContentTopPosition !== undefined && AppLocked_module.appLockedFixed, getDoesUsePinPad() && slideForBiometricAuth === SLIDES.passwordForm && AppLocked_module.withPinPad)
    }, slideForBiometricAuth === SLIDES.button && isNonNativeBiometricAuthEnabled ? /*#__PURE__*/teact.createElement(appLocked_UnlockButtonSlide, {
      ref: ref,
      theme: theme,
      innerContentTopPosition: innerContentTopPosition,
      handleChangeSlideForBiometricAuth: handleChangeSlideForBiometricAuth
    }) : /*#__PURE__*/teact.createElement(appLocked_PasswordFormSlide, {
      ref: ref,
      isActive: isActive,
      theme: theme,
      innerContentTopPosition: innerContentTopPosition,
      shouldHideBiometrics: !!shouldHideBiometrics,
      onSubmit: unlock
    }));
  }
  const transitionKey = Number(slideForBiometricAuth === SLIDES.passwordForm) + Number(shouldRenderUi) * 2;
  const handleUnlockIntent = isNonNativeBiometricAuthEnabled ? slideForBiometricAuth === SLIDES.passwordForm ? !src_config/* IS_TELEGRAM_APP */.tKX ? triggerPasswordFormHandleBiometrics : undefined : handleChangeSlideForBiometricAuth : undefined;
  useHotkeys(teact_useMemo(() => isAppLockEnabled && isLocked && handleUnlockIntent ? {
    Space: handleUnlockIntent,
    Enter: handleUnlockIntent,
    Escape: handleUnlockIntent
  } : undefined, [isAppLockEnabled, isLocked, handleUnlockIntent]));
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return undefined;
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    ref: transitionRef,
    name: isNonNativeBiometricAuthEnabled && src_config/* IS_TELEGRAM_APP */.tKX ? 'slideFade' : 'semiFade',
    onContainerClick: handleUnlockIntent,
    activeKey: transitionKey,
    className: AppLocked_module.appLockedWrapper,
    shouldCleanup: true
  }, shouldRenderUi ? renderTransitionContent : undefined);
}
/* harmony default export */ const appLocked_AppLocked = (memo(withGlobal(global => {
  const {
    autolockValue,
    isAppLockEnabled
  } = global.settings;
  const isPasswordPresent = selectIsPasswordPresent(global);
  const isBiometricAuthEnabled = selectIsBiometricAuthEnabled(global);
  const isNativeBiometricAuthEnabled = selectIsNativeBiometricAuthEnabled(global);
  const isNonNativeBiometricAuthEnabled = isBiometricAuthEnabled && (!isNativeBiometricAuthEnabled || src_config/* IS_TELEGRAM_APP */.tKX);
  return {
    isNonNativeBiometricAuthEnabled,
    autolockValue,
    canRender: Boolean(isAppLockEnabled && isPasswordPresent),
    isAppLockEnabled,
    theme: global.settings.theme,
    isManualLockActive: global.isManualLockActive,
    shouldHideBiometrics: global.appLockHideBiometrics
  };
})(AppLocked)));
;// ./src/global/actions/ui/misc.ts






















const APP_VERSION_URL = windowEnvironment/* IS_ANDROID_APP */.xy ? `${src_config/* IS_PRODUCTION */.p8S ? src_config/* PRODUCTION_URL */.yq6 : src_config/* BETA_URL */.DvZ}/version.txt` : 'version.txt';
addActionHandler('showActivityInfo', (global, actions, _ref) => {
  let {
    id
  } = _ref;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('showActivityInfo', {
      id
    });
    return undefined;
  }
  return updateCurrentAccountState(global, {
    currentActivityId: id
  });
});
addActionHandler('showAnyAccountTx', async (global, actions, _ref2) => {
  let {
    txId,
    accountId,
    network
  } = _ref2;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('showAnyAccountTx', {
      txId,
      accountId,
      network
    });
    return;
  }
  await Promise.all([closeAllOverlays(), switchAccount(global, accountId, network)]);
  actions.showActivityInfo({
    id: txId
  });
});
addActionHandler('showAnyAccountTokenActivity', async (global, actions, _ref3) => {
  let {
    slug,
    accountId,
    network
  } = _ref3;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('showAnyAccountTokenActivity', {
      slug,
      accountId,
      network
    });
    return;
  }
  await Promise.all([closeAllOverlays(), switchAccount(global, accountId, network)]);
  actions.showTokenActivity({
    slug
  });
});
addActionHandler('closeActivityInfo', (global, actions, _ref4) => {
  var _selectCurrentAccount;
  let {
    id
  } = _ref4;
  if (((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.currentActivityId) !== id) {
    return undefined;
  }
  return updateCurrentAccountState(global, {
    currentActivityId: undefined
  });
});
addActionHandler('addSavedAddress', (global, actions, _ref5) => {
  let {
    address,
    name,
    chain
  } = _ref5;
  const {
    savedAddresses = []
  } = selectCurrentAccountState(global) || {};
  return updateCurrentAccountState(global, {
    savedAddresses: [...savedAddresses, {
      address,
      name,
      chain
    }]
  });
});
addActionHandler('removeFromSavedAddress', (global, actions, _ref6) => {
  let {
    address,
    chain
  } = _ref6;
  const {
    savedAddresses = []
  } = selectCurrentAccountState(global) || {};
  const newSavedAddresses = savedAddresses.filter(item => !(item.address === address && item.chain === chain));
  return updateCurrentAccountState(global, {
    savedAddresses: newSavedAddresses
  });
});
addActionHandler('toggleTinyTransfersHidden', function (global, actions) {
  let {
    isEnabled
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return {
    ...global,
    settings: {
      ...global.settings,
      areTinyTransfersHidden: isEnabled
    }
  };
});
addActionHandler('setCurrentTokenPeriod', (global, actions, _ref7) => {
  let {
    period
  } = _ref7;
  return updateCurrentAccountState(global, {
    currentTokenPeriod: period
  });
});
addActionHandler('addAccount', async (global, actions, _ref8) => {
  let {
    method,
    password,
    isAuthFlow
  } = _ref8;
  const isPasswordPresent = selectIsPasswordPresent(global);
  const isMnemonicImport = method === 'importMnemonic';
  if (isPasswordPresent) {
    if (!isAuthFlow) {
      global = updateAccounts(global, {
        isLoading: true
      });
      setGlobal(global);
    }
    if (!(await (0,api/* callApi */.p)('verifyPassword', password))) {
      global = getGlobal();
      if (isAuthFlow) {
        global = updateAuth(global, {
          isLoading: undefined,
          error: 'Wrong password, please try again.'
        });
      } else {
        global = updateAccounts(getGlobal(), {
          isLoading: undefined,
          error: 'Wrong password, please try again.'
        });
      }
      setGlobal(global);
      return;
    }
    if (getDoesUsePinPad()) {
      global = setIsPinAccepted(getGlobal());
      setGlobal(global);
    }
    await vibrateOnSuccess(true);
  }
  global = getGlobal();
  if (isMnemonicImport || !isPasswordPresent) {
    global = {
      ...global,
      isAddAccountModalOpen: undefined
    };
  } else {
    global = updateAccounts(global, {
      isLoading: true
    });
  }
  setGlobal(global);
  if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    actions.addAccount2({
      method,
      password
    });
  } else {
    callActionInMain('addAccount2', {
      method,
      password
    });
  }
});
addActionHandler('addAccount2', (global, actions, _ref9) => {
  let {
    method,
    password
  } = _ref9;
  const isMnemonicImport = method === 'importMnemonic';
  const isPasswordPresent = selectIsPasswordPresent(global);
  const authState = isPasswordPresent ? isMnemonicImport ? AuthState.importWallet : undefined : getDoesUsePinPad() ? AuthState.createPin : windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh ? AuthState.createBiometrics : AuthState.createPassword;
  if (isMnemonicImport || !isPasswordPresent) {
    global = {
      ...global,
      appState: AppState.Auth
    };
  }
  global = updateAuth(global, {
    password,
    state: authState
  });
  global = clearCurrentTransfer(global);
  global = clearCurrentSwap(global);
  setGlobal(global);
  if (isMnemonicImport) {
    actions.startImportingWallet();
  } else {
    actions.startCreatingWallet();
  }
});
addActionHandler('renameAccount', (global, actions, _ref0) => {
  let {
    accountId,
    title
  } = _ref0;
  global = {
    ...global,
    shouldForceAccountEdit: false
  };
  setGlobal(renameAccount(global, accountId, title));
  actions.renameNotificationAccount({
    accountId
  });
});
addActionHandler('clearAccountError', global => {
  return updateAccounts(global, {
    error: undefined
  });
});
addActionHandler('openAddAccountModal', (global, _, props) => {
  const {
    forceAddingTonOnlyAccount
  } = props || {};
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !global.areSettingsOpen) {
    callActionInMain('openAddAccountModal', props);
    return;
  }
  global = {
    ...global,
    isAddAccountModalOpen: true
  };
  if (forceAddingTonOnlyAccount) {
    global = updateAuth(global, {
      forceAddingTonOnlyAccount
    });
  }
  setGlobal(global);
});
addActionHandler('closeAddAccountModal', (global, _, props) => {
  if (getDoesUsePinPad()) {
    global = clearIsPinAccepted(global);
  }
  global = updateAuth(global, {
    forceAddingTonOnlyAccount: undefined
  });
  global = {
    ...global,
    isAddAccountModalOpen: undefined
  };
  return global;
});
addActionHandler('changeNetwork', (global, actions, _ref1) => {
  let {
    network
  } = _ref1;
  return {
    ...global,
    settings: {
      ...global.settings,
      isTestnet: network === 'testnet'
    }
  };
});
addActionHandler('openSettings', global => {
  global = updateSettings(global, {
    state: SettingsState.Initial
  });
  return {
    ...global,
    areSettingsOpen: true
  };
});
addActionHandler('openSettingsWithState', (global, actions, _ref10) => {
  let {
    state
  } = _ref10;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !global.areSettingsOpen) {
    callActionInMain('openSettingsWithState', {
      state
    });
    return;
  }
  global = updateSettings(global, {
    state
  });
  setGlobal({
    ...global,
    areSettingsOpen: true
  });
});
addActionHandler('setSettingsState', (global, actions, _ref11) => {
  let {
    state
  } = _ref11;
  global = updateSettings(global, {
    state
  });
  setGlobal(global);
});
addActionHandler('closeSettings', global => {
  if (!global.currentAccountId) {
    return global;
  }
  return {
    ...global,
    areSettingsOpen: false
  };
});
addActionHandler('openBackupWalletModal', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openBackupWalletModal');
    return undefined;
  }
  return {
    ...global,
    isBackupWalletModalOpen: true
  };
});
addActionHandler('closeBackupWalletModal', global => {
  return {
    ...global,
    isBackupWalletModalOpen: undefined
  };
});
addActionHandler('toggleInvestorView', function (global, actions) {
  let {
    isEnabled
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return {
    ...global,
    settings: {
      ...global.settings,
      isInvestorViewEnabled: isEnabled
    }
  };
});
addActionHandler('changeLanguage', (global, actions, _ref12) => {
  let {
    langCode
  } = _ref12;
  return {
    ...global,
    settings: {
      ...global.settings,
      langCode
    }
  };
});
addActionHandler('toggleCanPlaySounds', function (global, actions) {
  let {
    isEnabled
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return {
    ...global,
    settings: {
      ...global.settings,
      canPlaySounds: isEnabled
    }
  };
});
addActionHandler('setLandscapeActionsActiveTabIndex', (global, actions, _ref13) => {
  let {
    index
  } = _ref13;
  return updateCurrentAccountState(global, {
    landscapeActionsActiveTabIndex: index
  });
});
addActionHandler('closeSecurityWarning', global => {
  return {
    ...global,
    settings: {
      ...global.settings,
      isSecurityWarningHidden: true
    }
  };
});
addActionHandler('toggleTokensWithNoCost', (global, actions, _ref14) => {
  let {
    isEnabled
  } = _ref14;
  return updateSettings(global, {
    areTokensWithNoCostHidden: isEnabled
  });
});
addActionHandler('toggleSortByValue', (global, actions, _ref15) => {
  let {
    isEnabled
  } = _ref15;
  return updateSettings(global, {
    isSortByValueEnabled: isEnabled
  });
});
addActionHandler('updateOrderedSlugs', (global, actions, _ref16) => {
  let {
    orderedSlugs
  } = _ref16;
  const accountSettings = selectCurrentAccountSettings(global);
  return updateCurrentAccountSettings(global, {
    ...accountSettings,
    orderedSlugs
  });
});
addActionHandler('toggleTokenVisibility', (global, actions, _ref17) => {
  let {
    slug,
    shouldShow
  } = _ref17;
  const accountSettings = selectCurrentAccountSettings(global) ?? {};
  const {
    alwaysShownSlugs = [],
    alwaysHiddenSlugs = []
  } = accountSettings;
  const alwaysShownSlugsSet = new Set(alwaysShownSlugs);
  const alwaysHiddenSlugsSet = new Set(alwaysHiddenSlugs);
  if (shouldShow) {
    alwaysHiddenSlugsSet.delete(slug);
    alwaysShownSlugsSet.add(slug);
  } else {
    alwaysShownSlugsSet.delete(slug);
    alwaysHiddenSlugsSet.add(slug);
  }
  return updateCurrentAccountSettings(global, {
    ...accountSettings,
    alwaysHiddenSlugs: Array.from(alwaysHiddenSlugsSet),
    alwaysShownSlugs: Array.from(alwaysShownSlugsSet)
  });
});
addActionHandler('deleteToken', (global, actions, _ref18) => {
  var _accountSettings$orde, _accountSettings$alwa, _accountSettings$alwa2, _accountSettings$impo;
  let {
    slug
  } = _ref18;
  const accountSettings = selectCurrentAccountSettings(global) ?? {};
  return updateCurrentAccountSettings(global, {
    ...accountSettings,
    orderedSlugs: (_accountSettings$orde = accountSettings.orderedSlugs) === null || _accountSettings$orde === void 0 ? void 0 : _accountSettings$orde.filter(s => s !== slug),
    alwaysHiddenSlugs: (_accountSettings$alwa = accountSettings.alwaysHiddenSlugs) === null || _accountSettings$alwa === void 0 ? void 0 : _accountSettings$alwa.filter(s => s !== slug),
    alwaysShownSlugs: (_accountSettings$alwa2 = accountSettings.alwaysShownSlugs) === null || _accountSettings$alwa2 === void 0 ? void 0 : _accountSettings$alwa2.filter(s => s !== slug),
    deletedSlugs: [...(accountSettings.deletedSlugs ?? []), slug],
    importedSlugs: (_accountSettings$impo = accountSettings.importedSlugs) === null || _accountSettings$impo === void 0 ? void 0 : _accountSettings$impo.filter(s => s !== slug)
  });
});
addActionHandler('checkAppVersion', global => {
  fetch(`${APP_VERSION_URL}?${Date.now()}`).then(response => response.text()).then(version => {
    version = version.trim();
    if (getIsAppUpdateNeeded(version, src_config/* APP_VERSION */.hl5)) {
      global = getGlobal();
      global = {
        ...global,
        isAppUpdateAvailable: true,
        latestAppVersion: version.trim()
      };
      setGlobal(global);
    }
  }).catch(err => {
    if (src_config/* DEBUG */.Oig) {
      // eslint-disable-next-line no-console
      console.error('[checkAppVersion failed] ', err);
    }
  });
});
addActionHandler('requestConfetti', global => {
  if (global.settings.animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp) return global;
  return {
    ...global,
    confettiRequestedAt: Date.now()
  };
});
addActionHandler('requestOpenQrScanner', async (global, actions) => {
  if ((0,windowEnvironment/* getIsMobileTelegramApp */.v3)()) {
    const webApp = telegram_getTelegramApp();
    webApp === null || webApp === void 0 || webApp.showScanQrPopup({}, data => {
      void vibrateOnSuccess();
      webApp.closeScanQrPopup();
      actions.handleQrCode({
        data
      });
    });
    return;
  }
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('requestOpenQrScanner');
    return;
  }
  let currentQrScan;
  if (global.currentTransfer.state === TransferState.Initial) {
    currentQrScan = {
      currentTransfer: global.currentTransfer
    };
  } else if (global.currentSwap.state === SwapState.Blockchain) {
    currentQrScan = {
      currentSwap: global.currentSwap
    };
  } else if (global.currentDomainLinking.state === DomainLinkingState.Initial) {
    currentQrScan = {
      currentDomainLinking: global.currentDomainLinking
    };
  }
  const {
    camera
  } = await BarcodeScanner.requestPermissions();
  const isGranted = camera === 'granted' || camera === 'limited';
  if (!isGranted) {
    actions.showNotification({
      message: getTranslation('Permission denied. Please grant camera permission to use the QR code scanner.')
    });
    return;
  }
  global = getGlobal();
  global = {
    ...global,
    isQrScannerOpen: true,
    currentQrScan
  };
  setGlobal(global);
});
addActionHandler('closeQrScanner', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('closeQrScanner');
  }
  return {
    ...global,
    isQrScannerOpen: undefined,
    currentQrScan: undefined
  };
});
addActionHandler('handleQrCode', async (global, actions, _ref19) => {
  let {
    data
  } = _ref19;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('handleQrCode', {
      data
    });
    return;
  }
  const {
    currentTransfer,
    currentSwap,
    currentDomainLinking
  } = global.currentQrScan || {};
  if (currentTransfer) {
    const transferParams = parseDeeplinkTransferParams(data, global);
    if (transferParams) {
      if ('error' in transferParams) {
        actions.showError({
          error: transferParams.error
        });
        // Not returning on error is intentional
      }
      setGlobal(updateCurrentTransfer(global, {
        ...currentTransfer,
        ...(0,iteratees/* omit */.cJ)(transferParams, ['error'])
      }));
    } else {
      // Assuming that the QR code content is a plain wallet address
      setGlobal(setCurrentTransferAddress(updateCurrentTransfer(global, currentTransfer), data));
    }
    return;
  }
  if (currentSwap || currentDomainLinking) {
    const linkParams = parseDeeplinkTransferParams(data, global);
    const toAddress = (linkParams === null || linkParams === void 0 ? void 0 : linkParams.toAddress) ?? data;
    if (currentSwap) {
      setGlobal(updateCurrentSwap(global, {
        ...currentSwap,
        toAddress
      }));
    } else {
      setGlobal(updateCurrentDomainLinking(global, {
        ...currentDomainLinking,
        walletAddress: toAddress
      }));
    }
    return;
  }
  if (await processDeeplink(data)) {
    return;
  }
  global = getGlobal();
  const plainAddressData = parsePlainAddressQr(global, data);
  if (plainAddressData) {
    actions.startTransfer({
      ...plainAddressData,
      isPortrait: getIsPortrait()
    });
    return;
  }
  actions.showDialog({
    title: 'This QR Code is not supported',
    message: ''
  });
});
addActionHandler('changeBaseCurrency', async (global, actions, _ref20) => {
  let {
    currency
  } = _ref20;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('changeBaseCurrency', {
      currency
    });
  }
  await (0,api/* callApi */.p)('setBaseCurrency', currency);
  await (0,api/* callApi */.p)('tryUpdateTokens');
  // Swap tokens will be merged with the new prices loaded in `tryUpdateTokens`
  await (0,api/* callApi */.p)('tryUpdateSwapTokens');
});
addActionHandler('setIsPinAccepted', global => {
  return setIsPinAccepted(global);
});
addActionHandler('clearIsPinAccepted', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    // Sometimes this action is called after the delegated bottom sheet is closed, e.g. on a component unmount.
    // The problem is, delegated bottom sheet doesn't synchronize the global state when it's closed, so the pin pad
    // can get stuck in the accepted state. To fix that, this action is called in the main WebView using a more reliable
    // mechanism.
    callActionInMain('clearIsPinAccepted');
  }
  return clearIsPinAccepted(global);
});
addActionHandler('openOnRampWidgetModal', (global, actions, _ref21) => {
  let {
    chain
  } = _ref21;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openOnRampWidgetModal', {
      chain
    });
    return;
  }
  setGlobal({
    ...global,
    chainForOnRampWidgetModal: chain
  });
});
addActionHandler('closeOnRampWidgetModal', global => {
  setGlobal({
    ...global,
    chainForOnRampWidgetModal: undefined
  });
});
addActionHandler('openMediaViewer', (global, actions, _ref22) => {
  let {
    mediaId,
    mediaType,
    txId,
    hiddenNfts,
    noGhostAnimation
  } = _ref22;
  const accountState = selectCurrentAccountState(global);
  const {
    byAddress
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {};
  const nft = byAddress === null || byAddress === void 0 ? void 0 : byAddress[mediaId];
  if (!nft) return undefined;
  return {
    ...global,
    mediaViewer: {
      mediaId,
      mediaType,
      txId,
      hiddenNfts,
      noGhostAnimation
    }
  };
});
addActionHandler('closeMediaViewer', global => {
  return {
    ...global,
    mediaViewer: {
      mediaId: undefined,
      mediaType: undefined
    }
  };
});
addActionHandler('setReceiveActiveTab', (global, actions, _ref23) => {
  let {
    chain
  } = _ref23;
  return updateCurrentAccountState(global, {
    receiveModalChain: chain
  });
});
addActionHandler('openReceiveModal', (global, actions, params) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openReceiveModal', params);
    return;
  }
  global = updateCurrentAccountState(global, {
    receiveModalChain: params === null || params === void 0 ? void 0 : params.chain
  });
  global = {
    ...global,
    isReceiveModalOpen: true
  };
  setGlobal(global);
});
addActionHandler('closeReceiveModal', global => {
  global = updateCurrentAccountState(global, {
    receiveModalChain: undefined
  });
  return {
    ...global,
    isReceiveModalOpen: undefined
  };
});
addActionHandler('openInvoiceModal', (global, actions, params) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('openInvoiceModal', params);
    return;
  }
  global = updateCurrentAccountState(global, {
    invoiceTokenSlug: params === null || params === void 0 ? void 0 : params.tokenSlug
  });
  setGlobal({
    ...global,
    isInvoiceModalOpen: true
  });
});
addActionHandler('changeInvoiceToken', (global, actions, params) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('changeInvoiceToken', params);
  }
  global = updateCurrentAccountState(global, {
    invoiceTokenSlug: params.tokenSlug
  });
  setGlobal(global);
});
addActionHandler('closeInvoiceModal', global => {
  global = updateCurrentAccountState(global, {
    invoiceTokenSlug: undefined
  });
  return {
    ...global,
    isInvoiceModalOpen: undefined
  };
});
addActionHandler('showIncorrectTimeError', (global, actions) => {
  actions.showDialog({
    message: getTranslation('Time synchronization issue. Please ensure your device\'s time settings are correct.')
  });
  return {
    ...global,
    isIncorrectTimeNotificationReceived: true
  };
});
addActionHandler('openLoadingOverlay', global => {
  setGlobal({
    ...global,
    isLoadingOverlayOpen: true
  });
});
addActionHandler('closeLoadingOverlay', global => {
  setGlobal({
    ...global,
    isLoadingOverlayOpen: undefined
  });
});
addActionHandler('clearAccountLoading', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('clearAccountLoading');
  }
  setGlobal(updateAccounts(global, {
    isLoading: undefined
  }));
});
addActionHandler('setIsAccountLoading', (global, actions, _ref24) => {
  let {
    isLoading
  } = _ref24;
  setGlobal(updateAccounts(global, {
    isLoading
  }));
});
addActionHandler('authorizeDiesel', global => {
  const address = selectCurrentAccount(global).addressByChain.ton;
  if (!address) throw new Error('TON address missing');
  setGlobal(updateCurrentAccountState(global, {
    isDieselAuthorizationStarted: true
  }));
  void openUrl(`https://t.me/${src_config/* BOT_USERNAME */.B9l}?start=auth-${address}`);
});
addActionHandler('submitAppLockActivityEvent', () => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('submitAppLockActivityEvent');
    return;
  }
  reportAppLockActivityEvent();
});
addActionHandler('closeAnyModal', () => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('closeAnyModal');
    return;
  }
  closeModal();
});
addActionHandler('openExplore', global => {
  return {
    ...global,
    isExploreOpen: true
  };
});
addActionHandler('closeExplore', global => {
  return {
    ...global,
    isExploreOpen: undefined
  };
});
addActionHandler('openFullscreen', global => {
  setGlobal({
    ...global,
    isFullscreen: true
  });
  void vibrate();
});
addActionHandler('closeFullscreen', global => {
  setGlobal({
    ...global,
    isFullscreen: undefined
  });
  void vibrate();
});
addActionHandler('setIsSensitiveDataHidden', (global, actions, _ref25) => {
  let {
    isHidden
  } = _ref25;
  setGlobal(updateSettings(global, {
    isSensitiveDataHidden: isHidden ? true : undefined
  }));
  void vibrate();
});
addActionHandler('setIsAppLockActive', (global, actions, _ref26) => {
  let {
    isActive
  } = _ref26;
  if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
    callActionInNative('setIsAppLockActive', {
      isActive
    });
  }
  setGlobal({
    ...global,
    isAppLockActive: isActive || undefined
  });
});
addActionHandler('switchAccountAndOpenUrl', async (global, actions, payload) => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('switchAccountAndOpenUrl', payload);
    return;
  }
  await Promise.all([
  // The browser is closed before opening the new URL, because otherwise the browser won't apply the new
  // parameters from `payload`. It's important to wait for `closeAllOverlays` to finish, because until the in-app
  // browser is closed, it won't open again.
  closeAllOverlays(), payload.accountId && switchAccount(global, payload.accountId, payload.network)]);
  await openDeeplinkOrUrl(payload.url, payload);
});
addActionHandler('switchToWallet', (global, actions) => {
  const {
    areSettingsOpen,
    isExploreOpen
  } = global;
  const accountState = selectCurrentAccountState(global);
  const areAssetsActive = (accountState === null || accountState === void 0 ? void 0 : accountState.activeContentTab) === ContentTab.Assets;
  const isWalletTabActive = !isExploreOpen && !areSettingsOpen;
  actions.closeExplore(undefined, {
    forceOnHeavyAnimation: true
  });
  actions.closeSettings(undefined, {
    forceOnHeavyAnimation: true
  });
  if (!areAssetsActive && isWalletTabActive) {
    actions.selectToken({
      slug: undefined
    }, {
      forceOnHeavyAnimation: true
    });
    actions.setActiveContentTab({
      tab: ContentTab.Assets
    }, {
      forceOnHeavyAnimation: true
    });
  }
});
addActionHandler('switchToExplore', (global, actions) => {
  const {
    isExploreOpen
  } = global;
  if (isExploreOpen) {
    actions.closeSiteCategory(undefined, {
      forceOnHeavyAnimation: true
    });
  }
  actions.closeSettings(undefined, {
    forceOnHeavyAnimation: true
  });
  actions.openExplore(undefined, {
    forceOnHeavyAnimation: true
  });
});
addActionHandler('switchToSettings', (global, actions) => {
  actions.closeExplore(undefined, {
    forceOnHeavyAnimation: true
  });
  actions.openSettings(undefined, {
    forceOnHeavyAnimation: true
  });
});
addActionHandler('setAppLayout', (global, actions, _ref27) => {
  let {
    layout
  } = _ref27;
  if (windowEnvironment/* IS_ELECTRON */.cp) {
    var _window$electron;
    void ((_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.changeAppLayout(layout));
  } else {
    void (0,api/* callApi */.p)('setAppLayout', layout);
  }
});
;// ./src/global/actions/ui/dapps.ts







addActionHandler('clearDappConnectRequestError', global => {
  global = clearDappConnectRequestError(global);
  setGlobal(global);
});
addActionHandler('showDappTransferTransaction', (global, actions, payload) => {
  const {
    transactionIdx
  } = payload;
  global = updateCurrentDappTransfer(global, {
    state: TransferState.Confirm,
    viewTransactionOnIdx: transactionIdx
  });
  setGlobal(global);
});
addActionHandler('setDappTransferScreen', (global, actions, payload) => {
  const {
    state
  } = payload;
  global = updateCurrentDappTransfer(global, {
    state
  });
  setGlobal(global);
});
addActionHandler('submitDappTransferConfirm', async (global, actions) => {
  const inMemoryPassword = await getInMemoryPassword();
  global = getGlobal();
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateCurrentDappTransfer(global, {
      state: TransferState.ConnectHardware
    });
    setGlobal(global);
  } else if (inMemoryPassword) {
    global = updateCurrentDappTransfer(global, {
      isLoading: true
    });
    setGlobal(global);
    actions.submitDappTransfer({
      password: inMemoryPassword
    });
  } else {
    global = updateCurrentDappTransfer(global, {
      state: TransferState.Password
    });
    setGlobal(global);
  }
});
addActionHandler('clearDappTransferError', global => {
  global = updateCurrentDappTransfer(global, {
    error: undefined
  });
  setGlobal(global);
});
addActionHandler('openBrowser', (global, actions, _ref) => {
  let {
    url,
    title,
    subtitle
  } = _ref;
  global = {
    ...global,
    currentBrowserOptions: {
      url,
      title,
      subtitle
    }
  };
  setGlobal(global);
});
addActionHandler('closeBrowser', global => {
  global = {
    ...global,
    currentBrowserOptions: undefined
  };
  setGlobal(global);
});
addActionHandler('addSiteToBrowserHistory', (global, actions, _ref2) => {
  let {
    url
  } = _ref2;
  const accountState = selectCurrentAccountState(global);
  const newHistory = (0,iteratees/* unique */.Am)([url, ...((accountState === null || accountState === void 0 ? void 0 : accountState.browserHistory) || [])]).slice(0, src_config/* BROWSER_HISTORY_LIMIT */.uSm);
  global = updateCurrentAccountState(global, {
    browserHistory: newHistory
  });
  setGlobal(global);
});
addActionHandler('removeSiteFromBrowserHistory', (global, actions, _ref3) => {
  var _accountState$browser;
  let {
    url
  } = _ref3;
  const accountState = selectCurrentAccountState(global);
  const newHistory = accountState === null || accountState === void 0 || (_accountState$browser = accountState.browserHistory) === null || _accountState$browser === void 0 ? void 0 : _accountState$browser.filter(currentUrl => currentUrl !== url);
  global = updateCurrentAccountState(global, {
    browserHistory: newHistory !== null && newHistory !== void 0 && newHistory.length ? newHistory : undefined
  });
  setGlobal(global);
});
addActionHandler('updateDappLastOpenedAt', (global, actions, _ref4) => {
  let {
    url
  } = _ref4;
  const {
    dappLastOpenedDatesByUrl
  } = selectCurrentAccountState(global);
  const newDates = {
    ...dappLastOpenedDatesByUrl,
    [url]: Date.now()
  };
  global = updateCurrentAccountState(global, {
    dappLastOpenedDatesByUrl: newDates
  });
  setGlobal(global);
});
addActionHandler('openSiteCategory', (global, actions, _ref5) => {
  let {
    id
  } = _ref5;
  return updateCurrentAccountState(global, {
    currentSiteCategoryId: id
  });
});
addActionHandler('closeSiteCategory', global => {
  return updateCurrentAccountState(global, {
    currentSiteCategoryId: undefined
  });
});
addActionHandler('closeDappTransfer', global => {
  global = updateCurrentDappTransfer(global, {
    state: TransferState.None
  });
  setGlobal(global);
});
addActionHandler('setDappSignDataScreen', (global, actions, payload) => {
  const {
    state
  } = payload;
  return updateCurrentDappSignData(global, {
    state
  });
});
addActionHandler('submitDappSignDataConfirm', async (global, actions) => {
  const inMemoryPassword = await getInMemoryPassword();
  global = getGlobal();
  if (inMemoryPassword) {
    global = updateCurrentDappSignData(global, {
      isLoading: true
    });
    setGlobal(global);
    actions.submitDappSignData({
      password: inMemoryPassword
    });
  } else {
    global = updateCurrentDappSignData(global, {
      state: SignDataState.Password
    });
    setGlobal(global);
  }
});
addActionHandler('clearDappSignDataError', global => {
  return updateCurrentDappSignData(global, {
    error: undefined
  });
});
addActionHandler('closeDappSignData', global => {
  return updateCurrentDappSignData(global, {
    state: SignDataState.None
  });
});
// EXTERNAL MODULE: ./src/util/ledger/tab.ts
var tab = __webpack_require__(51915);
// EXTERNAL MODULE: ./src/util/ledger/utils.ts
var utils = __webpack_require__(59301);
;// ./src/global/actions/ui/hardware.ts











// There is no long-term Ledger connection state in the application. Every time the application needs to interact with
// a Ledger device, it ensures the device is connected using the <LedgerConnect> component, and communicates with the
// device immediately after that.

const OPEN_LEDGER_TAB_DELAY = 500;
addActionHandler('initLedgerPage', global => {
  return {
    ...global,
    appState: AppState.Ledger
  };
});
addActionHandler('openHardwareWalletModal', global => {
  global = resetHardware(global);
  return {
    ...global,
    isHardwareModalOpen: true
  };
});
addActionHandler('closeHardwareWalletModal', global => {
  return {
    ...global,
    isHardwareModalOpen: false
  };
});
addActionHandler('initializeHardwareWalletModal', async (global, actions) => {
  const ledgerApi = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
  const {
    isBluetoothAvailable,
    isUsbAvailable
  } = await ledgerApi.detectAvailableTransports();
  const hasUsbDevice = await ledgerApi.hasUsbDevice();
  const availableTransports = [];
  if (isUsbAvailable) {
    availableTransports.push('usb');
  }
  if (isBluetoothAvailable) {
    availableTransports.push('bluetooth');
  }
  global = getGlobal();
  global = updateHardware(global, {
    availableTransports
  });
  if (availableTransports.length === 0) {
    setGlobal(global);
    if (src_config/* IS_CAPACITOR */.UMQ) {
      actions.showDialog({
        title: 'Bluetooth unavailable',
        message: '$bluetooth_enable_guide',
        buttons: {
          confirm: {
            title: 'Open Settings',
            action: 'openBluetoothSettings'
          },
          cancel: {
            title: 'Cancel'
          }
        }
      });
    } else {
      actions.showNotification({
        message: 'Ledger is not supported on this device.'
      });
    }
  } else if (availableTransports.length === 1) {
    setGlobal(global);

    // Chrome requires a user gesture before showing the WebHID permission dialog in extension tabs.
    if (!windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe) {
      actions.initializeHardwareWalletConnection({
        transport: availableTransports[0]
      });
    }
  } else {
    if (!hasUsbDevice) {
      global = updateHardware(global, {
        lastUsedTransport: 'bluetooth'
      });
    }
    setGlobal(global);
  }
});
addActionHandler('initializeHardwareWalletConnection', async (global, actions, params) => {
  await connectLedger(params.transport);
});
async function connectLedger(transport, noRetry, noRemoteTab) {
  let global = getGlobal();
  setGlobal(updateHardware(global, {
    hardwareState: HardwareConnectState.Connecting,
    hardwareWallets: undefined,
    isLedgerConnected: undefined,
    isTonAppConnected: undefined
  }));
  const ledgerApi = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
  const isLedgerConnected = await ledgerApi.connectLedger(transport);
  global = getGlobal();
  if (!isLedgerConnected) {
    var _global$hardware$avai;
    if (src_config/* IS_EXTENSION */.hL1 && !windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe && !noRemoteTab) {
      return connectLedgerViaRemoteTab(transport);
    }
    global = updateHardware(global, {
      isLedgerConnected: false,
      hardwareState: HardwareConnectState.Failed
    });
    if (transport === 'usb' && (_global$hardware$avai = global.hardware.availableTransports) !== null && _global$hardware$avai !== void 0 && _global$hardware$avai.includes('bluetooth')) {
      global = updateHardware(global, {
        lastUsedTransport: 'bluetooth'
      });
    }
    setGlobal(global);
    return;
  }
  setGlobal(updateHardware(global, {
    isLedgerConnected: true
  }));

  // The only thing needed from the remote tab is getting the user permission to use the HID device (see the
  // `openLedgerTab` description for more details). Successful connection means that the permission is granted.
  if (windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe) {
    return (0,tab/* closeThisTab */.ks)();
  }
  try {
    const isTonAppConnected = await ledgerApi.waitLedgerTonApp();
    global = getGlobal();
    if (!isTonAppConnected) {
      setGlobal(updateHardware(global, {
        isTonAppConnected: false,
        hardwareState: HardwareConnectState.Failed
      }));
      return;
    }
    setGlobal(updateHardware(global, {
      isTonAppConnected: true
    }));

    // todo: Load the wallets only during authentication
    const hardwareWallets = await getLedgerWallets(ledgerApi);
    const nextHardwareState = hardwareWallets.length === 1 ? HardwareConnectState.ConnectedWithSingleWallet : HardwareConnectState.ConnectedWithSeveralWallets;
    setGlobal(updateHardware(getGlobal(), {
      hardwareWallets,
      hardwareState: nextHardwareState,
      lastUsedTransport: transport
    }));
  } catch (err) {
    const isLedgerDisconnected = (0,utils/* isLedgerConnectionBroken */.HN)(err.name);
    if (isLedgerDisconnected && !noRetry) {
      return connectLedger(transport, true, noRemoteTab);
    }
    global = getGlobal();
    setGlobal(updateHardware(global, {
      isLedgerConnected: !isLedgerDisconnected,
      isTonAppConnected: isLedgerDisconnected ? undefined : global.hardware.isTonAppConnected,
      hardwareState: HardwareConnectState.Failed
    }));
    (0,logs/* logDebugError */.SJ)('connectHardwareWallet', err);
  }
}
async function connectLedgerViaRemoteTab(transport) {
  setGlobal(updateHardware(getGlobal(), {
    hardwareState: HardwareConnectState.WaitingForRemoteTab
  }));
  await (0,schedulers/* pause */.v7)(OPEN_LEDGER_TAB_DELAY);
  const id = await (0,tab/* openLedgerTab */.nm)();
  const popup = await chrome.windows.getCurrent();
  await new Promise(resolve => (0,tab/* onLedgerTabClose */.i6)(id, resolve));
  await chrome.windows.update(popup.id, {
    focused: true
  });
  await connectLedger(transport, false, true);
}
async function getLedgerWallets(ledgerApi) {
  const global = getGlobal();
  const network = selectCurrentNetwork(global);
  const lastIndex = selectLedgerAccountIndexToImport(global, network);
  const currentHardwareAddresses = selectAllHardwareAccounts(global, network).map(account => account.addressByChain.ton).filter(Boolean);
  const hardwareWallets = await ledgerApi.getNextLedgerWallets(network, lastIndex, currentHardwareAddresses);
  if ('error' in hardwareWallets) {
    getActions().showError({
      error: hardwareWallets.error
    });
    throw Error(hardwareWallets.error);
  }
  return hardwareWallets;
}
addActionHandler('resetHardwareWalletConnect', global => {
  return resetHardware(global);
});
addActionHandler('loadMoreHardwareWallets', async (global, actions, _ref) => {
  let {
    lastIndex
  } = _ref;
  const network = selectCurrentNetwork(global);
  const oldHardwareWallets = global.hardware.hardwareWallets ?? [];
  const ledgerApi = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
  const hardwareWallets = await ledgerApi.getNextLedgerWallets(network, lastIndex);
  global = getGlobal();
  if ('error' in hardwareWallets) {
    actions.showError({
      error: hardwareWallets.error
    });
    throw Error(hardwareWallets.error);
  }
  global = updateHardware(global, {
    hardwareWallets: oldHardwareWallets.concat(hardwareWallets)
  });
  setGlobal(global);
});
;// ./src/global/actions/ui/settings.ts










let prevGlobal;
addCallback(global => {
  if (!prevGlobal || !prevGlobal.settings) {
    prevGlobal = global;
    return;
  }
  const {
    settings: prevSettings
  } = prevGlobal;
  const {
    settings
  } = global;
  if (settings.theme !== prevSettings.theme) {
    switchTheme(settings.theme);
  }
  if (settings.langCode !== prevSettings.langCode) {
    void setLanguage(settings.langCode);
  }
  prevGlobal = global;
});
addActionHandler('setAppLockValue', (global, actions, _ref) => {
  let {
    value,
    isEnabled
  } = _ref;
  return {
    ...global,
    settings: {
      ...global.settings,
      autolockValue: value,
      isAppLockEnabled: isEnabled
    }
  };
});
addActionHandler('setIsManualLockActive', (global, actions, _ref2) => {
  let {
    isActive,
    shouldHideBiometrics
  } = _ref2;
  return {
    ...global,
    isManualLockActive: isActive,
    appLockHideBiometrics: shouldHideBiometrics
  };
});
addActionHandler('setIsAutoConfirmEnabled', (global, actions, _ref3) => {
  let {
    isEnabled
  } = _ref3;
  if (!isEnabled) {
    actions.setInMemoryPassword({
      password: undefined,
      force: true
    });
  }
  return {
    ...global,
    settings: {
      ...global.settings,
      isAutoConfirmEnabled: isEnabled || undefined
    }
  };
});
addActionHandler('setIsAllowSuspiciousActions', (global, actions, _ref4) => {
  let {
    isEnabled
  } = _ref4;
  const accountId = global.currentAccountId;
  return updateAccountSettings(global, accountId, {
    isAllowSuspiciousActions: isEnabled || undefined
  });
});
addActionHandler('setInMemoryPassword', (global, actions, _ref5) => {
  let {
    password,
    isFinalCall,
    force
  } = _ref5;
  // `global` is not loaded in the NBS until it's opened for the first time, so `isAutoConfirmEnabled` may be
  // incorrectly `undefined` when Auto Confirm is actually enabled. To mitigate that, we skip checking the setting
  // when `isFinalCall` is `true`, because in this case the action is fired by the main WebView only when Auto Confirm is enabled.
  if (!(global.settings.isAutoConfirmEnabled || isFinalCall || force)) {
    return global;
  }

  // If biometrics are enabled, we don't need to set the password in memory
  const isBiometricAuthEnabled = selectIsBiometricAuthEnabled(global);
  if (isBiometricAuthEnabled) {
    return global;
  }
  setInMemoryPasswordSignal(password);
  if (!isFinalCall) {
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
      void callActionInNative('setInMemoryPassword', {
        password,
        isFinalCall: true
      });
    }
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
      void callActionInMain('setInMemoryPassword', {
        password,
        isFinalCall: true
      });
    }
  }
  return global;
});
addActionHandler('openSettingsHardwareWallet', global => {
  global = resetHardware(global);
  global = updateSettings(global, {
    state: SettingsState.LedgerConnectHardware
  });
  setGlobal(global);
});
;// ./src/global/actions/ui/nfts.ts




addActionHandler('openNftCollection', (global, actions, _ref) => {
  let {
    address
  } = _ref;
  const accountId = global.currentAccountId;
  const accountState = accounts_selectAccountState(global, accountId);
  global = misc_updateAccountState(global, accountId, {
    nfts: {
      ...accountState.nfts,
      currentCollectionAddress: address
    }
  });
  return global;
});
addActionHandler('closeNftCollection', global => {
  const accountState = selectCurrentAccountState(global);
  global = updateCurrentAccountState(global, {
    nfts: {
      ...accountState.nfts,
      currentCollectionAddress: undefined
    },
    selectedNftsToHide: undefined
  });
  return global;
});
addActionHandler('selectNfts', (global, actions, _ref2) => {
  let {
    addresses
  } = _ref2;
  const accountId = global.currentAccountId;
  global = addToSelectedAddresses(global, accountId, addresses);
  setGlobal(global);
});
addActionHandler('selectAllNfts', (global, actions, _ref3) => {
  let {
    collectionAddress
  } = _ref3;
  const accountId = global.currentAccountId;
  const {
    blacklistedNftAddresses,
    whitelistedNftAddresses
  } = accounts_selectAccountState(global, accountId) || {};
  const whitelistedNftAddressesSet = new Set(whitelistedNftAddresses);
  const blacklistedNftAddressesSet = new Set(blacklistedNftAddresses);
  const {
    nfts: accountNfts
  } = accounts_selectAccountState(global, accountId);
  const nfts = Object.values(accountNfts.byAddress).filter(nft => (!nft.isHidden || whitelistedNftAddressesSet.has(nft.address)) && !blacklistedNftAddressesSet.has(nft.address) && (collectionAddress === undefined || nft.collectionAddress === collectionAddress));
  global = misc_updateAccountState(global, accountId, {
    nfts: {
      ...accountNfts,
      selectedAddresses: nfts.map(_ref4 => {
        let {
          address
        } = _ref4;
        return address;
      })
    }
  });
  setGlobal(global);
});
addActionHandler('clearNftSelection', (global, actions, _ref5) => {
  let {
    address
  } = _ref5;
  const accountId = global.currentAccountId;
  global = removeFromSelectedAddresses(global, accountId, address);
  setGlobal(global);
});
addActionHandler('clearNftsSelection', global => {
  const accountId = global.currentAccountId;
  const accountState = accounts_selectAccountState(global, accountId);
  global = misc_updateAccountState(global, accountId, {
    nfts: {
      ...accountState.nfts,
      selectedAddresses: []
    }
  });
  setGlobal(global);
});
addActionHandler('addCollectionTab', (global, actions, _ref6) => {
  let {
    collectionAddress,
    isAuto
  } = _ref6;
  const accountId = global.currentAccountId;
  const accountState = accounts_selectAccountState(global, accountId);
  const currentNfts = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {
    byAddress: {}
  };
  if (isAuto && collectionAddress === src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R && currentNfts.wasTelegramGiftsAutoAdded) {
    return global;
  }
  const existingCollectionTabs = currentNfts.collectionTabs || [];
  if (!existingCollectionTabs.includes(collectionAddress)) {
    global = misc_updateAccountState(global, accountId, {
      nfts: {
        ...currentNfts,
        collectionTabs: [...existingCollectionTabs, collectionAddress],
        ...(isAuto && collectionAddress === src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R && {
          wasTelegramGiftsAutoAdded: true
        })
      }
    });
  }
  return global;
});
addActionHandler('removeCollectionTab', (global, actions, _ref7) => {
  let {
    collectionAddress
  } = _ref7;
  const accountId = global.currentAccountId;
  const accountState = accounts_selectAccountState(global, accountId);
  const currentNfts = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {
    byAddress: {}
  };
  if (!currentNfts.collectionTabs) {
    return global;
  }
  global = misc_updateAccountState(global, accountId, {
    nfts: {
      ...currentNfts,
      collectionTabs: currentNfts.collectionTabs.filter(address => address !== collectionAddress)
    }
  });
  return global;
});
;// ./src/global/actions/ui/vesting.ts






addActionHandler('openVestingModal', global => {
  setGlobal({
    ...global,
    isVestingModalOpen: true
  });
});
addActionHandler('closeVestingModal', global => {
  setGlobal({
    ...global,
    isVestingModalOpen: undefined
  });
});
addActionHandler('startClaimingVesting', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('startClaimingVesting');
    return;
  }
  const accountId = global.currentAccountId;
  global = {
    ...global,
    isVestingModalOpen: undefined
  };
  global = updateVesting(global, accountId, {
    isConfirmRequested: true
  });
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateVesting(global, accountId, {
      unfreezeState: VestingUnfreezeState.ConnectHardware
    });
  } else {
    global = updateVesting(global, accountId, {
      unfreezeState: VestingUnfreezeState.Password
    });
  }
  setGlobal(global);
});
addActionHandler('cancelClaimingVesting', global => {
  const accountId = global.currentAccountId;
  global = updateVesting(global, accountId, {
    isConfirmRequested: undefined
  });
  setGlobal(global);
});
addActionHandler('clearVestingError', global => {
  const accountId = global.currentAccountId;
  global = updateVesting(global, accountId, {
    error: undefined
  });
  setGlobal(global);
});
;// ./src/global/actions/ui/tokens.ts





addActionHandler('rebuildOrderedSlugs', global => {
  const accountSettings = selectCurrentAccountSettings(global) ?? {};
  const {
    orderedSlugs = []
  } = accountSettings;
  const accountTokens = selectCurrentAccountTokens(global) ?? [];
  const allSlugs = accountTokens.map(_ref => {
    let {
      slug
    } = _ref;
    return slug;
  });
  const newOrderedSlugs = (0,iteratees/* unique */.Am)([...orderedSlugs, ...allSlugs]);
  if ((0,iteratees/* areSortedArraysEqual */.k)(orderedSlugs, newOrderedSlugs)) {
    return global;
  }
  return updateCurrentAccountSettings(global, {
    ...accountSettings,
    orderedSlugs: newOrderedSlugs
  });
});
addActionHandler('showTokenActivity', (global, actions, _ref2) => {
  let {
    slug
  } = _ref2;
  actions.selectToken({
    slug
  }, {
    forceOnHeavyAnimation: true
  });
  actions.setActiveContentTab({
    tab: ContentTab.Activity
  });
});
;// ./src/global/actions/ui/transfer.ts








addActionHandler('startTransfer', (global, actions, payload) => {
  var _global$currentTransf, _payload$nfts;
  const isOpen = global.currentTransfer.state !== TransferState.None;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && !isOpen) {
    callActionInMain('startTransfer', payload);
    return;
  }
  const {
    isPortrait,
    ...rest
  } = payload ?? {};
  const nftTokenSlug = Symbol('nft');
  const previousFeeTokenSlug = (_global$currentTransf = global.currentTransfer.nfts) !== null && _global$currentTransf !== void 0 && _global$currentTransf.length ? nftTokenSlug : global.currentTransfer.tokenSlug;
  const nextFeeTokenSlug = payload !== null && payload !== void 0 && (_payload$nfts = payload.nfts) !== null && _payload$nfts !== void 0 && _payload$nfts.length ? nftTokenSlug : payload === null || payload === void 0 ? void 0 : payload.tokenSlug;
  const shouldClearFee = nextFeeTokenSlug && nextFeeTokenSlug !== previousFeeTokenSlug;
  setGlobal(updateCurrentTransfer(global, {
    state: isPortrait ? TransferState.Initial : TransferState.None,
    error: undefined,
    ...(shouldClearFee ? {
      fee: undefined,
      realFee: undefined,
      diesel: undefined
    } : {}),
    ...rest
  }));
  if (!isPortrait) {
    actions.setLandscapeActionsActiveTabIndex({
      index: ActiveTab.Transfer
    });
  }
});
addActionHandler('changeTransferToken', (global, actions, _ref) => {
  let {
    tokenSlug,
    withResetAmount
  } = _ref;
  const {
    amount,
    tokenSlug: currentTokenSlug,
    nfts
  } = global.currentTransfer;
  if (!(nfts !== null && nfts !== void 0 && nfts.length) && tokenSlug === currentTokenSlug && !withResetAmount) {
    return;
  }
  const currentToken = currentTokenSlug ? global.tokenInfo.bySlug[currentTokenSlug] : undefined;
  const newToken = global.tokenInfo.bySlug[tokenSlug];
  if (withResetAmount) {
    global = updateCurrentTransfer(global, {
      amount: undefined
    });
  } else if (amount && (currentToken === null || currentToken === void 0 ? void 0 : currentToken.decimals) !== (newToken === null || newToken === void 0 ? void 0 : newToken.decimals)) {
    global = updateCurrentTransfer(global, {
      amount: (0,util_decimals/* fromDecimal */.UH)((0,util_decimals/* toDecimal */.nI)(amount, currentToken === null || currentToken === void 0 ? void 0 : currentToken.decimals), newToken === null || newToken === void 0 ? void 0 : newToken.decimals)
    });
  }
  setGlobal(updateCurrentTransfer(global, {
    tokenSlug,
    fee: undefined,
    realFee: undefined,
    diesel: undefined,
    nfts: undefined
  }));
});
addActionHandler('setTransferScreen', (global, actions, payload) => {
  const {
    state
  } = payload;
  return updateCurrentTransfer(global, {
    state
  });
});
addActionHandler('setTransferAmount', (global, actions, _ref2) => {
  let {
    amount
  } = _ref2;
  return updateCurrentTransfer(global, {
    amount
  });
});
addActionHandler('setTransferToAddress', (global, actions, _ref3) => {
  let {
    toAddress
  } = _ref3;
  return setCurrentTransferAddress(global, toAddress);
});
addActionHandler('setTransferComment', (global, actions, _ref4) => {
  let {
    comment
  } = _ref4;
  return updateCurrentTransfer(global, {
    comment
  });
});
addActionHandler('setTransferShouldEncrypt', (global, actions, _ref5) => {
  let {
    shouldEncrypt
  } = _ref5;
  return updateCurrentTransfer(global, {
    shouldEncrypt
  });
});
addActionHandler('submitTransferConfirm', async (global, actions) => {
  const inMemoryPassword = await getInMemoryPassword();
  global = getGlobal();
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateCurrentTransfer(global, {
      state: TransferState.ConnectHardware
    });
    setGlobal(global);
  } else if (inMemoryPassword) {
    global = updateCurrentTransfer(global, {
      isLoading: true
    });
    setGlobal(global);
    actions.submitTransfer({
      password: inMemoryPassword
    });
  } else {
    global = updateCurrentTransfer(global, {
      state: TransferState.Password
    });
    setGlobal(global);
  }
});
addActionHandler('clearTransferError', global => {
  setGlobal(updateCurrentTransfer(global, {
    error: undefined
  }));
});
addActionHandler('dismissTransferScamWarning', global => {
  if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
    callActionInNative('dismissTransferScamWarning');
  }
  global = updateCurrentTransfer(global, {
    scamWarningType: undefined
  });
  setGlobal(global);
});
addActionHandler('showTransferScamWarning', (global, actions, _ref6) => {
  let {
    type
  } = _ref6;
  global = updateCurrentTransfer(global, {
    scamWarningType: type
  });
  setGlobal(global);
});
;// ./src/global/actions/ui/shared.ts

addActionHandler('setTheme', (global, actions, _ref) => {
  let {
    theme
  } = _ref;
  return {
    ...global,
    settings: {
      ...global.settings,
      theme
    }
  };
});
addActionHandler('setAnimationLevel', (global, actions, _ref2) => {
  let {
    level
  } = _ref2;
  return {
    ...global,
    settings: {
      ...global.settings,
      animationLevel: level
    }
  };
});
;// ./src/global/actions/ui/notifications.ts







addActionHandler('tryAddNotificationAccount', (global, actions, _ref) => {
  let {
    accountId
  } = _ref;
  if (global.pushNotifications.isAvailable && Object.keys(selectAccounts(global) || {}).length <= src_config/* MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT */.vdF) {
    actions.createNotificationAccount({
      accountId
    });
  }
});
addActionHandler('renameNotificationAccount', (global, actions, _ref2) => {
  let {
    accountId
  } = _ref2;
  const {
    enabledAccounts,
    isAvailable
  } = global.pushNotifications;
  if (isAvailable && enabledAccounts !== null && enabledAccounts !== void 0 && enabledAccounts[accountId]) {
    actions.createNotificationAccount({
      accountId
    });
  }
});
addActionHandler('toggleNotificationAccount', (global, actions, _ref3) => {
  let {
    accountId
  } = _ref3;
  const {
    enabledAccounts,
    userToken,
    platform
  } = global.pushNotifications;
  if (!userToken || !platform) {
    return;
  }
  const isExists = enabledAccounts && enabledAccounts[accountId];
  if (!isExists && enabledAccounts && isKeyCountGreater(enabledAccounts, src_config/* MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT */.vdF - 1)) {
    return;
  }
  if (isExists) {
    actions.deleteNotificationAccount({
      accountId,
      withAbort: true
    });
  } else {
    actions.createNotificationAccount({
      accountId,
      withAbort: true
    });
  }
});
addActionHandler('deleteAllNotificationAccounts', async (global, actions, props) => {
  const {
    enabledAccounts,
    userToken
  } = global.pushNotifications;
  if (!enabledAccounts || !userToken) {
    return;
  }
  const accountIds = (props === null || props === void 0 ? void 0 : props.accountIds) || Object.keys(enabledAccounts);
  await (0,api/* callApi */.p)('unsubscribeNotifications', {
    userToken,
    addresses: Object.values(selectNotificationTonAddressesSlow(global, accountIds))
  });
  global = getGlobal();
  setGlobal(deleteAllNotificationAccounts(global));
});
// EXTERNAL MODULE: ./src/util/launchMediaWorkers.ts
var launchMediaWorkers = __webpack_require__(41074);
;// ./src/util/accentColor/constants.ts
const COLOR_COUNT = 2;
const QUALITY = 1;
const ACCENT_COLORS = {
  light: ['#31AFC7', '#35C759', '#FF9500', '#FF2C55', '#AF52DE', '#5856D7', '#73AAED', '#FFB07A', '#B76C78', '#9689D1', '#E572CC', '#6BA07A', '#338FCC', '#1FC863', '#929395', '#E4B102', '#000000'],
  dark: ['#3AB5CC', '#32D74B', '#FF9F0B', '#FF325A', '#BF5AF2', '#7977FF', '#73AAED', '#FFB07A', '#B76C78', '#9689D1', '#E572CC', '#6BA07A', '#338FCC', '#2CD36F', '#C3C5C6', '#DDBA00', '#FFFFFF']
};
const ACCENT_RADIOACTIVE_INDEX = 13;
const ACCENT_SILVER_INDEX = 14;
const ACCENT_GOLD_INDEX = 15;
const ACCENT_BNW_INDEX = 16;
const excludedIndices = new Set([ACCENT_RADIOACTIVE_INDEX, ACCENT_SILVER_INDEX, ACCENT_GOLD_INDEX, ACCENT_BNW_INDEX]);
const COLORS_TO_DETECT = ACCENT_COLORS.light.map((color, index) => ({
  color,
  index
})).filter(_ref => {
  let {
    index
  } = _ref;
  return !excludedIndices.has(index);
});
;// ./src/util/accentColor/index.ts






const HEX_80_PERCENT = 'CC';
const HEX_10_PERCENT = '1A';
function useAccentColor(elementRefOrBody, appTheme, accentColorIndex) {
  const accentColor = accentColorIndex ? ACCENT_COLORS[appTheme][accentColorIndex] : undefined;
  useLayoutEffect(() => {
    const element = elementRefOrBody === 'body' ? document.body : elementRefOrBody.current;
    if (!element) return;
    setExtraStyles(element, {
      '--color-accent': accentColor || 'inherit',
      '--color-accent-10o': accentColor ? `${accentColor}${HEX_10_PERCENT}` : 'inherit',
      '--color-accent-button-background': accentColor || 'inherit',
      '--color-accent-button-background-hover': accentColor ? `${accentColor}${HEX_80_PERCENT}` : 'inherit',
      '--color-accent-button-text': accentColor === '#FFFFFF' ? '#000000' : 'inherit',
      '--color-accent-button-text-hover': accentColor === '#FFFFFF' ? '#000000' : 'inherit'
    });
    toggleExtraClass(document.documentElement, 'is-white-accent', accentColor === '#FFFFFF');
  }, [elementRefOrBody, accentColor]);
}
async function getAccentColorIndexFromNft(nft) {
  const {
    mtwCardType,
    mtwCardBorderShineType
  } = nft.metadata;
  if (mtwCardBorderShineType === 'radioactive') {
    return ACCENT_RADIOACTIVE_INDEX;
  }
  if (mtwCardType === 'silver') {
    return ACCENT_SILVER_INDEX;
  }
  if (mtwCardType === 'gold') {
    return ACCENT_GOLD_INDEX;
  }
  if (mtwCardType === 'platinum' || mtwCardType === 'black') {
    return ACCENT_BNW_INDEX;
  }
  const src = getCardNftImageUrl(nft);
  if (!src) return undefined;
  try {
    return await (0,launchMediaWorkers/* requestMediaWorker */.M1)({
      name: 'offscreen-canvas:processNftImage',
      args: [src, QUALITY, COLOR_COUNT]
    }, Math.round(nft.index) % launchMediaWorkers/* MAX_WORKERS */.bP);
  } catch (error) {
    (0,logs/* logDebugError */.SJ)('getAccentColorIndexFromNft', error);
    return undefined;
  }
}
;// ./src/global/actions/ui/cards.ts







addActionHandler('openMintCardModal', global => {
  return updateMintCards(global, {
    state: MintCardState.Initial
  });
});
addActionHandler('closeMintCardModal', global => {
  return {
    ...global,
    currentMintCard: undefined
  };
});
addActionHandler('startCardMinting', (global, action, _ref) => {
  let {
    type
  } = _ref;
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateMintCards(global, {
      state: MintCardState.ConnectHardware
    });
  } else {
    global = updateMintCards(global, {
      state: MintCardState.Password
    });
  }
  return global;
});
addActionHandler('clearMintCardError', global => {
  return updateMintCards(global, {
    error: undefined
  });
});
addActionHandler('setCardBackgroundNft', (global, actions, _ref2) => {
  let {
    nft
  } = _ref2;
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('setCardBackgroundNft', {
      nft
    });
    return;
  }
  global = updateCurrentAccountSettings(global, {
    cardBackgroundNft: nft
  });
  setGlobal(global);
});
addActionHandler('clearCardBackgroundNft', global => {
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    callActionInMain('clearCardBackgroundNft');
    return;
  }
  global = updateCurrentAccountSettings(global, {
    cardBackgroundNft: undefined
  });
  setGlobal(global);
});
addActionHandler('installAccentColorFromNft', async (global, actions, _ref3) => {
  let {
    nft
  } = _ref3;
  const accentColorIndex = await getAccentColorIndexFromNft(nft);
  global = getGlobal();
  global = updateCurrentAccountSettings(global, {
    accentColorNft: nft,
    accentColorIndex
  });
  setGlobal(global);
});
addActionHandler('clearAccentColorFromNft', global => {
  return updateCurrentAccountSettings(global, {
    accentColorNft: undefined,
    accentColorIndex: undefined
  });
});
;// ./src/global/actions/ui/domains.ts








addActionHandler('openDomainRenewalModal', async (global, actions, _ref) => {
  var _selectCurrentAccount2;
  let {
    accountId,
    network,
    addresses
  } = _ref;
  if (accountId) {
    await Promise.all([closeAllOverlays(), switchAccount(global, accountId, network)]);
  }
  // After switching account, wait for nft domains to be fetched
  if (!(await (0,schedulers/* waitFor */.fm)(() => {
    var _selectCurrentAccount;
    return Boolean((_selectCurrentAccount = selectCurrentAccountState(getGlobal())) === null || _selectCurrentAccount === void 0 || (_selectCurrentAccount = _selectCurrentAccount.nfts) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.byAddress);
  }, 1000, 30))) {
    return;
  }
  global = getGlobal();
  const {
    byAddress
  } = ((_selectCurrentAccount2 = selectCurrentAccountState(global)) === null || _selectCurrentAccount2 === void 0 ? void 0 : _selectCurrentAccount2.nfts) || {};
  addresses = (addresses || []).filter(address => byAddress === null || byAddress === void 0 ? void 0 : byAddress[address]);
  if (!addresses.length) {
    return;
  }
  global = updateCurrentDomainRenewal(global, {
    state: DomainRenewalState.Initial,
    addresses
  });
  setGlobal(global);
});
addActionHandler('startDomainsRenewal', global => {
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateCurrentDomainRenewal(global, {
      state: DomainRenewalState.ConnectHardware
    });
  } else {
    global = updateCurrentDomainRenewal(global, {
      state: DomainRenewalState.Password
    });
  }
  return global;
});
addActionHandler('clearDomainsRenewalError', global => {
  return updateCurrentDomainRenewal(global, {
    error: undefined
  });
});
addActionHandler('cancelDomainsRenewal', global => {
  return {
    ...global,
    currentDomainRenewal: INITIAL_STATE.currentDomainRenewal
  };
});
addActionHandler('openDomainLinkingModal', (global, actions, _ref2) => {
  let {
    address
  } = _ref2;
  return updateCurrentDomainLinking(global, {
    state: DomainLinkingState.Initial,
    address
  });
});
addActionHandler('startDomainLinking', global => {
  if (selectIsHardwareAccount(global)) {
    global = resetHardware(global);
    global = updateCurrentDomainLinking(global, {
      state: DomainLinkingState.ConnectHardware
    });
  } else {
    global = updateCurrentDomainLinking(global, {
      state: DomainLinkingState.Password
    });
  }
  return global;
});
addActionHandler('clearDomainLinkingError', global => {
  return updateCurrentDomainLinking(global, {
    error: undefined
  });
});
addActionHandler('cancelDomainLinking', global => {
  return {
    ...global,
    currentDomainLinking: INITIAL_STATE.currentDomainLinking
  };
});
addActionHandler('setDomainLinkingWalletAddress', (global, actions, _ref3) => {
  let {
    address
  } = _ref3;
  return updateCurrentDomainLinking(global, {
    walletAddress: address
  });
});
;// ./src/global/actions/index.ts






























;// ./src/global/cache.ts
















const UPDATE_THROTTLE = src_config/* IS_CAPACITOR */.UMQ ? 500 : 5000;
const ACTIVITIES_LIMIT = 20;
const ACTIVITY_TOKENS_LIMIT = 30;
const STAKING_HISTORY_LIMIT = 30;
const updateCacheThrottled = (0,schedulers/* throttle */.nF)(() => onFullyIdle(() => updateCache()), UPDATE_THROTTLE, false);
const updateCacheForced = () => updateCache(true);
let isCaching = false;
let unsubscribeFromBeforeUnload;
let preloadedData;
function initCache() {
  if (src_config/* GLOBAL_STATE_CACHE_DISABLED */.UuV) {
    return;
  }
  addActionHandler('afterSignIn', setupCaching);
  addActionHandler('afterSignOut', (global, actions, payload) => {
    clearPoisoningCache();
    if (payload !== null && payload !== void 0 && payload.shouldReset) {
      preloadedData = (0,iteratees/* pick */.Up)(global, ['swapTokenInfo', 'tokenInfo', 'restrictions']);
      clearCaching();
      localStorage.removeItem(src_config/* GLOBAL_STATE_CACHE_KEY */.pge);
    }
  });
  addActionHandler('cancelCaching', clearCaching);
}
function setupCaching() {
  if (isCaching) return;
  isCaching = true;
  addCallback(updateCacheThrottled);
  unsubscribeFromBeforeUnload = (0,schedulers/* onBeforeUnload */.yu)(updateCacheForced, true);
  window.addEventListener('blur', updateCacheForced);
  updateCacheForced();
}
function clearCaching() {
  var _unsubscribeFromBefor;
  if (!isCaching) return;
  window.removeEventListener('blur', updateCacheForced);
  (_unsubscribeFromBefor = unsubscribeFromBeforeUnload) === null || _unsubscribeFromBefor === void 0 || _unsubscribeFromBefor();
  removeCallback(updateCacheThrottled);
  isCaching = false;
}
function loadCache(initialState) {
  if (src_config/* GLOBAL_STATE_CACHE_DISABLED */.UuV) {
    return initialState;
  }
  if (src_config/* DEBUG */.Oig) {
    // eslint-disable-next-line no-console
    console.time('global-state-cache-read');
  }
  const json = localStorage.getItem(src_config/* GLOBAL_STATE_CACHE_KEY */.pge);
  let cached = json ? JSON.parse(json, bigint/* bigintReviver */.bk) : undefined;
  if (src_config/* DEBUG */.Oig) {
    // eslint-disable-next-line no-console
    console.timeEnd('global-state-cache-read');
  }
  if (cached) {
    try {
      migrateCache(cached, initialState);
      loadMemoryCache(cached);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error(err);
      cached = undefined;
    }
  }
  return {
    ...initialState,
    ...preloadedData,
    ...cached
  };
}
function migrateCache(cached, initialState) {
  // Pre-fill settings with defaults
  cached.settings = {
    ...initialState.settings,
    ...cached.settings
  };
  if (cached.stateVersion === STATE_VERSION) {
    return;
  }

  // Migration to multi-accounts
  if (!cached.byAccountId) {
    cached.accounts = {
      byId: {
        [src_config/* MAIN_ACCOUNT_ID */.Kih]: {
          address: cached.addresses.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih],
          title: 'Main Account'
        }
      }
    };
    delete cached.addresses;
    cached.byAccountId = {};
    cached.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih] = {
      isBackupRequired: Boolean(cached.isBackupRequired),
      currentTokenSlug: cached.currentTokenSlug,
      currentTokenPeriod: cached.currentTokenPeriod
    };
    if ('balances' in cached) {
      cached.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih].balances = cached.balances.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih];
      delete cached.balances;
    }
    if ('transactions' in cached) {
      cached.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih].transactions = cached.transactions;
      delete cached.transactions;
    }
    if ('nfts' in cached) {
      cached.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih].nfts = cached.nfts;
      delete cached.nfts;
    }
    if ('savedAddresses' in cached) {
      cached.byAccountId[src_config/* MAIN_ACCOUNT_ID */.Kih].savedAddresses = cached.savedAddresses;
      delete cached.savedAddresses;
    }
    if ('backupWallet' in cached) {
      delete cached.backupWallet;
    }
  }
  if ((!cached.currentAccountId || !cached.byAccountId[cached.currentAccountId]) && Object.keys(cached.byAccountId).length) {
    cached.currentAccountId = Object.keys(cached.byAccountId)[0];
  }

  // Initializing the v1
  if (!cached.stateVersion && cached.accounts && !isEmptyObject(cached.accounts)) {
    cached.stateVersion = 1;
  }
  if (cached.stateVersion === 1) {
    var _cached$tokenInfo;
    cached.stateVersion = 2;
    if ((_cached$tokenInfo = cached.tokenInfo) !== null && _cached$tokenInfo !== void 0 && _cached$tokenInfo.bySlug) {
      cached.tokenInfo.bySlug = {
        toncoin: {
          ...cached.tokenInfo.bySlug.toncoin,
          decimals: src_config/* TONCOIN */.Tu9.decimals
        }
      };
    }
    if (cached.byAccountId) {
      Object.values(cached.byAccountId).forEach(accountState => {
        var _accountState$balance;
        if ((_accountState$balance = accountState.balances) !== null && _accountState$balance !== void 0 && _accountState$balance.bySlug) {
          accountState.balances.bySlug = (0,iteratees/* pick */.Up)(accountState.balances.bySlug, ['toncoin']);
        }
        if (accountState.transactions) {
          delete accountState.transactions;
        }
      });
    }
  }
  if (cached.stateVersion === 2) {
    cached.stateVersion = 3;

    // Normalization of MAIN_ACCOUNT_ID '0' => '0-ton-mainnet'
    const oldId = '0';
    const newId = src_config/* MAIN_ACCOUNT_ID */.Kih;
    if (cached.accounts && oldId in cached.accounts.byId) {
      if (cached.currentAccountId === oldId) {
        cached.currentAccountId = newId;
      }
      cached.accounts.byId[newId] = cached.accounts.byId[oldId];
      delete cached.accounts.byId[oldId];
      cached.byAccountId[newId] = cached.byAccountId[oldId];
      delete cached.byAccountId[oldId];
    }

    // Add testnet accounts
    if (cached.accounts) {
      for (const accountId of Object.keys(cached.accounts.byId)) {
        const testnetAccountId = (0,util_account/* buildAccountId */.zu)({
          ...(0,util_account/* parseAccountId */.cK)(accountId),
          network: 'testnet'
        });
        cached.accounts.byId[testnetAccountId] = (0,iteratees/* cloneDeep */.mg)(cached.accounts.byId[accountId]);
        cached.byAccountId[testnetAccountId] = {};
      }
    }
  }
  if (cached.stateVersion === 3) {
    cached.stateVersion = 4;
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        delete cached.byAccountId[accountId].transactions;
      }
    }
  }
  if (cached.stateVersion === 4) {
    cached.stateVersion = 5;
    cached.staking = {
      state: StakingState.None
    };
  }
  if (cached.stateVersion === 5) {
    cached.stateVersion = 6;
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        delete cached.byAccountId[accountId].transactions;
      }
    }
  }
  if (cached.stateVersion === 6) {
    cached.stateVersion = 7;
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        delete cached.byAccountId[accountId].transactions;
      }
    }
  }
  if (cached.stateVersion === 7) {
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        delete cached.byAccountId[accountId].backupWallet;
      }
    }
    cached.stateVersion = 8;
  }
  if (cached.stateVersion === 8) {
    if (cached.settings && windowEnvironment/* IS_ELECTRON */.cp) {
      cached.settings.isDeeplinkHookEnabled = true;
    }
    cached.stateVersion = 9;
  }
  function clearActivities() {
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        delete cached.byAccountId[accountId].activities;
      }
    }
  }
  if (cached.stateVersion === 9) {
    clearActivities();
    cached.stateVersion = 10;
  }
  if (cached.stateVersion === 10) {
    if (cached.settings.areTokensWithNoBalanceHidden === undefined) {
      cached.settings.areTokensWithNoBalanceHidden = true;
    }
    cached.stateVersion = 11;
  }
  if (cached.stateVersion === 11) {
    clearActivities();
    cached.stateVersion = 12;
  }
  if (cached.stateVersion === 12) {
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        delete cached.byAccountId[accountId].activities;
        const {
          balances
        } = cached.byAccountId[accountId];
        if (balances) {
          balances.bySlug = Object.entries(balances.bySlug).reduce((acc, _ref) => {
            let [slug, balance] = _ref;
            acc[slug] = BigInt(balance);
            return acc;
          }, {});
        }
      }
    }
    cached.stateVersion = 13;
  }
  if (cached.stateVersion === 13) {
    const {
      areTokensWithNoPriceHidden,
      areTokensWithNoBalanceHidden
    } = cached.settings;
    cached.settings.areTokensWithNoCostHidden = Boolean(areTokensWithNoPriceHidden || areTokensWithNoBalanceHidden);
    cached.stateVersion = 14;
  }
  if (cached.stateVersion >= 14 && cached.stateVersion <= 17) {
    clearActivities();
    cached.stateVersion = 18;
  }
  if (cached.stateVersion === 18 || cached.stateVersion === 19) {
    for (const accountId of Object.keys(cached.byAccountId)) {
      cached.byAccountId[accountId].currentTokenPeriod = '1D';
    }
    cached.stateVersion = 20;
  }
  if (cached.stateVersion >= 20 && cached.stateVersion <= 22) {
    clearActivities();
    cached.stateVersion = 23;
  }
  if (cached.stateVersion === 23) {
    if (!('isSortByValueEnabled' in cached.settings)) {
      cached.settings.isSortByValueEnabled = initialState.settings.isSortByValueEnabled;
    }
    cached.stateVersion = 24;
  }
  if (cached.stateVersion === 24) {
    if (cached.accounts) {
      clearActivities();
      for (const account of Object.values(cached.accounts.byId)) {
        account.addressByChain = {
          ton: account.address
        };
        delete account.address;
      }
    }
    cached.stateVersion = 25;
  }
  if (cached.stateVersion === 25) {
    if (cached.byAccountId) {
      for (const accountId of Object.keys(cached.byAccountId)) {
        const savedAddresses = cached.byAccountId[accountId].savedAddresses;
        if (savedAddresses && !('length' in savedAddresses)) {
          cached.byAccountId[accountId].savedAddresses = Object.keys(savedAddresses).map(address => ({
            name: savedAddresses[address],
            address,
            chain: 'ton'
          }));
        }
      }
    }
    cached.stateVersion = 26;
  }
  if (cached.stateVersion === 26) {
    clearActivities();
    cached.stateVersion = 27;
  }
  if (cached.stateVersion === 27) {
    delete cached.settings.dapps;
    cached.stateVersion = 28;
  }
  if (cached.stateVersion === 28) {
    const accountIds = Object.keys(cached.settings.byAccountId);
    for (const accountId of accountIds) {
      const exceptionSlugs = cached.settings.byAccountId[accountId].exceptionSlugs;
      if (cached.settings.areTokensWithNoCostHidden) {
        cached.settings.byAccountId[accountId].alwaysShownSlugs = exceptionSlugs;
      } else {
        cached.settings.byAccountId[accountId].alwaysHiddenSlugs = exceptionSlugs;
      }
    }
    cached.stateVersion = 29;
  }
  if (cached.stateVersion === 29) {
    cached.currentTransfer.tokenSlug = src_config/* TONCOIN */.Tu9.slug;
    cached.stateVersion = 30;
  }
  if (cached.stateVersion === 30) {
    clearActivities();
    cached.stateVersion = 31;
  }
  if (cached.stateVersion === 31) {
    if (cached.settings.autolockValue && cached.settings.autolockValue !== 'never') {
      cached.settings.isAppLockEnabled = true;
    }
    cached.stateVersion = 32;
  }
  if (cached.stateVersion >= 32 && cached.stateVersion <= 35) {
    clearActivities();
    cached.stateVersion = 36;
  }
  if (cached.stateVersion === 36) {
    for (const account of Object.values(((_cached$accounts = cached.accounts) === null || _cached$accounts === void 0 ? void 0 : _cached$accounts.byId) ?? {})) {
      var _cached$accounts;
      account.type = account.isHardware ? 'hardware' : 'mnemonic';
      delete account.isHardware;
    }
    cached.stateVersion = 37;
  }
  if (cached.stateVersion === 37) {
    for (const token of Object.values(cached.tokenInfo.bySlug)) {
      if (!token.price) token.price = 0;
      if (!token.percentChange24h) token.percentChange24h = 0;
      if (!token.priceUsd) token.priceUsd = 0;
      if (token.quote) delete token.quote;
    }
    cached.stateVersion = 38;
  }
  if (cached.stateVersion >= 38 && cached.stateVersion <= 41) {
    clearActivities();
    cached.stateVersion = 42;
  }
  if (cached.stateVersion === 41) {
    for (const accountId of Object.keys(cached.byAccountId)) {
      const accountState = cached.byAccountId[accountId];
      if (accountState.dappLastOpenedDatesByOrigin) {
        accountState.dappLastOpenedDatesByUrl = accountState.dappLastOpenedDatesByOrigin;
        delete accountState.dappLastOpenedDatesByOrigin;
      }
    }
    cached.stateVersion = 42;
  }
  if (cached.stateVersion >= 42 && cached.stateVersion <= 44) {
    clearActivities();
    cached.stateVersion = 45;
  }

  // When adding migration here, increase `STATE_VERSION`
}
function loadMemoryCache(cached) {
  if (!cached.currentAccountId) return;
  const {
    byId,
    newestActivitiesBySlug
  } = cached.byAccountId[cached.currentAccountId].activities || {};
  if (byId) {
    Object.values(byId).forEach(tx => {
      if (tx.kind === 'transaction' && tx.isIncoming) {
        updatePoisoningCache(tx);
      }
    });
  }
  if (newestActivitiesBySlug) {
    Object.values(newestActivitiesBySlug).forEach(activity => {
      if (activity.kind === 'transaction' && activity.isIncoming) {
        updatePoisoningCache(activity);
      }
    });
  }
}
const getUsedTokenSlugs = reducedGlobal => {
  const usedTokenSlugs = new Set(Object.keys(src_config/* TOKEN_INFO */.lfO));
  if (reducedGlobal.currentAccountId) {
    var _reducedGlobal$byAcco;
    const currentTokenSlug = (_reducedGlobal$byAcco = reducedGlobal.byAccountId[reducedGlobal.currentAccountId]) === null || _reducedGlobal$byAcco === void 0 ? void 0 : _reducedGlobal$byAcco.currentTokenSlug;
    if (currentTokenSlug) {
      usedTokenSlugs.add(currentTokenSlug);
    }
  }
  Object.values(reducedGlobal.byAccountId).forEach(state => {
    const {
      balances,
      activities,
      staking
    } = state;
    Object.keys((balances === null || balances === void 0 ? void 0 : balances.bySlug) ?? {}).forEach(slug => usedTokenSlugs.add(slug));
    Object.keys((activities === null || activities === void 0 ? void 0 : activities.byId) ?? {}).forEach(transactionId => {
      getActivityTokenSlugs(activities.byId[transactionId]).forEach(slug => usedTokenSlugs.add(slug));
    });
    Object.keys((activities === null || activities === void 0 ? void 0 : activities.idsBySlug) ?? {}).forEach(slug => usedTokenSlugs.add(slug));
    Object.keys((staking === null || staking === void 0 ? void 0 : staking.stateById) ?? {}).forEach(id => {
      usedTokenSlugs.add(staking.stateById[id].tokenSlug);
    });
  });
  return Array.from(usedTokenSlugs);
};
function getAccountTokenSlugs(global, accountId) {
  const {
    currentTokenSlug
  } = accounts_selectAccountState(global, accountId) ?? {};
  const tokenSlugs = (0,iteratees/* extractKey */.JY)(selectAccountTokens(global, accountId) ?? [], 'slug').slice(0, ACTIVITY_TOKENS_LIMIT);
  if (!tokenSlugs.includes(src_config/* TONCOIN */.Tu9.slug)) {
    tokenSlugs.push(src_config/* TONCOIN */.Tu9.slug);
  }
  if (currentTokenSlug && !tokenSlugs.includes(currentTokenSlug)) {
    tokenSlugs.push(currentTokenSlug);
  }
  return tokenSlugs;
}
function updateCache(force) {
  var _global$accounts;
  if (src_config/* GLOBAL_STATE_CACHE_DISABLED */.UuV || !isCaching || !force && heavyAnimation_getIsHeavyAnimating()) {
    return;
  }
  const global = getGlobal();
  const accountsById = ((_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.byId) || {};
  const reducedGlobal = {
    ...INITIAL_STATE,
    ...(0,iteratees/* pick */.Up)(global, ['currentAccountId', 'stateVersion', 'restrictions', 'pushNotifications', 'isFullscreen', 'isManualLockActive', 'stakingDefault']),
    accounts: {
      byId: accountsById
    },
    byAccountId: reduceByAccountId(global),
    settings: {
      ...global.settings,
      byAccountId: (0,iteratees/* pick */.Up)(global.settings.byAccountId, Object.keys(accountsById))
    }
  };
  const usedTokenSlugs = getUsedTokenSlugs(reducedGlobal);
  reducedGlobal.tokenInfo = {
    bySlug: (0,iteratees/* pickTruthy */._E)(global.tokenInfo.bySlug, usedTokenSlugs)
  };
  const json = JSON.stringify(reducedGlobal);
  localStorage.setItem(src_config/* GLOBAL_STATE_CACHE_KEY */.pge, json);
}
function reduceByAccountId(global) {
  return Object.entries(global.byAccountId).reduce((acc, _ref2) => {
    var _global$accounts2, _state$nfts, _state$stakingHistory;
    let [accountId, state] = _ref2;
    if (!((_global$accounts2 = global.accounts) !== null && _global$accounts2 !== void 0 && _global$accounts2.byId[accountId])) {
      return acc;
    }
    acc[accountId] = (0,iteratees/* pick */.Up)(state, ['isBackupRequired', 'currentTokenSlug', 'currentTokenPeriod', 'savedAddresses', 'staking', 'activeContentTab', 'landscapeActionsActiveTabIndex', 'browserHistory', 'blacklistedNftAddresses', 'whitelistedNftAddresses', 'dappLastOpenedDatesByUrl', 'dapps']);
    if ((_state$nfts = state.nfts) !== null && _state$nfts !== void 0 && _state$nfts.collectionTabs) {
      acc[accountId].nfts = {
        collectionTabs: state.nfts.collectionTabs,
        wasTelegramGiftsAutoAdded: state.nfts.wasTelegramGiftsAutoAdded
      };
    }
    const accountTokenSlugs = getAccountTokenSlugs(global, accountId);
    acc[accountId].balances = reduceAccountBalances(state.balances, accountTokenSlugs);
    acc[accountId].activities = reduceAccountActivities(state.activities, accountTokenSlugs);
    acc[accountId].staking = reduceAccountStaking(state.staking);
    acc[accountId].stakingHistory = (_state$stakingHistory = state.stakingHistory) !== null && _state$stakingHistory !== void 0 && _state$stakingHistory.length ? state.stakingHistory.slice(0, STAKING_HISTORY_LIMIT) : undefined;
    return acc;
  }, {});
}
function reduceAccountBalances(balances, tokenSlugs) {
  if (!(balances !== null && balances !== void 0 && balances.bySlug) || !tokenSlugs) return balances;
  return {
    ...balances,
    bySlug: (0,iteratees/* pick */.Up)(balances.bySlug, tokenSlugs)
  };
}
function reduceAccountActivities(activities, tokenSlugs) {
  const {
    idsBySlug,
    newestActivitiesBySlug,
    byId,
    idsMain
  } = activities || {};
  if (!tokenSlugs || !idsBySlug || !byId || !idsMain) return undefined;
  const reducedIdsMain = pickVisibleActivities(idsMain, byId);
  const reducedIdsBySlug = (0,iteratees/* mapValues */.LG)((0,iteratees/* pickTruthy */._E)(idsBySlug, tokenSlugs), ids => pickVisibleActivities(ids, byId));
  const reducedNewestActivitiesBySlug = newestActivitiesBySlug ? (0,iteratees/* pick */.Up)(newestActivitiesBySlug, tokenSlugs) : undefined;
  const reducedIds = Object.values(reducedIdsBySlug).concat(reducedIdsMain).flat();
  const reducedById = (0,iteratees/* pick */.Up)(byId, reducedIds);
  return {
    byId: reducedById,
    idsMain: reducedIdsMain,
    idsBySlug: reducedIdsBySlug,
    newestActivitiesBySlug: reducedNewestActivitiesBySlug
  };
}
function reduceAccountStaking(staking) {
  let {
    stakingId,
    stateById
  } = staking ?? {};
  if (stateById && !isEmptyObject(stateById)) {
    stateById = (0,iteratees/* filterValues */.lk)(stateById, getIsActiveStakingState);
    if (!stakingId || !(stakingId in stateById)) {
      var _Object$values$;
      stakingId = (_Object$values$ = Object.values(stateById)[0]) === null || _Object$values$ === void 0 ? void 0 : _Object$values$.id;
    }
  }
  return {
    ...staking,
    stateById,
    stakingId
  };
}
function pickVisibleActivities(ids, byId) {
  const result = [];
  let visibleIdCount = 0;
  ids.filter(id => shouldCacheActivity(id, byId)).forEach(id => {
    if (visibleIdCount === ACTIVITIES_LIMIT) return;
    if (!byId[id].shouldHide) {
      visibleIdCount += 1;
    }
    result.push(id);
  });
  return result;
}
function shouldCacheActivity(id, byId) {
  const activity = byId[id];
  return activity && !getIsTxIdLocal(id) && !getIsActivityPending(activity);
}
;// ./src/global/init.ts






if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
  initCache();
}
addActionHandler('init', (_, actions) => {
  const initial = (0,iteratees/* cloneDeep */.mg)(INITIAL_STATE);
  const global = loadCache(initial);
  if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
    return {
      ...initial,
      settings: {
        ...initial.settings,
        theme: global.settings.theme
      }
    };
  }
  if (windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe) {
    actions.initLedgerPage();
    return {
      ...initial,
      settings: {
        ...initial.settings,
        theme: global.settings.theme
      }
    };
  }
  if (selectHasSession(global)) {
    actions.afterSignIn();
  }
  return global;
});
;// ./src/util/bigintPatch.ts


// Fixes serialization of objects containing `bigint` values.
// Extracted to a separate file to avoid leaking into Extension Page Script.
// @ts-ignore
BigInt.prototype.toJSON = function toJSON() {
  return `${bigint/* BIGINT_PREFIX */.tH}${this.toString()}`;
};
;// ./src/util/betterView.ts



const TEST_INTERVAL = 5000; // 5 sec
const FRAMES_TO_TEST = 10;
const REDUCED_FPS = 35;
let isImproved = false;
function betterView() {
  if (!windowEnvironment/* IS_IOS */.pz) return;
  let interval;
  let lastFocusAt = Date.now();
  function setupInterval() {
    if (interval || isImproved) return;
    interval = window.setInterval(testAndImprove, TEST_INTERVAL);
  }
  window.addEventListener('focus', () => {
    const now = Date.now();
    if (now - lastFocusAt < 100) return; // iOS triggers two `focus` events for some reason
    lastFocusAt = now;
    setupInterval();
    void testAndImprove();
  });
  window.addEventListener('blur', () => {
    clearInterval(interval);
    interval = undefined;
  });
  if (document.hasFocus()) {
    setupInterval();
    void testAndImprove();
  }
}
async function testAndImprove() {
  const fps = await testFps();
  if (fps <= REDUCED_FPS) {
    improveView();
  }
}
function testFps() {
  return new Promise(resolve => {
    const frames = [];
    let lastFrameAt = performance.now();
    (0,animation/* animate */.i0)(() => {
      const now = performance.now();
      frames.push(now - lastFrameAt);
      lastFrameAt = now;
      if (frames.length === FRAMES_TO_TEST) {
        const mean = frames.sort()[Math.floor(frames.length / 2)];
        resolve(Math.round(1000 / mean));
        return false;
      }
      return true;
    }, schedulers/* fastRaf */.IJ);
  });
}
function improveView() {
  isImproved = true;
  const containerEl = document.createElement('div');
  containerEl.style.cssText = 'position: absolute; top: 0; left: 0; width: 0; height: 100%; overflow: hidden;';
  const boosterEl = document.createElement('div');
  const height = window.screen.height * 1.5;
  boosterEl.style.cssText = `width: 0; height: ${height}px; transform: translateX(100%); transition: transform 100ms;`;
  boosterEl.innerHTML = '&nbsp;';
  containerEl.appendChild(boosterEl);
  document.body.appendChild(containerEl);
  requestAnimationFrame(() => {
    boosterEl.addEventListener('transitionend', () => {
      containerEl.remove();
    });
    boosterEl.style.transform = '';
  });
}
;// ./src/electron/types.ts
let ElectronEvent = /*#__PURE__*/function (ElectronEvent) {
  ElectronEvent["DEEPLINK"] = "deeplink";
  ElectronEvent["UPDATE_ERROR"] = "update-error";
  ElectronEvent["UPDATE_DOWNLOADED"] = "update-downloaded";
  return ElectronEvent;
}({});
let ElectronAction = /*#__PURE__*/function (ElectronAction) {
  ElectronAction["CLOSE"] = "close";
  ElectronAction["MINIMIZE"] = "minimize";
  ElectronAction["MAXIMIZE"] = "maximize";
  ElectronAction["UNMAXIMIZE"] = "unmaximize";
  ElectronAction["GET_IS_MAXIMIZED"] = "get-is-maximized";
  ElectronAction["INSTALL_UPDATE"] = "install-update";
  ElectronAction["HANDLE_DOUBLE_CLICK"] = "handle-double-click";
  ElectronAction["TOGGLE_DEEPLINK_HANDLER"] = "toggle-deeplink-handler";
  ElectronAction["GET_IS_TOUCH_ID_SUPPORTED"] = "get-is-touch-id-supported";
  ElectronAction["ENCRYPT_PASSWORD"] = "encrypt-password";
  ElectronAction["DECRYPT_PASSWORD"] = "decrypt-password";
  ElectronAction["SET_IS_TRAY_ICON_ENABLED"] = "set-is-tray-icon-enabled";
  ElectronAction["GET_IS_TRAY_ICON_ENABLED"] = "get-is-tray-icon-enabled";
  ElectronAction["SET_IS_AUTO_UPDATE_ENABLED"] = "set-is-auto-update-enabled";
  ElectronAction["GET_IS_AUTO_UPDATE_ENABLED"] = "get-is-auto-update-enabled";
  ElectronAction["CHANGE_APP_LAYOUT"] = "change-app-layout";
  ElectronAction["RESTORE_STORAGE"] = "restore-storage";
  return ElectronAction;
}({});
;// ./src/util/electron.ts


function initElectron() {
  var _window$electron;
  (_window$electron = window.electron) === null || _window$electron === void 0 || _window$electron.on(ElectronEvent.DEEPLINK, _ref => {
    let {
      url
    } = _ref;
    void processDeeplink(url);
  });
}
;// ./src/util/focusScroll.ts




const focusScroller = createFocusScroller();
function isFocusable(element) {
  const tagName = element.tagName.toLowerCase();
  return tagName === 'input' || tagName === 'textarea' || tagName === 'select' || element.hasAttribute('contenteditable');
}

/**
 * Implements a custom scroll behavior on input focus. Designed for Capacitor platforms only. Meets the following goals:
 * - Allow to customize where to scroll the focused element to (via the `data-focus-scroll-position` HTML attribute).
 * - Scroll to show the focused element if it's behind by the virtual keyboard at the moment when it opens.
 * - Scroll to the focused element smoothly whenever possible.
 *
 * Warning: this functions requires the @capacitor/keyboard plugin to be activated. It also relies on a
 * `scroll-behavior: smooth;` style set in scrollable elements to implement smooth scrolling depending on the animation
 * preferences.
 */
function initFocusScrollController() {
  if (src_config/* IS_CAPACITOR */.UMQ) {
    initForCapacitor();
  } else if ((windowEnvironment/* IS_IOS */.pz || windowEnvironment/* IS_ANDROID */.Ni) && window.visualViewport) {
    initForVisualViewport();
  }
}
function initForCapacitor() {
  // `scrollToActiveElement` shouldn't be called in `keyboardWillShow` because the <body> size won't be patched yet, so
  // if the focused input at the bottom of the scrollable element, it won't be scrolled to.
  // `keyboardWillShow` could be used if the screen scroll height increased (instead of decreasing the <body> height).
  // Note: on iOS `onVirtualKeyboardOpen` calls the callback on every focus (it doesn't affect the scroll behavior).
  onVirtualKeyboardOpen(() => {
    // The manual focus scroller is activated only when the virtual keyboard is open it order to avoid a scroll when the
    // keyboard starts opening (it would scroll the 2nd time when the keyboard has opened).
    // This has a side effect of keeping the natural scroll behavior when a hardware keyboard is used (it's ok).
    focusScroller.install();
    scrollToActiveElement();
  });
  void __webpack_require__.e(/* import() */ 408).then(__webpack_require__.bind(__webpack_require__, 408)).then(_ref => {
    let {
      Keyboard
    } = _ref;
    void Keyboard.addListener('keyboardWillHide', focusScroller.uninstall);
  });
}
function initForVisualViewport() {
  const {
    visualViewport
  } = window;
  let viewportHeight = visualViewport.height;
  function handleViewportResize() {
    const newHeight = visualViewport.height;
    const activeElement = document.activeElement;

    // If the viewport height has decreased (the keyboard has opened) and the active element is focusable,
    // we activate the scroller and scroll to the element
    if (newHeight < viewportHeight && activeElement && isFocusable(activeElement)) {
      focusScroller.install();
      scrollToActiveElement();
    } else if (newHeight > viewportHeight) {
      // If the viewport height has increased (the keyboard has closed), we deactivate the scroller
      focusScroller.uninstall();
    }

    // The viewport height is updated for the next comparison
    viewportHeight = newHeight;
  }

  // In the TMA application on iOS, the VisualViewport behaves incorrectly,
  // not taking into account the height of the virtual keyboard. Therefore,
  // the height compensation is performed first (see the `windowSize` file),
  // and then the `handleViewportResize` processing should be executed.
  function delayedViewportResizeHandler() {
    (0,fasterdom/* requestMutation */.RK)(() => {
      (0,fasterdom/* requestMeasure */.YS)(handleViewportResize);
    });
  }
  visualViewport.addEventListener('resize', windowEnvironment/* IS_IOS */.pz && src_config/* IS_TELEGRAM_APP */.tKX ? delayedViewportResizeHandler : handleViewportResize);
}
function createFocusScroller() {
  let originalFocus;
  let isProgrammaticFocus = false;

  // Prevents native scroll for all `focus()` calls, because if the element is outside the viewport, `focus()` scrolls
  // the screen instantly to place the element in the middle (we don't want that).
  const patchedFocus = function focus(options) {
    var _originalFocus;
    isProgrammaticFocus = true;
    // Does not work on Android, because it doesn't support `preventScroll`
    (_originalFocus = originalFocus) === null || _originalFocus === void 0 || _originalFocus.call(this, {
      ...options,
      preventScroll: true
    });
  };
  const handleFocus = () => {
    // Because Android doesn't support `preventScroll`, we make the scroll instant to prevent excessive back-and-forth
    // scrolls. Doing it only for programmatic `focus` calls allows to have smooth scrolling when the user focuses the
    // input by tapping it while the keyboard is open.
    scrollToActiveElement(windowEnvironment/* IS_ANDROID */.Ni && isProgrammaticFocus);
    isProgrammaticFocus = false;
  };
  return {
    install() {
      if (originalFocus) {
        return; // This branch is reached when the scroller is already installed
      }
      originalFocus = HTMLElement.prototype.focus;
      HTMLElement.prototype.focus = patchedFocus;
      window.addEventListener('focusin', handleFocus);
    },
    uninstall() {
      if (!originalFocus) {
        return; // This branch is reached when the scroller is already uninstalled
      }
      HTMLElement.prototype.focus = originalFocus;
      originalFocus = undefined;
      window.removeEventListener('focusin', handleFocus);
    }
  };
}
function scrollToActiveElement(enforceInstantScroll) {
  const scrollTarget = document.activeElement;
  if (!scrollTarget) {
    return;
  }
  const scrollPosition = scrollTarget.dataset.focusScrollPosition ?? 'nearest';
  (0,fasterdom/* requestMeasure */.YS)(() => {
    scrollTarget.scrollIntoView({
      block: scrollPosition,
      behavior: enforceInstantScroll ? 'instant' : 'auto'
    });
  });
}
;// ./src/util/fonts.ts

function forceLoadFonts() {
  const el = document.createElement('div');
  el.textContent = 'â‚½';
  el.classList.add('visually-hidden');
  document.body.appendChild(el);
  (0,fasterdom/* requestMutation */.RK)(() => {
    document.body.removeChild(el);
  });
}
;// ./src/util/activeTabMonitor.ts


const IS_DISABLED = windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA || windowEnvironment/* IS_ELECTRON */.cp || src_config/* IS_TELEGRAM_APP */.tKX;
const INTERVAL = 2000;
const tabKey = String(Date.now() + Math.random());
if (!IS_DISABLED) {
  localStorage.setItem(src_config/* ACTIVE_TAB_STORAGE_KEY */.tOu, tabKey);
}
let callback;
const interval = window.setInterval(() => {
  if (!IS_DISABLED && callback && localStorage.getItem(src_config/* ACTIVE_TAB_STORAGE_KEY */.tOu) !== tabKey) {
    callback();
    clearInterval(interval);
  }
}, INTERVAL);
function setActiveTabChangeListener(_callback) {
  callback = _callback;
}
;// ./src/util/embeddedDappBridge/provider/useIFrameBridgeProvider.ts





function useIFrameBridgeProvider(pageUrl) {
  const cleanupRef = teact_useRef();
  const setupDappBridge = useLastCallback(e => {
    var _cleanupRef$current;
    (_cleanupRef$current = cleanupRef.current) === null || _cleanupRef$current === void 0 || _cleanupRef$current.call(cleanupRef);
    const iframe = e.target;
    cleanupRef.current = (0,createPostMessageInterface/* createReverseIFrameInterface */.kB)(buildBridgeApi(pageUrl), new URL(pageUrl).origin, iframe.contentWindow, src_config/* EMBEDDED_DAPP_BRIDGE_CHANNEL */.hUJ);
  });
  teact_useEffect(() => {
    if (!pageUrl) return;
    return () => {
      var _cleanupRef$current2;
      (_cleanupRef$current2 = cleanupRef.current) === null || _cleanupRef$current2 === void 0 || _cleanupRef$current2.call(cleanupRef);
    };
  }, [pageUrl]);
  return {
    setupDappBridge
  };
}
// EXTERNAL MODULE: ./node_modules/@capacitor/filesystem/dist/esm/definitions.js
var dist_esm_definitions = __webpack_require__(37448);
;// ./node_modules/@capacitor/filesystem/dist/esm/index.js

const Filesystem = (0,dist/* registerPlugin */.F3)('Filesystem', {
    web: () => __webpack_require__.e(/* import() */ 956).then(__webpack_require__.bind(__webpack_require__, 69956)).then(m => new m.FilesystemWeb()),
});


//# sourceMappingURL=index.js.map
;// ./node_modules/@capacitor/share/dist/esm/index.js

const Share = (0,dist/* registerPlugin */.F3)('Share', {
    web: () => __webpack_require__.e(/* import() */ 104).then(__webpack_require__.bind(__webpack_require__, 78104)).then(m => new m.ShareWeb()),
});


//# sourceMappingURL=index.js.map
;// ./src/util/share.ts
// The file is about sending data using the OS social sharing UI








async function shareUrl(url, title) {
  const shareData = {
    url,
    title
  };
  if ((await tryCapacitorShare(shareData)) || (await tryNavigatorShare(shareData))) {
    return;
  }
  await copyTextToClipboard(url);
  getActions().showNotification({
    message: getTranslation('Link was copied!'),
    icon: 'icon-link'
  });
}
async function shareFile(name, content, mimeType) {
  if (src_config/* IS_CAPACITOR */.UMQ) {
    const fileLocation = {
      path: name,
      directory: dist_esm_definitions/* Directory */.__.Cache
    };
    const file = await Filesystem.writeFile({
      ...fileLocation,
      data: content,
      encoding: dist_esm_definitions/* Encoding */.Wi.UTF8
    });
    try {
      if (await tryCapacitorShare({
        url: file.uri
      })) {
        return;
      }
    } finally {
      void Filesystem.deleteFile(fileLocation);
    }
  }
  const file = new File([content], name, {
    type: mimeType
  });
  if (await tryNavigatorShare({
    files: [file]
  })) {
    return;
  }
  const url = URL.createObjectURL(file);
  try {
    if (windowEnvironment/* IS_IOS */.pz) {
      window.open(url, '_blank', 'noreferrer');
    } else {
      const link = document.createElement('a');
      link.href = url;
      link.download = name;
      link.click();
    }
  } finally {
    URL.revokeObjectURL(url);
  }
}

/**
 * Returns `true` if the sharing is successful. Returns `false` if the sharing is unsuccessful and another sharing
 * method should be tried. Throws in case of an unexpected error.
 */
async function tryCapacitorShare(data) {
  if (!src_config/* IS_CAPACITOR */.UMQ) {
    return false;
  }
  try {
    await Share.share(data);
    return true;
  } catch (error) {
    // Occurs when the user closes the sharing UI without choosing a sharing destination
    if (error instanceof Error && error.message === 'Share canceled') {
      return true;
    }

    // Sometimes on iOS a false "Can't share while sharing is in progress" error is thrown
    if (error instanceof Error && error.message === 'Can\'t share while sharing is in progress') {
      return false;
    }
    throw error;
  }
}

/**
 * Returns `true` if the sharing is successful. Returns `false` if the sharing is unsuccessful and another sharing
 * method should be tried. Throws in case of an unexpected error.
 */
async function tryNavigatorShare(data) {
  if (!windowEnvironment/* IS_TOUCH_ENV */.TF || !navigator.share) {
    return false;
  }
  try {
    await navigator.share(data);
    return true;
  } catch (error) {
    // Occurs when the user closes the sharing UI without choosing a sharing destination
    if (error instanceof Error && error.name === 'AbortError') {
      return true;
    }

    // Occurs when the sharing API is called not in response to a user gesture
    if (error instanceof Error && error.name === 'NotAllowedError') {
      return false;
    }
    throw error;
  }
}
;// ./src/hooks/useCurrentOrPrev.ts

function useCurrentOrPrev(current) {
  let shouldSkipUndefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let shouldForceCurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const prev = hooks_usePrevious(current, shouldSkipUndefined);

  // eslint-disable-next-line no-null/no-null
  return shouldForceCurrent || current !== null && current !== undefined ? current : prev;
}
;// ./src/components/ui/Dropdown.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Dropdown_module = ({"button":"Dropdown-module__button","item":"Dropdown-module__item","wide":"Dropdown-module__wide","interactive":"Dropdown-module__interactive","label":"Dropdown-module__label","light":"Dropdown-module__light","inherit":"Dropdown-module__inherit","disabled":"Dropdown-module__disabled","dangerous":"Dropdown-module__dangerous","buttonIcon":"Dropdown-module__buttonIcon","item_selected":"Dropdown-module__item_selected","itemSelected":"Dropdown-module__item_selected","item_with_icon":"Dropdown-module__item_with_icon","itemWithIcon":"Dropdown-module__item_with_icon","itemIcon":"Dropdown-module__itemIcon","itemMainIcon":"Dropdown-module__itemMainIcon","itemOverlayIcon":"Dropdown-module__itemOverlayIcon","fontIcon":"Dropdown-module__fontIcon","itemName":"Dropdown-module__itemName","itemDescription":"Dropdown-module__itemDescription","delimiter":"Dropdown-module__delimiter","delimiterAfter":"Dropdown-module__delimiterAfter","dropdownButtonWrapper":"Dropdown-module__dropdownButtonWrapper","spinner":"Dropdown-module__spinner"});
;// ./src/components/ui/DropdownItemContent.tsx




function DropdownItemContent(_ref) {
  let {
    item,
    shouldUseSelectedName,
    shouldTranslate,
    prefix,
    suffix,
    className,
    iconClassName,
    iconOverlayClassName,
    fontIconClassName,
    itemClassName,
    itemDescriptionClassName,
    onClick
  } = _ref;
  const lang = hooks_useLang();
  const displayedName = shouldUseSelectedName ? item.selectedName ?? item.name : item.name;
  const fullClassName = buildClassName(item.isDisabled && Dropdown_module.disabled, item.isDangerous && Dropdown_module.dangerous, className);
  return /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: fullClassName,
    disabled: item.isDisabled,
    onClick: onClick && (e => onClick(e, item.value))
  }, prefix, item.icon && /*#__PURE__*/teact.createElement("span", {
    className: buildClassName('icon', Dropdown_module.itemIcon, iconClassName)
  }, /*#__PURE__*/teact.createElement("img", {
    src: item.icon,
    alt: "",
    className: Dropdown_module.itemMainIcon
  }), item.overlayIcon && /*#__PURE__*/teact.createElement("img", {
    src: item.overlayIcon,
    alt: "",
    className: buildClassName('icon', Dropdown_module.itemOverlayIcon, iconOverlayClassName)
  })), item.fontIcon && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(`icon icon-${item.fontIcon}`, Dropdown_module.fontIcon, fontIconClassName),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Dropdown_module.itemName, itemClassName)
  }, shouldTranslate ? lang(displayedName) : displayedName, !!item.description && /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Dropdown_module.itemDescription, itemDescriptionClassName)
  }, shouldTranslate && typeof item.description === 'string' ? lang(item.description) : item.description)), suffix);
}
/* harmony default export */ const ui_DropdownItemContent = (memo(DropdownItemContent));
;// ./src/util/captureEscKeyListener.ts

function captureEscKeyListener(handler) {
  return captureKeyboardListeners({
    onEsc: () => {
      handler();
    }
  });
}
;// ./src/components/ui/Menu.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Menu_module = ({"wrapper":"Menu-module__wrapper","inPortal":"Menu-module__inPortal","bubble":"Menu-module__bubble","top":"Menu-module__top","bottom":"Menu-module__bottom","left":"Menu-module__left","right":"Menu-module__right","backdrop":"Menu-module__backdrop","menu":"Menu-module__menu","suggestion":"Menu-module__suggestion","dropdown":"Menu-module__dropdown"});
;// ./src/hooks/useMenuPosition.ts







const POSITIONING = {
  VISUAL_COMFORT_SPACE: 16,
  BOTTOM_MARGIN: 12,
  HORIZONTAL_OFFSET: 3,
  FALLBACK_X: 16,
  TRIGGER_OFFSET: 6
};
const EMPTY_RECT = {
  width: 0,
  left: 0,
  height: 0,
  top: 0,
  right: 0,
  bottom: 0
};
function useMenuPosition(isOpen, containerRef, bubbleRef, options) {
  const optionsRef = useStateRef(options);
  useLayoutEffect(() => {
    if (!isOpen) return;
    const options2 = optionsRef.current;
    if (isDynamicPositionOptions(options2)) {
      (0,fasterdom/* requestForcedReflow */.gm)(() => {
        const staticOptions = processDynamically(options2);
        return () => {
          applyStaticOptions(containerRef, bubbleRef, staticOptions);
        };
      });
    } else {
      applyStaticOptions(containerRef, bubbleRef, options2);
    }
  }, [isOpen, containerRef, bubbleRef, optionsRef]);
}
function applyStaticOptions(containerRef, bubbleRef, _ref) {
  let {
    anchor,
    positionX = 'left',
    positionY = 'top',
    transformOriginX,
    transformOriginY,
    style,
    bubbleStyle
  } = _ref;
  const containerEl = containerRef.current;
  const bubbleEl = bubbleRef.current;
  let finalStyle = style;
  if (anchor && !style) {
    finalStyle = `left: ${anchor.x}px; top: ${anchor.y}px`;
  }
  if (finalStyle) {
    containerEl.style.cssText = finalStyle;
  }
  if (bubbleStyle) {
    bubbleEl.style.cssText = bubbleStyle;
  }
  if (positionX) {
    removeExtraClass(bubbleEl, Menu_module.left);
    removeExtraClass(bubbleEl, Menu_module.right);
    addExtraClass(bubbleEl, Menu_module[positionX]);
  }
  if (positionY) {
    removeExtraClass(bubbleEl, Menu_module.top);
    removeExtraClass(bubbleEl, Menu_module.bottom);
    addExtraClass(bubbleEl, Menu_module[positionY]);
  }
  setExtraStyles(bubbleEl, {
    transformOrigin: [transformOriginX ? `${transformOriginX}px` : positionX, transformOriginY ? `${transformOriginY}px` : positionY].join(' ')
  });
}
function gatherBounds(_ref2) {
  let {
    getTriggerElement,
    getRootElement,
    getMenuElement,
    layout,
    anchor
  } = _ref2;
  const triggerEl = getTriggerElement === null || getTriggerElement === void 0 ? void 0 : getTriggerElement();
  const rootEl = getRootElement();
  const menuEl = getMenuElement();
  const {
    extraMarginTop = 0,
    menuElMinWidth = 0
  } = layout;
  const triggerRect = triggerEl ? triggerEl.getBoundingClientRect() : {
    ...EMPTY_RECT,
    left: anchor.x,
    top: anchor.y,
    right: anchor.x,
    bottom: anchor.y
  };
  const rootRect = rootEl ? rootEl.getBoundingClientRect() : EMPTY_RECT;
  rootRect.height -= windowSize.get().safeAreaBottom;
  let menuDimensions;
  if (menuEl) {
    const marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10) + extraMarginTop;
    const {
      offsetWidth,
      offsetHeight
    } = menuEl;
    menuDimensions = {
      width: Math.max(offsetWidth, menuElMinWidth),
      height: offsetHeight + marginTop,
      marginTop
    };
  } else {
    menuDimensions = {
      width: 0,
      height: 0,
      marginTop: 0
    };
  }
  return {
    triggerRect,
    rootRect,
    menuDimensions
  };
}
function determineHorizontalPosition(anchor, rootRect, menuWidth, deltaX) {
  let preferredPositionX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'right';
  let x = anchor.x;
  let positionX;
  if (preferredPositionX === 'right') {
    // Prefer left-leaning (opening leftward): try 'right' position first
    if (x - menuWidth >= rootRect.left + POSITIONING.VISUAL_COMFORT_SPACE) {
      positionX = 'right';
      x -= POSITIONING.HORIZONTAL_OFFSET;
    } else {
      // Fall back to right-leaning (opening rightward)
      positionX = 'left';
      x += POSITIONING.HORIZONTAL_OFFSET;
    }
  } else {
    // Prefer right-leaning (opening rightward): try 'left' position first
    if (x + menuWidth <= rootRect.right - POSITIONING.VISUAL_COMFORT_SPACE) {
      positionX = 'left';
      x += POSITIONING.HORIZONTAL_OFFSET;
    } else {
      // Fall back to left-leaning (opening leftward)
      positionX = 'right';
      x -= POSITIONING.HORIZONTAL_OFFSET;
    }
  }
  x += deltaX;
  return {
    positionX,
    x
  };
}
function determineVerticalPosition(anchor, triggerRect, rootRect, menuHeight, layout) {
  const {
    topShiftY = 0,
    extraTopPadding = 0,
    isDense = false,
    doNotCoverTrigger = false,
    preferredPositionY
  } = layout;
  let y = anchor.y;
  let positionY;

  // For `doNotCoverTrigger` we use the position relative to the trigger
  if (doNotCoverTrigger) {
    const hasSpaceBelow = triggerRect.bottom + POSITIONING.TRIGGER_OFFSET + menuHeight <= rootRect.bottom;
    const hasSpaceAbove = triggerRect.top - POSITIONING.TRIGGER_OFFSET - menuHeight >= rootRect.top;
    if (hasSpaceBelow && preferredPositionY !== 'bottom') {
      positionY = 'top';
      y = triggerRect.bottom + POSITIONING.TRIGGER_OFFSET;
    } else if (hasSpaceAbove) {
      positionY = 'bottom';
      y = triggerRect.top - POSITIONING.TRIGGER_OFFSET;
    } else {
      // If there is no room at the top or bottom, we use standard logic
      positionY = 'bottom';
      y = rootRect.top + rootRect.height;
    }
  } else {
    const yWithTopShift = y + topShiftY;
    const hasSpaceBelow = yWithTopShift + triggerRect.height + menuHeight < rootRect.height + rootRect.top;
    const hasSpaceAbove = y - triggerRect.height - menuHeight >= rootRect.top + extraTopPadding;
    if (preferredPositionY === 'bottom' && hasSpaceAbove || !isDense && !hasSpaceBelow) {
      positionY = 'bottom';
      if (!hasSpaceAbove) {
        y = rootRect.top + rootRect.height;
      }
    } else {
      positionY = 'top';
      y = yWithTopShift;
    }
  }
  return {
    positionY,
    y
  };
}
function applyBoundaryConstraints(coordinates, positionX, triggerRect, rootRect, menuDimensions, layout) {
  const {
    shouldAvoidNegativePosition = false,
    withPortal = false,
    isDense = false,
    menuElMinWidth = 0,
    centerHorizontally = false
  } = layout;
  let {
    x,
    y
  } = coordinates;

  // Centering the menu with respect to the trigger
  if (centerHorizontally) {
    x = triggerRect.left + (triggerRect.width - menuDimensions.width) / 2;

    // Check that the menu does not extend beyond the edges of the screen
    x = clamp(x, rootRect.left + POSITIONING.VISUAL_COMFORT_SPACE, rootRect.right - menuDimensions.width - POSITIONING.VISUAL_COMFORT_SPACE);
    if (!withPortal) {
      y -= triggerRect.top;
    }
  } else {
    // Calculate relative position to trigger
    const leftWithPossibleNegative = Math.min(x - triggerRect.left, rootRect.width - menuDimensions.width - POSITIONING.VISUAL_COMFORT_SPACE);

    // Apply horizontal constraints
    if (positionX === 'left') {
      if (withPortal || shouldAvoidNegativePosition) {
        x = Math.max(POSITIONING.VISUAL_COMFORT_SPACE, leftWithPossibleNegative);
      } else {
        x = leftWithPossibleNegative;
      }
    } else {
      x -= triggerRect.left;
    }

    // Apply portal positioning
    if (withPortal) {
      x += triggerRect.left;
      // For portal, Y coordinate should remain unchanged (already in viewport coordinates)
      // y stays as is
    } else {
      // For non-portal, convert from anchor coordinates to relative coordinates
      y -= triggerRect.top;
    }
  }

  // Apply dense mode constraints
  if (isDense) {
    x = Math.min(x, rootRect.width - menuDimensions.width - POSITIONING.VISUAL_COMFORT_SPACE);
    y = Math.min(y, rootRect.height - menuDimensions.height - POSITIONING.VISUAL_COMFORT_SPACE);
  }

  // Handle portal edge constraints
  if (withPortal && !centerHorizontally) {
    if (positionX === 'left') {
      x = Math.min(x, rootRect.width - menuDimensions.width - POSITIONING.VISUAL_COMFORT_SPACE);
    } else {
      x = Math.max(x, POSITIONING.VISUAL_COMFORT_SPACE + menuDimensions.width);
    }
  }

  // Handle minimum width adjustments
  const addedXForMenuPositioning = menuElMinWidth ? Math.max(0, (menuElMinWidth - (menuDimensions.width - menuElMinWidth)) / 2) : 0;
  if (x - addedXForMenuPositioning < 0 && shouldAvoidNegativePosition) {
    x = addedXForMenuPositioning + POSITIONING.VISUAL_COMFORT_SPACE;
  }
  return {
    x,
    y
  };
}
function calculateTransformOrigin(anchor, finalCoordinates, positionResult, triggerRect, menuDimensions, withPortal) {
  const portalOffset = withPortal ? {
    x: triggerRect.left,
    y: triggerRect.top
  } : {
    x: 0,
    y: 0
  };
  const offsetX = anchor.x + portalOffset.x - triggerRect.left - finalCoordinates.x;
  const offsetY = anchor.y + portalOffset.y - triggerRect.top - finalCoordinates.y - menuDimensions.marginTop;
  const transformOriginX = positionResult.positionX === 'left' ? offsetX : menuDimensions.width + offsetX;
  const transformOriginY = positionResult.positionY === 'bottom' ? menuDimensions.height + offsetY : offsetY;
  return {
    x: transformOriginX,
    y: transformOriginY
  };
}
function processDynamically(_ref3) {
  let {
    anchor,
    getRootElement,
    getMenuElement,
    getTriggerElement,
    getLayout,
    withMaxHeight
  } = _ref3;
  const layout = (getLayout === null || getLayout === void 0 ? void 0 : getLayout()) || {};
  const {
    triggerRect,
    rootRect,
    menuDimensions
  } = gatherBounds({
    getTriggerElement,
    getRootElement,
    getMenuElement,
    layout,
    anchor
  });
  const {
    positionX,
    x
  } = determineHorizontalPosition(anchor, rootRect, menuDimensions.width, layout.deltaX || 0, layout.preferredPositionX);
  const {
    positionY,
    y
  } = determineVerticalPosition(anchor, triggerRect, rootRect, menuDimensions.height, layout);
  const finalCoordinates = applyBoundaryConstraints({
    x,
    y
  }, positionX, triggerRect, rootRect, menuDimensions, layout);
  const transformOrigin = calculateTransformOrigin(anchor, finalCoordinates, {
    positionX,
    positionY
  }, triggerRect, menuDimensions, layout.withPortal || false);
  const style = `left: ${finalCoordinates.x}px; top: ${finalCoordinates.y}px; --menu-width: ${menuDimensions.width}px;`;
  let bubbleStyle;
  if (withMaxHeight) {
    const menuMaxHeight = rootRect.height - POSITIONING.BOTTOM_MARGIN - menuDimensions.marginTop;
    bubbleStyle = `max-height: ${menuMaxHeight}px;`;
  }
  return {
    positionX,
    positionY,
    transformOriginX: transformOrigin.x,
    transformOriginY: transformOrigin.y,
    style,
    bubbleStyle
  };
}
function isDynamicPositionOptions(options) {
  return 'getRootElement' in options;
}
;// ./src/hooks/useVirtualBackdrop.ts



// This effect implements closing menus by clicking outside of them
// without adding extra elements to the DOM
function useVirtualBackdrop(isOpen, menuRef, onClose) {
  teact_useEffect(() => {
    const handleEvent = e => {
      const menu = menuRef.current;
      const target = e.target;
      if (!menu || !target) {
        return;
      }
      if (!menu.contains(e.target) || target.classList.contains(Menu_module.backdrop)) {
        e.preventDefault();
        e.stopPropagation();
        if (onClose) {
          onClose();
        }
      }
    };
    if (isOpen && onClose) {
      document.addEventListener('mousedown', handleEvent);
    }
    return () => {
      document.removeEventListener('mousedown', handleEvent);
    };
  }, [isOpen, menuRef, onClose]);
}
;// ./src/components/ui/Menu.tsx











const ANIMATION_DURATION = 200;
const Menu = _ref => {
  let {
    children,
    isOpen,
    id,
    menuRef,
    className,
    bubbleClassName,
    type = 'menu',
    autoClose = false,
    shouldSkipTransition,
    noBackdrop = false,
    withPortal,
    noCloseOnBackdrop = false,
    shouldCleanup,
    onCloseAnimationEnd,
    onClose,
    onMouseEnter,
    onMouseLeave,
    ...positionOptions
  } = _ref;
  const containerRef = teact_useRef();
  let bubbleRef = teact_useRef();
  if (menuRef) {
    bubbleRef = menuRef;
  }
  useMenuPosition(isOpen, containerRef, bubbleRef, positionOptions);
  useHistoryBack({
    isActive: Boolean(isOpen && onClose),
    onBack: onClose,
    shouldBeReplaced: true
  });
  const {
    shouldRender
  } = useShowTransition({
    isOpen,
    ref: bubbleRef,
    onCloseAnimationEnd,
    noMountTransition: shouldSkipTransition,
    noCloseTransition: shouldSkipTransition,
    withShouldRender: true
  });
  teact_useEffect(() => isOpen && onClose ? captureEscKeyListener(onClose) : undefined, [isOpen, onClose]);
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevIsOpen] = _ref2;
    if (isOpen || !isOpen && prevIsOpen === true) {
      beginHeavyAnimation(ANIMATION_DURATION);
    }
  }, [isOpen]);
  useVirtualBackdrop(isOpen && !noBackdrop, containerRef, noCloseOnBackdrop ? undefined : onClose);
  const fullBubbleClassName = buildClassName(Menu_module.bubble, bubbleClassName, 'menu-bubble', Menu_module[type]);
  if (shouldCleanup && !shouldRender) {
    return undefined;
  }
  const menu = /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    id: id,
    className: buildClassName(Menu_module.wrapper, className, withPortal && Menu_module.inPortal),
    onMouseEnter: onMouseEnter,
    onMouseLeave: isOpen ? onMouseLeave : undefined
  }, isOpen && !noBackdrop &&
  /*#__PURE__*/
  // This only prevents click events triggering on underlying elements
  teact.createElement("div", {
    className: Menu_module.backdrop,
    onClick: stopEvent
  }), /*#__PURE__*/teact.createElement("div", {
    ref: bubbleRef,
    className: fullBubbleClassName,
    onClick: autoClose ? onClose : undefined
  }, children));
  if (withPortal) {
    return /*#__PURE__*/teact.createElement(ui_Portal, null, menu);
  }
  return menu;
};
/* harmony default export */ const ui_Menu = (Menu);
;// ./src/components/ui/DropdownMenu.tsx
function DropdownMenu_extends() { return DropdownMenu_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, DropdownMenu_extends.apply(null, arguments); }






function DropdownMenu(_ref) {
  let {
    isOpen,
    ref,
    selectedValue,
    items,
    withPortal,
    menuAnchor,
    menuPositionX,
    menuPositionY,
    shouldTranslateOptions,
    className,
    bubbleClassName,
    buttonClassName,
    iconClassName,
    fontIconClassName,
    itemDescriptionClassName,
    shouldCleanup,
    onSelect,
    onClose,
    getTriggerElement,
    getRootElement,
    getMenuElement,
    getLayout,
    onCloseAnimationEnd
  } = _ref;
  let menuRef = teact_useRef();
  if (ref) {
    menuRef = ref;
  }

  // Create position options
  const menuPositionOptions = menuAnchor && getTriggerElement && getRootElement && getMenuElement ? {
    anchor: menuAnchor,
    getTriggerElement,
    getRootElement,
    getMenuElement,
    getLayout
  } : menuAnchor && getRootElement && getMenuElement ? {
    anchor: menuAnchor,
    getRootElement,
    getMenuElement,
    getLayout,
    positionX: menuPositionX,
    positionY: menuPositionY
  } : {
    anchor: menuAnchor,
    positionX: menuPositionX,
    positionY: menuPositionY
  };
  const handleItemClick = useLastCallback((e, value) => {
    e.stopPropagation();
    onSelect === null || onSelect === void 0 || onSelect(value, e);
    onClose();
  });
  return /*#__PURE__*/teact.createElement(ui_Menu, DropdownMenu_extends({
    menuRef: menuRef,
    isOpen: isOpen,
    type: "dropdown",
    withPortal: withPortal,
    className: className,
    bubbleClassName: bubbleClassName,
    shouldCleanup: shouldCleanup,
    onClose: onClose,
    onCloseAnimationEnd: onCloseAnimationEnd
  }, menuPositionOptions), items.map((item, index) => {
    const fullButtonClassName = buildClassName(Dropdown_module.item, (item.icon || item.fontIcon) && Dropdown_module.item_with_icon, item.withDelimiter && index > 0 && Dropdown_module.delimiter, item.withDelimiterAfter && Dropdown_module.delimiterAfter, selectedValue === item.value && Dropdown_module.item_selected, buttonClassName, 'capture-scroll');
    return /*#__PURE__*/teact.createElement(ui_DropdownItemContent, {
      key: item.value,
      item: item,
      shouldTranslate: shouldTranslateOptions,
      className: fullButtonClassName,
      iconClassName: iconClassName,
      fontIconClassName: fontIconClassName,
      itemClassName: "menuItemName",
      itemDescriptionClassName: itemDescriptionClassName,
      onClick: handleItemClick
    });
  }));
}
/* harmony default export */ const ui_DropdownMenu = (memo(DropdownMenu));
;// ./src/components/ui/ModalHeader.tsx







function ModalHeader(_ref) {
  let {
    title,
    className,
    withNotch,
    closeClassName,
    menuItems,
    onClose,
    onBackButtonClick,
    onMenuItemClick
  } = _ref;
  const lang = hooks_useLang();
  const menuRef = teact_useRef();
  const menuButtonRef = teact_useRef();
  const [menuAnchor, setMenuAnchor] = useState();
  const hasMenu = Boolean(menuItems === null || menuItems === void 0 ? void 0 : menuItems.length);
  const isMenuOpen = Boolean(menuAnchor);
  const getTriggerElement = useLastCallback(() => menuButtonRef.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true
  }));
  const closeMenu = useLastCallback(() => setMenuAnchor(undefined));
  const handleMenuButtonClick = useLastCallback(() => {
    if (isMenuOpen) {
      closeMenu();
    } else {
      const {
        right: x,
        y,
        height
      } = menuButtonRef.current.getBoundingClientRect();
      setMenuAnchor({
        x,
        y: y + height
      });
    }
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.header, 'with-notch-on-scroll', withNotch && 'is-scrolled', !onBackButtonClick && Modal_module.header_wideContent, className, isMenuOpen && 'is-menu-open')
  }, onBackButtonClick && /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: onBackButtonClick,
    className: Modal_module.header_back
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Modal_module.header_backIcon, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), title !== undefined && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.title, Modal_module.singleTitle)
  }, title), hasMenu && /*#__PURE__*/teact.createElement(ui_Button, {
    ref: menuButtonRef,
    isSimple: true,
    className: buildClassName(Modal_module.menuButton, closeClassName),
    ariaLabel: lang('Menu'),
    onClick: handleMenuButtonClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Modal_module.menuIcon, 'icon-menu-dots'),
    "aria-hidden": true
  })), onClose && /*#__PURE__*/teact.createElement(ui_Button, {
    isRound: true,
    className: buildClassName(Modal_module.closeButton, closeClassName),
    ariaLabel: lang('Close'),
    onClick: onClose
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Modal_module.closeIcon, 'icon-close'),
    "aria-hidden": true
  })), hasMenu && /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isMenuOpen,
    ref: menuRef,
    items: menuItems,
    withPortal: true,
    shouldTranslateOptions: true,
    menuPositionX: "right",
    menuAnchor: menuAnchor,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    onSelect: onMenuItemClick,
    onClose: closeMenu
  }));
}
/* harmony default export */ const ui_ModalHeader = (memo(ModalHeader));
;// ./src/components/ui/IFrameBrowser.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const IFrameBrowser_module = ({"iframe":"IFrameBrowser-module__iframe","dialog":"IFrameBrowser-module__dialog","modalHeader":"IFrameBrowser-module__modalHeader"});
;// ./src/components/ui/IFrameBrowser.tsx












const TITLES = {
  'tonscan.org': 'TON Explorer',
  'multisend.mytonwallet.io': 'Multi-Send',
  'localhost:4323': 'Multi-Send'
};
const MENU_ITEMS = [{
  value: 'reload',
  name: 'Reload',
  fontIcon: 'menu-reload'
}, {
  value: 'openInBrowser',
  name: 'Open in Browser',
  fontIcon: 'menu-globe'
}, {
  value: 'copyUrl',
  name: 'Copy Link',
  fontIcon: 'menu-copy'
}, {
  value: 'close',
  name: 'Close',
  fontIcon: 'menu-close',
  withDelimiter: true
}];
function IFrameBrowser(_ref) {
  let {
    url,
    title
  } = _ref;
  const {
    closeBrowser,
    showNotification
  } = getActions();
  const lang = hooks_useLang();
  const iframeRef = teact_useRef();
  const {
    setupDappBridge
  } = useIFrameBridgeProvider(url);
  const host = teact_useMemo(() => url && new URL(url).host, [url]);
  const renderingTitle = useCurrentOrPrev(title || host && (TITLES[host] || host));
  const handleMenuItemClick = useLastCallback(value => {
    if (!url) return;
    const frame = iframeRef.current;
    switch (value) {
      case 'reload':
        frame.src = 'about:blank';
        frame.addEventListener('load', () => {
          frame.src = url;
        }, {
          once: true
        });
        break;
      case 'openInBrowser':
        void openUrl(url, {
          isExternal: true
        });
        break;
      case 'copyUrl':
        void copyTextToClipboard(url);
        showNotification({
          message: lang('URL was copied!'),
          icon: 'icon-copy'
        });
        break;
      case 'share':
        void shareUrl(url, renderingTitle);
        break;
      case 'close':
        closeBrowser();
        break;
    }
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: Boolean(url),
    dialogClassName: IFrameBrowser_module.dialog,
    onClose: closeBrowser
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: renderingTitle,
    menuItems: MENU_ITEMS,
    onMenuItemClick: handleMenuItemClick,
    className: IFrameBrowser_module.modalHeader
  }), /*#__PURE__*/teact.createElement("iframe", {
    ref: iframeRef,
    title: renderingTitle,
    src: url,
    className: IFrameBrowser_module.iframe,
    allow: "web-share; clipboard-write",
    onLoad: setupDappBridge
  }));
}
/* harmony default export */ const ui_IFrameBrowser = (memo(withGlobal(global => {
  const {
    currentBrowserOptions
  } = global;
  return {
    url: currentBrowserOptions === null || currentBrowserOptions === void 0 ? void 0 : currentBrowserOptions.url,
    title: currentBrowserOptions === null || currentBrowserOptions === void 0 ? void 0 : currentBrowserOptions.title
  };
})(IFrameBrowser)));
;// ./src/hooks/useIntersectionObserver.ts





function useIntersectionObserver(_ref, rootCallback) {
  let {
    rootRef,
    throttleMs,
    throttleScheduler,
    debounceMs,
    shouldSkipFirst,
    margin,
    threshold,
    isDisabled
  } = _ref;
  const controllerRef = teact_useRef();
  const rootCallbackRef = teact_useRef();
  const freezeFlagsRef = teact_useRef(0);
  const onUnfreezeRef = teact_useRef();
  rootCallbackRef.current = rootCallback;
  const freeze = useLastCallback(() => {
    freezeFlagsRef.current++;
  });
  const unfreeze = useLastCallback(() => {
    if (!freezeFlagsRef.current) {
      return;
    }
    freezeFlagsRef.current--;
    if (!freezeFlagsRef.current && onUnfreezeRef.current) {
      onUnfreezeRef.current();
      onUnfreezeRef.current = undefined;
    }
  });
  useHeavyAnimation(freeze, unfreeze);
  teact_useEffect(() => {
    if (isDisabled) {
      return undefined;
    }
    return () => {
      if (controllerRef.current) {
        controllerRef.current.observer.disconnect();
        controllerRef.current.callbacks.clear();
        controllerRef.current = undefined;
      }
    };
  }, [isDisabled]);
  function initController() {
    const callbacks = new Map();
    const entriesAccumulator = new Map();
    let observerCallback;
    if (typeof throttleScheduler === 'function') {
      observerCallback = (0,schedulers/* throttleWith */.nb)(throttleScheduler, observerCallbackSync);
    } else if (throttleMs) {
      observerCallback = (0,schedulers/* throttle */.nF)(observerCallbackSync, throttleMs, !shouldSkipFirst);
    } else if (debounceMs) {
      observerCallback = (0,schedulers/* debounce */.sg)(observerCallbackSync, debounceMs, !shouldSkipFirst);
    } else {
      observerCallback = observerCallbackSync;
    }
    function observerCallbackSync() {
      if (freezeFlagsRef.current) {
        onUnfreezeRef.current = observerCallback;
        return;
      }
      const entries = Array.from(entriesAccumulator.values());
      entries.forEach(entry => {
        const callback = callbacks.get(entry.target);
        if (callback) {
          callback(entry, entries);
        }
      });
      if (rootCallbackRef.current) {
        rootCallbackRef.current(entries);
      }
      entriesAccumulator.clear();
    }
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        entriesAccumulator.set(entry.target, entry);
      });
      if (freezeFlagsRef.current) {
        onUnfreezeRef.current = observerCallback;
      } else {
        observerCallback();
      }
    }, {
      root: rootRef === null || rootRef === void 0 ? void 0 : rootRef.current,
      rootMargin: margin ? `${margin}px` : undefined,
      threshold
    });
    controllerRef.current = {
      observer,
      callbacks
    };
  }
  const observe = useLastCallback((target, targetCallback) => {
    if (!controllerRef.current) {
      initController();
    }
    const controller = controllerRef.current;
    controller.observer.observe(target);
    if (targetCallback) {
      controller.callbacks.set(target, targetCallback);
    }
    return () => {
      if (targetCallback) {
        controller.callbacks.delete(target);
      }
      controller.observer.unobserve(target);
    };
  });
  return {
    observe,
    freeze,
    unfreeze
  };
}
function useOnIntersect(targetRef, observe, callback) {
  const lastCallback = useLastCallback(callback);
  teact_useEffect(() => {
    return observe ? observe(targetRef.current, lastCallback) : undefined;
  }, [lastCallback, observe, targetRef]);
}
function useGetIsIntersecting(targetRef, observe, callback) {
  const [getIsIntersecting, setIsIntersecting] = useSignal(!observe);
  useOnIntersect(targetRef, observe, entry => {
    setIsIntersecting(entry.isIntersecting);
    if (callback) {
      callback(entry);
    }
  });
  return getIsIntersecting;
}
function useIsIntersecting(targetRef, observe, callback) {
  return hooks_useDerivedState(useGetIsIntersecting(targetRef, observe, callback));
}
;// ./src/hooks/useAppIntersectionObserver.ts

let observeIntersection;
const useAppIntersectionObserver_THROTTLE = 350;
function useAppIntersectionObserver() {
  const {
    observe
  } = useIntersectionObserver({
    throttleMs: useAppIntersectionObserver_THROTTLE
  });
  observeIntersection = observe;
}
function useGetIsIntersectingWithApp(targetRef) {
  return useGetIsIntersecting(targetRef, observeIntersection);
}
;// ./src/hooks/useInterval.ts


function useInterval(callback, delay) {
  let noFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const lastCallback = useLastCallback(callback);
  teact_useEffect(() => {
    if (delay === undefined) {
      return undefined;
    }
    const id = setInterval(lastCallback, delay);
    if (!noFirst) lastCallback();
    return () => clearInterval(id);
  }, [delay, lastCallback, noFirst]);
}
/* harmony default export */ const hooks_useInterval = (useInterval);
;// ./src/hooks/useTimeout.ts



function useTimeout(callback, delay) {
  let dependencies = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  const savedCallback = useLastCallback(callback);
  teact_useEffect(() => {
    if (typeof delay !== 'number') {
      return undefined;
    }
    return (0,schedulers/* setCancellableTimeout */.Gf)(delay, savedCallback);
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, [delay, savedCallback, ...dependencies]);
}
/* harmony default export */ const hooks_useTimeout = (useTimeout);
;// ./src/components/AppInactive.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AppInactive_module = ({"root":"AppInactive-module__root","content":"AppInactive-module__content","actions":"AppInactive-module__actions","title":"AppInactive-module__title","description":"AppInactive-module__description","img":"AppInactive-module__img","button":"AppInactive-module__button"});
;// ./src/assets/app-inactive.png
const app_inactive_namespaceObject = __webpack_require__.p + "app-inactive.e835efd0bf0191aaa6ab.png";
;// ./src/assets/app-inactive.webp
const src_assets_app_inactive_namespaceObject = __webpack_require__.p + "app-inactive.70579bd9a710cd418aff.webp";
;// ./src/components/AppInactive.tsx









function AppInactive() {
  const lang = hooks_useLang();
  const handleReload = useLastCallback(() => {
    window.location.reload();
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: AppInactive_module.root
  }, /*#__PURE__*/teact.createElement("div", {
    className: AppInactive_module.content
  }, /*#__PURE__*/teact.createElement("picture", {
    className: AppInactive_module.img
  }, /*#__PURE__*/teact.createElement("source", {
    src: src_assets_app_inactive_namespaceObject
  }), /*#__PURE__*/teact.createElement("img", {
    src: app_inactive_namespaceObject,
    alt: "",
    className: AppInactive_module.img
  })), /*#__PURE__*/teact.createElement("h3", {
    className: AppInactive_module.title
  }, lang('Such error, many tabs')), /*#__PURE__*/teact.createElement("div", {
    className: AppInactive_module.description
  }, renderText(lang('$many_tabs_error_description', {
    app_name: src_config/* APP_NAME */.C39
  }))), /*#__PURE__*/teact.createElement("div", {
    className: AppInactive_module.actions
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isText: true,
    className: AppInactive_module.button,
    onClick: handleReload
  }, lang('Reload App')))));
}
/* harmony default export */ const components_AppInactive = (AppInactive);
;// ./src/hooks/useScrolledState.ts


const THRESHOLD = 1;
function useScrolledState() {
  let threshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : THRESHOLD;
  const [isAtBeginning, setIsAtBeginning] = useState(true);
  const [isAtEnd, setIsAtEnd] = useState(true);
  const update = useLastCallback(element => {
    if (!element) return;
    const {
      scrollHeight,
      scrollTop,
      clientHeight
    } = element;
    setIsAtBeginning(scrollTop < threshold);
    setIsAtEnd(scrollHeight - scrollTop - clientHeight < threshold);
  });
  const handleScroll = useLastCallback(e => {
    update(e.target);
  });
  return {
    isAtBeginning,
    isAtEnd,
    isScrolled: !isAtBeginning,
    handleScroll,
    update
  };
}
;// ./src/components/ui/Emoji.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Emoji_module = ({"root":"Emoji-module__root"});
;// ./src/components/ui/Emoji.tsx






const PATH_BY_EMOJI = {
  'ðŸ¥·': '1f977',
  'ðŸ¦„': '1f984',
  'âš ï¸': '26a0'
};
const loadedImages = new Set();
function Emoji(_ref) {
  let {
    from
  } = _ref;
  const key = from in PATH_BY_EMOJI ? PATH_BY_EMOJI[from] : from;
  const src = `./emoji/${key}.png`;
  const [isLoaded, markLoaded] = hooks_useFlag(loadedImages.has(src));
  const ref = useMediaTransition(isLoaded);
  const handleLoad = useLastCallback(() => {
    markLoaded();
    loadedImages.add(src);
  });
  return /*#__PURE__*/teact.createElement("img", {
    ref: ref,
    src: src,
    alt: from,
    className: buildClassName(Emoji_module.root, Emoji_module[`key-${key}`]),
    onLoad: handleLoad
  });
}
/* harmony default export */ const ui_Emoji = (memo(Emoji));
;// ./src/components/settings/Settings.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Settings_module = ({"wrapper":"Settings-module__wrapper","slide":"Settings-module__slide","modalDialog":"Settings-module__modalDialog","header":"Settings-module__header","withTopSpace":"Settings-module__withTopSpace","nestedTransition":"Settings-module__nestedTransition","transitionContainer":"Settings-module__transitionContainer","developerCloseButton":"Settings-module__developerCloseButton","onlyTextHeader":"Settings-module__onlyTextHeader","headerInsideModal":"Settings-module__headerInsideModal","languageHeader":"Settings-module__languageHeader","headerBack":"Settings-module__headerBack","isInsideModal":"Settings-module__isInsideModal","hidden":"Settings-module__hidden","iconChevron":"Settings-module__iconChevron","headerBackInContent":"Settings-module__headerBackInContent","headerTitle":"Settings-module__headerTitle","modalHeader":"Settings-module__modalHeader","content":"Settings-module__content","content_noScroll":"Settings-module__content_noScroll","contentNoScroll":"Settings-module__content_noScroll","withBottomSpace":"Settings-module__withBottomSpace","contentInModal":"Settings-module__contentInModal","contentFullSize":"Settings-module__contentFullSize","blockTitle":"Settings-module__blockTitle","menuIcon":"Settings-module__menuIcon","themeWrapper":"Settings-module__themeWrapper","blockAbout":"Settings-module__blockAbout","theme":"Settings-module__theme","theme_active":"Settings-module__theme_active","themeActive":"Settings-module__theme_active","themeIcon":"Settings-module__themeIcon","themeIcon_active":"Settings-module__themeIcon_active","themeIconActive":"Settings-module__themeIcon_active","themeImg":"Settings-module__themeImg","colorList":"Settings-module__colorList","colorButton":"Settings-module__colorButton","colorButtonCurrent":"Settings-module__colorButtonCurrent","iconLock":"Settings-module__iconLock","iconLockInverted":"Settings-module__iconLockInverted","subBlockAsButton":"Settings-module__subBlockAsButton","block":"Settings-module__block","text":"Settings-module__text","settingsBlockWithDescription":"Settings-module__settingsBlockWithDescription","settingsBlock":"Settings-module__settingsBlock","iconChevronRight":"Settings-module__iconChevronRight","iconQuestion":"Settings-module__iconQuestion","item":"Settings-module__item","draggable":"Settings-module__draggable","item_red":"Settings-module__item_red","itemRed":"Settings-module__item_red","item_small":"Settings-module__item_small","itemSmall":"Settings-module__item_small","item_lang":"Settings-module__item_lang","itemLang":"Settings-module__item_lang","item_wallet_version":"Settings-module__item_wallet_version","itemWalletVersion":"Settings-module__item_wallet_version","item_token":"Settings-module__item_token","itemToken":"Settings-module__item_token","item_disabled":"Settings-module__item_disabled","itemDisabled":"Settings-module__item_disabled","itemAutoLock":"Settings-module__itemAutoLock","itemInfo":"Settings-module__itemInfo","small":"Settings-module__small","version":"Settings-module__version","languageMain":"Settings-module__languageMain","languageNative":"Settings-module__languageNative","wideTooltip":"Settings-module__wideTooltip","disconnectButton":"Settings-module__disconnectButton","dapps":"Settings-module__dapps","changePasswordButton":"Settings-module__changePasswordButton","passwordFormContent":"Settings-module__passwordFormContent","passwordFormContentInModal":"Settings-module__passwordFormContentInModal","sticker":"Settings-module__sticker","blockDescription":"Settings-module__blockDescription","emptyList":"Settings-module__emptyList","emptyListTitle":"Settings-module__emptyListTitle","dapp":"Settings-module__dapp","backButton":"Settings-module__backButton","logo":"Settings-module__logo","stickerNativeBiometric":"Settings-module__stickerNativeBiometric","pinPadHeader":"Settings-module__pinPadHeader","pinPadHeaderMinified":"Settings-module__pinPadHeaderMinified","pinPadTitle":"Settings-module__pinPadTitle","title":"Settings-module__title","titleLink":"Settings-module__titleLink","heading":"Settings-module__heading","github":"Settings-module__github","telegram":"Settings-module__telegram","tokenSortIcon":"Settings-module__tokenSortIcon","tokenTitle":"Settings-module__tokenTitle","tokenDescription":"Settings-module__tokenDescription","tokenAmount":"Settings-module__tokenAmount","dot":"Settings-module__dot","dotLarge":"Settings-module__dotLarge","contentRelative":"Settings-module__contentRelative","sortableContainer":"Settings-module__sortableContainer","modalDialogWeb":"Settings-module__modalDialogWeb","modalContent":"Settings-module__modalContent","deleteText":"Settings-module__deleteText","languageInfo":"Settings-module__languageInfo","tokenInfo":"Settings-module__tokenInfo","stickerAndTitle":"Settings-module__stickerAndTitle","sideTitle":"Settings-module__sideTitle","aboutFooterWrapper":"Settings-module__aboutFooterWrapper","aboutFooterContent":"Settings-module__aboutFooterContent","blockWalletVersionText":"Settings-module__blockWalletVersionText","walletVersionInfo":"Settings-module__walletVersionInfo","walletVersionInfoRight":"Settings-module__walletVersionInfoRight","walletVersionTitle":"Settings-module__walletVersionTitle","walletVersionTokens":"Settings-module__walletVersionTokens","walletVersionAddress":"Settings-module__walletVersionAddress","walletVersionAmount":"Settings-module__walletVersionAmount","blockWalletVersionReadMore":"Settings-module__blockWalletVersionReadMore","nftPrimaryCell":"Settings-module__nftPrimaryCell","nftName":"Settings-module__nftName","nftCollection":"Settings-module__nftCollection","nftImage":"Settings-module__nftImage","nftButtonUnhide":"Settings-module__nftButtonUnhide","account":"Settings-module__account","accountDisabled":"Settings-module__accountDisabled"});
;// ./src/components/settings/SettingsAbout.tsx















function SettingsAbout(_ref) {
  let {
    isActive,
    isInsideModal,
    theme,
    headerClassName,
    handleBackClick
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  const appTheme = hooks_useAppTheme(theme);
  const logoPath = appTheme === 'light' ? logoLight_namespaceObject : logoDark_namespaceObject;
  const aboutExtensionTitle = lang('$about_extension_link_text', {
    app_name: src_config/* APP_NAME */.C39
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('About %app_name%', {
      app_name: src_config/* APP_NAME */.C39
    }),
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, headerClassName, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('About %app_name%', {
    app_name: src_config/* APP_NAME */.C39
  }))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, isInsideModal && 'custom-scroll', !isInsideModal && Settings_module.content_noScroll),
    onScroll: isInsideModal ? handleContentScroll : undefined
  }, /*#__PURE__*/teact.createElement("img", {
    src: logoPath,
    alt: lang('Logo'),
    className: Settings_module.logo
  }), /*#__PURE__*/teact.createElement("h2", {
    className: Settings_module.title
  }, src_config/* APP_NAME */.C39, " ", src_config/* APP_VERSION */.hl5, " ", src_config/* APP_ENV_MARKER */.vOV, !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("a", {
    href: "https://mytonwallet.io/",
    target: "_blank",
    className: Settings_module.titleLink,
    rel: "noreferrer"
  }, "mytonwallet.io")), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.blockAbout, !isInsideModal && 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$about_description1'))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$about_description2'))), src_config/* IS_EXTENSION */.hL1 ? /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("h3", {
    className: buildClassName(Settings_module.text, Settings_module.heading)
  }, /*#__PURE__*/teact.createElement(ui_Emoji, {
    from: "\uD83E\uDD77"
  }), " ", lang('What is TON Proxy?')), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$about_extension_description1')), ' ', /*#__PURE__*/teact.createElement("a", {
    href: "https://telegra.ph/TON-Sites-TON-WWW-and-TON-Proxy-09-29-2",
    target: "_blank",
    rel: "noopener noreferrer"
  }, lang('More info and demo.'))), /*#__PURE__*/teact.createElement("h3", {
    className: buildClassName(Settings_module.text, Settings_module.heading)
  }, /*#__PURE__*/teact.createElement(ui_Emoji, {
    from: "\uD83E\uDD84"
  }), " ", lang('What is TON Magic?')), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$about_extension_description2'))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, lang('$about_extension_description3'), ' ', /*#__PURE__*/teact.createElement("a", {
    href: "https://telegra.ph/Telegram--TON-11-10",
    target: "_blank",
    rel: "noopener noreferrer"
  }, lang('More info and demo.')))) : /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("h3", {
    className: buildClassName(Settings_module.text, Settings_module.heading)
  }, lang('$about_proxy_magic_title', {
    ninja: /*#__PURE__*/teact.createElement(ui_Emoji, {
      from: "\uD83E\uDD77"
    }),
    unicorn: /*#__PURE__*/teact.createElement(ui_Emoji, {
      from: "\uD83E\uDD84"
    })
  })), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, lang('$about_proxy_magic_description', {
    extension_link: /*#__PURE__*/teact.createElement("a", {
      href: "https://mytonwallet.io/",
      target: "_blank",
      rel: "noreferrer"
    }, renderText(aboutExtensionTitle))
  }))), /*#__PURE__*/teact.createElement("h3", {
    className: buildClassName(Settings_module.text, Settings_module.heading)
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.github, 'icon-github'),
    "aria-hidden": true
  }), " ", lang('Is it open source?')), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, lang('$about_wallet_github', {
    github_link: /*#__PURE__*/teact.createElement("a", {
      href: src_config/* APP_REPO_URL */.V3_,
      target: "_blank",
      rel: "noreferrer"
    }, renderText(lang('$about_github_link_text')))
  })), /*#__PURE__*/teact.createElement("h3", {
    className: Settings_module.heading
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.telegram, 'icon-telegram'),
    "aria-hidden": true
  }), " ", lang('Is there a community?')), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, lang('$about_wallet_community', {
    community_link: /*#__PURE__*/teact.createElement("a", {
      href: lang.code === 'ru' ? 'https://t.me/MyTonWalletRu' : 'https://t.me/MyTonWalletEn',
      target: "_blank",
      rel: "noreferrer"
    }, renderText(lang('$about_community_link_text')))
  }))), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.aboutFooterWrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.aboutFooterContent
  }, /*#__PURE__*/teact.createElement("a", {
    href: "https://mytonwallet.io/terms-of-use",
    target: "_blank",
    rel: "noreferrer",
    onClick: handleUrlClick
  }, lang('Terms of Use')), /*#__PURE__*/teact.createElement("i", {
    className: Settings_module.dotLarge,
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("a", {
    href: "https://mytonwallet.io/privacy-policy",
    target: "_blank",
    rel: "noreferrer",
    onClick: handleUrlClick
  }, lang('Privacy Policy'))))));
}
/* harmony default export */ const settings_SettingsAbout = (memo(SettingsAbout));
;// ./src/components/auth/Auth.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Auth_module = ({"wrapper":"Auth-module__wrapper","transitionContainer":"Auth-module__transitionContainer","transitionSlide":"Auth-module__transitionSlide","container":"Auth-module__container","container_scrollable":"Auth-module__container_scrollable","containerScrollable":"Auth-module__container_scrollable","container_password":"Auth-module__container_password","containerPassword":"Auth-module__container_password","containerAlignTop":"Auth-module__containerAlignTop","containerFullSize":"Auth-module__containerFullSize","aboutHeader":"Auth-module__aboutHeader","logo":"Auth-module__logo","appName":"Auth-module__appName","title":"Auth-module__title","title_afterSmallSticker":"Auth-module__title_afterSmallSticker","titleAfterSmallSticker":"Auth-module__title_afterSmallSticker","titleSmallMargin":"Auth-module__titleSmallMargin","infoBlock":"Auth-module__infoBlock","text":"Auth-module__text","informationCheckbox":"Auth-module__informationCheckbox","informationCheckboxContent":"Auth-module__informationCheckboxContent","info":"Auth-module__info","info_push":"Auth-module__info_push","infoPush":"Auth-module__info_push","info__space":"Auth-module__info__space","infoSpace":"Auth-module__info__space","infoPull":"Auth-module__infoPull","infoSmallFont":"Auth-module__infoSmallFont","counter":"Auth-module__counter","counterTitle":"Auth-module__counterTitle","counterDigit":"Auth-module__counterDigit","small":"Auth-module__small","sticker":"Auth-module__sticker","viewModeSticker":"Auth-module__viewModeSticker","stickerAndTitle":"Auth-module__stickerAndTitle","backupNotice":"Auth-module__backupNotice","backupNoticeButtons":"Auth-module__backupNoticeButtons","modalSticker":"Auth-module__modalSticker","form":"Auth-module__form","formWidgets":"Auth-module__formWidgets","passwordForm":"Auth-module__passwordForm","errors":"Auth-module__errors","passwordRules":"Auth-module__passwordRules","passwordRule":"Auth-module__passwordRule","valid":"Auth-module__valid","error":"Auth-module__error","buttons":"Auth-module__buttons","buttons__inner":"Auth-module__buttons__inner","buttonsInner":"Auth-module__buttons__inner","footerButton":"Auth-module__footerButton","btn":"Auth-module__btn","btn_push":"Auth-module__btn_push","btnPush":"Auth-module__btn_push","btn_text":"Auth-module__btn_text","btnText":"Auth-module__btn_text","btn_about":"Auth-module__btn_about","btnAbout":"Auth-module__btn_about","btn_wide":"Auth-module__btn_wide","btnWide":"Auth-module__btn_wide","btn_mini":"Auth-module__btn_mini","btnMini":"Auth-module__btn_mini","btn_single":"Auth-module__btn_single","btnSingle":"Auth-module__btn_single","btnHalfWidth":"Auth-module__btnHalfWidth","modalDialog":"Auth-module__modalDialog","privateKey":"Auth-module__privateKey","importingContent":"Auth-module__importingContent","footerError":"Auth-module__footerError","importButtonsBlock":"Auth-module__importButtonsBlock","importButtonsBlockSimple":"Auth-module__importButtonsBlockSimple","importText":"Auth-module__importText","importButtons":"Auth-module__importButtons","biometricsStep":"Auth-module__biometricsStep","warning":"Auth-module__warning","biometricsError":"Auth-module__biometricsError","stepTransition":"Auth-module__stepTransition","passwordFormContainer":"Auth-module__passwordFormContainer","header":"Auth-module__header","headerTitle":"Auth-module__headerTitle","pinPadHeader":"Auth-module__pinPadHeader","headerBack":"Auth-module__headerBack","headerBackBlock":"Auth-module__headerBackBlock","iconChevron":"Auth-module__iconChevron","biometricsIcon":"Auth-module__biometricsIcon","biometricsTitle":"Auth-module__biometricsTitle","biometricsSubtitle":"Auth-module__biometricsSubtitle","actionsSection":"Auth-module__actionsSection","importModalContent":"Auth-module__importModalContent","disclaimerBackupDialog":"Auth-module__disclaimerBackupDialog"});
;// ./src/components/auth/AuthCheckPassword.tsx







function AuthCheckPassword(_ref) {
  let {
    isActive,
    isLoading,
    error,
    method
  } = _ref;
  const {
    resetAuth,
    cleanAuthError,
    addAccount
  } = getActions();
  const lang = hooks_useLang();
  const isImporting = method !== 'createAccount';
  const handleSubmit = useLastCallback(password => {
    addAccount({
      method: isImporting ? 'importMnemonic' : 'createAccount',
      password,
      isAuthFlow: true
    });
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.container_scrollable, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_PasswordForm, {
    isActive: isActive,
    isLoading: isLoading,
    error: error,
    containerClassName: Auth_module.passwordForm,
    submitLabel: lang('Send'),
    cancelLabel: lang('Back'),
    onSubmit: handleSubmit,
    onCancel: resetAuth,
    onUpdate: cleanAuthError
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang('Enter your password'))));
}
/* harmony default export */ const auth_AuthCheckPassword = (memo(AuthCheckPassword));
;// ./src/components/ui/SuggestionList.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SuggestionList_module = ({"suggestions":"SuggestionList-module__suggestions","bottom":"SuggestionList-module__bottom","top":"SuggestionList-module__top","suggestion":"SuggestionList-module__suggestion","active":"SuggestionList-module__active"});
;// ./src/components/ui/SuggestionList.tsx




function SuggestionList(_ref) {
  let {
    position = 'bottom',
    suggestions,
    activeIndex,
    isInModal,
    onSelect
  } = _ref;
  const lang = hooks_useLang();
  const handleClick = e => {
    e.preventDefault();
    const suggest = e.target.innerText.trim();
    onSelect(suggest);
  };
  return suggestions.length ? /*#__PURE__*/teact.createElement("ul", {
    className: buildClassName(SuggestionList_module.suggestions, SuggestionList_module[position], isInModal && SuggestionList_module.embedded)
  }, suggestions.map((suggestion, index) => {
    return /*#__PURE__*/teact.createElement("li", {
      key: suggestion,
      role: "button",
      tabIndex: 0,
      className: buildClassName(SuggestionList_module.suggestion, index === activeIndex && SuggestionList_module.active),
      onMouseDown: handleClick
    }, suggestion);
  })) : /*#__PURE__*/teact.createElement("div", {
    className: SuggestionList_module.suggestions
  }, /*#__PURE__*/teact.createElement("li", {
    className: SuggestionList_module.suggestion
  }, lang('No suggestions, you\'re on your own!')));
}
/* harmony default export */ const ui_SuggestionList = (memo(SuggestionList));
;// ./src/components/common/InputMnemonic.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const InputMnemonic_module = ({"wrapper":"InputMnemonic-module__wrapper","wrapper_focus":"InputMnemonic-module__wrapper_focus","wrapperFocus":"InputMnemonic-module__wrapper_focus","wrapper_error":"InputMnemonic-module__wrapper_error","wrapperError":"InputMnemonic-module__wrapper_error","input":"InputMnemonic-module__input","label":"InputMnemonic-module__label"});
;// ./src/components/common/InputMnemonic.tsx










const SUGGESTION_WORDS_COUNT = 7;
function InputMnemonic(_ref) {
  let {
    id,
    nextId,
    labelText,
    className,
    value = '',
    isInModal,
    suggestionsPosition,
    inputArg,
    onInput,
    onEnter
  } = _ref;
  const [hasFocus, markFocus, unmarkFocus] = hooks_useFlag();
  const [hasError, setHasError] = useState(false);
  const [filteredSuggestions, setFilteredSuggestions] = useState([]);
  const [activeSuggestionIndex, setActiveSuggestionIndex] = useState(0);
  const [areSuggestionsShown, setAreSuggestionsShown] = useState(false);
  const [wordlist, setWordlist] = useState([]);
  const shouldRenderSuggestions = areSuggestionsShown && value && filteredSuggestions.length > 0;
  teact_useEffect(() => {
    void (0,api/* callApi */.p)('getMnemonicWordList').then(words => setWordlist(words ?? []));
  }, []);
  teact_useEffect(() => {
    const noError = !value || areSuggestionsShown && filteredSuggestions.length > 0 || isCorrectMnemonic(value, wordlist);
    setHasError(!noError);
  }, [areSuggestionsShown, filteredSuggestions.length, value, wordlist]);
  const processSuggestions = userInput => {
    // Filter our suggestions that don't contain the user's input
    const unLinked = wordlist.filter(suggestion => suggestion.toLowerCase().startsWith(userInput.toLowerCase())).slice(0, SUGGESTION_WORDS_COUNT);
    onInput(userInput, inputArg);
    setFilteredSuggestions(unLinked);
    setActiveSuggestionIndex(0);
    setAreSuggestionsShown(true);
  };
  const handleChange = e => {
    const userInput = e.target.value;
    processSuggestions(userInput);
  };
  const handlePaste = e => {
    const pastedValue = e.clipboardData.getData('text');
    if (!pastedValue) return;
    processSuggestions(pastedValue);
  };
  const handleEnter = useLastCallback(e => {
    if (!value) return;
    if (onEnter && !areSuggestionsShown) {
      onEnter();
    }
    const suggestedValue = filteredSuggestions[activeSuggestionIndex];
    if (!suggestedValue) return;
    onInput(suggestedValue, inputArg);
    setFilteredSuggestions([suggestedValue]);
    setActiveSuggestionIndex(0);
    setAreSuggestionsShown(false);
    if (areSuggestionsShown) {
      e.preventDefault();
    }
    if (nextId) {
      (0,fasterdom/* requestMeasure */.YS)(() => {
        (0,fasterdom/* requestMeasure */.YS)(() => {
          const nextInput = document.getElementById(nextId);
          nextInput === null || nextInput === void 0 || nextInput.focus();
          nextInput === null || nextInput === void 0 || nextInput.select();
        });
      });
    }
  });
  teact_useEffect(() => {
    return hasFocus ? captureKeyboardListeners({
      onEnter: handleEnter,
      onTab: e => {
        if (!(e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) {
          handleEnter(e);
        }
      },
      onUp: () => {
        if (activeSuggestionIndex > 0) {
          setActiveSuggestionIndex(activeSuggestionIndex - 1);
        }
      },
      onDown: () => {
        if (activeSuggestionIndex < filteredSuggestions.length - 1) {
          setActiveSuggestionIndex(activeSuggestionIndex + 1);
        }
      }
    }) : undefined;
  });
  const handleClick = useLastCallback(suggestion => {
    onInput(suggestion, inputArg);
    setAreSuggestionsShown(false);
    setActiveSuggestionIndex(0);
    setFilteredSuggestions([]);
    if (nextId) {
      (0,fasterdom/* requestMeasure */.YS)(() => {
        (0,fasterdom/* requestMeasure */.YS)(() => {
          const nextInput = document.getElementById(nextId);
          nextInput === null || nextInput === void 0 || nextInput.focus();
          nextInput === null || nextInput === void 0 || nextInput.select();
        });
      });
    }
  });
  const handleFocus = e => {
    processSuggestions(e.target.value);
    markFocus();
  };
  const handleBlur = e => {
    // Remove focus from the input element to ensure correct blur handling, especially when triggered by window switching
    e.target.blur();
    unmarkFocus();
    requestAnimationFrame(() => {
      setAreSuggestionsShown(false);
      setFilteredSuggestions([]);
    });
  };
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(InputMnemonic_module.wrapper, className, hasFocus && InputMnemonic_module.wrapper_focus, hasError && InputMnemonic_module.wrapper_error)
  }, shouldRenderSuggestions && /*#__PURE__*/teact.createElement(ui_SuggestionList, {
    suggestions: filteredSuggestions,
    activeIndex: activeSuggestionIndex,
    position: suggestionsPosition,
    isInModal: isInModal,
    onSelect: handleClick
  }), /*#__PURE__*/teact.createElement("label", {
    className: InputMnemonic_module.label,
    htmlFor: id
  }, labelText, "."), /*#__PURE__*/teact.createElement("input", {
    id: id,
    className: buildClassName(InputMnemonic_module.input, value !== '' && InputMnemonic_module.touched),
    type: "text",
    autoCapitalize: "none",
    autoComplete: "off",
    autoCorrect: false,
    spellCheck: false,
    onChange: handleChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onPaste: handlePaste,
    value: value,
    tabIndex: 0,
    "data-focus-scroll-position": suggestionsPosition === 'top' ? 'end' : 'start'
  }));
}
function isCorrectMnemonic(mnemonic, wordlist) {
  return mnemonic.length === src_config/* PRIVATE_KEY_HEX_LENGTH */.PcM || wordlist.includes(mnemonic);
}
/* harmony default export */ const common_InputMnemonic = (memo(InputMnemonic));
;// ./src/components/common/backup/BackUpContent.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackUpContent_module = ({"modalSticker":"BackUpContent-module__modalSticker","buttonWrapper":"BackUpContent-module__buttonWrapper","footerButton":"BackUpContent-module__footerButton","checkMnemonicInput":"BackUpContent-module__checkMnemonicInput","error":"BackUpContent-module__error","checkMnemonicForm":"BackUpContent-module__checkMnemonicForm","info":"BackUpContent-module__info","mnemonicContainer":"BackUpContent-module__mnemonicContainer","warning":"BackUpContent-module__warning","words":"BackUpContent-module__words","word":"BackUpContent-module__word","small":"BackUpContent-module__small"});
;// ./src/components/common/backup/CheckWordsForm.tsx








function CheckWordsForm(_ref) {
  var _checkIndexes$map;
  let {
    isActive,
    isInModal,
    checkIndexes,
    mnemonic,
    descriptionClassName,
    formClassName,
    errorClassName,
    onSubmit
  } = _ref;
  const lang = hooks_useLang();
  const [words, setWords] = useState({});
  const [hasMnemonicError, setHasMnemonicError] = useState(false);
  const handleMnemonicCheckSubmit = useLastCallback(e => {
    e.preventDefault();
    const answer = mnemonic && (checkIndexes === null || checkIndexes === void 0 ? void 0 : checkIndexes.map(index => mnemonic[index]));
    if (answer && (0,iteratees/* areSortedArraysEqual */.k)(answer, Object.values(words))) {
      onSubmit();
    } else {
      setHasMnemonicError(true);
    }
  });
  teact_useEffect(() => {
    if (isActive) {
      setWords({});
      setHasMnemonicError(false);
    }
  }, [isActive]);
  const handleSetWord = useLastCallback((value, index) => {
    setWords({
      ...words,
      [index]: value === null || value === void 0 ? void 0 : value.toLowerCase()
    });
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: descriptionClassName
  }, renderText(lang('$mnemonic_check_words_list', checkIndexes === null || checkIndexes === void 0 || (_checkIndexes$map = checkIndexes.map(n => n + 1)) === null || _checkIndexes$map === void 0 ? void 0 : _checkIndexes$map.join(', ')))), /*#__PURE__*/teact.createElement("form", {
    className: formClassName,
    onSubmit: handleMnemonicCheckSubmit,
    id: "check_mnemonic_form"
  }, checkIndexes.map((key, i) => /*#__PURE__*/teact.createElement(common_InputMnemonic, {
    key: key,
    id: `check-mnemonic-${i}`,
    nextId: i + 1 < src_config/* MNEMONIC_CHECK_COUNT */.ow1 ? `check-mnemonic-${i + 1}` : undefined,
    labelText: `${key + 1}`,
    value: words[key],
    isInModal: isInModal,
    suggestionsPosition: i <= 1 ? 'bottom' : 'top',
    inputArg: key,
    className: BackUpContent_module.checkMnemonicInput,
    onInput: handleSetWord
  }))), hasMnemonicError && /*#__PURE__*/teact.createElement("div", {
    className: errorClassName
  }, renderText(lang('$mnemonic_check_error'))));
}
/* harmony default export */ const backup_CheckWordsForm = (memo(CheckWordsForm));
;// ./src/components/common/backup/CheckWordsContent.tsx












function CheckWordsContent(_ref) {
  let {
    isActive,
    checkIndexes,
    mnemonic
  } = _ref;
  const {
    closeCheckWordsPage
  } = getActions();
  const onSubmit = useLastCallback(() => {
    closeCheckWordsPage({
      isBackupCreated: true
    });
  });
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview,
    size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW,
    play: isActive,
    nonInteractive: true,
    noLoop: false,
    className: BackUpContent_module.modalSticker
  }), /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(BackUpContent_module.info, BackUpContent_module.small)
  }, renderText(lang('$check_words_description'))), /*#__PURE__*/teact.createElement(backup_CheckWordsForm, {
    descriptionClassName: buildClassName(BackUpContent_module.info, BackUpContent_module.small),
    formClassName: BackUpContent_module.checkMnemonicForm,
    isActive: isActive,
    mnemonic: mnemonic,
    checkIndexes: checkIndexes,
    errorClassName: BackUpContent_module.error,
    onSubmit: onSubmit
  }), /*#__PURE__*/teact.createElement("div", {
    className: BackUpContent_module.buttonWrapper
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    forFormId: "check_mnemonic_form",
    className: BackUpContent_module.footerButton
  }, lang('Continue'))));
}
/* harmony default export */ const backup_CheckWordsContent = (memo(CheckWordsContent));
;// ./src/components/auth/AuthCheckWords.tsx








const AuthCheckWords = _ref => {
  let {
    isActive,
    mnemonic,
    checkIndexes
  } = _ref;
  const {
    openMnemonicPage
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: openMnemonicPage
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.wrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: openMnemonicPage,
    className: Auth_module.headerBackBlock
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Auth_module.headerTitle
  }, lang('Let\'s Check!'))), /*#__PURE__*/teact.createElement(backup_CheckWordsContent, {
    isActive: isActive,
    mnemonic: mnemonic,
    checkIndexes: checkIndexes
  })));
};
/* harmony default export */ const auth_AuthCheckWords = (memo(AuthCheckWords));
;// ./src/components/auth/AuthConfirmBiometrics.tsx












const START_BIOMETRICS_CONFIRMATION_DELAY_MS = dateFormat/* SECOND */.Z2;
function AuthConfirmBiometrics(_ref) {
  let {
    isActive,
    biometricsStep,
    error,
    isLoading
  } = _ref;
  const {
    afterCreateBiometrics,
    resetAuth,
    cancelCreateBiometrics
  } = getActions();
  hooks_useTimeout(afterCreateBiometrics, isActive ? START_BIOMETRICS_CONFIRMATION_DELAY_MS : undefined, [isActive]);
  const lang = hooks_useLang();
  const shouldRenderSteps = Boolean(biometricsStep);
  const shouldRenderError = Boolean(error && !shouldRenderSteps);
  const renderingError = useCurrentOrPrev(error, true);
  useHistoryBack({
    isActive,
    onBack: resetAuth
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.container_scrollable, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.guard,
    previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
    noLoop: false,
    nonInteractive: true,
    className: Auth_module.sticker
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang('Turn On Biometrics')), shouldRenderSteps && /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.biometricsStep
  }, lang(biometricsStep === 1 ? 'Step 1 of 2. Registration' : 'Step 2 of 2. Verification')), shouldRenderError && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.biometricsError)
  }, /*#__PURE__*/teact.createElement("div", null, lang(renderingError || 'Unknown error')), /*#__PURE__*/teact.createElement("div", null, lang('Please try to confirm your biometrics again'))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons__inner
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isDisabled: Boolean(biometricsStep) || isLoading,
    className: buildClassName(Auth_module.btn, Auth_module.btnHalfWidth),
    onClick: cancelCreateBiometrics
  }, lang('Cancel')), shouldRenderError && /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: buildClassName(Auth_module.btn, Auth_module.btnHalfWidth),
    isDisabled: Boolean(biometricsStep) || isLoading,
    onClick: afterCreateBiometrics
  }, lang('Try Again')))));
}
/* harmony default export */ const auth_AuthConfirmBiometrics = (memo(AuthConfirmBiometrics));
;// ./src/components/auth/AuthConfirmPin.tsx













const SUBMIT_PAUSE_MS = 1500;
const AuthConfirmPin = _ref => {
  let {
    isActive,
    method,
    pin
  } = _ref;
  const {
    confirmPin,
    cancelConfirmPin
  } = getActions();
  const lang = hooks_useLang();
  const [pinConfirm, setPinConfirm] = useState('');
  const [error, setError] = useState('');
  const [isConfirmed, setIsConfirmed] = useState(false);
  const isImporting = method !== 'createAccount';
  const handleBackClick = useLastCallback(() => {
    cancelConfirmPin({
      isImporting
    });
  });
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  teact_useEffect(() => {
    if (isActive) {
      setPinConfirm('');
      setError('');
      setIsConfirmed(false);
    }
  }, [isActive]);
  const handleChange = useLastCallback(value => {
    setPinConfirm(value);
    setError('');
  });
  const handleSubmit = useLastCallback(async value => {
    if (value === pin) {
      setIsConfirmed(true);
      await (0,schedulers/* pause */.v7)(SUBMIT_PAUSE_MS);
      confirmPin({
        isImporting
      });
    } else {
      setError(lang('Codes don\'t match'));
    }
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.containerFullSize)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Auth_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.pinPadHeader
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.guard,
    previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
    noLoop: false,
    nonInteractive: true
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang(isImporting ? 'Wallet is imported!' : 'Wallet is ready!'))), /*#__PURE__*/teact.createElement(ui_PinPad, {
    isActive: isActive,
    title: isConfirmed ? lang('Code set successfully') : error || lang('Enter your code again'),
    type: isConfirmed ? 'success' : error ? 'error' : undefined,
    length: src_config/* PIN_LENGTH */.NEx,
    value: pinConfirm,
    onChange: handleChange,
    onSubmit: handleSubmit
  }));
};
/* harmony default export */ const auth_AuthConfirmPin = (memo(withGlobal(global => {
  return {
    pin: global.auth.password
  };
})(AuthConfirmPin)));
;// ./src/components/auth/AuthCreateBackup.tsx











function AuthCreateBackup(_ref) {
  let {
    isActive
  } = _ref;
  const {
    skipCheckMnemonic,
    openAuthBackupWalletModal,
    resetAuth
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: resetAuth
  });
  const canSkipMnemonicCheck = !src_config/* IS_PRODUCTION */.p8S;
  return /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.wrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: resetAuth,
    className: Auth_module.headerBackBlock
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Auth_module.headerTitle
  }, " ")), /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.snitch,
    previewUrl: ANIMATED_STICKERS_PATHS.snitchPreview,
    noLoop: false,
    nonInteractive: true,
    className: Auth_module.sticker
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang('Create Backup')), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.info
  }, /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.info__space
  }, renderText(lang('$auth_backup_description1'))), /*#__PURE__*/teact.createElement("p", null, renderText(lang('$auth_backup_description2'))), /*#__PURE__*/teact.createElement("p", null, renderText(lang('$auth_backup_description3')))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: buildClassName(Auth_module.btn, Auth_module.btn_wide, !canSkipMnemonicCheck && Auth_module.btn_single),
    onClick: openAuthBackupWalletModal
  }, lang('$back_up_auth')), canSkipMnemonicCheck && /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    isText: true,
    className: buildClassName(Auth_module.btn, Auth_module.btn_push),
    onClick: skipCheckMnemonic
  }, lang('Later')))));
}
/* harmony default export */ const auth_AuthCreateBackup = (memo(AuthCreateBackup));
;// ./src/components/auth/AuthCreateBiometrics.tsx









const AuthCreateBiometrics = _ref => {
  let {
    isActive,
    method
  } = _ref;
  const {
    startCreatingBiometrics,
    resetAuth,
    skipCreateBiometrics
  } = getActions();
  const lang = hooks_useLang();
  const isImporting = method !== 'createAccount';
  useHistoryBack({
    isActive,
    onBack: resetAuth
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.container_scrollable, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.happy,
    previewUrl: ANIMATED_STICKERS_PATHS.happyPreview,
    noLoop: false,
    nonInteractive: true,
    className: Auth_module.sticker
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang('Congratulations!')), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.info
  }, /*#__PURE__*/teact.createElement("b", null, lang(isImporting ? 'The wallet is imported' : 'The wallet is ready'), ".")), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.info
  }, lang('Create a password or use biometric authentication to protect it.')), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: Auth_module.btn,
    onClick: startCreatingBiometrics
  }, lang('Connect Biometrics')), /*#__PURE__*/teact.createElement(ui_Button, {
    isText: true,
    className: buildClassName(Auth_module.btn, Auth_module.btn_text),
    onClick: skipCreateBiometrics
  }, lang('Use Password'))));
};
/* harmony default export */ const auth_AuthCreateBiometrics = (memo(AuthCreateBiometrics));
;// ./src/assets/settings/settings_biometrics.svg
const settings_biometrics_namespaceObject = __webpack_require__.p + "settings_biometrics.507638446829e8e0d552.svg";
;// ./src/assets/settings/settings_face-id.svg
const settings_face_id_namespaceObject = __webpack_require__.p + "settings_face-id.9114cd96723fdb063bc4.svg";
;// ./src/components/auth/AuthCreateNativeBiometrics.tsx










const AuthCreateNativeBiometrics = _ref => {
  let {
    isActive,
    isLoading
  } = _ref;
  const {
    afterCreateNativeBiometrics,
    skipCreateNativeBiometrics,
    resetAuth
  } = getActions();
  const lang = hooks_useLang();
  const isFaceId = getIsFaceIdAvailable();
  const isTouchId = getIsTouchIdAvailable();
  useHistoryBack({
    isActive,
    onBack: resetAuth
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.container
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: resetAuth,
    className: Auth_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("img", {
    src: isFaceId ? settings_face_id_namespaceObject : settings_biometrics_namespaceObject,
    alt: "",
    className: Auth_module.biometricsIcon
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.biometricsTitle
  }, isFaceId ? lang('Use Face ID') : isTouchId ? lang('Use Touch ID') : lang('Use Biometrics')), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.biometricsSubtitle
  }, lang('You can connect your biometric data for more convenience')), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: Auth_module.btn,
    isLoading: isLoading,
    onClick: !isLoading ? afterCreateNativeBiometrics : undefined
  }, lang(isFaceId ? 'Connect Face ID' : isTouchId ? 'Connect Touch ID' : 'Connect Biometrics')), /*#__PURE__*/teact.createElement(ui_Button, {
    isText: true,
    isDisabled: isLoading,
    className: buildClassName(Auth_module.btn, Auth_module.btn_text),
    onClick: skipCreateNativeBiometrics
  }, lang('Not Now'))));
};
/* harmony default export */ const auth_AuthCreateNativeBiometrics = (memo(AuthCreateNativeBiometrics));
;// ./src/hooks/usePasswordValidation.ts

const SPECIAL_CHARS_REGEX = /[`!@#$%^&*()_+\-=\]{};':"\\|,.<>?~]/;
const usePasswordValidation = _ref => {
  let {
    firstPassword = '',
    secondPassword = '',
    requiredMinLength = 8,
    requiredLength,
    isOnlyNumbers
  } = _ref;
  const [invalidLength, setInvalidLength] = useState(false);
  const [noNumber, setNoNumber] = useState(false);
  const [noUpperCase, setNoUpperCase] = useState(false);
  const [noLowerCase, setNoLowerCase] = useState(false);
  const [noSpecialChar, setNoSpecialChar] = useState(false);
  const [noEqual, setNoEqual] = useState(false);
  teact_useEffect(() => {
    const isInvalidLength = Boolean(!requiredLength && firstPassword.length < requiredMinLength || requiredLength && firstPassword.length !== requiredLength);
    setInvalidLength(isInvalidLength);
    setNoUpperCase(!isOnlyNumbers && firstPassword.toLowerCase() === firstPassword);
    setNoLowerCase(!isOnlyNumbers && firstPassword.toUpperCase() === firstPassword);
    setNoNumber(!/\d/.test(firstPassword));
    setNoEqual(Boolean(firstPassword && firstPassword !== secondPassword));
    setNoSpecialChar(!isOnlyNumbers && !SPECIAL_CHARS_REGEX.test(firstPassword));
  }, [firstPassword, secondPassword, requiredMinLength, isOnlyNumbers, requiredLength]);
  return {
    invalidLength,
    noNumber,
    noUpperCase,
    noLowerCase,
    noEqual,
    noSpecialChar
  };
};
;// ./src/components/ui/CreatePasswordForm.tsx















function CreatePasswordForm(_ref) {
  let {
    isActive,
    isLoading,
    formId,
    onCancel,
    onSubmit,
    containerClassName
  } = _ref;
  const lang = hooks_useLang();
  const isMobile = windowEnvironment/* IS_IOS */.pz || windowEnvironment/* IS_ANDROID */.Ni;
  const firstInputRef = teact_useRef();
  const [isJustSubmitted, setIsJustSubmitted] = useState(false);
  const [firstPassword, setFirstPassword] = useState('');
  const [secondPassword, setSecondPassword] = useState('');
  const [isPasswordFocused, markPasswordFocused, unmarkPasswordFocused] = hooks_useFlag(false);
  const [isWeakPasswordModalOpen, openWeakPasswordModal, closeWeakPasswordModal] = hooks_useFlag(false);
  const [hasError, setHasError] = useState(false);
  const [isPasswordsNotEqual, setIsPasswordsNotEqual] = useState(false);
  const [isSecondPasswordFocused, markSecondPasswordFocused, unmarkSecondPasswordFocused] = hooks_useFlag(false);
  const canSubmit = isActive && firstPassword.length > 0 && secondPassword.length > 0 && !hasError;
  const shouldRenderError = hasError && !isPasswordFocused;
  const validation = usePasswordValidation({
    firstPassword,
    secondPassword,
    isOnlyNumbers: isMobile,
    requiredLength: isMobile ? src_config/* PIN_LENGTH */.NEx : undefined
  });
  useFocusAfterAnimation(firstInputRef, !isActive);
  teact_useEffect(() => {
    setIsPasswordsNotEqual(false);
    if (firstPassword === '' || !isActive || isPasswordFocused) {
      setHasError(false);
      return;
    }
    const {
      noEqual,
      invalidLength
    } = validation;
    if ((!isSecondPasswordFocused || isJustSubmitted) && noEqual && secondPassword !== '') {
      setHasError(true);
      setIsPasswordsNotEqual(true);
    } else if (!noEqual || secondPassword === '' || isSecondPasswordFocused && !isJustSubmitted) {
      setHasError(false);
    }
    if (isMobile && invalidLength && !isJustSubmitted) {
      setHasError(true);
    }
  }, [isActive, firstPassword, secondPassword, validation, isSecondPasswordFocused, isPasswordFocused, isJustSubmitted, isMobile]);
  const handleFirstPasswordChange = useLastCallback(value => {
    setFirstPassword(value);
    if (isJustSubmitted) {
      setIsJustSubmitted(false);
    }
  });
  const handleSecondPasswordChange = useLastCallback(value => {
    setSecondPassword(value);
    if (isJustSubmitted) {
      setIsJustSubmitted(false);
    }
  });
  const handleSubmit = useLastCallback(e => {
    stopEvent(e);
    if (!canSubmit) {
      return;
    }
    if (firstPassword !== secondPassword) {
      setIsJustSubmitted(true);
      setHasError(true);
      setIsPasswordsNotEqual(true);
      return;
    }
    const isWeakPassword = Object.values(validation).find(rule => rule);
    if (!isMobile && isWeakPassword && !isWeakPasswordModalOpen) {
      openWeakPasswordModal();
      return;
    }
    if (isWeakPasswordModalOpen) {
      closeWeakPasswordModal();
    }
    onSubmit(firstPassword, isMobile);
  });
  function renderErrors() {
    if (isPasswordsNotEqual) {
      return /*#__PURE__*/teact.createElement("div", {
        className: buildClassName(Auth_module.errors, Auth_module.error)
      }, lang('Passwords must be equal.'));
    }
    const {
      invalidLength,
      noUpperCase,
      noLowerCase,
      noNumber,
      noSpecialChar
    } = validation;
    if (isMobile) {
      return /*#__PURE__*/teact.createElement("div", {
        className: Auth_module.passwordRules
      }, /*#__PURE__*/teact.createElement("span", {
        className: getValidationRuleClass(shouldRenderError, invalidLength || noNumber)
      }, lang('Password must contain %length% digits.', {
        length: src_config/* PIN_LENGTH */.NEx
      })));
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: Auth_module.passwordRules
    }, lang('To protect your wallet as much as possible, use a password with'), /*#__PURE__*/teact.createElement("span", {
      className: getValidationRuleClass(shouldRenderError, invalidLength)
    }, ' ', lang('$auth_password_rule_8chars'), ","), /*#__PURE__*/teact.createElement("span", {
      className: getValidationRuleClass(shouldRenderError, noLowerCase)
    }, ' ', lang('$auth_password_rule_one_small_char'), ","), /*#__PURE__*/teact.createElement("span", {
      className: getValidationRuleClass(shouldRenderError, noUpperCase)
    }, ' ', lang('$auth_password_rule_one_capital_char'), ","), /*#__PURE__*/teact.createElement("span", {
      className: getValidationRuleClass(shouldRenderError, noNumber)
    }, ' ', lang('$auth_password_rule_one_digit'), ","), /*#__PURE__*/teact.createElement("span", {
      className: getValidationRuleClass(shouldRenderError, noSpecialChar)
    }, ' ', lang('$auth_password_rule_one_special_char')), ".");
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("form", {
    id: formId,
    className: buildClassName(Auth_module.form, containerClassName),
    onSubmit: handleSubmit
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.formWidgets
  }, /*#__PURE__*/teact.createElement(ui_Input, {
    ref: firstInputRef,
    type: "password",
    isRequired: true,
    id: "first-password",
    inputMode: isMobile ? 'numeric' : undefined,
    hasError: shouldRenderError,
    placeholder: lang('Enter your password...'),
    value: firstPassword,
    autoComplete: "new-password",
    onInput: handleFirstPasswordChange,
    onFocus: markPasswordFocused,
    onBlur: unmarkPasswordFocused,
    className: Auth_module.input,
    maxLength: isMobile ? src_config/* PIN_LENGTH */.NEx : undefined,
    enterKeyHint: "next"
  }), /*#__PURE__*/teact.createElement(ui_Input, {
    type: "password",
    isRequired: true,
    id: "second-password",
    inputMode: isMobile ? 'numeric' : undefined,
    placeholder: lang('...and repeat it'),
    hasError: isPasswordsNotEqual,
    value: secondPassword,
    autoComplete: "new-password",
    onInput: handleSecondPasswordChange,
    onFocus: markSecondPasswordFocused,
    onBlur: unmarkSecondPasswordFocused,
    className: Auth_module.input,
    maxLength: isMobile ? src_config/* PIN_LENGTH */.NEx : undefined,
    enterKeyHint: "next"
  })), renderErrors(), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onCancel,
    className: Modal_module.button,
    isDisabled: isLoading
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isSubmit: true,
    isPrimary: true,
    isDisabled: isPasswordsNotEqual || firstPassword === '',
    isLoading: isLoading,
    className: Modal_module.button
  }, lang('Continue')))), /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isWeakPasswordModalOpen,
    isCompact: true,
    onClose: closeWeakPasswordModal,
    title: lang('Insecure Password')
  }, /*#__PURE__*/teact.createElement("p", {
    className: Modal_module.text
  }, lang('Your have entered an insecure password, which can be easily guessed by scammers.')), /*#__PURE__*/teact.createElement("p", {
    className: Modal_module.text
  }, lang('Continue or change password to something more secure?')), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.buttons, Modal_module.buttonsNoExtraSpace)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    onClick: closeWeakPasswordModal,
    className: Modal_module.button
  }, lang('Change')), /*#__PURE__*/teact.createElement(ui_Button, {
    forFormId: formId,
    isSubmit: true,
    isDestructive: true,
    className: Modal_module.button
  }, lang('Continue')))));
}
/* harmony default export */ const ui_CreatePasswordForm = (memo(CreatePasswordForm));
function getValidationRuleClass(shouldRenderError, ruleHasError) {
  return buildClassName(Auth_module.passwordRule, !ruleHasError ? Auth_module.valid : shouldRenderError ? Auth_module.invalid : undefined);
}
;// ./src/components/auth/AuthCreatePassword.tsx











const AuthCreatePassword = _ref => {
  let {
    isActive,
    method,
    isLoading
  } = _ref;
  const {
    afterCreatePassword,
    resetAuth
  } = getActions();
  const lang = hooks_useLang();
  const isImporting = method !== 'createAccount';
  const formId = getFormId(method);
  const withDescription = !getIsBiometricAuthSupported();
  useHistoryBack({
    isActive,
    onBack: resetAuth
  });
  const handleSubmit = useLastCallback((password, isPasswordNumeric) => {
    afterCreatePassword({
      password,
      isPasswordNumeric
    });
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.container_scrollable, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.guard,
    previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
    noLoop: false,
    nonInteractive: true,
    className: Auth_module.sticker
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.title, !withDescription && Auth_module.titleSmallMargin)
  }, lang(withDescription ? 'Congratulations!' : 'Create Password')), withDescription && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.info
  }, /*#__PURE__*/teact.createElement("b", null, lang(isImporting ? 'The wallet is imported' : 'The wallet is ready'), ".")), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.info
  }, lang('Create a password to protect it.'))), /*#__PURE__*/teact.createElement(ui_CreatePasswordForm, {
    isActive: isActive,
    isLoading: isLoading,
    formId: formId,
    onCancel: resetAuth,
    onSubmit: handleSubmit
  }));
};
function getFormId(method) {
  switch (method) {
    case 'createAccount':
      return 'auth_create_password';
    case 'importMnemonic':
      return 'auth_import_mnemonic_password';
    case 'importHardwareWallet':
      return 'auth_import_hardware_password';
  }
}
/* harmony default export */ const auth_AuthCreatePassword = (memo(AuthCreatePassword));
;// ./src/components/auth/AuthCreatePin.tsx













const AuthCreatePin_SUBMIT_PAUSE_MS = 750;
const AuthCreatePin = _ref => {
  let {
    isActive,
    method
  } = _ref;
  const {
    createPin,
    resetAuth
  } = getActions();
  const lang = hooks_useLang();
  const [pin, setPin] = useState('');
  const isImporting = method !== 'createAccount';
  teact_useEffect(() => {
    if (isActive) {
      setPin('');
    }
  }, [isActive]);
  useHistoryBack({
    isActive,
    onBack: resetAuth
  });
  const handleSubmit = useLastCallback(async value => {
    await (0,schedulers/* pause */.v7)(AuthCreatePin_SUBMIT_PAUSE_MS);
    createPin({
      pin: value,
      isImporting
    });
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.containerFullSize)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: resetAuth,
    className: Auth_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.pinPadHeader
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.guard,
    previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
    noLoop: false,
    nonInteractive: true
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang(isImporting ? 'Wallet is imported!' : 'Wallet is ready!'))), /*#__PURE__*/teact.createElement(ui_PinPad, {
    isActive: isActive,
    title: lang('Create a code to protect it'),
    length: src_config/* PIN_LENGTH */.NEx,
    value: pin,
    onChange: setPin,
    onSubmit: handleSubmit
  }));
};
/* harmony default export */ const auth_AuthCreatePin = (memo(AuthCreatePin));
;// ./src/components/auth/AuthCreatingWallet.tsx










const START_DELAY = 700;
const AuthCreatingWallet_INTERVAL = dateFormat/* SECOND */.Z2;
const AuthCreatingWallet = _ref => {
  let {
    isActive
  } = _ref;
  const lang = hooks_useLang();
  const [one, markOne] = hooks_useFlag();
  const [two, markTwo] = hooks_useFlag();
  const [three, markThree] = hooks_useFlag();
  hooks_useTimeout(markOne, isActive ? START_DELAY : undefined);
  hooks_useTimeout(markTwo, isActive ? START_DELAY + AuthCreatingWallet_INTERVAL : undefined);
  hooks_useTimeout(markThree, isActive ? START_DELAY + AuthCreatingWallet_INTERVAL * 2 : undefined);
  const oneRef = useMediaTransition(one);
  const twoRef = useMediaTransition(two);
  const threeRef = useMediaTransition(three);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.hello,
    previewUrl: ANIMATED_STICKERS_PATHS.helloPreview,
    nonInteractive: true,
    noLoop: false
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang('Creating Wallet...')), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.counter
  }, /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.counterTitle
  }, lang('On the count of three...')), /*#__PURE__*/teact.createElement("b", {
    ref: oneRef,
    className: buildClassName(Auth_module.counterDigit, 'rounded-font')
  }, "1"), /*#__PURE__*/teact.createElement("b", {
    ref: twoRef,
    className: buildClassName(Auth_module.counterDigit, 'rounded-font')
  }, "2"), /*#__PURE__*/teact.createElement("b", {
    ref: threeRef,
    className: buildClassName(Auth_module.counterDigit, 'rounded-font')
  }, "3")));
};
/* harmony default export */ const auth_AuthCreatingWallet = (memo(AuthCreatingWallet));
;// ./src/components/auth/AuthBackupWarning.tsx










function AuthBackupWarning(_ref) {
  let {
    isOpen,
    onSkip,
    onClose
  } = _ref;
  const {
    openAuthBackupWalletModal
  } = getActions();
  const handleBackupClick = useLastCallback(() => {
    onClose();
    openAuthBackupWalletModal();
  });
  const lang = hooks_useLang();
  const canSkipMnemonicCheck = !src_config/* IS_PRODUCTION */.p8S;
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    onClose: onClose,
    forceBottomSheet: true,
    nativeBottomSheetKey: "backup-warning",
    dialogClassName: Auth_module.disclaimerBackupDialog
  }, /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.backupNotice
  }, renderText(lang('$auth_backup_warning_notice'))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.backupNoticeButtons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: buildClassName(Auth_module.btn, Auth_module.btn_wide, !canSkipMnemonicCheck && Auth_module.btn_single),
    onClick: handleBackupClick
  }, lang('Back Up Now')), canSkipMnemonicCheck && /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    className: buildClassName(Auth_module.btn, Auth_module.btn_mini),
    onClick: onSkip
  }, lang('Later'))));
}
/* harmony default export */ const auth_AuthBackupWarning = (memo(AuthBackupWarning));
;// ./src/components/auth/AuthDisclaimer.tsx















const CONFIRM_DELAY_MS = 350;
const AuthDisclaimer = _ref => {
  let {
    isActive,
    isImport
  } = _ref;
  const {
    skipCheckMnemonic,
    confirmDisclaimer,
    cancelDisclaimer
  } = getActions();
  const lang = hooks_useLang();
  const [isInformationConfirmed, markInformationConfirmed, unmarkInformationConfirmed] = hooks_useFlag(false);
  useHistoryBack({
    isActive,
    onBack: cancelDisclaimer
  });
  const setIsInformationConfirmed = useLastCallback(isConfirmed => {
    if (isConfirmed) {
      markInformationConfirmed();
      if (isImport) {
        window.setTimeout(confirmDisclaimer, CONFIRM_DELAY_MS);
      }
    } else {
      unmarkInformationConfirmed();
    }
  });
  useOpenFromMainBottomSheet('backup-warning', markInformationConfirmed);
  const handleCloseBackupWarningModal = useLastCallback(() => {
    setIsInformationConfirmed(false);
  });
  const handleSkipMnemonic = useLastCallback(() => {
    skipCheckMnemonic();
    handleCloseBackupWarningModal();
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.wrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.container_scrollable, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.stickerAndTitle
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.snitch,
    previewUrl: ANIMATED_STICKERS_PATHS.snitchPreview,
    noLoop: false,
    nonInteractive: true,
    size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW,
    className: Auth_module.sticker
  }), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.title
  }, lang('Use Responsibly'))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.infoBlock
  }, /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.text
  }, renderText(lang('$auth_responsibly_description1', {
    app_name: src_config/* APP_NAME */.C39
  }))), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.text
  }, renderText(lang('$auth_responsibly_description2'))), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.text
  }, renderText(lang('$auth_responsibly_description3', {
    app_name: src_config/* APP_NAME */.C39
  }))), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.text
  }, renderText(lang('$auth_responsibly_description4')))), /*#__PURE__*/teact.createElement(ui_Checkbox, {
    id: "information-confirmed",
    checked: isInformationConfirmed,
    isDisabled: isImport && isInformationConfirmed,
    className: Auth_module.informationCheckbox,
    contentClassName: Auth_module.informationCheckboxContent,
    onChange: setIsInformationConfirmed
  }, lang('I have read and accept this information')), !isImport && /*#__PURE__*/teact.createElement(auth_AuthBackupWarning, {
    isOpen: isInformationConfirmed,
    onClose: handleCloseBackupWarningModal,
    onSkip: handleSkipMnemonic
  })));
};
/* harmony default export */ const auth_AuthDisclaimer = (memo(AuthDisclaimer));
;// ./src/hooks/useClipboardPaste.ts

const MAX_MESSAGE_LENGTH = 4096;
const useClipboardPaste = (isActive, onPaste) => {
  teact_useEffect(() => {
    if (!isActive) {
      return undefined;
    }
    function handlePaste(e) {
      if (!e.clipboardData) {
        return;
      }
      const pastedText = e.clipboardData.getData('text').substring(0, MAX_MESSAGE_LENGTH);
      if (!pastedText) {
        return;
      }
      e.preventDefault();
      onPaste(pastedText);
    }
    document.addEventListener('paste', handlePaste, false);
    return () => {
      document.removeEventListener('paste', handlePaste, false);
    };
  }, [isActive, onPaste]);
};
/* harmony default export */ const hooks_useClipboardPaste = (useClipboardPaste);
;// ./src/components/auth/AuthImportMnemonic.tsx



















const MNEMONIC_INPUTS = [...Array(src_config/* MNEMONIC_COUNT */.xA_)].map((_, index) => ({
  id: index,
  label: `${index + 1}`
}));
const MAX_LENGTH = src_config/* PRIVATE_KEY_HEX_LENGTH */.PcM;
const SLIDE_ANIMATION_DURATION_MS = 250;
const AuthImportMnemonic = _ref => {
  let {
    isActive,
    isLoading,
    error
  } = _ref;
  const {
    afterImportMnemonic,
    resetAuth,
    cleanAuthError
  } = getActions();
  const lang = hooks_useLang();
  const [mnemonic, setMnemonic] = useState({});
  const {
    isPortrait
  } = useDeviceScreen();
  const handleMnemonicSet = useLastCallback(pastedMnemonic => {
    var _document$activeEleme;
    if (!src_config/* MNEMONIC_COUNTS */.Yyb.includes(pastedMnemonic.length) && !isMnemonicPrivateKey(pastedMnemonic)) {
      return;
    }

    // RAF is a workaround for several Android browsers (e.g. Vivaldi)
    requestAnimationFrame(() => {
      setMnemonic(pastedMnemonic);
    });
    if ((_document$activeEleme = document.activeElement) !== null && _document$activeEleme !== void 0 && _document$activeEleme.id.startsWith('import-mnemonic-')) {
      document.activeElement.blur();
    }
  });
  const handlePasteMnemonic = useLastCallback(pastedText => {
    var _document$activeEleme2;
    const pastedMnemonic = parsePastedText(pastedText);
    if (pastedMnemonic.length === 1 && (_document$activeEleme2 = document.activeElement) !== null && _document$activeEleme2 !== void 0 && _document$activeEleme2.id.startsWith('import-mnemonic-')) {
      document.activeElement.value = pastedMnemonic[0];
      const event = new Event('input');
      document.activeElement.dispatchEvent(event);
      return;
    }
    handleMnemonicSet(pastedMnemonic);
  });
  hooks_useClipboardPaste(Boolean(isActive), handlePasteMnemonic);
  const isSubmitDisabled = teact_useMemo(() => {
    const mnemonicValues = (0,iteratees/* compact */.oE)(Object.values(mnemonic));
    return !src_config/* MNEMONIC_COUNTS */.Yyb.includes(mnemonicValues.length) && !isMnemonicPrivateKey(mnemonicValues) || !!error;
  }, [mnemonic, error]);
  const handleSetWord = useLastCallback((value, index) => {
    cleanAuthError();
    const pastedMnemonic = parsePastedText(value);
    if (src_config/* MNEMONIC_COUNTS */.Yyb.includes(pastedMnemonic.length)) {
      handleMnemonicSet(pastedMnemonic);
      return;
    }
    setMnemonic({
      ...mnemonic,
      [index]: pastedMnemonic[0].toLowerCase()
    });
  });
  const handleCancel = useLastCallback(() => {
    setTimeout(() => {
      resetAuth();
    }, SLIDE_ANIMATION_DURATION_MS);
  });
  const handleSubmit = useLastCallback(async () => {
    if (isSubmitDisabled) return;
    const mnemonicValues = (0,iteratees/* compact */.oE)(Object.values(mnemonic));
    if (mnemonicValues.length === 12) {
      const isShortMnemonicValid = await (0,api/* callApi */.p)('validateMnemonic', mnemonicValues);
      if (!isShortMnemonicValid) return;
    }
    afterImportMnemonic({
      mnemonic: mnemonicValues
    });
  });
  useHistoryBack({
    isActive,
    onBack: handleCancel
  });
  teact_useEffect(() => {
    return isSubmitDisabled || isLoading ? undefined : captureKeyboardListeners({
      onEnter: {
        handler: handleSubmit,
        noStopPropagation: true
      }
    });
  }, [handleSubmit, isLoading, isSubmitDisabled, mnemonic]);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.container_scrollable, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    size: src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp,
    tgsUrl: ANIMATED_STICKERS_PATHS.snitch,
    previewUrl: ANIMATED_STICKERS_PATHS.snitchPreview,
    nonInteractive: true,
    noLoop: false,
    className: Auth_module.sticker
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.title, Auth_module.title_afterSmallSticker)
  }, lang('Enter Secret Words')), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.info, Auth_module.infoSmallFont, Auth_module.infoPull)
  }, renderText(lang(src_config/* IS_BIP39_MNEMONIC_ENABLED */.iAh ? '$auth_import_mnemonic_description' : '$auth_import_24_mnemonic_description'))), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.importingContent
  }, MNEMONIC_INPUTS.map((_ref2, i) => {
    let {
      id,
      label
    } = _ref2;
    return /*#__PURE__*/teact.createElement(common_InputMnemonic, {
      key: id,
      id: `import-mnemonic-${id}`,
      nextId: id + 1 < src_config/* MNEMONIC_COUNT */.xA_ ? `import-mnemonic-${id + 1}` : undefined,
      labelText: label,
      value: mnemonic[id],
      suggestionsPosition: getSuggestPosition(id, isPortrait),
      inputArg: id,
      onInput: handleSetWord,
      onEnter: i === src_config/* MNEMONIC_COUNT */.xA_ - 1 ? handleSubmit : undefined
    });
  })), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons
  }, error && /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.footerError
  }, lang(error)), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.buttons__inner
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: handleCancel,
    className: Auth_module.footerButton
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDisabled: isSubmitDisabled,
    isLoading: isLoading,
    className: Auth_module.footerButton,
    onClick: handleSubmit
  }, lang('Continue')))));
};
/* harmony default export */ const auth_AuthImportMnemonic = (memo(withGlobal(global => {
  return {
    error: global.auth.error,
    isLoading: global.auth.isLoading
  };
})(AuthImportMnemonic)));
function parsePastedText() {
  let str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return str.replace(/(?:\r\n)+|[\r\n\s;,\t]+/g, ' ').trim().split(' ').map(w => w.slice(0, MAX_LENGTH));
}
function getSuggestPosition(id) {
  let isPortrait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (isPortrait) {
    return 'top';
  }
  return id > 5 && id < 8 || id > 13 && id < 16 || id > 21 ? 'top' : undefined;
}
;// ./src/components/auth/AuthImportViewAccount.tsx

















function AuthImportViewAccount(_ref) {
  let {
    isActive,
    isLoading,
    onCancel,
    onClose
  } = _ref;
  const {
    importViewAccount
  } = getActions();
  const lang = hooks_useLang();
  const inputRef = teact_useRef();
  const [value, setValue] = useState('');
  const [isInvalidAddress, setIsInvalidAddress] = useState(false);
  useFocusAfterAnimation(inputRef, !isActive);
  useHistoryBack({
    isActive,
    onBack: onCancel
  });
  const handleChange = useLastCallback(newValue => {
    setValue(newValue);
    if (isInvalidAddress) {
      setIsInvalidAddress(false);
    }
  });
  function handleSubmit(e) {
    stopEvent(e);
    if (isInvalidAddress || isLoading) return;
    const addresses = value.trim().split(/\s+/);
    const addressByChain = {};
    const hasValidAddress = addresses.reduce((isValid, address) => {
      if (isValidAddressOrDomain(address, 'ton')) {
        addressByChain.ton = address;
        return true;
      }
      if (isValidAddressOrDomain(address, 'tron')) {
        addressByChain.tron = address;
        return true;
      }
      return isValid;
    }, false);
    if (hasValidAddress) {
      var _inputRef$current;
      importViewAccount({
        addressByChain
      });
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur(); // To hide the virtual keyboard to show the loading indicator in the button
    } else {
      setIsInvalidAddress(true);
    }
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContentWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('View Any Address'),
    onClose: onClose,
    onBackButtonClick: onCancel
  }), /*#__PURE__*/teact.createElement("form", {
    action: "#",
    className: buildClassName(Modal_module.transitionContent, 'custom-scroll'),
    onSubmit: handleSubmit
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview,
    noLoop: false,
    nonInteractive: true,
    className: Auth_module.viewModeSticker
  }), /*#__PURE__*/teact.createElement(ui_Input, {
    ref: inputRef,
    value: value,
    hasError: isInvalidAddress,
    placeholder: lang('Wallet Address or Domain'),
    autoCapitalize: "none",
    autoComplete: "off",
    autoCorrect: false,
    enterKeyHint: "done",
    onInput: handleChange
  }), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.info
  }, renderText(lang('$import_view_account_note'))), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isSubmit: true,
    className: Modal_module.buttonFullWidth,
    isLoading: isLoading,
    isDisabled: isInvalidAddress
  }, isInvalidAddress ? lang('Invalid Address') : lang('Continue')))));
}
/* harmony default export */ const auth_AuthImportViewAccount = (memo(AuthImportViewAccount));
;// ./src/components/common/backup/SafetyRulesContent.tsx










function SafetyRulesContent(_ref) {
  let {
    customStickerClassName,
    customButtonWrapperClassName,
    isFullSizeButton,
    isActive,
    isFirstCheckboxSelected,
    isSecondCheckboxSelected,
    isThirdCheckboxSelected,
    textFirst,
    textSecond,
    textThird,
    onFirstCheckboxClick,
    onSecondCheckboxClick,
    onThirdCheckboxClick,
    onSubmit
  } = _ref;
  const lang = hooks_useLang();
  const canSubmit = isFirstCheckboxSelected && isSecondCheckboxSelected && isThirdCheckboxSelected;
  const handleSubmit = useLastCallback(() => {
    if (!canSubmit) {
      return;
    }
    onSubmit();
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview,
    size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW,
    play: isActive,
    nonInteractive: true,
    noLoop: false,
    className: customStickerClassName || BackUpContent_module.modalSticker
  }), /*#__PURE__*/teact.createElement(ui_Checkbox, {
    checked: isFirstCheckboxSelected,
    onChange: onFirstCheckboxClick
  }, renderText(textFirst)), /*#__PURE__*/teact.createElement(ui_Checkbox, {
    checked: isSecondCheckboxSelected,
    onChange: onSecondCheckboxClick
  }, renderText(textSecond)), /*#__PURE__*/teact.createElement(ui_Checkbox, {
    checked: isThirdCheckboxSelected,
    onChange: onThirdCheckboxClick
  }, renderText(textThird)), /*#__PURE__*/teact.createElement("div", {
    className: customButtonWrapperClassName || BackUpContent_module.buttonWrapper
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDisabled: !canSubmit,
    className: isFullSizeButton ? BackUpContent_module.footerButton : undefined,
    onClick: handleSubmit
  }, lang('Understood'))));
}
/* harmony default export */ const backup_SafetyRulesContent = (memo(SafetyRulesContent));
;// ./src/components/auth/AuthSafetyRules.tsx








const AuthSafetyRules = _ref => {
  let {
    isActive
  } = _ref;
  const {
    openCreateBackUpPage,
    openMnemonicPage
  } = getActions();
  const [firstChecked, setFirstChecked] = useState(false);
  const [secondChecked, setSecondChecked] = useState(false);
  const [thirdChecked, setThirdChecked] = useState(false);
  useHistoryBack({
    isActive,
    onBack: openCreateBackUpPage
  });
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.wrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: openCreateBackUpPage,
    className: Auth_module.headerBackBlock
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Auth_module.headerTitle
  }, lang('Safety Rules'))), /*#__PURE__*/teact.createElement(backup_SafetyRulesContent, {
    isActive: isActive,
    isFullSizeButton: true,
    textFirst: lang('$safety_rules_one'),
    textSecond: lang('$safety_rules_two'),
    textThird: lang('$safety_rules_three'),
    isFirstCheckboxSelected: firstChecked,
    onFirstCheckboxClick: setFirstChecked,
    isSecondCheckboxSelected: secondChecked,
    onSecondCheckboxClick: setSecondChecked,
    isThirdCheckboxSelected: thirdChecked,
    onThirdCheckboxClick: setThirdChecked,
    onSubmit: openMnemonicPage
  })));
};
/* harmony default export */ const auth_AuthSafetyRules = (memo(AuthSafetyRules));
;// ./src/components/common/backup/SecretWordsList.tsx





function SecretWordsList(_ref) {
  let {
    mnemonic
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(BackUpContent_module.info, BackUpContent_module.small)
  }, renderText(lang('$mnemonic_list_description'))), /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(BackUpContent_module.warning)
  }, renderText(lang('$mnemonic_warning'))), /*#__PURE__*/teact.createElement("ol", {
    className: BackUpContent_module.words
  }, mnemonic === null || mnemonic === void 0 ? void 0 : mnemonic.map((word, i) => /*#__PURE__*/teact.createElement("li", {
    key: i,
    className: BackUpContent_module.word
  }, word))));
}
/* harmony default export */ const backup_SecretWordsList = (memo(SecretWordsList));
;// ./src/components/common/backup/SecretWordsContent.tsx







function SecretWordsContent(_ref) {
  let {
    isActive,
    mnemonic,
    onSubmit,
    buttonText
  } = _ref;
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview,
    size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW,
    play: isActive,
    nonInteractive: true,
    noLoop: false,
    className: BackUpContent_module.modalSticker
  }), /*#__PURE__*/teact.createElement(backup_SecretWordsList, {
    mnemonic: mnemonic
  }), /*#__PURE__*/teact.createElement("div", {
    className: BackUpContent_module.buttonWrapper
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    onClick: onSubmit,
    className: BackUpContent_module.footerButton
  }, buttonText)));
}
/* harmony default export */ const backup_SecretWordsContent = (memo(SecretWordsContent));
;// ./src/components/auth/AuthSecretWords.tsx








const AuthSecretWords = _ref => {
  let {
    isActive,
    mnemonic
  } = _ref;
  const {
    openAuthBackupWalletModal,
    openCheckWordsPage
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: openAuthBackupWalletModal
  });
  const wordsCount = (mnemonic === null || mnemonic === void 0 ? void 0 : mnemonic.length) || 0;
  return /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.wrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, Auth_module.containerAlignTop, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: openAuthBackupWalletModal,
    className: Auth_module.headerBackBlock
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Auth_module.headerTitle
  }, lang('%1$d Secret Words', wordsCount))), /*#__PURE__*/teact.createElement(backup_SecretWordsContent, {
    isActive: isActive,
    mnemonic: mnemonic,
    onSubmit: openCheckWordsPage,
    buttonText: lang('Let\'s Check')
  })));
};
/* harmony default export */ const auth_AuthSecretWords = (memo(AuthSecretWords));
;// ./src/components/auth/AuthStart.tsx
















function AuthStart(_ref) {
  let {
    isActive,
    hasAccounts,
    isLoading,
    theme
  } = _ref;
  const {
    startCreatingWallet,
    startImportingWallet,
    openAbout,
    openHardwareWalletModal,
    resetAuth,
    openAuthImportWalletModal
  } = getActions();
  const lang = hooks_useLang();
  const appTheme = hooks_useAppTheme(theme);
  const logoPath = appTheme === 'light' ? logoLight_namespaceObject : logoDark_namespaceObject;
  const [isLogoReady, markLogoReady] = hooks_useFlag();
  const logoRef = useMediaTransition(isLogoReady);
  function renderSimpleImportForm() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
      className: Auth_module.importText
    }, lang('or import from')), /*#__PURE__*/teact.createElement("div", {
      className: Auth_module.importButtons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: buildClassName(Auth_module.btn, !windowEnvironment/* IS_LEDGER_SUPPORTED */.sC && Auth_module.btn_single),
      onClick: !isLoading ? startImportingWallet : undefined
    }, lang('Secret Words')), windowEnvironment/* IS_LEDGER_SUPPORTED */.sC && /*#__PURE__*/teact.createElement(ui_Button, {
      className: buildClassName(Auth_module.btn, Auth_module.btn_mini),
      onClick: !isLoading ? openHardwareWalletModal : undefined
    }, lang('Ledger'))));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.container, 'custom-scroll')
  }, hasAccounts && /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: resetAuth,
    className: Auth_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Auth_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), src_config/* IS_CORE_WALLET */.TI6 ? /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.coreWalletLogo,
    previewUrl: ANIMATED_STICKERS_PATHS.coreWalletLogoPreview,
    noLoop: false,
    nonInteractive: true
  }) : /*#__PURE__*/teact.createElement("img", {
    ref: logoRef,
    src: logoPath,
    alt: src_config/* APP_NAME */.C39,
    className: Auth_module.logo,
    onLoad: markLogoReady
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.appName, 'rounded-font')
  }, src_config/* APP_NAME */.C39), /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.info
  }, renderText(lang('$auth_intro'))), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement(ui_Button, {
    isText: true,
    className: buildClassName(Auth_module.btn, Auth_module.btn_about),
    onClick: openAbout
  }, lang('More about %app_name%', {
    app_name: src_config/* APP_NAME */.C39
  }), /*#__PURE__*/teact.createElement("i", {
    className: "icon-chevron-right",
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.importButtonsBlock, src_config/* IS_CORE_WALLET */.TI6 && Auth_module.importButtonsBlockSimple)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: buildClassName(Auth_module.btn, !src_config/* IS_CORE_WALLET */.TI6 && Auth_module.btn_single, !src_config/* IS_CORE_WALLET */.TI6 && Auth_module.btn_wide),
    isLoading: isLoading,
    onClick: !isLoading ? startCreatingWallet : undefined
  }, lang('Create Wallet')), src_config/* IS_CORE_WALLET */.TI6 ? renderSimpleImportForm() : /*#__PURE__*/teact.createElement(ui_Button, {
    className: buildClassName(Auth_module.btn, Auth_module.btn_wide, Auth_module.btn_single),
    onClick: !isLoading ? openAuthImportWalletModal : undefined
  }, lang('Import Existing Wallet'))));
}
/* harmony default export */ const auth_AuthStart = (memo(withGlobal(global => {
  return {
    hasAccounts: Boolean(global.currentAccountId),
    isLoading: global.auth.isLoading,
    theme: global.settings.theme
  };
})(AuthStart)));
;// ./src/components/auth/Auth.tsx



























const RENDER_COUNT = Object.keys(AuthState).length / 2;
const Auth = _ref => {
  let {
    state,
    biometricsStep,
    error,
    isLoading,
    mnemonic,
    mnemonicCheckIndexes,
    method,
    theme
  } = _ref;
  const {
    closeAbout,
    closeImportViewAccount
  } = getActions();
  const {
    isPortrait
  } = useDeviceScreen();

  // Transitioning to ready state is done in another component
  const renderingAuthState = useCurrentOrPrev(state === AuthState.ready ? undefined : state, true) ?? -1;
  const [prevKey, setPrevKey] = useState(undefined);
  const [nextKey, setNextKey] = useState(renderingAuthState + 1);
  const updateRenderingKeys = useLastCallback(() => {
    setNextKey(renderingAuthState + 1);
    setPrevKey(renderingAuthState === AuthState.confirmPin ? AuthState.createPin : undefined);
  });
  function renderAuthScreen(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case AuthState.none:
        return /*#__PURE__*/teact.createElement(auth_AuthStart, {
          isActive: isActive
        });
      case AuthState.createWallet:
        return /*#__PURE__*/teact.createElement(auth_AuthCreatingWallet, {
          isActive: isActive
        });
      case AuthState.checkPassword:
        return /*#__PURE__*/teact.createElement(auth_AuthCheckPassword, {
          isActive: isActive,
          isLoading: isLoading,
          method: "createAccount",
          error: error
        });
      case AuthState.createPin:
        return /*#__PURE__*/teact.createElement(auth_AuthCreatePin, {
          isActive: isActive,
          method: "createAccount"
        });
      case AuthState.confirmPin:
        return /*#__PURE__*/teact.createElement(auth_AuthConfirmPin, {
          isActive: isActive,
          method: "createAccount"
        });
      case AuthState.createBiometrics:
        return /*#__PURE__*/teact.createElement(auth_AuthCreateBiometrics, {
          isActive: isActive,
          method: "createAccount"
        });
      case AuthState.confirmBiometrics:
        return /*#__PURE__*/teact.createElement(auth_AuthConfirmBiometrics, {
          isActive: isActive,
          isLoading: isLoading,
          error: error,
          biometricsStep: biometricsStep
        });
      case AuthState.createNativeBiometrics:
        return /*#__PURE__*/teact.createElement(auth_AuthCreateNativeBiometrics, {
          isActive: isActive,
          isLoading: isLoading
        });
      case AuthState.createPassword:
        return /*#__PURE__*/teact.createElement(auth_AuthCreatePassword, {
          isActive: isActive,
          isLoading: isLoading,
          method: "createAccount"
        });
      case AuthState.createBackup:
        return /*#__PURE__*/teact.createElement(auth_AuthCreateBackup, {
          isActive: isActive
        });
      case AuthState.disclaimerAndBackup:
        return /*#__PURE__*/teact.createElement(auth_AuthDisclaimer, {
          key: "create",
          isActive: isActive
        });
      case AuthState.importWallet:
        return /*#__PURE__*/teact.createElement(auth_AuthImportMnemonic, {
          isActive: isActive
        });
      case AuthState.importWalletCreatePin:
        return /*#__PURE__*/teact.createElement(auth_AuthCreatePin, {
          isActive: isActive,
          method: "importMnemonic"
        });
      case AuthState.importWalletConfirmPin:
        return /*#__PURE__*/teact.createElement(auth_AuthConfirmPin, {
          isActive: isActive,
          method: "importMnemonic"
        });
      case AuthState.importWalletCheckPassword:
        return /*#__PURE__*/teact.createElement(auth_AuthCheckPassword, {
          isActive: isActive,
          isLoading: isLoading,
          method: "importMnemonic",
          error: error
        });
      case AuthState.disclaimer:
        return /*#__PURE__*/teact.createElement(auth_AuthDisclaimer, {
          key: "import",
          isActive: isActive,
          isImport: true
        });
      case AuthState.importWalletCreateNativeBiometrics:
        return /*#__PURE__*/teact.createElement(auth_AuthCreateNativeBiometrics, {
          isActive: isActive,
          isLoading: isLoading
        });
      case AuthState.importWalletCreatePassword:
        return /*#__PURE__*/teact.createElement(auth_AuthCreatePassword, {
          isActive: isActive,
          isLoading: isLoading,
          method: method
        });
      case AuthState.importWalletCreateBiometrics:
        return /*#__PURE__*/teact.createElement(auth_AuthCreateBiometrics, {
          isActive: isActive,
          method: method
        });
      case AuthState.importWalletConfirmBiometrics:
        return /*#__PURE__*/teact.createElement(auth_AuthConfirmBiometrics, {
          isActive: isActive,
          isLoading: isLoading,
          error: error,
          biometricsStep: biometricsStep
        });
      case AuthState.about:
        return /*#__PURE__*/teact.createElement(settings_SettingsAbout, {
          isActive: isActive,
          theme: theme,
          headerClassName: Auth_module.aboutHeader,
          handleBackClick: closeAbout
        });
      case AuthState.safetyRules:
        return /*#__PURE__*/teact.createElement(auth_AuthSafetyRules, {
          isActive: isActive
        });
      case AuthState.mnemonicPage:
        return /*#__PURE__*/teact.createElement(auth_AuthSecretWords, {
          isActive: isActive,
          mnemonic: mnemonic
        });
      case AuthState.checkWords:
        return /*#__PURE__*/teact.createElement(auth_AuthCheckWords, {
          isActive: isActive,
          mnemonic: mnemonic,
          checkIndexes: mnemonicCheckIndexes
        });
      case AuthState.importViewAccount:
        return /*#__PURE__*/teact.createElement(auth_AuthImportViewAccount, {
          isActive: isActive,
          isLoading: isLoading,
          onCancel: closeImportViewAccount
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: isPortrait ? windowEnvironment/* IS_ANDROID */.Ni ? 'slideFade' : 'slideLayers' : 'semiFade',
    activeKey: renderingAuthState,
    renderCount: RENDER_COUNT,
    shouldCleanup: true,
    className: Auth_module.transitionContainer,
    slideClassName: Auth_module.transitionSlide,
    prevKey: prevKey,
    nextKey: nextKey,
    onStop: updateRenderingKeys,
    shouldWrap: true
  }, renderAuthScreen);
};
/* harmony default export */ const auth_Auth = (memo(withGlobal(global => {
  const authProps = (0,iteratees/* pick */.Up)(global.auth, ['state', 'biometricsStep', 'error', 'mnemonic', 'mnemonicCheckIndexes', 'isLoading', 'method']);
  return {
    ...authProps,
    theme: global.settings.theme
  };
})(Auth)));
;// ./src/components/ui/Spinner.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Spinner_module = ({"spinner":"Spinner-module__spinner","inner":"Spinner-module__inner","spin":"Spinner-module__spin","white":"Spinner-module__white"});
;// ./src/components/ui/Spinner.tsx




function Spinner(_ref) {
  let {
    ref,
    color,
    className
  } = _ref;
  const lang = hooks_useLang();
  const fullClassName = buildClassName(Spinner_module.spinner, color && Spinner_module[color], className);
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: fullClassName,
    "aria-label": lang('Loading...')
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Spinner_module.inner, 'icon-spinner'),
    "aria-hidden": true
  }));
}
/* harmony default export */ const ui_Spinner = (memo(Spinner));
;// ./src/components/ui/ListItem.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ListItem_module = ({"root":"ListItem-module__root","icon":"ListItem-module__icon","rightItem":"ListItem-module__rightItem","spinner":"ListItem-module__spinner"});
;// ./src/components/ui/ListItem.tsx




function ListItem(_ref) {
  let {
    icon,
    label,
    className,
    isLoading,
    onClick
  } = _ref;
  return /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: buildClassName(ListItem_module.root, className),
    onClick: onClick,
    disabled: isLoading
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(ListItem_module.icon, `icon-${icon}`),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", {
    className: ListItem_module.label
  }, label), isLoading ? /*#__PURE__*/teact.createElement(ui_Spinner, {
    className: buildClassName(ListItem_module.rightItem, ListItem_module.spinner)
  }) : /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(ListItem_module.rightItem, 'icon-chevron-right'),
    "aria-hidden": true
  }));
}
/* harmony default export */ const ui_ListItem = (memo(ListItem));
;// ./src/components/auth/AuthImportWalletModal.tsx









function AuthImportWalletModal(_ref) {
  let {
    isOpen
  } = _ref;
  const {
    startImportingWallet,
    startImportViewAccount,
    openHardwareWalletModal,
    closeAuthImportWalletModal
  } = getActions();
  const lang = hooks_useLang();
  const handleSecretWordsClick = useLastCallback(() => {
    closeAuthImportWalletModal();
    startImportingWallet();
  });
  const handleImportHardwareWalletClick = useLastCallback(() => {
    closeAuthImportWalletModal();
    openHardwareWalletModal();
  });
  const handleImportViewAccountClick = useLastCallback(() => {
    closeAuthImportWalletModal();
    startImportViewAccount();
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    title: lang('Import Wallet'),
    hasCloseButton: true,
    forceBottomSheet: true,
    nativeBottomSheetKey: "import-account",
    contentClassName: Auth_module.importModalContent,
    onClose: closeAuthImportWalletModal
  }, /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.actionsSection
  }, /*#__PURE__*/teact.createElement(ui_ListItem, {
    icon: "key",
    label: lang(src_config/* IS_CORE_WALLET */.TI6 ? '24 Secret Words' : '12/24 Secret Words'),
    onClick: handleSecretWordsClick
  }), windowEnvironment/* IS_LEDGER_SUPPORTED */.sC && /*#__PURE__*/teact.createElement(ui_ListItem, {
    icon: "ledger-alt",
    label: lang('Ledger'),
    onClick: handleImportHardwareWalletClick
  })), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("div", {
    className: Auth_module.actionsSection
  }, /*#__PURE__*/teact.createElement(ui_ListItem, {
    icon: "wallet-view",
    label: lang('View Any Address'),
    onClick: handleImportViewAccountClick
  })));
}
/* harmony default export */ const auth_AuthImportWalletModal = (memo(withGlobal(global => {
  return {
    isOpen: global.auth.isImportModalOpen
  };
})(AuthImportWalletModal)));
;// ./src/util/resolveSlideTransitionName.ts

function resolveSlideTransitionName() {
  return windowEnvironment/* IS_ANDROID */.Ni ? 'slideFadeAndroid' : windowEnvironment/* IS_IOS */.pz ? 'slideLayers' : 'slideFade';
}
;// ./src/hooks/useModalTransitionKeys.ts



const useModalTransitionKeys_ANIMATION_DURATION = 300;
function useModalTransitionKeys(activeKey, isOpen) {
  // Use previous key during closing animation
  const renderingKey = useCurrentOrPrev(isOpen ? activeKey : undefined, true) ?? -1;
  const [nextKey, setNextKey] = useState();
  const updateNextKey = useLastCallback(() => {
    setNextKey(isOpen ? renderingKey + 1 : undefined);
  });

  // Set next key after modal is fully open
  teact_useEffect(() => {
    if (isOpen) {
      setTimeout(updateNextKey, useModalTransitionKeys_ANIMATION_DURATION);
    }
  }, [isOpen, updateNextKey]);
  return {
    renderingKey,
    nextKey,
    updateNextKey
  };
}
;// ./src/util/getCachedImageUrl.ts

async function getCachedImageUrl(url) {
  const cache = await caches.open(src_config/* IMAGE_CACHE_NAME */.F9m);
  const cachedResponse = await cache.match(url);
  if (cachedResponse) {
    const blob = await cachedResponse.blob();
    return URL.createObjectURL(blob);
  }
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Image loading error: ${response.statusText}. URL: ${url}`);
  }
  await cache.put(url, response.clone());
  const blob = await response.blob();
  return URL.createObjectURL(blob);
}
;// ./src/hooks/useAsync.ts

const useAsync = (fn, deps, defaultValue) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState();
  const [result, setResult] = useState(defaultValue);
  teact_useEffect(() => {
    setIsLoading(true);
    let wasCancelled = false;
    fn().then(res => {
      if (wasCancelled) return;
      setIsLoading(false);
      setResult(res);
    }, err => {
      if (wasCancelled) return;
      setIsLoading(false);
      setError(err);
    });
    return () => {
      wasCancelled = true;
    };
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, deps);
  return {
    isLoading,
    error,
    result
  };
};
/* harmony default export */ const hooks_useAsync = (useAsync);
;// ./src/hooks/useCachedImage.ts



function useCachedImage(src) {
  const {
    result: imageUrl
  } = hooks_useAsync(() => src ? getCachedImageUrl(src) : Promise.resolve(undefined), [src]);
  teact_useEffect(() => {
    return imageUrl ? () => {
      URL.revokeObjectURL(imageUrl);
    } : undefined;
  }, [imageUrl]);
  return {
    imageUrl
  };
}
;// ./src/hooks/useCardCustomization.ts


function useCardCustomization(cardNft) {
  const {
    mtwCardType,
    mtwCardTextType,
    mtwCardBorderShineType
  } = (cardNft === null || cardNft === void 0 ? void 0 : cardNft.metadata) || {};
  const withTextGradient = !!mtwCardType && mtwCardType !== 'standard';
  const mtwCardTextTypeClass = mtwCardType !== 'standard' ? undefined : mtwCardTextType === 'dark' ? 'MtwCard__darkText' : 'MtwCard__lightText';
  const backgroundImageUrl = cardNft ? getCardNftImageUrl(cardNft) : undefined;
  return {
    backgroundImageUrl,
    withTextGradient,
    classNames: buildClassName(mtwCardType && `MtwCard__${mtwCardType}`, mtwCardTextTypeClass),
    borderShineType: mtwCardBorderShineType
  };
}
;// ./src/components/main/sections/Header/AccountButton.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AccountButton_module = ({"button":"AccountButton-module__button","current":"AccountButton-module__current","customCard":"AccountButton-module__customCard","accountName":"AccountButton-module__accountName","accountAddressBlock":"AccountButton-module__accountAddressBlock","edit":"AccountButton-module__edit"});
;// ./src/components/main/sections/Header/AccountButton.tsx











const ACCOUNT_WITH_ICON_ADDRESS_SHIFT = 3;
const ACCOUNT_ADDRESS_SHIFT = 4;
function AccountButton(_ref) {
  let {
    isActive,
    accountId,
    addressByChain,
    accountType,
    title,
    cardBackgroundNft,
    canEditAccount,
    onClick,
    onEdit
  } = _ref;
  const lang = hooks_useLang();
  const isHardware = accountType === 'hardware';
  const isViewMode = accountType === 'view';
  const addressOrMultichain = isKeyCountGreater(addressByChain, 1) ? lang('Multichain') : (0,shortenAddress/* shortenAddress */.W)((0,util_account/* getMainAccountAddress */.LG)(addressByChain) ?? '', accountType !== 'mnemonic' ? ACCOUNT_WITH_ICON_ADDRESS_SHIFT : ACCOUNT_ADDRESS_SHIFT, ACCOUNT_ADDRESS_SHIFT);
  const {
    backgroundImageUrl,
    withTextGradient,
    classNames: mtwCardClassNames
  } = useCardCustomization(cardBackgroundNft);
  const {
    imageUrl
  } = useCachedImage(backgroundImageUrl);
  const fullClassName = buildClassName(AccountButton_module.button, isActive && AccountButton_module.current, imageUrl && AccountButton_module.customCard, imageUrl && mtwCardClassNames);
  const handleEditClick = e => {
    stopEvent(e);
    onEdit();
  };
  return /*#__PURE__*/teact.createElement("div", {
    className: fullClassName,
    "aria-label": lang('Switch Account'),
    onClick: isActive ? undefined : () => onClick(accountId),
    style: buildStyle(imageUrl && `--bg: url(${imageUrl})`)
  }, title && /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(AccountButton_module.accountName, withTextGradient && 'gradientText')
  }, title), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(AccountButton_module.accountAddressBlock, withTextGradient && 'gradientText')
  }, isHardware && /*#__PURE__*/teact.createElement("i", {
    className: "icon-ledger",
    "aria-hidden": true
  }), isViewMode && /*#__PURE__*/teact.createElement("i", {
    className: "icon-eye-filled",
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, addressOrMultichain)), isActive && canEditAccount && /*#__PURE__*/teact.createElement("div", {
    className: AccountButton_module.edit,
    onClick: handleEditClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-pen",
    "aria-hidden": true
  })));
}
/* harmony default export */ const Header_AccountButton = (AccountButton);
;// ./src/components/common/AccountButton.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const common_AccountButton_module = ({"accounts":"AccountButton-module__accounts","accounts_two":"AccountButton-module__accounts_two","accountsTwo":"AccountButton-module__accounts_two","account":"AccountButton-module__account","account_current":"AccountButton-module__account_current","accountCurrent":"AccountButton-module__account_current","account_disabled":"AccountButton-module__account_disabled","accountDisabled":"AccountButton-module__account_disabled","account_inactive":"AccountButton-module__account_inactive","accountInactive":"AccountButton-module__account_inactive","accounts_single":"AccountButton-module__accounts_single","accountsSingle":"AccountButton-module__accounts_single","customCard":"AccountButton-module__customCard","accountName":"AccountButton-module__accountName","button_current":"AccountButton-module__button_current","buttonCurrent":"AccountButton-module__button_current","accountFooter":"AccountButton-module__accountFooter","icon":"AccountButton-module__icon","accountAddress":"AccountButton-module__accountAddress","accountCheckMark":"AccountButton-module__accountCheckMark","accountCheckMark_active":"AccountButton-module__accountCheckMark_active","accountCheckMarkActive":"AccountButton-module__accountCheckMark_active"});
;// ./src/components/common/AccountButton.tsx








function AccountButton_AccountButton(_ref) {
  let {
    accountId,
    address,
    title,
    accountType,
    ariaLabel,
    isActive,
    isLoading,
    className,
    withCheckbox,
    cardBackgroundNft,
    onClick
  } = _ref;
  const {
    backgroundImageUrl,
    withTextGradient,
    classNames: mtwCardClassNames
  } = useCardCustomization(cardBackgroundNft);
  const {
    imageUrl
  } = useCachedImage(backgroundImageUrl);
  const isHardware = accountType === 'hardware';
  const isViewMode = accountType === 'view';
  const fullClassName = buildClassName(className, common_AccountButton_module.account, imageUrl && common_AccountButton_module.customCard, imageUrl && mtwCardClassNames, isActive && !withCheckbox && common_AccountButton_module.account_current, isLoading && common_AccountButton_module.account_disabled, !onClick && common_AccountButton_module.account_inactive);
  return /*#__PURE__*/teact.createElement("div", {
    key: accountId,
    className: fullClassName,
    onClick: onClick,
    style: buildStyle(imageUrl && `--bg: url(${imageUrl})`),
    "aria-label": ariaLabel
  }, title && /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(common_AccountButton_module.accountName, withTextGradient && 'gradientText')
  }, title), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(common_AccountButton_module.accountFooter, withTextGradient && 'gradientText')
  }, isViewMode && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-eye-filled', common_AccountButton_module.icon),
    "aria-hidden": true
  }), isHardware && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-ledger', common_AccountButton_module.icon),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", {
    className: common_AccountButton_module.accountAddress
  }, (0,shortenAddress/* shortenAddress */.W)(address, isHardware ? ACCOUNT_WITH_ICON_ADDRESS_SHIFT : ACCOUNT_ADDRESS_SHIFT, ACCOUNT_ADDRESS_SHIFT))), withCheckbox && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(common_AccountButton_module.accountCheckMark, isActive && common_AccountButton_module.accountCheckMark_active)
  }));
}
/* harmony default export */ const common_AccountButton = (memo(AccountButton_AccountButton));
;// ./src/components/common/AccountButtonWrapper.tsx



function AccountButtonWrapper(_ref) {
  let {
    accountLength,
    labelText,
    children,
    className
  } = _ref;
  const fullClassName = buildClassName(className, common_AccountButton_module.accounts, 'custom-scroll', accountLength === 1 && common_AccountButton_module.accounts_single, accountLength === 2 && common_AccountButton_module.accounts_two);
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, labelText && /*#__PURE__*/teact.createElement("p", {
    className: common_AccountButton_module.label
  }, labelText), /*#__PURE__*/teact.createElement("div", {
    className: fullClassName
  }, children));
}
/* harmony default export */ const common_AccountButtonWrapper = (memo(AccountButtonWrapper));
;// ./src/components/ledger/LedgerModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const LedgerModal_module = ({"modalDialog":"LedgerModal-module__modalDialog","modalDialogInsideSettings":"LedgerModal-module__modalDialogInsideSettings","slide":"LedgerModal-module__slide","container":"LedgerModal-module__container","containerStatic":"LedgerModal-module__containerStatic","content":"LedgerModal-module__content","iconBlockSlide":"LedgerModal-module__iconBlockSlide","iconBlockSlideStatic":"LedgerModal-module__iconBlockSlideStatic","iconBlock":"LedgerModal-module__iconBlock","mobile":"LedgerModal-module__mobile","ledgerIcon":"LedgerModal-module__ledgerIcon","textBlock":"LedgerModal-module__textBlock","textBlock_gap":"LedgerModal-module__textBlock_gap","textBlockGap":"LedgerModal-module__textBlock_gap","textBlock_success":"LedgerModal-module__textBlock_success","textBlockSuccess":"LedgerModal-module__textBlock_success","textBlock_small":"LedgerModal-module__textBlock_small","textBlockSmall":"LedgerModal-module__textBlock_small","text":"LedgerModal-module__text","textIcon":"LedgerModal-module__textIcon","text_failed":"LedgerModal-module__text_failed","textFailed":"LedgerModal-module__text_failed","text_connected":"LedgerModal-module__text_connected","textConnected":"LedgerModal-module__text_connected","text_success":"LedgerModal-module__text_success","textSuccess":"LedgerModal-module__text_success","actionBlock":"LedgerModal-module__actionBlock","actionBlock_single":"LedgerModal-module__actionBlock_single","actionBlockSingle":"LedgerModal-module__actionBlock_single","button":"LedgerModal-module__button","button_single":"LedgerModal-module__button_single","buttonSingle":"LedgerModal-module__button_single","accounts":"LedgerModal-module__accounts","accounts_two":"LedgerModal-module__accounts_two","accountsTwo":"LedgerModal-module__accounts_two","account":"LedgerModal-module__account","account_current":"LedgerModal-module__account_current","accountCurrent":"LedgerModal-module__account_current","addAccountContainer":"LedgerModal-module__addAccountContainer","addAccountIcon":"LedgerModal-module__addAccountIcon","accountName":"LedgerModal-module__accountName","accountFooter":"LedgerModal-module__accountFooter","accountCurrencyIcon":"LedgerModal-module__accountCurrencyIcon","accountAddress":"LedgerModal-module__accountAddress","accountCheckMark":"LedgerModal-module__accountCheckMark","accountCheckMark_active":"LedgerModal-module__accountCheckMark_active","accountCheckMarkActive":"LedgerModal-module__accountCheckMark_active","sticker":"LedgerModal-module__sticker","declinedLabel":"LedgerModal-module__declinedLabel","declinedLabelDetailed":"LedgerModal-module__declinedLabelDetailed","dropdownBlock":"LedgerModal-module__dropdownBlock"});
;// ./src/components/ledger/LedgerConfirmOperation.tsx














var ConfirmTransactionState = /*#__PURE__*/function (ConfirmTransactionState) {
  ConfirmTransactionState[ConfirmTransactionState["Waiting"] = 0] = "Waiting";
  ConfirmTransactionState[ConfirmTransactionState["Error"] = 1] = "Error";
  return ConfirmTransactionState;
}(ConfirmTransactionState || {});
function LedgerConfirmOperation(_ref) {
  let {
    isActive,
    text,
    error,
    onClose,
    onTryAgain
  } = _ref;
  const lang = hooks_useLang();
  const [activeState, setActiveState] = useState(ConfirmTransactionState.Waiting);
  const [nextKey, setNextKey] = useState(ConfirmTransactionState.Error);
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  teact_useEffect(() => {
    if (error) {
      setActiveState(ConfirmTransactionState.Error);
      setNextKey(ConfirmTransactionState.Waiting);
    } else {
      setActiveState(ConfirmTransactionState.Waiting);
      setNextKey(ConfirmTransactionState.Error);
    }
  }, [error]);
  function renderWaitingConfirm(isActiveSlide) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm via Ledger'),
      onClose: onClose
    }), /*#__PURE__*/teact.createElement("div", {
      className: LedgerModal_module.container
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
      play: isActiveSlide,
      noLoop: false,
      nonInteractive: true,
      className: LedgerModal_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.holdTon,
      previewUrl: ANIMATED_STICKERS_PATHS.holdTonPreview
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.textBlock, LedgerModal_module.textBlock_small)
    }, /*#__PURE__*/teact.createElement("span", {
      className: LedgerModal_module.text
    }, text)), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.actionBlock, LedgerModal_module.actionBlock_single)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: onClose,
      className: buildClassName(LedgerModal_module.button, LedgerModal_module.button_single)
    }, lang('Cancel')))));
  }
  function renderTryAgain(isActiveSlide) {
    const isErrorDetailed = error && ['$hardware_blind_sign_not_enabled', '$hardware_blind_sign_not_enabled_internal'].includes(error);
    const errorMessage = isErrorDetailed ? /*#__PURE__*/teact.createElement("span", null, renderText(lang(error))) : renderText(lang(error));
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm via Ledger'),
      onClose: onClose
    }), /*#__PURE__*/teact.createElement("div", {
      className: LedgerModal_module.container
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
      play: isActiveSlide,
      noLoop: false,
      nonInteractive: true,
      className: LedgerModal_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.holdTon,
      previewUrl: ANIMATED_STICKERS_PATHS.holdTonPreview
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.declinedLabel, isErrorDetailed && LedgerModal_module.declinedLabelDetailed)
    }, errorMessage), /*#__PURE__*/teact.createElement("div", {
      className: LedgerModal_module.actionBlock
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: onClose,
      className: LedgerModal_module.button
    }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      onClick: onTryAgain,
      className: LedgerModal_module.button
    }, lang('Try Again')))));
  }
  function renderContent(isActiveSlide, isFrom, currentKey) {
    switch (currentKey) {
      case ConfirmTransactionState.Waiting:
        return renderWaitingConfirm(isActiveSlide);
      case ConfirmTransactionState.Error:
        return renderTryAgain(isActiveSlide);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: buildClassName(Modal_module.transitionSlide, LedgerModal_module.slide),
    activeKey: activeState,
    nextKey: nextKey
  }, renderContent);
}
/* harmony default export */ const ledger_LedgerConfirmOperation = (memo(LedgerConfirmOperation));
;// ./src/components/ui/Dropdown.tsx








const DEFAULT_ARROW = 'caret';
const DEFAULT_MENU_POSITION_X = 'right';
function Dropdown(_ref) {
  let {
    label,
    items,
    selectedValue,
    className,
    itemClassName,
    menuClassName,
    theme,
    arrow = DEFAULT_ARROW,
    menuPositionX = DEFAULT_MENU_POSITION_X,
    menuPositionY,
    disabled,
    shouldTranslateOptions,
    onChange,
    isLoading = false,
    buttonPrefix
  } = _ref;
  const [isMenuOpen, openMenu, closeMenu] = hooks_useFlag();
  const withMenu = items.length > 1;
  const isFullyInteractive = Boolean(label);
  const selectedItem = teact_useMemo(() => {
    let item = selectedValue !== undefined && items.find(i => i.value === selectedValue);
    item ||= {
      value: '',
      name: ''
    };
    return {
      ...item,
      isDisabled: !isFullyInteractive && disabled
    };
  }, [items, selectedValue, isFullyInteractive, disabled]);
  const handleSelect = useLastCallback(value => {
    if (value !== selectedValue) {
      onChange === null || onChange === void 0 || onChange(value);
    }
  });
  if (!items.length) {
    return undefined;
  }
  const fullClassName = buildClassName(className, withMenu && Dropdown_module.interactive, isFullyInteractive && Dropdown_module.wide, isFullyInteractive && disabled && Dropdown_module.disabled);
  const buttonFullClassName = buildClassName(Dropdown_module.button, withMenu && Dropdown_module.interactive, withMenu && menuClassName, theme && Dropdown_module[theme], itemClassName);
  const buttonSuffix = teact_useMemo(() => {
    return withMenu && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Dropdown_module.buttonIcon, arrow === 'chevron' ? 'icon-chevron-down' : 'icon-caret-down'),
      "aria-hidden": true
    });
  }, [withMenu, arrow]);
  return /*#__PURE__*/teact.createElement("div", {
    className: fullClassName,
    onClick: isFullyInteractive && !disabled && withMenu ? openMenu : undefined
  }, label && /*#__PURE__*/teact.createElement("span", {
    className: Dropdown_module.label
  }, label), isLoading ? /*#__PURE__*/teact.createElement(ui_Spinner, {
    className: Dropdown_module.spinner
  }) : /*#__PURE__*/teact.createElement(ui_DropdownItemContent, {
    item: selectedItem,
    prefix: buttonPrefix,
    suffix: buttonSuffix,
    shouldTranslate: shouldTranslateOptions,
    shouldUseSelectedName: true,
    className: buttonFullClassName,
    itemClassName: buildClassName('itemName', itemClassName),
    onClick: !isFullyInteractive && withMenu ? openMenu : undefined
  }), withMenu && /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isMenuOpen && !isLoading,
    menuPositionX: menuPositionX,
    menuPositionY: menuPositionY,
    items: items,
    shouldTranslateOptions: shouldTranslateOptions,
    selectedValue: selectedValue,
    buttonClassName: itemClassName,
    onSelect: handleSelect,
    onClose: closeMenu
  }));
}
/* harmony default export */ const ui_Dropdown = (memo(Dropdown));
;// ./src/assets/ledger/desktop.png
const desktop_namespaceObject = __webpack_require__.p + "desktop.5b697d2d91cbfdc91f29.png";
;// ./src/assets/ledger/desktop-dark.png
const desktop_dark_namespaceObject = __webpack_require__.p + "desktop-dark.aacce131e03bae83c744.png";
;// ./src/assets/ledger/ios.png
const ios_namespaceObject = __webpack_require__.p + "ios.5d8a0178f3ed44e81862.png";
;// ./src/assets/ledger/ios-dark.png
const ios_dark_namespaceObject = __webpack_require__.p + "ios-dark.0ba8808ed3906393a417.png";
;// ./src/assets/ledger/mobile-bluetooth.png
const mobile_bluetooth_namespaceObject = __webpack_require__.p + "mobile-bluetooth.7fea27504891420bc158.png";
;// ./src/assets/ledger/mobile-bluetooth-dark.png
const mobile_bluetooth_dark_namespaceObject = __webpack_require__.p + "mobile-bluetooth-dark.9a47bff03978eddfd080.png";
;// ./src/assets/ledger/mobile-usb.png
const mobile_usb_namespaceObject = __webpack_require__.p + "mobile-usb.165003c19b688130909d.png";
;// ./src/assets/ledger/mobile-usb-dark.png
const mobile_usb_dark_namespaceObject = __webpack_require__.p + "mobile-usb-dark.273f665b4cc76537f15b.png";
;// ./src/components/ledger/LedgerConnect.tsx































const NEXT_SLIDE_DELAY = 500;
const TRANSPORT_NAMES = {
  usb: 'USB',
  bluetooth: 'Bluetooth'
};
function LedgerConnect(_ref) {
  let {
    isActive,
    isStatic,
    state,
    isLedgerConnected,
    isTonAppConnected,
    availableTransports,
    lastUsedTransport,
    currentTheme,
    className,
    onConnected,
    onBackButtonClick,
    onCancel,
    onClose
  } = _ref;
  const {
    initializeHardwareWalletModal,
    initializeHardwareWalletConnection
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const [selectedTransport, setSelectedTransport] = useState(lastUsedTransport);
  const appTheme = hooks_useAppTheme(currentTheme);
  const isLedgerFailed = isLedgerConnected === false;
  const isTonAppFailed = isTonAppConnected === false;
  const isConnected = state === HardwareConnectState.ConnectedWithSingleWallet || state === HardwareConnectState.ConnectedWithSeveralWallets;
  const isConnecting = state === HardwareConnectState.Connecting;
  const isWaitingForRemoteTab = state === HardwareConnectState.WaitingForRemoteTab;
  const title = isConnected ? lang('Ledger Connected!') : lang('Connect Ledger');
  const shouldCloseOnCancel = !onCancel;
  const renderingAvailableTransports = teact_useMemo(() => {
    return (availableTransports || []).map(transport => ({
      value: transport,
      name: TRANSPORT_NAMES[transport]
    }));
  }, [availableTransports]);
  const {
    shouldRender: shouldRenderAvailableTransports,
    ref: availableTransportsRef
  } = useShowTransition({
    isOpen: Boolean(renderingAvailableTransports.length > 1 && selectedTransport),
    withShouldRender: true
  });
  useHistoryBack({
    isActive,
    onBack: onCancel ?? onClose
  });
  teact_useEffect(() => {
    if (selectedTransport) return;
    if (availableTransports !== null && availableTransports !== void 0 && availableTransports.length) {
      setSelectedTransport(availableTransports === null || availableTransports === void 0 ? void 0 : availableTransports[0]);
    } else if (windowEnvironment/* IS_IOS_APP */.ZH) {
      setSelectedTransport('bluetooth');
    }
  }, [availableTransports, selectedTransport]);
  teact_useEffect(() => {
    if (!isActive) return;
    initializeHardwareWalletModal();
  }, [isActive]);
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevLastUsedTransport] = _ref2;
    if (lastUsedTransport && prevLastUsedTransport !== lastUsedTransport) {
      setSelectedTransport(lastUsedTransport);
    }
  }, [lastUsedTransport]);
  const handleConnected = useLastCallback(isSingleWallet => {
    if (windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe) {
      return;
    }
    setTimeout(() => {
      onConnected(isSingleWallet);
    }, NEXT_SLIDE_DELAY);
  });
  teact_useEffect(() => {
    if (isConnected && isActive) {
      handleConnected(state === HardwareConnectState.ConnectedWithSingleWallet);
    }
  }, [isConnected, isActive, state, handleConnected]);
  const handleCloseWithRemoteTab = useLastCallback(() => {
    const closeAction = shouldCloseOnCancel ? onClose : onCancel;
    (0,tab/* closeLedgerTab */.rt)(); // To close the remote extension tab when the connection is cancelled in the popup
    closeAction();
  });
  const handleSubmit = useLastCallback(() => {
    if (selectedTransport) {
      initializeHardwareWalletConnection({
        transport: selectedTransport
      });
    }
  });
  function renderAvailableTransports() {
    return /*#__PURE__*/teact.createElement("div", {
      ref: availableTransportsRef,
      className: LedgerModal_module.dropdownBlock
    }, /*#__PURE__*/teact.createElement(ui_Dropdown, {
      label: lang('Connection Type'),
      items: renderingAvailableTransports,
      selectedValue: selectedTransport,
      theme: "light",
      arrow: "chevron",
      disabled: isConnecting,
      className: buildClassName(LedgerModal_module.item, LedgerModal_module.item_small),
      onChange: setSelectedTransport
    }));
  }
  function renderButtons() {
    const isFailed = state === HardwareConnectState.Failed;
    if (windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe && isConnected) {
      return /*#__PURE__*/teact.createElement("div", {
        className: buildClassName(LedgerModal_module.actionBlock, isConnected && LedgerModal_module.actionBlock_single)
      }, /*#__PURE__*/teact.createElement(ui_Button, {
        isDisabled: isConnecting,
        className: buildClassName(LedgerModal_module.button, isConnected && LedgerModal_module.button_single),
        onClick: onClose
      }, lang('Continue')));
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: LedgerModal_module.actionBlock
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: LedgerModal_module.button,
      onClick: shouldCloseOnCancel ? onClose : onCancel
    }, lang(shouldCloseOnCancel ? 'Cancel' : 'Back')), /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isLoading: isConnecting,
      isDisabled: isConnecting || isConnected || !(availableTransports !== null && availableTransports !== void 0 && availableTransports.length),
      className: LedgerModal_module.button,
      onClick: handleSubmit
    }, isFailed ? lang('Try Again') : lang('Continue')));
  }
  function getLedgerIconSrc() {
    const isDarkTheme = appTheme === 'dark';
    const iconData = {
      desktop: isDarkTheme ? desktop_dark_namespaceObject : desktop_namespaceObject,
      mobileUsb: isDarkTheme ? mobile_usb_dark_namespaceObject : mobile_usb_namespaceObject,
      ios: isDarkTheme ? ios_dark_namespaceObject : ios_namespaceObject,
      mobileBluetooth: isDarkTheme ? mobile_bluetooth_dark_namespaceObject : mobile_bluetooth_namespaceObject
    };
    if (!src_config/* IS_CAPACITOR */.UMQ) {
      // Ledger is only supported on iOS for Capacitor app
      return windowEnvironment/* IS_ANDROID */.Ni ? iconData.mobileUsb : iconData.desktop;
    }
    if (windowEnvironment/* IS_IOS */.pz) {
      return iconData.ios;
    }
    return selectedTransport === 'bluetooth' ? iconData.mobileBluetooth : iconData.mobileUsb;
  }
  function renderScreen(handleClose, children) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !isStatic ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: title,
      onBackButtonClick: onBackButtonClick,
      onClose: !onBackButtonClick ? handleClose : undefined
    }) : /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.header
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      isText: true,
      onClick: handleClose,
      className: Settings_module.headerBack
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
      className: Settings_module.headerTitle
    }, title)), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.container, isStatic && LedgerModal_module.containerStatic, isStatic && 'static-container')
    }, /*#__PURE__*/teact.createElement(ui_Transition, {
      activeKey: !src_config/* IS_CAPACITOR */.UMQ ? 0 : selectedTransport !== 'bluetooth' ? 1 : 2,
      name: "semiFade",
      className: buildClassName(LedgerModal_module.iconBlock, (isPortrait || windowEnvironment/* IS_IOS */.pz) && LedgerModal_module.mobile),
      slideClassName: isStatic ? LedgerModal_module.iconBlockSlideStatic : LedgerModal_module.iconBlockSlide
    }, /*#__PURE__*/teact.createElement(ui_Image, {
      url: getLedgerIconSrc(),
      imageClassName: LedgerModal_module.ledgerIcon
    })), children));
  }
  function renderWaitingForRemoteTab() {
    return renderScreen(handleCloseWithRemoteTab, /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.textBlock, LedgerModal_module.textBlock_gap)
    }, /*#__PURE__*/teact.createElement("span", {
      className: LedgerModal_module.text
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(LedgerModal_module.textIcon, 'icon-dot'),
      "aria-hidden": true
    }), lang('Switch to the newly opened tab to connect Ledger.')), /*#__PURE__*/teact.createElement("span", {
      className: LedgerModal_module.text
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(LedgerModal_module.textIcon, 'icon-dot'),
      "aria-hidden": true
    }), lang('Once connected, switch back to this window to proceed.'))), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.actionBlock, LedgerModal_module.actionBlock_single)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: buildClassName(LedgerModal_module.button, LedgerModal_module.button_single),
      onClick: handleCloseWithRemoteTab
    }, lang(shouldCloseOnCancel ? 'Cancel' : 'Back')))));
  }
  function renderConnect() {
    return renderScreen(onClose, /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.textBlock, isConnected && LedgerModal_module.textBlock_success)
    }, /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(LedgerModal_module.text, isLedgerFailed && LedgerModal_module.text_failed, isLedgerConnected && LedgerModal_module.text_connected, isConnected && LedgerModal_module.text_success)
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(LedgerModal_module.textIcon, isLedgerConnected ? 'icon-accept' : 'icon-dot'),
      "aria-hidden": true
    }), lang('Connect your Ledger')), /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(LedgerModal_module.text, isTonAppFailed && LedgerModal_module.text_failed, isTonAppConnected && LedgerModal_module.text_connected, isConnected && LedgerModal_module.text_success)
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(LedgerModal_module.textIcon, isTonAppConnected ? 'icon-accept' : 'icon-dot'),
      "aria-hidden": true
    }), lang('Unlock it and open the TON App'))), shouldRenderAvailableTransports && renderAvailableTransports(), renderButtons()));
  }
  function renderContent() {
    if (isWaitingForRemoteTab) {
      return renderWaitingForRemoteTab();
    }
    return renderConnect();
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll', className),
    slideClassName: Modal_module.transitionSlide,
    activeKey: isWaitingForRemoteTab ? 1 : 0
  }, renderContent);
}
/* harmony default export */ const ledger_LedgerConnect = (memo(withGlobal(global => {
  const {
    hardwareState,
    isLedgerConnected,
    isTonAppConnected,
    availableTransports,
    lastUsedTransport
  } = global.hardware;
  return {
    state: hardwareState,
    isLedgerConnected,
    isTonAppConnected,
    availableTransports,
    lastUsedTransport,
    currentTheme: global.settings.theme
  };
})(LedgerConnect)));
;// ./src/components/ui/Skeleton.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Skeleton_module = ({"skeleton":"Skeleton-module__skeleton","shimmerMobile":"Skeleton-module__shimmerMobile","shimmerDesktop":"Skeleton-module__shimmerDesktop"});
;// ./src/components/ui/Skeleton.tsx



function Skeleton(_ref) {
  let {
    className
  } = _ref;
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Skeleton_module.skeleton, className)
  });
}
/* harmony default export */ const ui_Skeleton = (memo(Skeleton));
;// ./src/components/ui/IconWithTooltip.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const IconWithTooltip_module = ({"container":"IconWithTooltip-module__container","tooltip":"IconWithTooltip-module__tooltip","small":"IconWithTooltip-module__small","medium":"IconWithTooltip-module__medium","arrow":"IconWithTooltip-module__arrow","icon":"IconWithTooltip-module__icon","fontIcon":"IconWithTooltip-module__fontIcon","color-warning":"IconWithTooltip-module__color-warning","colorWarning":"IconWithTooltip-module__color-warning"});
;// ./src/components/ui/IconWithTooltip.tsx











const ARROW_WIDTH = 0.6875 * windowEnvironment/* REM */.$;
const GAP = 2 * windowEnvironment/* REM */.$;

/** The component is designed to be positioned inline in text. Use a space symbol to create a gap on the left. */
const IconWithTooltip = _ref => {
  let {
    message,
    emoji,
    size = 'medium',
    type = 'hint',
    iconClassName,
    tooltipClassName
  } = _ref;
  const [isOpen, open, close] = hooks_useFlag();
  const {
    shouldRender,
    ref: tooltipContainerRef
  } = useShowTransition({
    isOpen,
    withShouldRender: true
  });
  const colorClassName = type === 'warning' && IconWithTooltip_module[`color-${type}`];
  const iconRef = teact_useRef();
  const tooltipRef = teact_useRef();
  const tooltipStyle = teact_useRef();
  const arrowStyle = teact_useRef();
  const randomTooltipKey = useUniqueId();
  const handleClickOutside = useLastCallback(event => {
    if (!event.target.closest(`[data-tooltip-key="${randomTooltipKey}"]`)) {
      close();
    }
  });
  teact_useEffect(() => {
    if (!isOpen) return undefined;
    document.addEventListener('touchstart', handleClickOutside);
    return () => {
      document.removeEventListener('touchstart', handleClickOutside);
    };
  }, [isOpen, close, handleClickOutside]);
  teact_useEffect(() => {
    if (!iconRef.current || !tooltipRef.current) return;
    const {
      top,
      left,
      width
    } = iconRef.current.getBoundingClientRect();
    const {
      width: tooltipWidth,
      height: tooltipHeight
    } = tooltipRef.current.getBoundingClientRect();
    const tooltipCenter = (window.innerWidth - tooltipWidth) / 2;
    const arrowPosition = left - tooltipCenter + width / 2 - ARROW_WIDTH / 2;
    const horizontalOffset = arrowPosition < GAP ? GAP - arrowPosition : 0;
    const tooltipVerticalStyle = `top: ${top - tooltipHeight - ARROW_WIDTH}px;`;
    const tooltipHorizontalStyle = `left: ${tooltipCenter - horizontalOffset}px;`;
    const arrowHorizontalStyle = `left: ${arrowPosition + horizontalOffset}px;`;
    const arrowVerticalStyle = `top: ${tooltipHeight - ARROW_WIDTH / 2 - 1}px;`;
    tooltipStyle.current = `${tooltipVerticalStyle} ${tooltipHorizontalStyle}`;
    arrowStyle.current = `${arrowVerticalStyle} ${arrowHorizontalStyle}`;
  }, [shouldRender]);
  function renderIcon() {
    const commonClassName = buildClassName(IconWithTooltip_module.icon, iconClassName, IconWithTooltip_module[size], colorClassName);
    const onClick = windowEnvironment/* IS_TOUCH_ENV */.TF ? stopEvent : undefined;
    if (emoji) {
      return /*#__PURE__*/teact.createElement("span", {
        ref: iconRef,
        className: commonClassName,
        "data-tooltip-key": randomTooltipKey,
        onClick: onClick,
        onMouseEnter: open,
        onMouseLeave: close
      }, /*#__PURE__*/teact.createElement(ui_Emoji, {
        from: emoji
      }));
    }
    return /*#__PURE__*/teact.createElement("i", {
      ref: iconRef,
      className: buildClassName(commonClassName, IconWithTooltip_module.fontIcon, type === 'warning' ? 'icon-exclamation' : 'icon-question'),
      "data-tooltip-key": randomTooltipKey,
      onClick: onClick,
      onMouseEnter: open,
      onMouseLeave: close
    });
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, shouldRender && /*#__PURE__*/teact.createElement(ui_Portal, null, /*#__PURE__*/teact.createElement("div", {
    ref: tooltipContainerRef,
    className: IconWithTooltip_module.container,
    onClick: stopEvent,
    style: tooltipStyle.current
  }, /*#__PURE__*/teact.createElement("div", {
    ref: tooltipRef,
    className: buildClassName(IconWithTooltip_module.tooltip, IconWithTooltip_module[size], colorClassName, tooltipClassName)
  }, message), /*#__PURE__*/teact.createElement("div", {
    className: IconWithTooltip_module.arrow,
    style: arrowStyle.current
  }))), renderIcon());
};
/* harmony default export */ const ui_IconWithTooltip = (memo(IconWithTooltip));
;// ./src/components/dapps/Dapp.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Dapp_module = ({"modalDialog":"Dapp-module__modalDialog","modalDialogExtraHeight":"Dapp-module__modalDialogExtraHeight","dapp":"Dapp-module__dapp","dapp_first":"Dapp-module__dapp_first","dappFirst":"Dapp-module__dapp_first","dapp_push":"Dapp-module__dapp_push","dappPush":"Dapp-module__dapp_push","dappIcon":"Dapp-module__dappIcon","dappLogo":"Dapp-module__dappLogo","dappLogo_icon":"Dapp-module__dappLogo_icon","dappLogoIcon":"Dapp-module__dappLogo_icon","transactionAccount":"Dapp-module__transactionAccount","dappInfo":"Dapp-module__dappInfo","dappName":"Dapp-module__dappName","dappHost":"Dapp-module__dappHost","dappHostWarningIcon":"Dapp-module__dappHostWarningIcon","dappHostWarningText":"Dapp-module__dappHostWarningText","dappHostWarningButton":"Dapp-module__dappHostWarningButton","dappDisconnect":"Dapp-module__dappDisconnect","label":"Dapp-module__label","description":"Dapp-module__description","footer":"Dapp-module__footer","buttons":"Dapp-module__buttons","button":"Dapp-module__button","rowContainerSkeleton":"Dapp-module__rowContainerSkeleton","dataField":"Dapp-module__dataField","receivingAddress":"Dapp-module__receivingAddress","payloadField":"Dapp-module__payloadField","payloadField_expanded":"Dapp-module__payloadField_expanded","payloadFieldExpanded":"Dapp-module__payloadField_expanded","payloadField_text":"Dapp-module__payloadField_text","payloadFieldText":"Dapp-module__payloadField_text","payloadFieldExpand":"Dapp-module__payloadFieldExpand","payloadFieldTerm":"Dapp-module__payloadFieldTerm","transactionList":"Dapp-module__transactionList","transactionRow":"Dapp-module__transactionRow","transactionRowAmount":"Dapp-module__transactionRowAmount","currencySymbol":"Dapp-module__currencySymbol","transactionRowAddress":"Dapp-module__transactionRowAddress","transactionRowChevron":"Dapp-module__transactionRowChevron","scam":"Dapp-module__scam","scamImage":"Dapp-module__scamImage","transactionDirection":"Dapp-module__transactionDirection","accountTitle":"Dapp-module__accountTitle","accountBalance":"Dapp-module__accountBalance","transactionDapp":"Dapp-module__transactionDapp","sticker":"Dapp-module__sticker","sticker_sizeSmall":"Dapp-module__sticker_sizeSmall","stickerSizeSmall":"Dapp-module__sticker_sizeSmall","descriptionContent":"Dapp-module__descriptionContent","dappInfoSkeleton":"Dapp-module__dappInfoSkeleton","accountWrapperSkeleton":"Dapp-module__accountWrapperSkeleton","dappInfoIconSkeleton":"Dapp-module__dappInfoIconSkeleton","dappInfoTextSkeleton":"Dapp-module__dappInfoTextSkeleton","nameSkeleton":"Dapp-module__nameSkeleton","descSkeleton":"Dapp-module__descSkeleton","nameDappSkeleton":"Dapp-module__nameDappSkeleton","descDappSkeleton":"Dapp-module__descDappSkeleton","transactionDirectionLeftSkeleton":"Dapp-module__transactionDirectionLeftSkeleton","transactionDirectionRightSkeleton":"Dapp-module__transactionDirectionRightSkeleton","dappInfoDataSkeleton":"Dapp-module__dappInfoDataSkeleton","rowSkeleton":"Dapp-module__rowSkeleton","rowLargeSkeleton":"Dapp-module__rowLargeSkeleton","rowLabelSkeleton":"Dapp-module__rowLabelSkeleton","rowTextLargeSkeleton":"Dapp-module__rowTextLargeSkeleton","rowFeeSkeleton":"Dapp-module__rowFeeSkeleton","skeletonTransitionWrapper":"Dapp-module__skeletonTransitionWrapper","skeletonBackground":"Dapp-module__skeletonBackground","transferWarning":"Dapp-module__transferWarning","warningForPayload":"Dapp-module__warningForPayload","emulation":"Dapp-module__emulation","emulationFee":"Dapp-module__emulationFee","transferButtons":"Dapp-module__transferButtons","transactionContent":"Dapp-module__transactionContent","balanceError":"Dapp-module__balanceError"});
;// ./src/components/dapps/DappInfo.tsx












function DappInfo(_ref) {
  let {
    dapp,
    className,
    onDisconnect
  } = _ref;
  const {
    deleteDapp
  } = getActions();
  const lang = hooks_useLang();
  const {
    name,
    iconUrl,
    url,
    isUrlEnsured
  } = dapp || {};
  const host = teact_useMemo(() => url ? new URL(url).host : undefined, [url]);
  const shouldShowDisconnect = Boolean(onDisconnect && url);
  const handleDisconnect = useLastCallback(() => {
    onDisconnect(url);
  });
  function handleHostWarningIabButtonClick() {
    deleteDapp({
      url: url,
      uniqueId: getDappConnectionUniqueId(dapp)
    });
    void openUrl(url);
  }
  function renderIcon() {
    if (iconUrl) {
      return /*#__PURE__*/teact.createElement("img", {
        src: iconUrl,
        alt: lang('Logo'),
        className: Dapp_module.dappLogo
      });
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Dapp_module.dappLogo, Dapp_module.dappLogo_icon)
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Dapp_module.dappIcon, 'icon-laptop'),
      "aria-hidden": true
    }));
  }
  function renderWarningIcon() {
    return /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
      message: /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("b", null, lang('Unverified Source')), /*#__PURE__*/teact.createElement("p", {
        className: Dapp_module.dappHostWarningText
      }, renderText(lang('$reopen_in_iab', {
        browserButton: src_config/* IS_CAPACITOR */.UMQ && url !== null && url !== void 0 && url.startsWith('http') ? /*#__PURE__*/teact.createElement("button", {
          className: Dapp_module.dappHostWarningButton,
          onClick: handleHostWarningIabButtonClick
        }, lang('MyTonWallet Browser')) : /*#__PURE__*/teact.createElement("b", null, lang('MyTonWallet Browser'))
      })))),
      type: "warning",
      size: "small",
      iconClassName: Dapp_module.dappHostWarningIcon
    });
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Dapp_module.dapp, className)
  }, renderIcon(), /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.dappInfo
  }, /*#__PURE__*/teact.createElement("span", {
    className: Dapp_module.dappName
  }, name), /*#__PURE__*/teact.createElement("span", {
    className: Dapp_module.dappHost
  }, !isUrlEnsured && renderWarningIcon(), host)), shouldShowDisconnect && /*#__PURE__*/teact.createElement(ui_Button, {
    isSmall: true,
    isPrimary: true,
    className: Dapp_module.dappDisconnect,
    onClick: handleDisconnect
  }, lang('Disconnect')));
}
/* harmony default export */ const dapps_DappInfo = (memo(DappInfo));
;// ./src/components/dapps/DappPassword.tsx








function DappPassword(_ref) {
  let {
    isActive,
    error,
    onSubmit,
    onCancel,
    onClose
  } = _ref;
  const {
    clearDappConnectRequestError
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onCancel
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Enter Password'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
    isActive: isActive,
    error: error,
    withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
    submitLabel: lang('Connect'),
    cancelLabel: lang('Cancel'),
    onSubmit: onSubmit,
    onCancel: onCancel,
    onUpdate: clearDappConnectRequestError
  }));
}
/* harmony default export */ const dapps_DappPassword = (memo(DappPassword));
;// ./src/components/dapps/DappConnectModal.tsx



























function DappConnectModal(_ref) {
  let {
    state,
    hasConnectRequest,
    dapp,
    error,
    requiredPermissions,
    requiredProof,
    accounts,
    currentAccountId,
    settingsByAccountId
  } = _ref;
  const {
    submitDappConnectRequestConfirm,
    cancelDappConnectRequestConfirm,
    setDappConnectRequestState,
    resetHardwareWalletConnect
  } = getActions();
  const lang = hooks_useLang();
  const [selectedAccount, setSelectedAccount] = useState(currentAccountId);
  const [isConfirmOpen, openConfirm, closeConfirm] = hooks_useFlag(false);
  const isOpen = hasConnectRequest;
  const {
    renderingKey,
    nextKey
  } = useModalTransitionKeys(state ?? 0, isOpen);
  const iterableAccounts = teact_useMemo(() => Object.entries(accounts || {}), [accounts]);
  const isLoading = dapp === undefined;
  teact_useEffect(() => {
    if (!currentAccountId) return;
    setSelectedAccount(currentAccountId);
  }, [currentAccountId]);
  const shouldRenderAccounts = accounts && isKeyCountGreater(accounts, 1);
  const handleSubmit = useLastCallback(async () => {
    closeConfirm();
    const isViewMode = isViewAccount(accounts[selectedAccount].type);
    const isHardware = accounts[selectedAccount].type === 'hardware';
    const {
      isPasswordRequired,
      isAddressRequired
    } = requiredPermissions || {};
    if (isViewMode) return;
    if (!requiredProof || !isHardware && isAddressRequired && !isPasswordRequired) {
      submitDappConnectRequestConfirm({
        accountId: selectedAccount
      });

      // Closing the modal is delayed in order to `submitDappConnectRequestConfirm` cause the "confirmed" effect first
      requestAnimationFrame(() => {
        cancelDappConnectRequestConfirm();
      });
    } else if (isHardware) {
      resetHardwareWalletConnect();
      setDappConnectRequestState({
        state: DappConnectState.ConnectHardware
      });
    } else if (getHasInMemoryPassword()) {
      submitDappConnectRequestConfirm({
        accountId: selectedAccount,
        password: await getInMemoryPassword()
      });
    } else {
      // The confirmation window must be closed before the password screen is displayed
      requestAnimationFrame(() => {
        setDappConnectRequestState({
          state: DappConnectState.Password
        });
      });
    }
  });
  const handlePasswordCancel = useLastCallback(() => {
    setDappConnectRequestState({
      state: DappConnectState.Info
    });
  });
  const submitDappConnectRequestHardware = useLastCallback(() => {
    submitDappConnectRequestConfirm({
      accountId: selectedAccount
    });
  });
  const handlePasswordSubmit = useLastCallback(password => {
    submitDappConnectRequestConfirm({
      accountId: selectedAccount,
      password
    });
  });
  function renderAccount(accountId, addressByChain, accountType, title) {
    const hasTonWallet = Boolean(addressByChain.ton);
    const onClick = !hasTonWallet || isViewAccount(accountType) ? undefined : () => setSelectedAccount(accountId);
    const address = (0,util_account/* getMainAccountAddress */.LG)(addressByChain) ?? '';
    const {
      cardBackgroundNft
    } = (settingsByAccountId === null || settingsByAccountId === void 0 ? void 0 : settingsByAccountId[accountId]) || {};
    return /*#__PURE__*/teact.createElement(common_AccountButton, {
      key: accountId,
      accountId: accountId,
      address: address,
      title: title,
      ariaLabel: lang('Switch Account'),
      accountType: accountType,
      isActive: accountId === selectedAccount,
      isLoading: isLoading,
      onClick: onClick,
      cardBackgroundNft: cardBackgroundNft
    });
  }
  function renderAccounts() {
    return /*#__PURE__*/teact.createElement(common_AccountButtonWrapper, {
      accountLength: iterableAccounts.length,
      labelText: lang('Select wallet to use on this dapp')
    }, iterableAccounts.map(_ref2 => {
      let [accountId, {
        title,
        addressByChain,
        type
      }] = _ref2;
      return renderAccount(accountId, addressByChain, type, title);
    }));
  }
  function renderDappInfo() {
    const isViewMode = Boolean(selectedAccount && isViewAccount(accounts === null || accounts === void 0 ? void 0 : accounts[selectedAccount].type));
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.transitionContent, Dapp_module.skeletonBackground)
    }, /*#__PURE__*/teact.createElement(dapps_DappInfo, {
      dapp: dapp,
      className: buildClassName(Dapp_module.dapp_first, Dapp_module.dapp_push)
    }), shouldRenderAccounts && renderAccounts(), /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.footer
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isDisabled: isViewMode,
      className: Modal_module.buttonFullWidth,
      onClick: openConfirm
    }, lang('Connect'))));
  }
  function renderWaitForConnection() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.transitionContent, Dapp_module.skeletonBackground)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Dapp_module.dappInfoSkeleton, Dapp_module.dapp_first)
    }, /*#__PURE__*/teact.createElement(ui_Skeleton, {
      className: Dapp_module.dappInfoIconSkeleton
    }), /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.dappInfoTextSkeleton
    }, /*#__PURE__*/teact.createElement(ui_Skeleton, {
      className: Dapp_module.nameSkeleton
    }), /*#__PURE__*/teact.createElement(ui_Skeleton, {
      className: Dapp_module.descSkeleton
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.accountWrapperSkeleton
    }, shouldRenderAccounts && renderAccounts()));
  }
  function renderDappInfoWithSkeleton() {
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "semiFade",
      activeKey: isLoading ? 0 : 1,
      slideClassName: Dapp_module.skeletonTransitionWrapper
    }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Connect Dapp'),
      onClose: cancelDappConnectRequestConfirm
    }), isLoading ? renderWaitForConnection() : renderDappInfo());
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case DappConnectState.Info:
        return renderDappInfoWithSkeleton();
      case DappConnectState.Password:
        return /*#__PURE__*/teact.createElement(dapps_DappPassword, {
          isActive: isActive,
          error: error,
          onSubmit: handlePasswordSubmit,
          onCancel: handlePasswordCancel,
          onClose: cancelDappConnectRequestConfirm
        });
      case DappConnectState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: submitDappConnectRequestHardware,
          onClose: handlePasswordCancel
        });
      case DappConnectState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          isActive: isActive,
          text: lang('Please confirm operation on your Ledger'),
          error: error,
          onTryAgain: submitDappConnectRequestHardware,
          onClose: handlePasswordCancel
        });
    }
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    dialogClassName: Dapp_module.modalDialog,
    nativeBottomSheetKey: "dapp-connect"
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    ,
    forceFullNative: renderingKey !== DappConnectState.Info,
    onClose: cancelDappConnectRequestConfirm,
    onCloseAnimationEnd: cancelDappConnectRequestConfirm
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey
  }, renderContent)), /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isConfirmOpen,
    isCompact: true,
    title: lang('Dapp Permissions'),
    onClose: closeConfirm
  }, /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.description
  }, lang('$dapp_can_view_balance', {
    dappname: /*#__PURE__*/teact.createElement("strong", null, dapp === null || dapp === void 0 ? void 0 : dapp.name)
  })), /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: closeConfirm,
    className: Dapp_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    onClick: handleSubmit,
    className: Dapp_module.button
  }, lang('Connect')))));
}
/* harmony default export */ const dapps_DappConnectModal = (memo(withGlobal(global => {
  var _global$dappConnectRe;
  const accounts = selectNetworkAccounts(global);
  const hasConnectRequest = ((_global$dappConnectRe = global.dappConnectRequest) === null || _global$dappConnectRe === void 0 ? void 0 : _global$dappConnectRe.state) !== undefined;
  const {
    state,
    dapp,
    error,
    accountId,
    permissions,
    proof
  } = global.dappConnectRequest || {};
  const currentAccountId = accountId || global.currentAccountId;
  return {
    state,
    hasConnectRequest,
    dapp,
    error,
    requiredPermissions: permissions,
    requiredProof: proof,
    currentAccountId,
    accounts,
    settingsByAccountId: global.settings.byAccountId
  };
})(DappConnectModal)));
;// ./src/components/dapps/DappInfoWithAccount.tsx








function DappInfoWithAccount(_ref) {
  var _accounts$currentAcco;
  let {
    dapp,
    toncoinBalance,
    currentAccountId,
    accounts,
    customTokenBalance,
    customTokenSymbol,
    customTokenDecimals
  } = _ref;
  // Use custom token display if provided, otherwise use TON balance
  const displayBalance = customTokenBalance !== undefined ? customTokenBalance : toncoinBalance;
  const displaySymbol = customTokenSymbol || src_config/* TONCOIN */.Tu9.symbol;
  const displayDecimals = customTokenDecimals !== undefined ? customTokenDecimals : src_config/* TONCOIN */.Tu9.decimals;
  return /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.transactionDirection
  }, /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.transactionAccount
  }, /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.accountTitle
  }, accounts === null || accounts === void 0 || (_accounts$currentAcco = accounts[currentAccountId]) === null || _accounts$currentAcco === void 0 ? void 0 : _accounts$currentAcco.title), /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.accountBalance
  }, formatCurrency((0,util_decimals/* toDecimal */.nI)(displayBalance, displayDecimals), displaySymbol))), /*#__PURE__*/teact.createElement(dapps_DappInfo, {
    dapp: dapp,
    className: Dapp_module.transactionDapp
  }));
}
/* harmony default export */ const dapps_DappInfoWithAccount = (memo(withGlobal(global => {
  const accounts = selectNetworkAccounts(global);
  return {
    toncoinBalance: selectCurrentToncoinBalance(global),
    currentAccountId: global.currentAccountId,
    accounts
  };
})(DappInfoWithAccount)));
;// ./src/components/dapps/DappSkeletonWithContent.tsx





function DappSkeletonWithContent(_ref) {
  let {
    rows
  } = _ref;
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.transitionContent, Dapp_module.skeletonBackground)
  }, /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.transactionDirection
  }, /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.transactionDirectionLeftSkeleton
  }, /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: buildClassName(Dapp_module.nameSkeleton, Dapp_module.nameDappSkeleton)
  }), /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: buildClassName(Dapp_module.descSkeleton, Dapp_module.descDappSkeleton)
  })), /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.transactionDirectionRightSkeleton
  }, /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: Dapp_module.dappInfoIconSkeleton
  }), /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.dappInfoDataSkeleton
  }, /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: buildClassName(Dapp_module.nameSkeleton, Dapp_module.nameDappSkeleton)
  }), /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: buildClassName(Dapp_module.descSkeleton, Dapp_module.descDappSkeleton)
  })))), rows === null || rows === void 0 ? void 0 : rows.map(renderRow));
}
/* harmony default export */ const dapps_DappSkeletonWithContent = (memo(DappSkeletonWithContent));
function renderRow(_ref2) {
  let {
    isLarge,
    hasFee
  } = _ref2;
  return /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.rowContainerSkeleton
  }, /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: buildClassName(Dapp_module.rowLabelSkeleton, isLarge && Dapp_module.rowTextLargeSkeleton)
  }), /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: buildClassName(Dapp_module.rowSkeleton, isLarge && Dapp_module.rowLargeSkeleton)
  }), hasFee && /*#__PURE__*/teact.createElement(ui_Skeleton, {
    className: Dapp_module.rowFeeSkeleton
  }));
}
;// ./src/components/dapps/DappSignDataInitial.tsx













const skeletonRows = [{
  isLarge: false,
  hasFee: false
}];
function DappSignDataInitial(_ref) {
  let {
    dapp,
    isLoading,
    payloadToSign
  } = _ref;
  const {
    closeDappSignData,
    submitDappSignDataConfirm
  } = getActions();
  const lang = hooks_useLang();
  const renderingPayloadToSign = useCurrentOrPrev(payloadToSign, true);
  const isDappLoading = dapp === undefined;
  function renderContent() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.transitionContent, Dapp_module.skeletonBackground)
    }, /*#__PURE__*/teact.createElement(dapps_DappInfoWithAccount, {
      dapp: dapp
    }), renderSignDataByType(), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.buttons, Dapp_module.transferButtons)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Modal_module.button,
      onClick: closeDappSignData
    }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isSubmit: true,
      isLoading: isLoading,
      className: Modal_module.button,
      onClick: submitDappSignDataConfirm
    }, lang('Sign'))));
  }
  function renderSignDataByType() {
    switch (renderingPayloadToSign === null || renderingPayloadToSign === void 0 ? void 0 : renderingPayloadToSign.type) {
      case 'text':
        {
          const {
            text
          } = renderingPayloadToSign;
          return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
            className: Dapp_module.label
          }, lang('Message')), /*#__PURE__*/teact.createElement("div", {
            className: buildClassName(Dapp_module.payloadField, Dapp_module.payloadField_text)
          }, text));
        }
      case 'binary':
        {
          const {
            bytes
          } = renderingPayloadToSign;
          return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
            className: Dapp_module.label
          }, lang('Binary Data')), /*#__PURE__*/teact.createElement("div", {
            className: buildClassName(Dapp_module.payloadField, Dapp_module.payloadField_expanded)
          }, bytes), /*#__PURE__*/teact.createElement("div", {
            className: Dapp_module.warningForPayload
          }, lang('The binary data content is unclear. Sign it only if you trust the service.')));
        }
      case 'cell':
        {
          const {
            cell,
            schema
          } = renderingPayloadToSign;
          return /*#__PURE__*/teact.createElement(teact.Fragment, null, !!schema && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
            className: Dapp_module.label
          }, lang('Cell Schema')), /*#__PURE__*/teact.createElement("div", {
            className: buildClassName(Dapp_module.payloadField, Dapp_module.payloadField_text)
          }, schema)), /*#__PURE__*/teact.createElement("p", {
            className: Dapp_module.label
          }, lang('Cell Data')), /*#__PURE__*/teact.createElement("div", {
            className: buildClassName(Dapp_module.dataField, Dapp_module.payloadField, Dapp_module.payloadField_expanded)
          }, cell), /*#__PURE__*/teact.createElement("div", {
            className: Dapp_module.warningForPayload
          }, lang('The binary data content is unclear. Sign it only if you trust the service.')));
        }
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "semiFade",
    activeKey: isDappLoading ? 0 : 1,
    slideClassName: Dapp_module.skeletonTransitionWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Sign Data'),
    onClose: closeDappSignData
  }), isDappLoading ? /*#__PURE__*/teact.createElement(dapps_DappSkeletonWithContent, {
    rows: skeletonRows
  }) : renderContent());
}
/* harmony default export */ const dapps_DappSignDataInitial = (memo(withGlobal(global => (0,iteratees/* pick */.Up)(global.currentDappSignData, ['dapp', 'isLoading', 'payloadToSign']))(DappSignDataInitial)));
;// ./src/components/common/TransferResult.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TransferResult_module = ({"sticker":"TransferResult-module__sticker","amount":"TransferResult-module__amount","amount_purple":"TransferResult-module__amount_purple","amountPurple":"TransferResult-module__amount_purple","amount_green":"TransferResult-module__amount_green","amountGreen":"TransferResult-module__amount_green","amountSymbol":"TransferResult-module__amountSymbol","amountFraction":"TransferResult-module__amountFraction","buttons":"TransferResult-module__buttons","buttonsAfterNft":"TransferResult-module__buttonsAfterNft","button":"TransferResult-module__button"});
;// ./src/components/dapps/DappTransferComplete.tsx










function DappTransferComplete(_ref) {
  let {
    isActive,
    onClose,
    type = 'transfer'
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  teact_useEffect(() => {
    return isActive ? captureKeyboardListeners({
      onEnter: onClose
    }) : undefined;
  }, [isActive, onClose]);
  const title = type === 'signData' ? lang('Data Signed!') : lang('Transaction Sent!');
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: title,
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContent
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    noLoop: false,
    nonInteractive: true,
    className: TransferResult_module.sticker,
    tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
    previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    isPrimary: true
  }, lang('Close')))));
}
/* harmony default export */ const dapps_DappTransferComplete = (memo(DappTransferComplete));
;// ./src/components/dapps/DappSignDataModal.tsx



















function DappSignDataModal(_ref) {
  let {
    isLoading,
    state,
    error
  } = _ref;
  const {
    setDappSignDataScreen,
    submitDappSignData,
    clearDappSignDataError,
    closeDappSignData,
    cancelDappSignData
  } = getActions();
  const lang = hooks_useLang();
  const isOpen = state !== SignDataState.None;
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const handleBackClick = useLastCallback(() => {
    if (state === SignDataState.Password) {
      setDappSignDataScreen({
        state: SignDataState.Initial
      });
    }
  });
  const handlePasswordSubmit = useLastCallback(password => {
    submitDappSignData({
      password
    });
  });
  const handleResetSignData = useLastCallback(() => {
    cancelDappSignData();
    updateNextKey();
  });
  function renderPassword(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Sign Data'),
      onClose: closeDappSignData
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      isLoading: isLoading,
      error: error,
      withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
      submitLabel: lang('Sign'),
      cancelLabel: lang('Back'),
      onSubmit: handlePasswordSubmit,
      onCancel: handleBackClick,
      onUpdate: clearDappSignDataError
    }));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case SignDataState.Initial:
        return /*#__PURE__*/teact.createElement(dapps_DappSignDataInitial, null);
      case SignDataState.Password:
        return renderPassword(isActive);
      case SignDataState.Complete:
        return /*#__PURE__*/teact.createElement(dapps_DappTransferComplete, {
          isActive: isActive,
          onClose: closeDappSignData,
          type: "signData"
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen,
    dialogClassName: Dapp_module.modalDialog,
    nativeBottomSheetKey: "dapp-sign-data",
    noBackdropClose: true
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    ,
    forceFullNative: renderingKey === SignDataState.Password,
    onClose: closeDappSignData,
    onCloseAnimationEnd: handleResetSignData
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const dapps_DappSignDataModal = (memo(withGlobal(global => (0,iteratees/* pick */.Up)(global.currentDappSignData, ['isLoading', 'state', 'error']))(DappSignDataModal)));
;// ./src/util/getPseudoRandomNumber.ts
// Converts a string to a numeric seed using a simple hashing algorithm
function stringToNumberSeed(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    // hash * 31 + charCode
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
    // Conversion to a 32-bit integer
    hash |= 0;
  }
  return hash;
}
function getPseudoRandomNumber(min, max, seed) {
  const numberSeed = stringToNumberSeed(seed);
  // Convert `seed` to a pseudorandom number using `Math.sin`
  const x = Math.sin(numberSeed) * 10000;
  const randomFraction = x - Math.floor(x);
  return Math.floor(randomFraction * (max - min + 1)) + min;
}
;// ./src/util/swap/getSwapRate.ts



const BTC = new Set(['jWBTC', 'oWBTC', 'BTC']);
const USD = new Set(['jUSDT', 'oUSDT', 'USDT', 'jUSDC', 'oUSDC', 'USDC', 'USDâ‚®']);
const FIAT = new Set(['USD', 'RUB', 'EUR', 'CNY']);
const LARGE_NUMBER = 1000;
function getCurrencyPriority(symbol) {
  if (FIAT.has(symbol)) return 5;
  if (USD.has(symbol)) return 4;
  if (BTC.has(symbol)) return 3;
  if (symbol === src_config/* TONCOIN */.Tu9.symbol) return 2;
  return 1;
}
function getSwapRate(fromAmount, toAmount, fromToken, toToken) {
  let shouldTrimLargeNumber = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  if (!fromAmount || !toAmount || !fromToken || !toToken) {
    return undefined;
  }
  let firstCurrencySymbol = fromToken.symbol;
  let secondCurrencySymbol = toToken.symbol;
  let price;
  const fromAmountBig = new big_js/* Big */.z(fromAmount);
  const toAmountBig = new big_js/* Big */.z(toAmount);
  if (fromAmountBig.eq(0) || toAmountBig.eq(0)) {
    return undefined;
  }
  const fromPriority = getCurrencyPriority(firstCurrencySymbol);
  const toPriority = getCurrencyPriority(secondCurrencySymbol);
  if (toPriority < fromPriority) {
    firstCurrencySymbol = toToken.symbol;
    secondCurrencySymbol = fromToken.symbol;
    const ratio = fromAmountBig.div(toAmount);
    const isLargeNumber = shouldTrimLargeNumber && ratio.gte(LARGE_NUMBER);
    price = formatNumber(ratio.toNumber(), isLargeNumber ? 0 : 4);
  } else {
    const ratio = toAmountBig.div(fromAmount);
    const isLargeNumber = shouldTrimLargeNumber && ratio.gte(LARGE_NUMBER);
    price = formatNumber(ratio.toNumber(), isLargeNumber ? 0 : 4);
  }
  return {
    firstCurrencySymbol,
    secondCurrencySymbol,
    price
  };
}
;// ./src/assets/blockchain/chain_avalanche.svg
const chain_avalanche_namespaceObject = __webpack_require__.p + "chain_avalanche.f5a22f3024a79c2a9f7e.svg";
;// ./src/assets/blockchain/chain_bitcoin.svg
const chain_bitcoin_namespaceObject = __webpack_require__.p + "chain_bitcoin.f45ee04748fc010b73f0.svg";
;// ./src/assets/blockchain/chain_bitcoincash.svg
const chain_bitcoincash_namespaceObject = __webpack_require__.p + "chain_bitcoincash.e58775a726a28f67a7ab.svg";
;// ./src/assets/blockchain/chain_bnb.svg
const chain_bnb_namespaceObject = __webpack_require__.p + "chain_bnb.01e2f3e1ea67de53c558.svg";
;// ./src/assets/blockchain/chain_cardano.svg
const chain_cardano_namespaceObject = __webpack_require__.p + "chain_cardano.687768b5a8564f340656.svg";
;// ./src/assets/blockchain/chain_cosmos.svg
const chain_cosmos_namespaceObject = __webpack_require__.p + "chain_cosmos.a7db04679752fce24427.svg";
;// ./src/assets/blockchain/chain_dash.svg
const chain_dash_namespaceObject = __webpack_require__.p + "chain_dash.cda178d1c80b14b84c65.svg";
;// ./src/assets/blockchain/chain_doge.svg
const chain_doge_namespaceObject = __webpack_require__.p + "chain_doge.299dffe46d1d20ecb64e.svg";
;// ./src/assets/blockchain/chain_eos.svg
const chain_eos_namespaceObject = __webpack_require__.p + "chain_eos.5d77746a1d3fe4f879d9.svg";
;// ./src/assets/blockchain/chain_ethereum.svg
const chain_ethereum_namespaceObject = __webpack_require__.p + "chain_ethereum.3af0d0aca7d489e97c88.svg";
;// ./src/assets/blockchain/chain_ethereumclassic.svg
const chain_ethereumclassic_namespaceObject = __webpack_require__.p + "chain_ethereumclassic.7a2a50f776866f7dc57f.svg";
;// ./src/assets/blockchain/chain_internetcomputer.svg
const chain_internetcomputer_namespaceObject = __webpack_require__.p + "chain_internetcomputer.a779e5a83feca271c1b5.svg";
;// ./src/assets/blockchain/chain_iota.svg
const chain_iota_namespaceObject = __webpack_require__.p + "chain_iota.74e7a3ff559ca5be6171.svg";
;// ./src/assets/blockchain/chain_litecoin.svg
const chain_litecoin_namespaceObject = __webpack_require__.p + "chain_litecoin.200bd2979f34cbf91fee.svg";
;// ./src/assets/blockchain/chain_monero.svg
const chain_monero_namespaceObject = __webpack_require__.p + "chain_monero.80470738ce04482ad225.svg";
;// ./src/assets/blockchain/chain_polkadot.svg
const chain_polkadot_namespaceObject = __webpack_require__.p + "chain_polkadot.ce8946cba8f597bc6435.svg";
;// ./src/assets/blockchain/chain_ripple.svg
const chain_ripple_namespaceObject = __webpack_require__.p + "chain_ripple.d4675f4b4373f6c8fdf4.svg";
;// ./src/assets/blockchain/chain_solana.svg
const chain_solana_namespaceObject = __webpack_require__.p + "chain_solana.3628ba06de78d3bc2018.svg";
;// ./src/assets/blockchain/chain_stellar.svg
const chain_stellar_namespaceObject = __webpack_require__.p + "chain_stellar.f7eb720521e4d55bb082.svg";
;// ./src/assets/blockchain/chain_ton.svg
const chain_ton_namespaceObject = __webpack_require__.p + "chain_ton.65285e35dece81bdab6c.svg";
;// ./src/assets/blockchain/chain_tron.svg
const chain_tron_namespaceObject = __webpack_require__.p + "chain_tron.78feaed45ec98c6779ca.svg";
;// ./src/assets/blockchain/chain_zcash.svg
const chain_zcash_namespaceObject = __webpack_require__.p + "chain_zcash.51dd09d4e46c4b2f1ace.svg";
;// ./src/util/swap/getChainNetworkIcon.ts






















const CHAIN_ICON_MAP = {
  avalanche: chain_avalanche_namespaceObject,
  bitcoin: chain_bitcoin_namespaceObject,
  bitcoin_cash: chain_bitcoincash_namespaceObject,
  binance_smart_chain: chain_bnb_namespaceObject,
  binance_dex: chain_bnb_namespaceObject,
  cardano: chain_cardano_namespaceObject,
  cosmos: chain_cosmos_namespaceObject,
  dash: chain_dash_namespaceObject,
  doge: chain_doge_namespaceObject,
  eos: chain_eos_namespaceObject,
  ethereum: chain_ethereum_namespaceObject,
  ethereum_classic: chain_ethereumclassic_namespaceObject,
  internet_computer: chain_internetcomputer_namespaceObject,
  iota: chain_iota_namespaceObject,
  litecoin: chain_litecoin_namespaceObject,
  monero: chain_monero_namespaceObject,
  polkadot: chain_polkadot_namespaceObject,
  ripple: chain_ripple_namespaceObject,
  solana: chain_solana_namespaceObject,
  stellar: chain_stellar_namespaceObject,
  ton: chain_ton_namespaceObject,
  tron: chain_tron_namespaceObject,
  zcash: chain_zcash_namespaceObject
};
function getChainNetworkIcon(networkName) {
  if (!networkName) return '';
  return CHAIN_ICON_MAP[networkName] ?? networkName;
}
;// ./src/assets/coins/coin_btc.png
const coin_btc_namespaceObject = __webpack_require__.p + "coin_btc.887dcd8a09b641cd64fc.png";
;// ./src/assets/coins/coin_my.svg
const coin_my_namespaceObject = __webpack_require__.p + "coin_my.0333e30adb78820c4490.svg";
;// ./src/assets/coins/coin_ton.png
const coin_ton_namespaceObject = __webpack_require__.p + "coin_ton.3ad15a82e5688b967ed1.png";
;// ./src/assets/coins/coin_trx.svg
const coin_trx_namespaceObject = __webpack_require__.p + "coin_trx.e9458515724ddbb167c8.svg";
;// ./src/assets/coins/coin_usdt.svg
const coin_usdt_namespaceObject = __webpack_require__.p + "coin_usdt.954394d1344db6c259d1.svg";
;// ./src/components/ui/helpers/assetLogos.ts





const ASSET_LOGO_PATHS = {
  ton: coin_ton_namespaceObject,
  btc: coin_btc_namespaceObject,
  trx: coin_trx_namespaceObject,
  usdt: coin_usdt_namespaceObject,
  my: coin_my_namespaceObject
};
;// ./src/components/common/TokenIcon.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TokenIcon_module = ({"wrapper":"TokenIcon-module__wrapper","icon":"TokenIcon-module__icon","large":"TokenIcon-module__large","x-large":"TokenIcon-module__x-large","xLarge":"TokenIcon-module__x-large","x-small":"TokenIcon-module__x-small","xSmall":"TokenIcon-module__x-small","small":"TokenIcon-module__small","middle":"TokenIcon-module__middle","fallbackIcon":"TokenIcon-module__fallbackIcon","blockchainIcon":"TokenIcon-module__blockchainIcon"});
;// ./src/components/common/TokenIcon.tsx






function TokenIcon(_ref) {
  let {
    token,
    size,
    withChainIcon,
    className,
    iconClassName,
    children
  } = _ref;
  const {
    symbol,
    image,
    chain
  } = token;
  const logoPath = ASSET_LOGO_PATHS[symbol.toLowerCase()] || image;
  const [isLoadingError, markLoadingError] = hooks_useFlag(false);
  function renderDefaultIcon() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(TokenIcon_module.icon, size && TokenIcon_module[size], iconClassName, TokenIcon_module.fallbackIcon)
    }, token.symbol.slice(0, 1));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(TokenIcon_module.wrapper, className)
  }, !isLoadingError ? /*#__PURE__*/teact.createElement("img", {
    src: logoPath,
    alt: symbol,
    className: buildClassName(TokenIcon_module.icon, size && TokenIcon_module[size], iconClassName),
    draggable: false,
    onError: markLoadingError
  }) : renderDefaultIcon(), withChainIcon && chain && /*#__PURE__*/teact.createElement("img", {
    src: getChainNetworkIcon(chain),
    alt: "",
    className: buildClassName(TokenIcon_module.blockchainIcon, size && TokenIcon_module[size]),
    draggable: false
  }), children);
}
/* harmony default export */ const common_TokenIcon = (memo(TokenIcon));
;// ./src/components/common/SensitiveDataMask.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SensitiveDataMask_module = ({"canvas":"SensitiveDataMask-module__canvas"});
;// ./src/components/common/SensitiveDataMask.tsx













// STEPS values are pre-multiplied by 1 / (1000 / 60) to compensate for FPS
const STEPS = [0.0001 * 0.06, 0.0001 * 0.06, 0.00001 * 0.06, 0.0003 * 0.06, 0.0001 * 0.06, 0.0025 * 0.06];
const FROM = 0.07;
const TO = 0.25;
const CHANGE_SPEED_INTERVAL = 3000;
const SKIN_COLORS = {
  lightTheme: '120, 121, 122',
  darkTheme: '240, 241, 242',
  cardLightText: '250, 250, 250',
  cardDarkText: '10, 10, 10',
  cardGoldText: '101, 73, 16',
  purple: '96, 107, 215',
  green: '43, 196, 105'
};
function SensitiveDataMask(_ref) {
  let {
    ref,
    cols,
    rows,
    cellSize,
    skin,
    className,
    theme
  } = _ref;
  let canvasRef = teact_useRef();
  if (ref) {
    canvasRef = ref;
  }
  const cellSizeDpr = cellSize * windowEnvironment/* DPR */.Lv;
  const appTheme = hooks_useAppTheme(theme);
  const color = SKIN_COLORS[skin ?? `${appTheme}Theme`];
  const animationStateRef = teact_useRef({
    opacityValues: [],
    steps: [],
    lastSpeedChangeAt: undefined,
    isRendered: false
  });
  const getIsIntersecting = useGetIsIntersectingWithApp(canvasRef);
  const getIsInBackground2 = getIsInBackground;
  const getShouldAnimate = hooks_useDerivedSignal(() => getIsIntersecting() && !getIsInBackground2(), [getIsIntersecting, getIsInBackground2]);
  useLayoutEffect(() => {
    const state = animationStateRef.current;
    if (state.isRendered && !getShouldAnimate()) return undefined;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = cols * cellSizeDpr;
    const height = rows * cellSizeDpr;
    let shouldStop = false;
    let lastFrameAt;
    canvas.width = width;
    canvas.height = height;
    state.lastSpeedChangeAt = undefined;
    const renderOptions = {
      ctx,
      cols,
      rows,
      width,
      height,
      cellSizeDpr,
      color
    };
    (0,animation/* animateInstantly */.iT)(() => {
      if (shouldStop || state.isRendered && !getShouldAnimate()) return false;
      const now = performance.now();
      const frameDuration = lastFrameAt ? now - lastFrameAt : 0;
      renderFrame(renderOptions, state, frameDuration);
      lastFrameAt = now;
      return true;
    }, fasterdom/* requestMutation */.RK);
    return () => {
      shouldStop = true;
    };
  }, [cols, rows, cellSizeDpr, getShouldAnimate, color]);
  return /*#__PURE__*/teact.createElement("canvas", {
    ref: canvasRef,
    style: `width: ${cellSize * cols}px; height: ${cellSize * rows}px`,
    className: buildClassName(SensitiveDataMask_module.canvas, className)
  });
}
function renderFrame(options, state) {
  let frameDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const {
    ctx,
    cols,
    rows,
    cellSizeDpr,
    width,
    height,
    color
  } = options;
  const now = performance.now();
  const shouldChangeSpeed = state.lastSpeedChangeAt ? now - state.lastSpeedChangeAt >= CHANGE_SPEED_INTERVAL : false;
  if (shouldChangeSpeed || !state.lastSpeedChangeAt) {
    state.lastSpeedChangeAt = now;
  }
  ctx.clearRect(0, 0, width, height);
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      state.steps[row] ??= [];
      state.opacityValues[row] ??= [];
      if (shouldChangeSpeed) {
        state.steps[row][col] = sample(STEPS) * (state.steps[row][col] < 0 ? -1 : 1);
      } else {
        state.steps[row][col] ??= sample(STEPS);
      }
      let nextOpacity = state.opacityValues[row][col] ?? Math.random() * (TO - FROM) + FROM;
      nextOpacity += state.steps[row][col] * frameDuration;
      if (nextOpacity > TO || nextOpacity < FROM) {
        state.steps[row][col] *= -1;
        nextOpacity = clamp(nextOpacity, FROM, TO);
      }
      state.opacityValues[row][col] = nextOpacity;
      ctx.fillStyle = `rgba(${color}, ${nextOpacity})`;
      ctx.fillRect(col * cellSizeDpr, row * cellSizeDpr, cellSizeDpr, cellSizeDpr);
      state.isRendered ||= true;
    }
  }
}

// Returns a random element from the array
function sample(array) {
  return array[(0,random/* random */.yT)(0, array.length - 1)];
}
/* harmony default export */ const common_SensitiveDataMask = (memo(withGlobal(global => {
  return {
    theme: global.settings.theme
  };
})(SensitiveDataMask)));
;// ./src/components/ui/SensitiveData.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SensitiveData_module = ({"wrapper":"SensitiveData-module__wrapper","center":"SensitiveData-module__center","right":"SensitiveData-module__right","interactive":"SensitiveData-module__interactive","content":"SensitiveData-module__content","spoiler":"SensitiveData-module__spoiler","left":"SensitiveData-module__left","fixedWidth":"SensitiveData-module__fixedWidth"});
;// ./src/components/ui/SensitiveData.tsx








function SensitiveData(_ref) {
  let {
    isActive,
    rows,
    cols,
    cellSize = 0,
    align = 'left',
    maskSkin,
    shouldHoldSize,
    className,
    maskClassName,
    contentClassName,
    children
  } = _ref;
  const [isShown, setIsShown] = useState(false);
  const isMaskActive = isActive && !isShown;
  teact_useEffect(() => {
    if (!isActive && isShown) {
      setIsShown(false);
    }
  }, [isActive, isShown]);
  const {
    ref: contentRef
  } = useShowTransition({
    isOpen: !isMaskActive,
    noMountTransition: !isMaskActive,
    className: 'slow'
  });
  const {
    shouldRender: shouldRenderSpoiler,
    ref: spoilerRef
  } = useShowTransition({
    isOpen: isMaskActive,
    withShouldRender: true,
    className: 'slow'
  });
  function handleClick(e) {
    stopEvent(e);
    if (!isActive) return;
    setIsShown(!isShown);
    void vibrate();
  }
  const fullClassName = buildClassName(SensitiveData_module.wrapper, className, isActive && SensitiveData_module.interactive, SensitiveData_module[align]);
  const spoilerClassName = buildClassName(SensitiveData_module.spoiler, maskClassName, SensitiveData_module[align]);
  const wrapperStyle = buildStyle(`--spoiler-width: calc(${cellSize * cols}px + var(--sensitive-data-extra-width, 0px))`, `min-height: ${cellSize * rows}px`, (isMaskActive || shouldHoldSize) && 'min-width: var(--spoiler-width);');
  const contentFullClassName = buildClassName(SensitiveData_module.content, contentClassName, isMaskActive && SensitiveData_module.fixedWidth);
  return /*#__PURE__*/teact.createElement("div", {
    style: wrapperStyle,
    className: fullClassName,
    onClick: isActive ? handleClick : undefined
  }, shouldRenderSpoiler && /*#__PURE__*/teact.createElement(common_SensitiveDataMask, {
    ref: spoilerRef,
    cols: cols,
    rows: rows,
    cellSize: cellSize,
    skin: maskSkin,
    className: spoilerClassName
  }), /*#__PURE__*/teact.createElement("div", {
    ref: contentRef,
    className: contentFullClassName
  }, children));
}
/* harmony default export */ const ui_SensitiveData = (SensitiveData);
;// ./src/components/main/sections/Content/Activity.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Activity_module = ({"item":"Activity-module__item","interactive":"Activity-module__interactive","active":"Activity-module__active","itemLast":"Activity-module__itemLast","icon":"Activity-module__icon","dnsIcon":"Activity-module__dnsIcon","iconFromToken":"Activity-module__iconFromToken","iconWaiting":"Activity-module__iconWaiting","iconError":"Activity-module__iconError","header":"Activity-module__header","subheader":"Activity-module__subheader","atMiddle":"Activity-module__atMiddle","operationName":"Activity-module__operationName","date":"Activity-module__date","subheaderHighlight":"Activity-module__subheaderHighlight","chainIcon":"Activity-module__chainIcon","amount":"Activity-module__amount","amountTokenIcon":"Activity-module__amountTokenIcon","commentIcon":"Activity-module__commentIcon","comment":"Activity-module__comment","outgoing":"Activity-module__outgoing","scamImage":"Activity-module__scamImage","swapArrowRight":"Activity-module__swapArrowRight","swapSell":"Activity-module__swapSell","swapBuy":"Activity-module__swapBuy","swapHold":"Activity-module__swapHold","swapError":"Activity-module__swapError","nft":"Activity-module__nft","nonInteractive":"Activity-module__nonInteractive","nftImage":"Activity-module__nftImage","nftData":"Activity-module__nftData","nftName":"Activity-module__nftName","nftCollection":"Activity-module__nftCollection","attachment":"Activity-module__attachment","attachmentsInFullSubheader":"Activity-module__attachmentsInFullSubheader","attachmentsInLeftSubheader":"Activity-module__attachmentsInLeftSubheader","colorIn":"Activity-module__colorIn","colorOut":"Activity-module__colorOut","colorStake":"Activity-module__colorStake","colorNegative":"Activity-module__colorNegative","colorSwap":"Activity-module__colorSwap"});
;// ./src/components/main/sections/Content/ActivityStatusIcon.tsx







const iconNamePrefix = 'iconClock';
function ActivityStatusIcon(_ref) {
  let {
    isPending,
    isError,
    color = 'Gray',
    appTheme
  } = _ref;
  const {
    shouldRender: shouldRenderClock,
    ref: clockRef
  } = useShowTransition({
    isOpen: isPending,
    withShouldRender: true
  });

  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
  const clockIconName = `${iconNamePrefix}${color}`;
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, isError && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Activity_module.iconError, 'icon-close-filled'),
    "aria-hidden": true
  }), shouldRenderClock && /*#__PURE__*/teact.createElement("div", {
    ref: clockRef,
    className: Activity_module.iconWaiting
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: true,
    size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
    nonInteractive: true,
    noLoop: false,
    forceOnHeavyAnimation: true,
    tgsUrl: ANIMATED_STICKERS_PATHS[appTheme][clockIconName],
    previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview[clockIconName]
  })));
}
/* harmony default export */ const Content_ActivityStatusIcon = (memo(ActivityStatusIcon));
;// ./src/components/main/sections/Content/Swap.tsx














const SWAP_HEIGHT = 4; // rem
const CHANGELLY_PENDING_STATUSES = new Set(['new', 'waiting', 'confirming', 'exchanging', 'sending', 'hold']);
const CHANGELLY_EXPIRED_STATUSES = new Set(['failed', 'expired', 'refunded', 'overdue']);
const ONCHAIN_ERROR_STATUSES = new Set(['expired', 'failed']);
function Swap(_ref) {
  let {
    ref,
    tokensBySlug,
    activity,
    isLast,
    isActive,
    appTheme,
    addressByChain,
    isSensitiveDataHidden,
    isFuture,
    onClick
  } = _ref;
  const lang = hooks_useLang();
  const {
    id,
    timestamp,
    status,
    from,
    to,
    cex
  } = activity;
  const fromToken = teact_useMemo(() => {
    if (!from || !tokensBySlug) return undefined;
    return resolveSwapAsset(tokensBySlug, from);
  }, [from, tokensBySlug]);
  const toToken = teact_useMemo(() => {
    if (!to || !tokensBySlug) return undefined;
    return resolveSwapAsset(tokensBySlug, to);
  }, [to, tokensBySlug]);
  const fromAmount = Number(activity.fromAmount);
  const toAmount = Number(activity.toAmount);
  const isPending = status === 'pending' || CHANGELLY_PENDING_STATUSES.has((cex === null || cex === void 0 ? void 0 : cex.status) ?? '');
  const isError = ONCHAIN_ERROR_STATUSES.has(status) || CHANGELLY_EXPIRED_STATUSES.has((cex === null || cex === void 0 ? void 0 : cex.status) ?? '');
  const isHold = (cex === null || cex === void 0 ? void 0 : cex.status) === 'hold';
  const amountCols = teact_useMemo(() => getPseudoRandomNumber(5, 13, timestamp.toString()), [timestamp]);
  const isFromToncoin = from === src_config/* TONCOIN */.Tu9.slug;
  const isInternalSwap = getIsInternalSwap({
    from: fromToken,
    to: toToken,
    toAddress: cex === null || cex === void 0 ? void 0 : cex.payoutAddress,
    addressByChain
  });
  function renderIcon() {
    let statusClass = Activity_module.colorSwap;
    let pendingIndicatorColor = 'Green';
    if (isError) {
      statusClass = Activity_module.colorNegative;
      pendingIndicatorColor = 'Red';
    } else if (isHold) {
      statusClass = undefined;
      pendingIndicatorColor = 'Gray';
    }
    if (status === 'pending') {
      pendingIndicatorColor = 'Orange';
    }
    return /*#__PURE__*/teact.createElement("i", {
      className: buildClassName('icon-swap', Activity_module.icon, statusClass),
      "aria-hidden": true
    }, /*#__PURE__*/teact.createElement(Content_ActivityStatusIcon, {
      isPending: isPending,
      isError: isError,
      color: pendingIndicatorColor,
      appTheme: appTheme
    }));
  }
  function renderAmount() {
    const statusClass = buildClassName(isError && Activity_module.swapError, isHold && Activity_module.swapHold);
    return /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: amountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      contentClassName: Activity_module.amount
    }, /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Activity_module.swapSell, statusClass)
    }, formatCurrencyExtended(Math.abs(fromAmount), (fromToken === null || fromToken === void 0 ? void 0 : fromToken.symbol) || src_config/* TONCOIN */.Tu9.symbol, true)), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Activity_module.swapArrowRight, 'icon-chevron-right', statusClass),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Activity_module.swapBuy, statusClass)
    }, formatCurrencyExtended(Math.abs(toAmount), (toToken === null || toToken === void 0 ? void 0 : toToken.symbol) || src_config/* TONCOIN */.Tu9.symbol, true)), fromToken && /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: fromToken,
      size: "x-small",
      className: Activity_module.amountTokenIcon
    }), toToken && /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: toToken,
      size: "x-small",
      className: Activity_module.amountTokenIcon
    }));
  }
  function renderStatusAndDate() {
    if (isFuture) {
      return /*#__PURE__*/teact.createElement("div", null);
    }
    const date = (0,dateFormat/* formatTime */.fU)(timestamp);
    let state = '';
    const cexStatus = cex === null || cex === void 0 ? void 0 : cex.status;
    if (cexStatus === 'expired' || cexStatus === 'overdue') {
      state = lang('Expired');
    } else if (cexStatus === 'refunded') {
      state = lang('Refunded');
    } else if (cexStatus === 'hold') {
      state = lang('On Hold');
    } else if (cexStatus === 'failed' || isError) {
      state = lang('Failed');
    } else if (cexStatus === 'waiting' && !isFromToncoin && !isInternalSwap) {
      // Skip the 'waiting' status for transactions from Toncoin to account or from Tron to Ton
      // inside the multichain wallet for delayed status updates from Ð¡hangelly
      state = lang('Waiting for Payment');
    } else if (isPending) {
      state = lang('In Progress');
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: Activity_module.date
    }, state && /*#__PURE__*/teact.createElement("span", {
      className: Activity_module.subheaderHighlight
    }, state), state && `${src_config/* WHOLE_PART_DELIMITER */.MS3}âˆ™${src_config/* WHOLE_PART_DELIMITER */.MS3}`, date);
  }
  function renderTitle() {
    if (isHold || isError || isFuture) {
      return lang('$swap_action');
    } else if (isPending) {
      return lang('Swapping');
    }
    return lang('Swapped');
  }
  function renderCurrency() {
    const rate = getSwapRate(activity.fromAmount, activity.toAmount, fromToken, toToken);
    if (!rate) return undefined;
    const [priceWhole, priceFraction] = rate.price.split('.');
    return /*#__PURE__*/teact.createElement("div", null, rate.firstCurrencySymbol, ' â‰ˆ ', /*#__PURE__*/teact.createElement("span", {
      className: Activity_module.subheaderHighlight
    }, priceWhole, /*#__PURE__*/teact.createElement("small", null, ".", priceFraction, ' ', rate.secondCurrencySymbol)));
  }
  return /*#__PURE__*/teact.createElement(ui_Button, {
    ref: ref,
    className: buildClassName(Activity_module.item, isLast && Activity_module.itemLast, isActive && Activity_module.active, onClick && Activity_module.interactive),
    onClick: onClick && (() => onClick(id)),
    isSimple: true
  }, renderIcon(), /*#__PURE__*/teact.createElement("div", {
    className: Activity_module.header
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Activity_module.operationName, isFuture && Activity_module.atMiddle)
  }, renderTitle()), renderAmount()), /*#__PURE__*/teact.createElement("div", {
    className: Activity_module.subheader
  }, renderStatusAndDate(), renderCurrency()));
}
/* harmony default export */ const Content_Swap = (memo(Swap));
function getSwapHeight() {
  return SWAP_HEIGHT;
}
;// ./src/util/getLocalAddressName.ts
function getLocalAddressName(_ref) {
  var _savedAddresses$find;
  let {
    address,
    chain,
    currentAccountId,
    accounts,
    savedAddresses
  } = _ref;
  if (!address) return undefined;
  const otherAccount = accounts ? Object.keys(accounts).find(accountId => {
    var _accounts$accountId$a;
    return accountId !== currentAccountId && ((_accounts$accountId$a = accounts[accountId].addressByChain) === null || _accounts$accountId$a === void 0 ? void 0 : _accounts$accountId$a[chain]) === address;
  }) : undefined;
  if (otherAccount) {
    return accounts[otherAccount].title;
  }
  return savedAddresses === null || savedAddresses === void 0 || (_savedAddresses$find = savedAddresses.find(item => {
    return item.address === address && item.chain === chain;
  })) === null || _savedAddresses$find === void 0 ? void 0 : _savedAddresses$find.name;
}
;// ./src/assets/scam.svg
const scam_namespaceObject = __webpack_require__.p + "scam.8fb66536b659fd1bbfc6.svg";
;// ./src/components/main/sections/Content/Transaction.tsx






















const TRANSACTION_HEIGHT = 4; // rem
const NFT_EXTRA_HEIGHT = 3.875; // rem
const COMMENT_EXTRA_HEIGHT = 2.375; // rem
const SUBHEADER_RELEASE_HEIGHT = 1.25; // rem

const OUT_TRANSACTION_TYPES = new Set([undefined, 'unstakeRequest', 'nftTrade', 'auctionBid', 'liquidityDeposit']);
function Transaction(_ref) {
  let {
    ref,
    tokensBySlug,
    transaction,
    isActive,
    annualYield,
    yieldType,
    savedAddresses,
    isLast,
    appTheme,
    withChainIcon,
    doesNftExist,
    isSensitiveDataHidden,
    isFuture,
    accounts,
    currentAccountId,
    baseCurrency,
    onClick
  } = _ref;
  const {
    openNftAttributesModal
  } = getActions();
  const lang = hooks_useLang();
  const {
    id,
    amount,
    fromAddress,
    toAddress,
    timestamp,
    comment,
    encryptedComment,
    isIncoming,
    type,
    metadata,
    slug,
    nft,
    extra,
    status
  } = transaction;
  const isStaking = STAKING_TRANSACTION_TYPES.has(type);
  const isDnsOperation = DNS_TRANSACTION_TYPES.has(type);
  const token = tokensBySlug[slug];
  const {
    chain
  } = token || {};
  const address = isIncoming ? fromAddress : toAddress;
  const localAddressName = teact_useMemo(() => {
    if (!chain) return undefined;
    return getLocalAddressName({
      address,
      chain,
      currentAccountId,
      accounts,
      savedAddresses
    });
  }, [accounts, address, chain, currentAccountId, savedAddresses]);
  const addressName = localAddressName || (metadata === null || metadata === void 0 ? void 0 : metadata.name);
  const dnsIconText = teact_useMemo(() => isDnsOperation ? getDnsIconText(nft) : '', [isDnsOperation, nft]);
  const amountCols = teact_useMemo(() => getPseudoRandomNumber(5, 13, timestamp.toString()), [timestamp]);
  const attachmentsTakeSubheader = shouldAttachmentTakeSubheader(transaction, isFuture);
  const isNoSubheaderLeft = getIsNoSubheaderLeft(transaction, isFuture);
  const titleTense = isFuture || status === 'failed' ? 'future' : 'past';
  let operationColorClass;
  let pendingIndicatorColor = 'Gray';
  if (status === 'failed' || type === 'burn') {
    operationColorClass = Activity_module.colorNegative;
    pendingIndicatorColor = 'Red';
  } else if (isIncoming) {
    operationColorClass = Activity_module.colorIn;
    pendingIndicatorColor = 'Green';
  } else if (type === 'stake') {
    operationColorClass = Activity_module.colorStake;
    pendingIndicatorColor = 'PurpleWhite';
  } else if (OUT_TRANSACTION_TYPES.has(type)) {
    operationColorClass = Activity_module.colorOut;
    pendingIndicatorColor = 'Blue';
  }
  if (status === 'pending') {
    pendingIndicatorColor = 'Orange';
  }
  const handleNftClick = useLastCallback(event => {
    event.stopPropagation();
    void vibrate();
    openNftAttributesModal({
      nft: nft
    });
  });
  function renderNft() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Activity_module.attachment, Activity_module.nft, !doesNftExist && Activity_module.nonInteractive, 'transaction-nft'),
      onClick: doesNftExist ? handleNftClick : undefined,
      "data-nft-address": nft === null || nft === void 0 ? void 0 : nft.address,
      "data-tx-id": id
    }, /*#__PURE__*/teact.createElement("img", {
      src: nft.thumbnail,
      alt: nft.name,
      className: Activity_module.nftImage
    }), /*#__PURE__*/teact.createElement("div", {
      className: Activity_module.nftData
    }, /*#__PURE__*/teact.createElement("div", {
      className: Activity_module.nftName
    }, nft.name), /*#__PURE__*/teact.createElement("div", {
      className: Activity_module.nftCollection
    }, nft.collectionName)));
  }
  function renderComment() {
    const className = buildClassName(Activity_module.attachment, Activity_module.comment, !isIncoming && Activity_module.outgoing, operationColorClass);
    return /*#__PURE__*/teact.createElement("div", {
      className: className
    }, encryptedComment && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Activity_module.commentIcon, 'icon-lock'),
      "aria-hidden": true
    }), encryptedComment ? /*#__PURE__*/teact.createElement("i", null, lang('Encrypted Message')) : comment);
  }
  function renderIcon() {
    let iconName;
    if (isStaking) {
      iconName = 'icon-earn';
    } else if (type === 'callContract' || type === 'contractDeploy') {
      iconName = 'icon-cog';
    } else if (isDnsOperation) {
      iconName = buildClassName('rounded-font', Activity_module.dnsIcon);
    } else if (type === 'mint') {
      iconName = 'icon-magic-wand';
    } else if (type === 'burn') {
      iconName = 'icon-fire';
    } else if (type === 'auctionBid') {
      iconName = 'icon-auction-alt';
    } else if (type === 'nftTrade') {
      iconName = isIncoming ? 'icon-tag' : 'icon-purchase';
    } else if (type === 'liquidityDeposit') {
      iconName = 'icon-can-in';
    } else if (type === 'liquidityWithdraw') {
      iconName = 'icon-can-out';
    } else if (isIncoming) {
      iconName = 'icon-receive-alt';
    } else {
      iconName = 'icon-send-alt';
    }
    return /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Activity_module.icon, iconName, operationColorClass),
      "aria-hidden": true
    }, isDnsOperation && /*#__PURE__*/teact.createElement("span", {
      style: isDnsOperation ? `font-size: ${Math.min(1, 4 / dnsIconText.length) * 100}%` : undefined
    }, dnsIconText), /*#__PURE__*/teact.createElement(Content_ActivityStatusIcon, {
      isPending: status === 'pending' || status === 'pendingTrusted',
      isError: status === 'failed',
      color: pendingIndicatorColor,
      appTheme: appTheme
    }));
  }
  function renderAmount() {
    const amountDisplayMode = getTransactionAmountDisplayMode(transaction);
    const noSign = amountDisplayMode === 'noSign';
    if (amountDisplayMode === 'hide') {
      return;
    }
    return /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: amountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      contentClassName: buildClassName(Activity_module.amount, operationColorClass !== Activity_module.colorOut && operationColorClass)
    }, formatCurrencyExtended((0,util_decimals/* toDecimal */.nI)(noSign ? (0,bigint/* bigintAbs */.wg)(amount) : amount, (token === null || token === void 0 ? void 0 : token.decimals) ?? src_config/* FRACTION_DIGITS */.I04), (token === null || token === void 0 ? void 0 : token.symbol) || src_config/* TONCOIN */.Tu9.symbol, noSign, undefined, !isIncoming), token && /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: token,
      size: "x-small",
      className: Activity_module.amountTokenIcon
    }));
  }
  function renderBaseCurrencyAmount() {
    if (getTransactionAmountDisplayMode(transaction) === 'hide' || !token) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: Math.round(3 + (amountCols - 5) / 3),
      rows: 2,
      cellSize: 8,
      align: "right"
    }, formatBaseCurrencyAmount(amount, baseCurrency, token));
  }
  function renderAddressAndDate() {
    const children = [];
    const delimiter = `${src_config/* WHOLE_PART_DELIMITER */.MS3}âˆ™${src_config/* WHOLE_PART_DELIMITER */.MS3}`;
    if (transaction.status === 'failed') {
      children.push(delimiter, lang('Failed'));
    }
    if (shouldShowTransactionAddress(transaction).includes('list')) {
      const dexName = (extra === null || extra === void 0 ? void 0 : extra.dex) && src_config/* SWAP_DEX_LABELS */.S7e[extra.dex];
      const marketplaceName = (extra === null || extra === void 0 ? void 0 : extra.marketplace) && src_config/* NFT_MARKETPLACE_TITLES */.fSo[extra.marketplace];
      children.push(delimiter, lang(dexName || marketplaceName ? '$transaction_on' : isIncoming ? '$transaction_from' : '$transaction_to', {
        address: /*#__PURE__*/teact.createElement("span", {
          className: Activity_module.subheaderHighlight
        }, withChainIcon && Boolean(chain) && /*#__PURE__*/teact.createElement("i", {
          className: buildClassName(Activity_module.chainIcon, `icon-chain-${chain.toLowerCase()}`),
          "aria-label": chain
        }), dexName || marketplaceName || addressName || (0,shortenAddress/* shortenAddress */.W)(address, src_config/* TRANSACTION_ADDRESS_SHIFT */.bOf))
      }));
    }
    if (shouldShowTransactionAnnualYield(transaction)) {
      children.push(delimiter, lang('at %annual_yield%', {
        annual_yield: /*#__PURE__*/teact.createElement("span", {
          className: Activity_module.subheaderHighlight
        }, yieldType, " ", annualYield, "%")
      }));
    }
    if (!isFuture) {
      children.push(delimiter, (0,dateFormat/* formatTime */.fU)(timestamp));
    }

    // Warning! Keep this function result in sync with `getIsNoSubheaderLeft`
    return /*#__PURE__*/teact.createElement("div", {
      className: Activity_module.date
    }, children.slice(1));
  }
  return /*#__PURE__*/teact.createElement(ui_Button, {
    ref: ref,
    className: buildClassName(Activity_module.item, isLast && Activity_module.itemLast, isActive && Activity_module.active, onClick && Activity_module.interactive, attachmentsTakeSubheader === 'full' ? Activity_module.attachmentsInFullSubheader : attachmentsTakeSubheader === 'left' ? Activity_module.attachmentsInLeftSubheader : undefined),
    onClick: onClick && (() => onClick(id)),
    isSimple: true
  }, renderIcon(), /*#__PURE__*/teact.createElement("div", {
    className: Activity_module.header
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Activity_module.operationName, isNoSubheaderLeft && attachmentsTakeSubheader === 'none' && Activity_module.atMiddle)
  }, getTransactionTitle(transaction, titleTense, lang), isScamTransaction(transaction) && /*#__PURE__*/teact.createElement("img", {
    src: scam_namespaceObject,
    alt: lang('Scam'),
    className: Activity_module.scamImage
  })), renderAmount()), /*#__PURE__*/teact.createElement("div", {
    className: Activity_module.subheader
  }, renderAddressAndDate(), renderBaseCurrencyAmount()), nft && renderNft(), shouldShowTransactionComment(transaction) && renderComment());
}
/* harmony default export */ const Content_Transaction = (memo(Transaction));
function getTransactionHeight(transaction, isFuture) {
  return TRANSACTION_HEIGHT + (transaction.nft ? NFT_EXTRA_HEIGHT : 0) + (shouldShowTransactionComment(transaction) ? COMMENT_EXTRA_HEIGHT : 0) - (shouldAttachmentTakeSubheader(transaction, isFuture) !== 'none' ? SUBHEADER_RELEASE_HEIGHT : 0);
}
function shouldAttachmentTakeSubheader(transaction, isFuture) {
  if (!transaction.nft && !shouldShowTransactionComment(transaction)) {
    return 'none';
  }
  if (!getIsNoSubheaderLeft(transaction, isFuture)) {
    return 'none'; // The attachment won't fit in the right slot, because the left subheader is too wide
  }
  if (getIsNoSubheaderRight(transaction)) {
    return 'full';
  }
  const isAttachmentOnTheLeft = transaction.nft || transaction.isIncoming;
  return isAttachmentOnTheLeft ? 'left' : 'none';
}
function getIsNoSubheaderLeft(transaction, isFuture) {
  return isFuture && transaction.status !== 'failed' && !shouldShowTransactionAddress(transaction).includes('list') && !shouldShowTransactionAnnualYield(transaction);
}
function getIsNoSubheaderRight(transaction) {
  return getTransactionAmountDisplayMode(transaction) === 'hide';
}
function getDnsIconText(nft) {
  if (nft !== null && nft !== void 0 && nft.name) {
    const resolved = getDnsDomainZone(nft.name);
    if (resolved) {
      return `.${resolved.zone.suffixes[0]}`;
    }
  }
  return 'DNS';
}
;// ./src/components/main/sections/Content/Activity.tsx



function Activity(_ref) {
  let {
    activity,
    isLast,
    isActive,
    isSensitiveDataHidden,
    isFuture,
    withChainIcon,
    tokensBySlug,
    swapTokensBySlug,
    appTheme,
    nftsByAddress,
    currentAccountId,
    stakingStateBySlug,
    savedAddresses,
    accounts,
    baseCurrency,
    onClick
  } = _ref;
  if (activity.kind === 'swap') {
    var _accounts$currentAcco;
    return /*#__PURE__*/teact.createElement(Content_Swap, {
      activity: activity,
      tokensBySlug: swapTokensBySlug,
      isLast: isLast,
      isActive: isActive,
      appTheme: appTheme,
      addressByChain: accounts === null || accounts === void 0 || (_accounts$currentAcco = accounts[currentAccountId]) === null || _accounts$currentAcco === void 0 ? void 0 : _accounts$currentAcco.addressByChain,
      isSensitiveDataHidden: isSensitiveDataHidden,
      isFuture: isFuture,
      onClick: onClick
    });
  } else {
    const doesNftExist = Boolean(activity.nft && (nftsByAddress === null || nftsByAddress === void 0 ? void 0 : nftsByAddress[activity.nft.address]));
    const {
      annualYield,
      yieldType
    } = stakingStateBySlug[activity.slug] ?? {};
    return /*#__PURE__*/teact.createElement(Content_Transaction, {
      currentAccountId: currentAccountId,
      transaction: activity,
      tokensBySlug: tokensBySlug,
      isActive: isActive,
      annualYield: annualYield,
      yieldType: yieldType,
      isLast: isLast,
      savedAddresses: savedAddresses,
      withChainIcon: withChainIcon,
      appTheme: appTheme,
      doesNftExist: doesNftExist,
      isSensitiveDataHidden: isSensitiveDataHidden,
      isFuture: isFuture,
      accounts: accounts,
      baseCurrency: baseCurrency,
      onClick: onClick
    });
  }
}
function getActivityHeight(activity, isFuture) {
  return activity.kind === 'swap' ? getSwapHeight() : getTransactionHeight(activity, isFuture);
}
;// ./src/components/dapps/DappLedgerWarning.tsx














function DappLedgerWarning(_ref) {
  let {
    currentAccount,
    toncoinBalance,
    dapp
  } = _ref;
  const {
    cancelDappTransfer,
    setDappTransferScreen
  } = getActions();
  const lang = hooks_useLang();
  const handleAgree = useLastCallback(() => {
    setDappTransferScreen({
      state: TransferState.Initial
    });
  });
  function renderDapp() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.transactionDirection
    }, /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.transactionAccount
    }, /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.accountTitle
    }, currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.title), /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.accountBalance
    }, formatCurrency((0,util_decimals/* toDecimal */.nI)(toncoinBalance), src_config/* TONCOIN */.Tu9.symbol))), /*#__PURE__*/teact.createElement(dapps_DappInfo, {
      dapp: dapp,
      className: Dapp_module.transactionDapp
    }));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContent
  }, renderDapp(), /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.descriptionContent
  }, /*#__PURE__*/teact.createElement("span", null, renderText(lang('$dapp_ledger_warning1'))), /*#__PURE__*/teact.createElement("span", null, renderText(lang('$dapp_ledger_warning2')))), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Modal_module.button,
    onClick: cancelDappTransfer
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isSubmit: true,
    className: Modal_module.button,
    onClick: handleAgree
  }, lang('Agree'))));
}
/* harmony default export */ const dapps_DappLedgerWarning = (memo(withGlobal(global => {
  const {
    dapp
  } = global.currentDappTransfer;
  const accounts = selectNetworkAccounts(global);
  return {
    currentAccount: accounts === null || accounts === void 0 ? void 0 : accounts[global.currentAccountId],
    toncoinBalance: selectCurrentToncoinBalance(global),
    dapp
  };
})(DappLedgerWarning)));
;// ./src/components/transfer/NftInfo.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const NftInfo_module = ({"root":"NftInfo-module__root","icon":"NftInfo-module__icon","interactive":"NftInfo-module__interactive","rootStatic":"NftInfo-module__rootStatic","thumbnail":"NftInfo-module__thumbnail","info":"NftInfo-module__info","title":"NftInfo-module__title","description":"NftInfo-module__description"});
;// ./src/components/transfer/NftInfo.tsx













function NftInfo(_ref) {
  let {
    nft,
    isStatic,
    withTonExplorer,
    withMediaViewer
  } = _ref;
  const {
    openMediaViewer
  } = getActions();
  const lang = hooks_useLang();
  const tonExplorerTitle = teact_useMemo(() => {
    return lang('Open on %ton_explorer_name%', {
      ton_explorer_name: getExplorerName('ton')
    }).join('');
  }, [lang]);
  const handleClickInfo = event => {
    event.stopPropagation();
    const url = getExplorerNftUrl(nft.address, getGlobal().settings.isTestnet);
    void openUrl(url);
  };
  const handleClick = useLastCallback(() => {
    openMediaViewer({
      mediaId: nft.address,
      mediaType: MediaType.Nft
    });
  });
  if (!nft) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(NftInfo_module.root, isStatic && NftInfo_module.rootStatic)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: true,
      noLoop: false,
      nonInteractive: true,
      size: src_config/* ANIMATED_STICKER_TINY_SIZE_PX */.YO8,
      className: NftInfo_module.thumbnail,
      tgsUrl: ANIMATED_STICKERS_PATHS.wait,
      previewUrl: ANIMATED_STICKERS_PATHS.waitPreview
    }), /*#__PURE__*/teact.createElement("div", {
      className: NftInfo_module.info
    }, /*#__PURE__*/teact.createElement("div", {
      className: NftInfo_module.title
    }, "NFT"), /*#__PURE__*/teact.createElement("div", {
      className: NftInfo_module.description
    }, lang('Name and collection are not available. Please check back later.'))));
  }
  const name = nft.name || (0,shortenAddress/* shortenAddress */.W)(nft.address);
  function renderContent() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("img", {
      src: nft.thumbnail,
      alt: name,
      className: NftInfo_module.thumbnail
    }), /*#__PURE__*/teact.createElement("div", {
      className: NftInfo_module.info
    }, /*#__PURE__*/teact.createElement("div", {
      className: NftInfo_module.title
    }, name, withTonExplorer && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(NftInfo_module.icon, 'icon-tonexplorer-small'),
      onClick: handleClickInfo,
      title: tonExplorerTitle,
      "aria-label": tonExplorerTitle,
      role: "button",
      tabIndex: 0
    })), /*#__PURE__*/teact.createElement("div", {
      className: NftInfo_module.description
    }, nft.collectionName)));
  }
  if (!withMediaViewer) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(NftInfo_module.root, isStatic && NftInfo_module.rootStatic)
    }, renderContent());
  }
  return /*#__PURE__*/teact.createElement("div", {
    role: "button",
    tabIndex: 0,
    "aria-label": lang('NFT'),
    className: buildClassName(NftInfo_module.root, NftInfo_module.interactive, isStatic && NftInfo_module.rootStatic),
    onClick: handleClick
  }, renderContent());
}
/* harmony default export */ const transfer_NftInfo = (memo(NftInfo));
;// ./src/hooks/useLongPress.ts


const DEFAULT_THRESHOLD = 350;
function useLongPress(_ref) {
  let {
    onClick,
    onStart,
    onEnd,
    threshold = DEFAULT_THRESHOLD
  } = _ref;
  const isLongPressActive = teact_useRef(false);
  const isPressed = teact_useRef(false);
  const timerId = teact_useRef(undefined);
  const start = teact_useCallback(e => {
    const canProcessEvent = 'button' in e && e.button === 0 || 'touches' in e && e.touches.length > 0;
    if (isPressed.current || !canProcessEvent) {
      return;
    }
    isPressed.current = true;
    timerId.current = window.setTimeout(() => {
      onStart === null || onStart === void 0 || onStart();
      isLongPressActive.current = true;
    }, threshold);
  }, [onStart, threshold]);
  const cancel = teact_useCallback(e => {
    if (!isPressed.current) return;
    if (isLongPressActive.current) {
      onEnd === null || onEnd === void 0 || onEnd();
    } else {
      onClick === null || onClick === void 0 || onClick(e);
    }
    isLongPressActive.current = false;
    isPressed.current = false;
    window.clearTimeout(timerId.current);
  }, [onEnd, onClick]);
  hooks_useEffectOnce(() => {
    return () => {
      window.clearTimeout(timerId.current);
    };
  });
  return {
    onMouseDown: start,
    onMouseUp: cancel,
    onMouseLeave: cancel,
    onTouchStart: start,
    onTouchEnd: cancel,
    onTouchCancel: cancel
  };
}
/* harmony default export */ const hooks_useLongPress = (useLongPress);
;// ./src/components/main/modals/DeleteSavedAddressModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const DeleteSavedAddressModal_module = ({"text":"DeleteSavedAddressModal-module__text"});
;// ./src/components/main/modals/DeleteSavedAddressModal.tsx








function DeleteSavedAddressModal(_ref) {
  let {
    isOpen,
    address,
    chain,
    onClose
  } = _ref;
  const {
    removeFromSavedAddress,
    showNotification
  } = getActions();
  const lang = hooks_useLang();
  const handleDeleteSavedAddress = useLastCallback(() => {
    removeFromSavedAddress({
      address: address,
      chain: chain
    });
    showNotification({
      message: lang('Address removed from saved'),
      icon: 'icon-trash'
    });
    onClose();
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    title: lang('Delete Saved Address'),
    isCompact: true,
    isOpen: isOpen,
    onClose: onClose
  }, /*#__PURE__*/teact.createElement("p", {
    className: DeleteSavedAddressModal_module.text
  }, lang('Are you sure you want to remove this address from your saved ones?')), /*#__PURE__*/teact.createElement("p", {
    className: DeleteSavedAddressModal_module.text
  }, lang('You will be able to save it again via Transaction Info with this address.')), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    className: Modal_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    onClick: handleDeleteSavedAddress,
    className: Modal_module.button
  }, lang('Delete'))));
}
/* harmony default export */ const modals_DeleteSavedAddressModal = (memo(DeleteSavedAddressModal));
;// ./src/components/ui/MenuBackdrop.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuBackdrop_module = ({"backdrop":"MenuBackdrop-module__backdrop","visible":"MenuBackdrop-module__visible","wrapperVisible":"MenuBackdrop-module__wrapperVisible","wrapperHide":"MenuBackdrop-module__wrapperHide"});
;// ./src/components/ui/MenuBackdrop.tsx






function MenuBackdrop(_ref) {
  let {
    isMenuOpen,
    contentRef,
    contentClassName
  } = _ref;
  const {
    shouldRender: menuBackdropShouldRender,
    ref: menuBackdropRef
  } = useShowTransition({
    isOpen: isMenuOpen,
    withShouldRender: true
  });
  useLayoutEffect(() => {
    if (!contentRef.current) return;
    toggleExtraClass(contentRef.current, MenuBackdrop_module.wrapperVisible, menuBackdropShouldRender);
    toggleExtraClass(contentRef.current, MenuBackdrop_module.wrapperHide, menuBackdropShouldRender && !isMenuOpen);
    if (contentClassName) {
      toggleExtraClass(contentRef.current, contentClassName, menuBackdropShouldRender);
    }
  }, [contentClassName, contentRef, isMenuOpen, menuBackdropShouldRender]);
  useToggleClass({
    className: 'with-menu-backdrop',
    isActive: isMenuOpen
  });
  if (!menuBackdropShouldRender) return undefined;
  return /*#__PURE__*/teact.createElement("div", {
    ref: menuBackdropRef,
    className: buildClassName(MenuBackdrop_module.backdrop, isMenuOpen && MenuBackdrop_module.visible)
  });
}
/* harmony default export */ const ui_MenuBackdrop = (memo(MenuBackdrop));
;// ./src/components/ui/InteractiveTextField.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const InteractiveTextField_module = ({"wrapper":"InteractiveTextField-module__wrapper","button":"InteractiveTextField-module__button","button_spoiler":"InteractiveTextField-module__button_spoiler","buttonSpoiler":"InteractiveTextField-module__button_spoiler","icon":"InteractiveTextField-module__icon","iconCaretDown":"InteractiveTextField-module__iconCaretDown","iconStar":"InteractiveTextField-module__iconStar","iconShare":"InteractiveTextField-module__iconShare","nameInput":"InteractiveTextField-module__nameInput","shortAddress":"InteractiveTextField-module__shortAddress","scam":"InteractiveTextField-module__scam","revealSpoiler":"InteractiveTextField-module__revealSpoiler","scamImage":"InteractiveTextField-module__scamImage","chainIcon":"InteractiveTextField-module__chainIcon","meaningfulPart":"InteractiveTextField-module__meaningfulPart","menuIcon":"InteractiveTextField-module__menuIcon","dimmedPart":"InteractiveTextField-module__dimmedPart","menu":"InteractiveTextField-module__menu","menuItem":"InteractiveTextField-module__menuItem"});
;// ./src/components/ui/InteractiveTextField.tsx
function InteractiveTextField_extends() { return InteractiveTextField_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, InteractiveTextField_extends.apply(null, arguments); }




























const SAVED_ADDRESS_NAME_MAX_LENGTH = 255;
const MENU_VERTICAL_OFFSET_PX = -16;
const MENU_ITEM_HEIGHT_PX = 3 * windowEnvironment/* REM */.$;
const COMFORT_MARGIN_PX = windowEnvironment/* REM */.$;
function InteractiveTextField(_ref) {
  let {
    chain,
    address,
    addressName,
    addressUrl,
    isScam,
    isTransaction,
    text = '',
    spoiler,
    spoilerRevealText,
    spoilerCallback,
    copyNotification,
    noSavedAddress,
    noExplorer,
    className,
    textClassName,
    savedAddresses,
    isTestnet,
    isMultichainAccount,
    noDimming,
    withShareInMenu
  } = _ref;
  const {
    showNotification,
    addSavedAddress
  } = getActions();
  const addressNameRef = teact_useRef();
  const contentRef = teact_useRef();
  const menuRef = teact_useRef();
  const lang = hooks_useLang();
  const [isSaveAddressModalOpen, openSaveAddressModal, closeSaveAddressModal] = hooks_useFlag();
  const [isDeleteSavedAddressModalOpen, openDeletedSavedAddressModal, closeDeleteSavedAddressModal] = hooks_useFlag();
  const [savedAddressName, setSavedAddressName] = useState(addressName);
  const [isConcealedWithSpoiler,, revealSpoiler] = hooks_useFlag(Boolean(spoiler));
  const isAddressAlreadySaved = teact_useMemo(() => {
    return Boolean(address && chain && (savedAddresses || []).find(savedAddress => {
      return savedAddress.address === address && savedAddress.chain === chain;
    }));
  }, [address, chain, savedAddresses]);
  addressUrl = addressUrl ?? (chain ? getExplorerAddressUrl(chain, address, isTestnet) : undefined);
  const saveAddressTitle = lang(isAddressAlreadySaved ? 'Remove From Saved' : 'Save Address');
  const explorerTitle = lang('View on Explorer');
  const withSavedAddresses = Boolean(!isScam && !noSavedAddress && address);
  const withExplorer = Boolean(!noExplorer && addressUrl);
  teact_useEffect(() => {
    if (isSaveAddressModalOpen) {
      setSavedAddressName('');
    }
  }, [isSaveAddressModalOpen]);
  const handleSaveAddressSubmit = useLastCallback(() => {
    if (!savedAddressName || !address || !chain) {
      return;
    }
    addSavedAddress({
      address,
      chain,
      name: savedAddressName
    });
    showNotification({
      message: lang('Address was saved!'),
      icon: 'icon-star'
    });
    closeSaveAddressModal();
  });
  teact_useEffect(() => isSaveAddressModalOpen ? captureKeyboardListeners({
    onEnter: handleSaveAddressSubmit
  }) : undefined, [handleSaveAddressSubmit, isSaveAddressModalOpen]);
  useFocusAfterAnimation(addressNameRef, !isSaveAddressModalOpen);
  const handleCopy = useLastCallback(() => {
    if (!copyNotification) return;
    showNotification({
      message: copyNotification,
      icon: 'icon-copy'
    });
    void copyTextToClipboard(address || text);
  });
  const handleShare = useLastCallback(() => {
    void shareUrl(addressUrl, chain ? getExplorerName(chain) : undefined);
  });
  const handleTonExplorerOpen = useLastCallback(() => {
    void openUrl(addressUrl, {
      title: getExplorerName(chain),
      subtitle: getHostnameFromUrl(addressUrl)
    });
  });
  const {
    isActionsMenuOpen,
    menuAnchor,
    menuPositionY,
    menuItems,
    handleMenuShow,
    handleMenuItemSelect,
    closeActionsMenu
  } = useDropdownMenu({
    copy: handleCopy,
    share: handleShare,
    addressBook: isAddressAlreadySaved ? openDeletedSavedAddressModal : openSaveAddressModal,
    explorer: handleTonExplorerOpen
  }, {
    isAddressAlreadySaved,
    isWalletAddress: Boolean(address && chain && noSavedAddress && !isTransaction),
    isTransaction,
    withSavedAddresses,
    withExplorer,
    withShare: withShareInMenu
  });
  const shouldUseMenu = !spoiler && windowEnvironment/* IS_TOUCH_ENV */.TF && menuItems.length > 1;
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true,
    preferredPositionY: menuPositionY
  }));
  const longPressHandlers = hooks_useLongPress({
    onClick: handleMenuShow,
    onStart: handleCopy
  });
  const handleRevealSpoiler = useLastCallback(() => {
    revealSpoiler();
    spoilerCallback === null || spoilerCallback === void 0 || spoilerCallback();
  });
  function renderContentOrSpoiler() {
    const content = addressName || address || text;
    if (!spoiler) {
      return renderContent(content);
    }
    const isConcealed = isConcealedWithSpoiler || !content;
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      activeKey: isConcealed ? 1 : 0,
      name: "fade",
      className: InteractiveTextField_module.commentContainer
    }, isConcealed ? /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(InteractiveTextField_module.button, InteractiveTextField_module.button_spoiler, textClassName)
    }, /*#__PURE__*/teact.createElement("i", null, spoiler), ' ', /*#__PURE__*/teact.createElement("span", {
      onClick: handleRevealSpoiler,
      tabIndex: 0,
      role: "button",
      className: InteractiveTextField_module.revealSpoiler
    }, spoilerRevealText)) : renderContent(content));
  }
  function renderContent(content) {
    let renderedContent = content;
    if (!noDimming && !isTransaction && content === address && content.length > shortenAddress/* MEANINGFUL_CHAR_LENGTH */.V * 2) {
      const prefix = content.substring(0, shortenAddress/* MEANINGFUL_CHAR_LENGTH */.V);
      const suffixStart = content.length - shortenAddress/* MEANINGFUL_CHAR_LENGTH */.V;
      const middle = content.substring(shortenAddress/* MEANINGFUL_CHAR_LENGTH */.V, suffixStart);
      const suffix = content.substring(suffixStart);
      renderedContent = /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
        className: InteractiveTextField_module.meaningfulPart
      }, prefix), /*#__PURE__*/teact.createElement("span", {
        className: InteractiveTextField_module.dimmedPart
      }, middle), /*#__PURE__*/teact.createElement("span", {
        className: InteractiveTextField_module.meaningfulPart
      }, suffix));
    } else if (!noDimming && isTransaction) {
      renderedContent = /*#__PURE__*/teact.createElement("span", {
        className: InteractiveTextField_module.dimmedPart
      }, content);
    }
    return /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(InteractiveTextField_module.button, isScam && InteractiveTextField_module.scam, textClassName),
      tabIndex: 0,
      role: "button",
      title: !shouldUseMenu ? lang('Copy') : undefined,
      onClick: !shouldUseMenu ? handleCopy : undefined
    }, isScam && /*#__PURE__*/teact.createElement("img", {
      src: scam_namespaceObject,
      alt: lang('Scam'),
      className: InteractiveTextField_module.scamImage
    }), isMultichainAccount && !isTransaction && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(InteractiveTextField_module.chainIcon, `icon-chain-${chain}`),
      "aria-label": chain
    }), renderedContent, Boolean(addressName) && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(InteractiveTextField_module.shortAddress, isScam && InteractiveTextField_module.scam)
    }, (0,shortenAddress/* shortenAddress */.W)(address)), Boolean(copyNotification) && !shouldUseMenu && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(InteractiveTextField_module.icon, 'icon-copy'),
      "aria-hidden": true
    }));
  }
  function renderActions() {
    if (shouldUseMenu) {
      const iconClassName = buildClassName(InteractiveTextField_module.icon, InteractiveTextField_module.iconCaretDown, 'icon-caret-down', isScam && InteractiveTextField_module.scam);
      return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("i", {
        className: iconClassName,
        "aria-hidden": true
      }), /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
        ref: menuRef,
        withPortal: true,
        shouldTranslateOptions: true,
        isOpen: isActionsMenuOpen,
        items: menuItems,
        menuPositionY: menuPositionY,
        menuAnchor: menuAnchor,
        getLayout: getLayout,
        getMenuElement: getMenuElement,
        getRootElement: getRootElement,
        bubbleClassName: InteractiveTextField_module.menu,
        buttonClassName: InteractiveTextField_module.menuItem,
        fontIconClassName: InteractiveTextField_module.menuIcon,
        onSelect: handleMenuItemSelect,
        onClose: closeActionsMenu
      }));
    }
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, withSavedAddresses && /*#__PURE__*/teact.createElement("span", {
      className: InteractiveTextField_module.button,
      title: saveAddressTitle,
      "aria-label": saveAddressTitle,
      tabIndex: 0,
      role: "button",
      onClick: isAddressAlreadySaved ? openDeletedSavedAddressModal : openSaveAddressModal
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(InteractiveTextField_module.icon, InteractiveTextField_module.iconStar, isAddressAlreadySaved ? 'icon-star-filled' : 'icon-star'),
      "aria-hidden": true
    })), isTransaction && /*#__PURE__*/teact.createElement("span", {
      className: InteractiveTextField_module.button,
      title: lang('Share Link'),
      "aria-label": lang('Share Link'),
      onClick: handleShare
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(InteractiveTextField_module.icon, InteractiveTextField_module.iconShare, 'icon-link'),
      "aria-hidden": true
    })), withExplorer && /*#__PURE__*/teact.createElement("a", {
      href: addressUrl,
      className: InteractiveTextField_module.button,
      title: explorerTitle,
      "aria-label": explorerTitle,
      target: "_blank",
      rel: "noreferrer noopener",
      onClick: handleUrlClick
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(InteractiveTextField_module.icon, 'icon-tonexplorer-small'),
      "aria-hidden": true
    })));
  }
  function renderSaveAddressModal() {
    return /*#__PURE__*/teact.createElement(ui_Modal, {
      title: lang('Save Address'),
      isCompact: true,
      isOpen: isSaveAddressModalOpen,
      onClose: closeSaveAddressModal
    }, /*#__PURE__*/teact.createElement("p", null, lang('You can save this address for quick access while sending.')), /*#__PURE__*/teact.createElement(ui_Input, {
      ref: addressNameRef,
      placeholder: lang('Name'),
      onInput: setSavedAddressName,
      value: savedAddressName,
      maxLength: SAVED_ADDRESS_NAME_MAX_LENGTH,
      className: InteractiveTextField_module.nameInput
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: closeSaveAddressModal,
      className: Modal_module.button
    }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleSaveAddressSubmit,
      isPrimary: true,
      isDisabled: !savedAddressName,
      className: Modal_module.button
    }, lang('Save'))));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_MenuBackdrop, {
    isMenuOpen: isActionsMenuOpen && shouldUseMenu,
    contentRef: contentRef
  }), /*#__PURE__*/teact.createElement("div", InteractiveTextField_extends({
    ref: contentRef,
    className: buildClassName(InteractiveTextField_module.wrapper, className)
  }, shouldUseMenu && !isActionsMenuOpen && {
    ...longPressHandlers,
    tabIndex: 0,
    role: 'button'
  }, {
    onContextMenu: shouldUseMenu ? stopEvent : undefined
  }), renderContentOrSpoiler(), renderActions()), address && /*#__PURE__*/teact.createElement(teact.Fragment, null, renderSaveAddressModal(), /*#__PURE__*/teact.createElement(modals_DeleteSavedAddressModal, {
    isOpen: isDeleteSavedAddressModalOpen,
    address: address,
    chain: chain,
    onClose: closeDeleteSavedAddressModal
  })));
}
/* harmony default export */ const ui_InteractiveTextField = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  return {
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    isTestnet: global.settings.isTestnet
  };
})(InteractiveTextField)));
function useDropdownMenu(menuHandlers, options) {
  const [menuPositionY, setMenuPositionY] = useState('top');
  const [menuAnchor, setMenuAnchor] = useState();
  const closeActionsMenu = useLastCallback(() => setMenuAnchor(undefined));
  const isActionsMenuOpen = Boolean(menuAnchor);
  const menuItems = teact_useMemo(() => {
    const {
      isAddressAlreadySaved,
      isWalletAddress,
      isTransaction,
      withSavedAddresses,
      withExplorer,
      withShare
    } = options;
    const items = [{
      name: withSavedAddresses || isWalletAddress ? 'Copy Address' : isTransaction ? 'Copy Transaction ID' : 'Copy',
      fontIcon: 'copy',
      value: 'copy'
    }];
    if (withSavedAddresses) {
      items.push({
        name: isAddressAlreadySaved ? 'Remove From Saved' : 'Save Address',
        fontIcon: isAddressAlreadySaved ? 'star-filled' : 'star',
        value: 'addressBook'
      });
    }
    if (isTransaction || withShare) {
      items.push({
        name: 'Share Link',
        fontIcon: windowEnvironment/* IS_IOS */.pz ? 'share-ios' : 'share-android',
        value: 'share'
      });
    }
    if (withExplorer) {
      items.push({
        name: 'View on Explorer',
        fontIcon: 'tonexplorer',
        value: 'explorer'
      });
    }
    return items;
  }, [options]);
  const handleMenuItemSelect = useLastCallback(value => {
    var _menuHandlers$value;
    (_menuHandlers$value = menuHandlers[value]) === null || _menuHandlers$value === void 0 || _menuHandlers$value.call(menuHandlers);
    closeActionsMenu();
  });
  const handleMenuShow = useLastCallback(e => {
    stopEvent(e);
    let x;
    if (e.type.startsWith('touch')) {
      const {
        changedTouches,
        touches
      } = e;
      if (touches.length > 0) {
        x = touches[0].clientX;
      } else {
        x = changedTouches[0].clientX;
      }
    } else {
      x = e.clientX;
    }
    const {
      top,
      bottom
    } = e.currentTarget.getBoundingClientRect();
    const menuHeight = menuItems.length * MENU_ITEM_HEIGHT_PX;
    const screenHeight = windowSize.get().height;
    if (bottom + menuHeight + MENU_VERTICAL_OFFSET_PX + COMFORT_MARGIN_PX >= screenHeight) {
      setMenuPositionY('bottom');
      setMenuAnchor({
        x,
        y: top
      });
    } else {
      setMenuPositionY('top');
      setMenuAnchor({
        x,
        y: bottom + MENU_VERTICAL_OFFSET_PX
      });
    }
  });
  return {
    isActionsMenuOpen,
    menuAnchor,
    menuPositionY,
    menuItems,
    handleMenuShow,
    handleMenuItemSelect,
    closeActionsMenu
  };
}
;// ./src/components/dapps/DappAmountField.tsx








function DappAmountField(_ref) {
  let {
    label,
    amountsBySlug,
    nftCount,
    tokensBySlug,
    baseCurrency
  } = _ref;
  const amountTerms = [];
  if (nftCount) {
    amountTerms.push(/*#__PURE__*/teact.createElement("span", {
      className: Dapp_module.payloadFieldTerm
    }, `${nftCount} NFT${nftCount > 1 ? 's' : ''}`));
  }
  for (const [tokenSlug, amount] of Object.entries(amountsBySlug)) {
    if (amountTerms.length) {
      amountTerms.push(' + ');
    }
    const token = tokensBySlug[tokenSlug] ?? src_config/* UNKNOWN_TOKEN */.Bx3;
    amountTerms.push(/*#__PURE__*/teact.createElement("span", {
      className: Dapp_module.payloadFieldTerm
    }, formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, token.decimals), token.symbol)));
  }
  if (!isEmptyObject(amountsBySlug)) {
    const totalCost = getTotalCost(amountsBySlug, tokensBySlug);
    amountTerms.push(` (${formatCurrency(totalCost, getShortCurrencySymbol(baseCurrency))})`);
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
    className: Dapp_module.label
  }, label), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Dapp_module.payloadField, Dapp_module.payloadField_expanded)
  }, amountTerms));
}
/* harmony default export */ const dapps_DappAmountField = (memo(withGlobal(global => {
  return {
    tokensBySlug: global.tokenInfo.bySlug,
    baseCurrency: global.settings.baseCurrency
  };
})(DappAmountField)));
function getTotalCost(amountsBySlug, tokensBySlug) {
  return Object.entries(amountsBySlug).reduce((sum, _ref2) => {
    let [tokenSlug, amount] = _ref2;
    const token = tokensBySlug[tokenSlug];
    if (!token) {
      return sum;
    }
    return sum + (0,util_decimals/* toBig */.CF)(amount, token.decimals).toNumber() * token.price;
  }, 0);
}
;// ./src/components/dapps/DappTransactionPayload.tsx











const FRACTION_DIGITS = 2;
function DappTransactionPayload(_ref) {
  let {
    transaction,
    tokensBySlug
  } = _ref;
  const lang = hooks_useLang();
  const payloadRef = teact_useRef();
  const [isPayloadExpanded, expandPayload] = hooks_useFlag(false);
  teact_useEffect(() => {
    const payloadElement = payloadRef.current;
    if (payloadElement && payloadElement.scrollWidth <= payloadElement.clientWidth) {
      expandPayload();
    }
  }, [expandPayload]);
  function renderPayload() {
    const {
      payload,
      rawPayload
    } = transaction;
    if (!payload || isNftTransferPayload(payload) || isTokenTransferPayload(payload)) {
      return undefined;
    }
    switch (payload.type) {
      case 'comment':
        return payload.comment;
      case 'tokens:burn':
        {
          const {
            slug: tokenSlug,
            amount
          } = payload;
          const token = tokensBySlug[tokenSlug];
          const decimals = (token === null || token === void 0 ? void 0 : token.decimals) ?? constants/* DEFAULT_DECIMALS */.fI;
          const symbol = (token === null || token === void 0 ? void 0 : token.symbol) ?? '';
          return lang('$dapp_transfer_tokens_burn', {
            amount: formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, decimals), symbol, FRACTION_DIGITS)
          });
        }
      case 'dns:change-record':
        {
          const {
            record
          } = payload;
          const category = record.type !== 'unknown' ? record.type : record.key;
          if (record.type === 'wallet' && record.value) {
            return lang('$dapp_dns_set_wallet_payload', {
              address: record.value
            });
          } else if (record.type === 'wallet' && !record.value) {
            return lang('$dapp_dns_delete_wallet_payload');
          } else if (record.value) {
            return lang('$dapp_dns_change_record_payload', {
              category,
              value: record.value
            });
          } else {
            return lang('$dapp_dns_delete_record_payload', {
              category
            });
          }
        }
      case 'token-bridge:pay-swap':
        {
          return lang('$dapp_token_bridge_pay_swap_payload', {
            swapId: payload.swapId
          });
        }
      case 'liquid-staking:deposit':
        {
          return lang('$dapp_liquid_staking_deposit_payload');
        }
      case 'liquid-staking:vote':
        {
          return lang('$dapp_liquid_staking_vote_payload', {
            votingAddress: payload.votingAddress,
            vote: payload.vote
          });
        }
      case 'single-nominator:change-validator':
        {
          return lang('$dapp_single_nominator_change_validator_payload', {
            address: payload.address
          });
        }
      case 'single-nominator:withdraw':
        {
          return lang('$dapp_single_nominator_withdraw_payload', {
            amount: (0,util_decimals/* toDecimal */.nI)(payload.amount)
          });
        }
      case 'vesting:add-whitelist':
        {
          return lang('$dapp_vesting_add_whitelist_payload', {
            address: payload.address
          });
        }
      case 'unknown':
        {
          return rawPayload;
        }
      default:
        return JSON.stringify(payload, undefined, 2).replace(`/"${bigint/* BIGINT_PREFIX */.tH}/g`, '"');
    }
  }
  function renderPayloadLabel() {
    var _transaction$payload;
    switch ((_transaction$payload = transaction.payload) === null || _transaction$payload === void 0 ? void 0 : _transaction$payload.type) {
      case 'comment':
        return lang('Comment');
      case 'unknown':
        return lang('Payload');
      default:
        return lang('Nested Transaction');
    }
  }
  const payloadElement = renderPayload();
  if (!payloadElement) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: Dapp_module.label
  }, renderPayloadLabel()), /*#__PURE__*/teact.createElement("div", {
    ref: payloadRef,
    className: buildClassName(Dapp_module.payloadField, isPayloadExpanded && Dapp_module.payloadField_expanded)
  }, payloadElement, !isPayloadExpanded && /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.payloadFieldExpand,
    onClick: expandPayload
  }, lang('View'))), transaction.isDangerous && /*#__PURE__*/teact.createElement("div", {
    className: Dapp_module.warningForPayload
  }, renderText(lang('$hardware_payload_warning'))));
}
/* harmony default export */ const dapps_DappTransactionPayload = (memo(DappTransactionPayload));
;// ./src/components/dapps/DappTransaction.tsx














function DappTransaction(_ref) {
  let {
    transaction,
    tokensBySlug,
    isActive,
    onClose,
    onBack
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Transaction Info'),
    onBackButtonClick: onBack,
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.transitionContent, Dapp_module.transactionContent)
  }, transaction && /*#__PURE__*/teact.createElement(DappTransactionContent, {
    transaction: transaction,
    tokensBySlug: tokensBySlug
  })));
}
/* harmony default export */ const dapps_DappTransaction = (memo(DappTransaction));
function DappTransactionContent(_ref2) {
  let {
    transaction,
    tokensBySlug
  } = _ref2;
  const lang = hooks_useLang();
  const amountBySlug = teact_useMemo(() => {
    const {
      amount: tonAmount,
      payload
    } = transaction;
    const amountBySlug = {};
    if (isTokenTransferPayload(payload)) {
      amountBySlug[payload.slug] = payload.amount;
    }
    if (tonAmount !== 0n || !isNftTransferPayload(payload) && isEmptyObject(amountBySlug)) {
      amountBySlug[src_config/* TONCOIN */.Tu9.slug] = tonAmount;
    }
    return amountBySlug;
  }, [transaction]);
  const feeBySlug = teact_useMemo(() => ({
    [src_config/* TONCOIN */.Tu9.slug]: transaction.networkFee
  }), [transaction.networkFee]);
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, isNftTransferPayload(transaction.payload) && /*#__PURE__*/teact.createElement(transfer_NftInfo, {
    nft: transaction.payload.nft
  }), /*#__PURE__*/teact.createElement("p", {
    className: Dapp_module.label
  }, lang('Receiving Address')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
    chain: src_config/* TONCOIN */.Tu9.chain,
    address: transaction.displayedToAddress,
    isScam: transaction.isScam,
    className: buildClassName(Dapp_module.dataField, Dapp_module.receivingAddress),
    copyNotification: lang('Address was copied!')
  }), !isEmptyObject(amountBySlug) && /*#__PURE__*/teact.createElement(dapps_DappAmountField, {
    label: isNftTransferPayload(transaction.payload) ? lang('Additional Amount Sent') : lang('Amount'),
    amountsBySlug: amountBySlug
  }), /*#__PURE__*/teact.createElement(dapps_DappAmountField, {
    label: lang('Fee'),
    amountsBySlug: feeBySlug
  }), /*#__PURE__*/teact.createElement(dapps_DappTransactionPayload, {
    transaction: transaction,
    tokensBySlug: tokensBySlug
  }));
}
;// ./src/components/ui/Fee.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Fee_module = ({"term":"Fee-module__term","tokenIcon":"Fee-module__tokenIcon"});
;// ./src/components/ui/Fee.tsx








const TERM_SEPARATOR = ' + ';
const PRECISION_PREFIX = {
  exact: '',
  approximate: '~\u202F',
  lessThan: '<\u202F'
};
const STARS_TOKEN = {
  slug: '__stars__',
  symbol: src_config/* STARS_SYMBOL */.xFF,
  decimals: 0
};
const UNKNOWN_TOKEN = {
  slug: '__unknown__',
  symbol: '',
  decimals: 0
};
const TOKEN_ICONS = {
  [src_config/* TONCOIN */.Tu9.slug]: 'icon-chain-ton',
  [src_config/* TRX */.X7T.slug]: 'icon-chain-tron'
};
/**
 * Formats a complex fee (containing multiple terms) into a human-readable span
 */
function Fee(_ref) {
  var _findChainConfig;
  let {
    terms,
    token,
    precision,
    shouldPreferIcons,
    termClassName,
    symbolClassName
  } = _ref;
  const nativeToken = ((_findChainConfig = findChainConfig(getChainBySlug(token.slug))) === null || _findChainConfig === void 0 ? void 0 : _findChainConfig.nativeToken) ?? UNKNOWN_TOKEN;
  const content = [PRECISION_PREFIX[precision]];
  convertTermsObjectToList(terms).forEach((_ref2, index) => {
    let {
      tokenType,
      amount
    } = _ref2;
    if (index > 0) {
      content.push(TERM_SEPARATOR);
    }
    const currentToken = tokenType === 'stars' ? STARS_TOKEN : tokenType === 'native' ? nativeToken : token;
    const icon = shouldPreferIcons ? TOKEN_ICONS[currentToken.slug] : undefined;
    if (typeof amount === 'bigint') {
      amount = (0,util_decimals/* toDecimal */.nI)(amount, currentToken.decimals);
    }
    let symbolNode = icon ? /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(icon, Fee_module.tokenIcon),
      "aria-label": currentToken.symbol
    }) : currentToken.symbol;
    if (symbolClassName) {
      symbolNode = /*#__PURE__*/teact.createElement("span", {
        className: symbolClassName
      }, symbolNode);
    }
    content.push(/*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Fee_module.term, termClassName)
    }, formatCurrency(amount, '', undefined, true), symbolNode));
  });
  return content;
}
/* harmony default export */ const ui_Fee = (memo(Fee));
function convertTermsObjectToList(terms) {
  const termList = [];
  let firstDefinedTerm;
  for (const [tokenType, amount] of Object.entries(terms)) {
    if (amount === undefined) {
      continue;
    }
    const term = {
      tokenType,
      amount
    };
    firstDefinedTerm ||= term;
    if (Number(amount)) {
      termList.push(term);
    }
  }

  // Keeping at least 1 term for better UX
  if (termList.length === 0) {
    termList.push(firstDefinedTerm ?? {
      tokenType: 'native',
      amount: 0
    });
  }
  return termList;
}
;// ./src/components/ui/FeeLine.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const FeeLine_module = ({"container":"FeeLine-module__container","static":"FeeLine-module__static","details":"FeeLine-module__details","detailsIcon":"FeeLine-module__detailsIcon"});
;// ./src/components/ui/FeeLine.tsx







/**
 * The component will be rendered empty unless all the required options from `FeeProps` are provided.
 * After that it will fade in.
 */

function FeeLine(_ref) {
  let {
    className,
    isStatic,
    terms,
    token,
    precision,
    keepDetailsButtonWithoutFee,
    onDetailsClick
  } = _ref;
  const lang = hooks_useLang();
  let content;
  if (terms && token) {
    const langKey = precision === 'exact' ? '$fee_value_with_colon' : '$fee_value';
    content = lang(langKey, {
      fee: /*#__PURE__*/teact.createElement(ui_Fee, {
        terms: terms,
        token: token,
        precision: precision
      })
    });
  }
  return /*#__PURE__*/teact.createElement(FeeLineContainer, {
    className: className,
    isStatic: isStatic,
    onDetailsClick: content || keepDetailsButtonWithoutFee ? onDetailsClick : undefined,
    transitionKey: content ? 1 : 0
  }, content);
}
/* harmony default export */ const ui_FeeLine = (memo(FeeLine));
/**
 * Use this component when you want to show a content that looks like `FeeLine`, but is not `FeeLine`.
 */
function FeeLineContainer(_ref2) {
  let {
    className,
    isStatic,
    onDetailsClick,
    children,
    transitionKey = 0
  } = _ref2;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "fade",
    activeKey: transitionKey + (onDetailsClick ? 0x10000 : 0),
    className: buildClassName(FeeLine_module.container, className, isStatic && FeeLine_module.static)
  }, children, Boolean(children) && onDetailsClick && ' Â· ', onDetailsClick && /*#__PURE__*/teact.createElement("span", {
    role: "button",
    tabIndex: 0,
    className: FeeLine_module.details,
    onClick: () => onDetailsClick()
  }, lang('Details'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-chevron-right', FeeLine_module.detailsIcon),
    "aria-hidden": true
  })));
}
;// ./src/components/dapps/DappTransferInitial.tsx


























const NFT_FAKE_COST_USD = 1_000_000_000;
const DappTransferInitial_skeletonRows = [{
  isLarge: false,
  hasFee: false
}, {
  isLarge: true,
  hasFee: true
}];
function DappTransferInitial(_ref) {
  var _renderingTransaction;
  let {
    transactions,
    totalAmountsBySlug,
    emulation,
    isScam,
    isDangerous,
    nftCount,
    dapp,
    isLoading,
    tokensBySlug,
    swapTokensBySlug,
    theme,
    baseCurrency,
    nftsByAddress,
    currentAccountId,
    stakingStateBySlug,
    savedAddresses,
    accounts,
    insufficientTokens,
    balancesBySlug,
    onClose
  } = _ref;
  const {
    closeDappTransfer,
    showDappTransferTransaction,
    submitDappTransferConfirm
  } = getActions();
  const lang = hooks_useLang();
  const appTheme = hooks_useAppTheme(theme);
  const renderingTransactions = useCurrentOrPrev(transactions, true);
  const sortedTransactions = teact_useMemo(() => sortTransactions(renderingTransactions, tokensBySlug), [renderingTransactions, tokensBySlug]);
  const isDappLoading = dapp === undefined;
  const hasSufficientBalance = !insufficientTokens;
  const tokenToDisplay = teact_useMemo(() => calculateTokenToDisplay(totalAmountsBySlug, balancesBySlug, tokensBySlug), [totalAmountsBySlug, balancesBySlug, tokensBySlug]);
  function renderContent() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.transitionContent, Dapp_module.skeletonBackground)
    }, /*#__PURE__*/teact.createElement(dapps_DappInfoWithAccount, {
      dapp: dapp,
      customTokenBalance: tokenToDisplay.balance,
      customTokenSymbol: tokenToDisplay.symbol,
      customTokenDecimals: tokenToDisplay.decimals
    }), isDangerous && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Dapp_module.transferWarning, Dapp_module.warningForPayload)
    }, renderText(lang('$hardware_payload_warning'))), renderTransactions(), renderEmulation(), /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.footer
    }, !hasSufficientBalance && /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.balanceError
    }, lang('Not Enough %symbol%', {
      symbol: insufficientTokens
    })), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.buttons, Dapp_module.transferButtons)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Modal_module.button,
      onClick: onClose
    }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isSubmit: true,
      isLoading: isLoading,
      isDisabled: isScam || !hasSufficientBalance,
      className: Modal_module.button,
      onClick: !isScam && hasSufficientBalance ? submitDappTransferConfirm : undefined
    }, lang('Send')))));
  }
  function renderTransactionRow(transaction) {
    const {
      payload
    } = transaction;
    const amountText = [];
    if (isNftTransferPayload(payload)) {
      amountText.push('1 NFT');
    } else if (isTokenTransferPayload(payload)) {
      const {
        slug: tokenSlug,
        amount
      } = payload;
      const {
        decimals,
        symbol
      } = tokensBySlug[tokenSlug] ?? src_config/* UNKNOWN_TOKEN */.Bx3;
      amountText.push(formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, decimals), symbol));
    }
    amountText.push(formatCurrency((0,util_decimals/* toDecimal */.nI)(transaction.amount + transaction.networkFee), src_config/* TONCOIN */.Tu9.symbol));
    return /*#__PURE__*/teact.createElement("div", {
      key: transaction.index,
      className: Dapp_module.transactionRow,
      onClick: () => showDappTransferTransaction({
        transactionIdx: transaction.index
      })
    }, transaction.isScam && /*#__PURE__*/teact.createElement("img", {
      src: scam_namespaceObject,
      alt: lang('Scam'),
      className: Dapp_module.scamImage
    }), /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Dapp_module.transactionRowAmount, transaction.isScam && Dapp_module.scam)
    }, amountText.join(' + ')), ' ', /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Dapp_module.transactionRowAddress, transaction.isScam && Dapp_module.scam)
    }, lang('$transaction_to', {
      address: (0,shortenAddress/* shortenAddress */.W)(transaction.displayedToAddress)
    })), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Dapp_module.transactionRowChevron, 'icon-chevron-right'),
      "aria-hidden": true
    }));
  }
  function renderTransactions() {
    if (!renderingTransactions) {
      return undefined;
    }
    const hasAmount = nftCount > 0 || !isEmptyObject(totalAmountsBySlug);
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Dapp_module.label
    }, lang('$many_transactions', renderingTransactions.length, 'i')), /*#__PURE__*/teact.createElement("div", {
      className: Dapp_module.transactionList
    }, sortedTransactions === null || sortedTransactions === void 0 ? void 0 : sortedTransactions.map(renderTransactionRow)), renderingTransactions.length > 1 && hasAmount && /*#__PURE__*/teact.createElement(dapps_DappAmountField, {
      label: lang('Total Amount'),
      amountsBySlug: totalAmountsBySlug,
      nftCount: nftCount
    }));
  }
  function renderEmulation() {
    var _emulation$activities;
    if (!(emulation !== null && emulation !== void 0 && (_emulation$activities = emulation.activities) !== null && _emulation$activities !== void 0 && _emulation$activities.length)) {
      return undefined;
    }
    const {
      activities,
      realFee
    } = emulation;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Dapp_module.label
    }, lang('Preview'), ' ', /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
      message: renderText(lang('$preview_not_guaranteed')),
      type: "warning",
      size: "small"
    })), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Dapp_module.transactionList, Dapp_module.emulation)
    }, activities.map((activity, index) => /*#__PURE__*/teact.createElement(Activity, {
      key: activity.id,
      activity: activity,
      isFuture: true,
      isLast: index === activities.length - 1,
      tokensBySlug: tokensBySlug,
      swapTokensBySlug: swapTokensBySlug,
      appTheme: appTheme,
      nftsByAddress: nftsByAddress,
      currentAccountId: currentAccountId,
      stakingStateBySlug: stakingStateBySlug,
      savedAddresses: savedAddresses,
      accounts: accounts,
      baseCurrency: baseCurrency
    }))), realFee !== 0n && /*#__PURE__*/teact.createElement(ui_FeeLine, {
      terms: {
        native: realFee
      },
      token: src_config/* TONCOIN */.Tu9,
      precision: "approximate",
      className: Dapp_module.emulationFee
    }));
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "semiFade",
    activeKey: isDappLoading ? 0 : 1,
    slideClassName: Dapp_module.skeletonTransitionWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang(isNftTransferPayload(renderingTransactions === null || renderingTransactions === void 0 || (_renderingTransaction = renderingTransactions[0]) === null || _renderingTransaction === void 0 ? void 0 : _renderingTransaction.payload) ? 'Send NFT' : 'Send Transaction'),
    onClose: closeDappTransfer
  }), isDappLoading ? /*#__PURE__*/teact.createElement(dapps_DappSkeletonWithContent, {
    rows: DappTransferInitial_skeletonRows
  }) : renderContent());
}
/* harmony default export */ const dapps_DappTransferInitial = (memo(withGlobal(global => {
  var _global$swapTokenInfo, _accountState$nfts, _accountState$balance;
  const {
    isLoading,
    dapp,
    transactions,
    emulation
  } = global.currentDappTransfer;
  const accountId = global.currentAccountId;
  const accountState = selectCurrentAccountState(global);
  const accounts = selectNetworkAccounts(global);
  const {
    amountsBySlug: totalAmountsBySlug,
    isScam,
    isDangerous,
    nftCount
  } = selectCurrentDappTransferTotals(global);
  return {
    transactions,
    totalAmountsBySlug,
    emulation,
    isScam,
    isDangerous,
    nftCount,
    dapp,
    isLoading,
    tokensBySlug: global.tokenInfo.bySlug,
    swapTokensBySlug: (_global$swapTokenInfo = global.swapTokenInfo) === null || _global$swapTokenInfo === void 0 ? void 0 : _global$swapTokenInfo.bySlug,
    theme: global.settings.theme,
    baseCurrency: global.settings.baseCurrency,
    nftsByAddress: accountState === null || accountState === void 0 || (_accountState$nfts = accountState.nfts) === null || _accountState$nfts === void 0 ? void 0 : _accountState$nfts.byAddress,
    currentAccountId: accountId,
    stakingStateBySlug: selectAccountStakingStatesBySlug(global, accountId),
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    accounts,
    insufficientTokens: selectDappTransferInsufficientTokens(global),
    balancesBySlug: accountState === null || accountState === void 0 || (_accountState$balance = accountState.balances) === null || _accountState$balance === void 0 ? void 0 : _accountState$balance.bySlug
  };
})(DappTransferInitial)));
function calculateTokenToDisplay(totalAmountsBySlug, balancesBySlug, tokensBySlug) {
  // Default to TON if no data
  if (!totalAmountsBySlug || !balancesBySlug || !tokensBySlug) {
    return {
      balance: (balancesBySlug === null || balancesBySlug === void 0 ? void 0 : balancesBySlug[src_config/* TONCOIN */.Tu9.slug]) ?? 0n,
      symbol: src_config/* TONCOIN */.Tu9.symbol,
      decimals: src_config/* TONCOIN */.Tu9.decimals
    };
  }
  const insufficientTokens = [];
  const sufficientTokens = [];

  // Analyze each token in the transaction
  for (const [slug, requiredAmount] of Object.entries(totalAmountsBySlug)) {
    const availableBalance = balancesBySlug[slug] ?? 0n;
    const token = tokensBySlug[slug];
    if (!token) continue;
    const {
      symbol,
      decimals,
      priceUsd = 0
    } = token;
    if (availableBalance < requiredAmount) {
      // Token is insufficient
      const insufficientAmount = requiredAmount - availableBalance;
      const insufficientUsdValue = (0,util_decimals/* toBig */.CF)(insufficientAmount, decimals).toNumber() * priceUsd;
      insufficientTokens.push({
        slug,
        insufficientUsdValue,
        balance: availableBalance,
        symbol,
        decimals
      });
    } else {
      // Token is sufficient
      const transactionUsdValue = (0,util_decimals/* toBig */.CF)(requiredAmount, decimals).toNumber() * priceUsd;
      sufficientTokens.push({
        slug,
        transactionUsdValue,
        balance: availableBalance,
        symbol,
        decimals
      });
    }
  }

  // If some tokens are insufficient, show the one with maximum insufficient USD value
  if (insufficientTokens.length > 0) {
    const maxInsufficientToken = insufficientTokens.reduce((max, current) => current.insufficientUsdValue > max.insufficientUsdValue ? current : max);
    return {
      balance: maxInsufficientToken.balance,
      symbol: maxInsufficientToken.symbol,
      decimals: maxInsufficientToken.decimals
    };
  }

  // If all tokens are sufficient, show the one with maximum transaction USD value
  if (sufficientTokens.length > 0) {
    const maxTransactionToken = sufficientTokens.reduce((max, current) => current.transactionUsdValue > max.transactionUsdValue ? current : max);
    return {
      balance: maxTransactionToken.balance,
      symbol: maxTransactionToken.symbol,
      decimals: maxTransactionToken.decimals
    };
  }

  // Fallback to TON
  return {
    balance: balancesBySlug[src_config/* TONCOIN */.Tu9.slug] ?? 0n,
    symbol: src_config/* TONCOIN */.Tu9.symbol,
    decimals: src_config/* TONCOIN */.Tu9.decimals
  };
}
function sortTransactions(transactions, tokensBySlug) {
  if (!transactions) {
    return transactions;
  }
  return transactions.map((transaction, index) => ({
    ...transaction,
    index,
    sortingCost: getTransactionCostForSorting(transaction, tokensBySlug)
  })).sort((transaction0, transaction1) => transaction1.sortingCost - transaction0.sortingCost);
}
function getTransactionCostForSorting(transaction, tokensBySlug) {
  const tonAmount = (0,util_decimals/* toBig */.CF)(transaction.amount + transaction.networkFee, src_config/* TONCOIN */.Tu9.decimals).toNumber();
  let cost = tokensBySlug[src_config/* TONCOIN */.Tu9.slug].priceUsd * tonAmount;
  if (isTokenTransferPayload(transaction.payload)) {
    const {
      amount,
      slug
    } = transaction.payload;
    const token = tokensBySlug[slug];
    if (token) {
      cost += token.priceUsd * (0,util_decimals/* toBig */.CF)(amount, token.decimals).toNumber();
    }
  } else if (isNftTransferPayload(transaction.payload)) {
    // Simple way to display NFT at top of list
    cost += NFT_FAKE_COST_USD;
  }
  return cost;
}
;// ./src/components/dapps/DappTransferModal.tsx
























function DappTransferModal(_ref) {
  let {
    currentDappTransfer: {
      isLoading,
      viewTransactionOnIdx,
      state,
      transactions,
      emulation,
      error
    },
    tokensBySlug,
    isMediaViewerOpen,
    isDangerous
  } = _ref;
  const {
    setDappTransferScreen,
    clearDappTransferError,
    submitDappTransfer,
    closeDappTransfer,
    cancelDappTransfer
  } = getActions();
  const lang = hooks_useLang();
  const isOpen = state !== TransferState.None;
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const needsExtraHeight = teact_useMemo(() => {
    // Apply the extra height only on mobile apps.
    // On the web, the height is controlled by the CSS.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    if (src_config/* IS_CAPACITOR */.UMQ && renderingKey === TransferState.Password) {
      return true;
    }

    // Do not apply the extra height if the transfer is complete, otherwise the Close button will be hidden on the iOS device
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    if (renderingKey === TransferState.Complete) {
      return false;
    }
    return shouldForceFullScreen(transactions, emulation === null || emulation === void 0 ? void 0 : emulation.activities, isDangerous);
  }, [transactions, emulation, isDangerous, renderingKey]);
  const handleBackClick = useLastCallback(() => {
    if (state === TransferState.Confirm || state === TransferState.Password) {
      setDappTransferScreen({
        state: TransferState.Initial
      });
    }
  });
  const handleTransferPasswordSubmit = useLastCallback(password => {
    submitDappTransfer({
      password
    });
  });
  const handleLedgerConnect = useLastCallback(() => {
    submitDappTransfer();
  });
  const handleResetTransfer = useLastCallback(() => {
    cancelDappTransfer();
    updateNextKey();
  });
  function renderPassword(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm Action'),
      onClose: closeDappTransfer
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      isLoading: isLoading,
      error: error,
      withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
      submitLabel: lang('Send'),
      cancelLabel: lang('Back'),
      onSubmit: handleTransferPasswordSubmit,
      onCancel: handleBackClick,
      onUpdate: clearDappTransferError
    }));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case TransferState.Initial:
        return /*#__PURE__*/teact.createElement(dapps_DappTransferInitial, {
          onClose: closeDappTransfer
        });
      case TransferState.WarningHardware:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Send Transaction'),
          onClose: closeDappTransfer
        }), /*#__PURE__*/teact.createElement(dapps_DappLedgerWarning, null));
      case TransferState.Confirm:
        return /*#__PURE__*/teact.createElement(dapps_DappTransaction, {
          transaction: viewTransactionOnIdx !== undefined ? transactions === null || transactions === void 0 ? void 0 : transactions[viewTransactionOnIdx] : undefined,
          tokensBySlug: tokensBySlug,
          isActive: isActive,
          onBack: handleBackClick,
          onClose: closeDappTransfer
        });
      case TransferState.Password:
        return renderPassword(isActive);
      case TransferState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleLedgerConnect,
          onClose: closeDappTransfer
        });
      case TransferState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onTryAgain: handleLedgerConnect,
          onClose: closeDappTransfer
        });
      case TransferState.Complete:
        return /*#__PURE__*/teact.createElement(dapps_DappTransferComplete, {
          isActive: isActive,
          onClose: closeDappTransfer
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen && !isMediaViewerOpen,
    noBackdropClose: true,
    dialogClassName: buildClassName(Dapp_module.modalDialog, needsExtraHeight && Dapp_module.modalDialogExtraHeight),
    nativeBottomSheetKey: "dapp-transfer",
    forceFullNative: needsExtraHeight,
    onClose: closeDappTransfer,
    onCloseAnimationEnd: handleResetTransfer
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const dapps_DappTransferModal = (memo(withGlobal(global => {
  const {
    isDangerous
  } = selectCurrentDappTransferTotals(global);
  return {
    currentDappTransfer: global.currentDappTransfer,
    tokensBySlug: global.tokenInfo.bySlug,
    isMediaViewerOpen: Boolean(global.mediaViewer.mediaId),
    isDangerous
  };
})(DappTransferModal)));
function shouldForceFullScreen(transactions, activities, isDangerous) {
  let height = 0; // rem

  if (transactions) {
    height += transactions.length * 3;
    if (transactions.length > 1) height += 5.125; // The Total Amount field
  }
  if (activities) {
    for (const activity of activities) {
      height += getActivityHeight(activity, true);
    }
  }
  if (isDangerous) {
    height += 4.6;
  }
  return height >= 14.5; // The actual available height is 15.125. Leaving a margin just in case.
}
;// ./mobile/plugins/native-dialog/dist/esm/index.js

const Dialog = (0,dist/* registerPlugin */.F3)('Dialog', {
  web: () => __webpack_require__.e(/* import() */ 564).then(__webpack_require__.bind(__webpack_require__, 94564)).then(m => new m.DialogWeb())
});


;// ./src/components/Dialogs.tsx












const Dialogs = _ref => {
  var _dialog$buttons, _buttons$cancel;
  let {
    dialogs
  } = _ref;
  const {
    dismissDialog
  } = getActions();
  const lang = hooks_useLang();
  const [isModalOpen, openModal, closeModal] = hooks_useFlag();
  const dialog = dialogs[dialogs.length - 1];
  const title = lang((dialog === null || dialog === void 0 ? void 0 : dialog.title) ?? 'Something went wrong');
  const buttons = (dialog === null || dialog === void 0 ? void 0 : dialog.buttons) ?? {
    confirm: {}
  };
  const hasCancel = Boolean(dialog === null || dialog === void 0 || (_dialog$buttons = dialog.buttons) === null || _dialog$buttons === void 0 ? void 0 : _dialog$buttons.cancel);
  const confirmTitle = lang(buttons.confirm.title ?? 'OK');
  const cancelTitle = hasCancel ? lang(((_buttons$cancel = buttons.cancel) === null || _buttons$cancel === void 0 ? void 0 : _buttons$cancel.title) ?? 'Cancel') : undefined;
  const isNativeDialog = src_config/* IS_CAPACITOR */.UMQ && typeof (dialog === null || dialog === void 0 ? void 0 : dialog.message) === 'string';
  const handleAction = useLastCallback(() => {
    if (buttons.confirm.action) {
      void executeDialogAction(buttons.confirm.action);
    }
    if (isNativeDialog) {
      dismissDialog();
    } else {
      closeModal();
    }
  });
  teact_useEffect(() => {
    if (!dialog) {
      closeModal();
      return;
    }
    if (isNativeDialog) {
      if (hasCancel) {
        void Dialog.confirm({
          title,
          message: lang(dialog.message),
          okButtonTitle: confirmTitle,
          cancelButtonTitle: cancelTitle
        }).then(result => {
          if (result.value) {
            handleAction();
          } else {
            dismissDialog();
          }
        });
      } else {
        void Dialog.alert({
          title,
          message: lang(dialog.message),
          buttonTitle: confirmTitle
        }).then(handleAction);
      }
    } else {
      openModal();
    }
  }, [cancelTitle, confirmTitle, dialog, hasCancel, isNativeDialog, lang, title]);
  if (!dialog) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isModalOpen,
    isCompact: true,
    title: title,
    noBackdropClose: dialog.noBackdropClose,
    isInAppLock: dialog.isInAppLock,
    onClose: closeModal,
    onCloseAnimationEnd: dismissDialog
  }, /*#__PURE__*/teact.createElement("div", null, typeof dialog.message === 'string' ? renderText(lang(dialog.message, dialog.entities)) : dialog.message), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.footerButtons
  }, hasCancel && /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: closeModal
  }, cancelTitle), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDestructive: buttons.confirm.isDestructive,
    onClick: handleAction
  }, confirmTitle)));
};
/* harmony default export */ const components_Dialogs = (memo(withGlobal(global => (0,iteratees/* pick */.Up)(global, ['dialogs']))(Dialogs)));
async function executeDialogAction(action) {
  switch (action) {
    case 'openBluetoothSettings':
      {
        const {
          openSystemBluetoothSettings
        } = await Promise.all(/* import() */[__webpack_require__.e(800), __webpack_require__.e(909), __webpack_require__.e(629), __webpack_require__.e(803)]).then(__webpack_require__.bind(__webpack_require__, 50243));
        openSystemBluetoothSettings();
        break;
      }
    case 'signOutAll':
      {
        const {
          signOut
        } = getActions();
        signOut({
          level: 'all'
        });
        break;
      }
  }
}
;// ./src/hooks/useElectronDrag.ts


const DRAG_DISTANCE_THRESHOLD = 5;
const useElectronDrag = ref => {
  const isDragging = teact_useRef(false);
  const x = teact_useRef(window.screenX);
  const y = teact_useRef(window.screenY);
  const distance = teact_useRef(0);
  teact_useEffect(() => {
    const element = ref.current;
    if (!element || !(windowEnvironment/* IS_ELECTRON */.cp && windowEnvironment/* IS_MAC_OS */.MP)) return undefined;
    const handleClick = event => {
      distance.current = 0;
      if (isDragging.current) {
        event.preventDefault();
        event.stopPropagation();
        isDragging.current = false;
      }
    };
    const handleMousedown = event => {
      if (isDragging.current) {
        event.preventDefault();
        event.stopPropagation();
      }
    };
    const handleDrag = event => {
      if (event.buttons === 1) {
        distance.current += Math.sqrt((x.current - window.screenX) ** 2 + (y.current - window.screenY) ** 2);
        x.current = window.screenX;
        y.current = window.screenY;
        if (!isDragging.current && distance.current > DRAG_DISTANCE_THRESHOLD) {
          isDragging.current = true;
        }
      }
    };
    const handleDoubleClick = event => {
      if (event.currentTarget === event.target) {
        var _window$electron;
        void ((_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.handleDoubleClick());
      }
    };
    element.addEventListener('click', handleClick);
    element.addEventListener('mousedown', handleMousedown);
    element.addEventListener('mousemove', handleDrag);
    element.addEventListener('dblclick', handleDoubleClick);
    return () => {
      element.removeEventListener('click', handleClick);
      element.removeEventListener('mouseup', handleMousedown);
      element.removeEventListener('mousemove', handleDrag);
      element.removeEventListener('dblclick', handleDoubleClick);
    };
  }, [ref]);
};
/* harmony default export */ const hooks_useElectronDrag = (useElectronDrag);
;// ./src/components/electron/UpdateApp.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const UpdateApp_module = ({"container":"UpdateApp-module__container","icon":"UpdateApp-module__icon","disabled":"UpdateApp-module__disabled","icon-wrapper":"UpdateApp-module__icon-wrapper","iconWrapper":"UpdateApp-module__icon-wrapper","text":"UpdateApp-module__text"});
;// ./src/components/electron/UpdateApp.tsx










function UpdateApp(_ref) {
  let {
    isAppUpdateAvailable
  } = _ref;
  const lang = hooks_useLang();
  const [isElectronUpdateDownloaded, setIsElectronUpdateDownloaded] = useState(false);
  const [isElectronAutoUpdateEnabled, setIsElectronAutoUpdateEnabled] = useState(false);
  const [isDisabled, disable] = hooks_useFlag(false);
  teact_useEffect(() => {
    var _window$electron, _window$electron2, _window$electron3;
    const removeUpdateErrorListener = (_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.on(ElectronEvent.UPDATE_ERROR, () => {
      setIsElectronUpdateDownloaded(false);
    });
    const removeUpdateDownloadedListener = (_window$electron2 = window.electron) === null || _window$electron2 === void 0 ? void 0 : _window$electron2.on(ElectronEvent.UPDATE_DOWNLOADED, () => {
      setIsElectronUpdateDownloaded(true);
    });
    void ((_window$electron3 = window.electron) === null || _window$electron3 === void 0 ? void 0 : _window$electron3.getIsAutoUpdateEnabled().then(setIsElectronAutoUpdateEnabled));
    return () => {
      removeUpdateErrorListener === null || removeUpdateErrorListener === void 0 || removeUpdateErrorListener();
      removeUpdateDownloadedListener === null || removeUpdateDownloadedListener === void 0 || removeUpdateDownloadedListener();
    };
  }, []);
  const handleClick = useLastCallback(async () => {
    if (isDisabled) {
      return;
    }
    if (!isElectronAutoUpdateEnabled) {
      window.open(`${src_config/* PRODUCTION_URL */.yq6}/get`, '_blank', 'noopener');
      return;
    }
    if (isElectronUpdateDownloaded) {
      var _window$electron4;
      disable();
      await ((_window$electron4 = window.electron) === null || _window$electron4 === void 0 ? void 0 : _window$electron4.installUpdate());
      return;
    }
    if (isAppUpdateAvailable) {
      window.location.reload();
    }
  });
  const {
    ref,
    shouldRender
  } = useShowTransition({
    isOpen: isElectronUpdateDownloaded || isAppUpdateAvailable,
    withShouldRender: true
  });
  if (!shouldRender) {
    return null; // eslint-disable-line no-null/no-null
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: buildClassName(UpdateApp_module.container, isDisabled && UpdateApp_module.disabled),
    onClick: handleClick
  }, /*#__PURE__*/teact.createElement("div", {
    className: UpdateApp_module.iconWrapper
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-update', UpdateApp_module.icon)
  })), /*#__PURE__*/teact.createElement("div", {
    className: UpdateApp_module.text
  }, lang('Update %app_name%', {
    app_name: src_config/* APP_NAME */.C39
  })));
}
/* harmony default export */ const electron_UpdateApp = (memo(withGlobal(global => {
  const {
    isAppUpdateAvailable
  } = global;
  return {
    isAppUpdateAvailable
  };
})(UpdateApp)));
;// ./src/components/electron/ElectronHeader.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ElectronHeader_module = ({"container":"ElectronHeader-module__container","wrapper":"ElectronHeader-module__wrapper","applicationName":"ElectronHeader-module__applicationName","buttons":"ElectronHeader-module__buttons","windowsButtons":"ElectronHeader-module__windowsButtons","windowsButton":"ElectronHeader-module__windowsButton"});
;// ./src/components/electron/ElectronHeader.tsx







const ELECTRON_HEADER_HEIGHT_REM = 3;
function ElectronHeader(_ref) {
  let {
    children,
    withTitle
  } = _ref;
  const containerRef = teact_useRef();
  hooks_useElectronDrag(containerRef);
  const handleMinimize = useLastCallback(() => {
    var _window$electron;
    (_window$electron = window.electron) === null || _window$electron === void 0 || _window$electron.minimize();
  });
  const handleMaximize = useLastCallback(async () => {
    var _window$electron2;
    if (await ((_window$electron2 = window.electron) === null || _window$electron2 === void 0 ? void 0 : _window$electron2.getIsMaximized())) {
      var _window$electron3;
      (_window$electron3 = window.electron) === null || _window$electron3 === void 0 || _window$electron3.unmaximize();
    } else {
      var _window$electron4;
      (_window$electron4 = window.electron) === null || _window$electron4 === void 0 || _window$electron4.maximize();
    }
  });
  const handleClose = useLastCallback(() => {
    var _window$electron5;
    (_window$electron5 = window.electron) === null || _window$electron5 === void 0 || _window$electron5.close();
  });
  const handleDoubleClick = useLastCallback(() => {
    var _window$electron6;
    void ((_window$electron6 = window.electron) === null || _window$electron6 === void 0 ? void 0 : _window$electron6.handleDoubleClick());
  });
  if (windowEnvironment/* IS_WINDOWS */.H8) {
    return /*#__PURE__*/teact.createElement("div", {
      ref: containerRef,
      className: ElectronHeader_module.container,
      onDoubleClick: handleDoubleClick
    }, /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.wrapper
    }, Boolean(children) && /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.buttons
    }, children), withTitle && /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.applicationName
    }, src_config/* APP_NAME */.C39)), /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.windowsButtons
    }, /*#__PURE__*/teact.createElement(electron_UpdateApp, null), /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.windowsButton,
      onClick: handleMinimize
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-windows-minimize"
    })), /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.windowsButton,
      onClick: handleMaximize
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-windows-maximize"
    })), /*#__PURE__*/teact.createElement("div", {
      className: ElectronHeader_module.windowsButton,
      onClick: handleClose
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-windows-close"
    }))));
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    className: ElectronHeader_module.container,
    onDoubleClick: handleDoubleClick
  }, /*#__PURE__*/teact.createElement("div", {
    className: ElectronHeader_module.wrapper
  }, withTitle && /*#__PURE__*/teact.createElement("div", {
    className: ElectronHeader_module.applicationName
  }, src_config/* APP_NAME */.C39), /*#__PURE__*/teact.createElement("div", {
    className: ElectronHeader_module.buttons
  }, /*#__PURE__*/teact.createElement(electron_UpdateApp, null), children)));
}
/* harmony default export */ const electron_ElectronHeader = (memo(ElectronHeader));
;// ./src/util/telegram/hooks/useTelegramMiniAppSwipeToClose.ts




function useTelegramMiniAppSwipeToClose(isActive) {
  const isSwipeDisabledRef = teact_useRef(false);
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_IOS */.pz) return;
    if (!isActive && isSwipeDisabledRef.current) {
      enableTelegramMiniAppSwipeToClose();
      isSwipeDisabledRef.current = false;
    }
  }, [isActive]);
  const disableSwipeToClose = useLastCallback(() => {
    if (windowEnvironment/* IS_IOS */.pz && !isSwipeDisabledRef.current) {
      disableTelegramMiniAppSwipeToClose();
      isSwipeDisabledRef.current = true;
    }
  });
  const enableSwipeToClose = useLastCallback(() => {
    if (windowEnvironment/* IS_IOS */.pz && isSwipeDisabledRef.current) {
      enableTelegramMiniAppSwipeToClose();
      isSwipeDisabledRef.current = false;
    }
  });
  return {
    disableSwipeToClose,
    enableSwipeToClose
  };
}
;// ./src/components/explore/helpers/utils.ts



const GOOGLE_SEARCH_URL = 'https://www.google.com/search?q=';
function filterSites(sites, shouldRestrict) {
  if (!sites) {
    return undefined;
  }
  return shouldRestrict ? sites.filter(site => !site.canBeRestricted) : sites;
}
function generateSearchSuggestions(searchValue, browserHistory, filteredSites) {
  const search = searchValue.toLowerCase();
  const historyResult = browserHistory === null || browserHistory === void 0 ? void 0 : browserHistory.filter(url => url.toLowerCase().includes(search));
  const sitesResult = search.length && filteredSites ? filteredSites.filter(_ref => {
    let {
      url,
      name,
      description
    } = _ref;
    return url.toLowerCase().includes(search) || name.toLowerCase().includes(search) || description.toLowerCase().includes(search);
  }) : undefined;
  return {
    history: historyResult,
    sites: sitesResult,
    isEmpty: ((historyResult === null || historyResult === void 0 ? void 0 : historyResult.length) || 0) + ((sitesResult === null || sitesResult === void 0 ? void 0 : sitesResult.length) || 0) === 0
  };
}
function processSites(sites) {
  return (sites || []).reduce((acc, site) => {
    if (site.isFeatured) {
      acc.trendingSites.push(site);
    }
    if (!acc.allSites[site.categoryId]) {
      acc.allSites[site.categoryId] = [];
    }
    acc.allSites[site.categoryId].push(site);
    return acc;
  }, {
    trendingSites: [],
    allSites: {}
  });
}
function findSiteByUrl(sites, targetUrl) {
  return sites === null || sites === void 0 ? void 0 : sites.find(_ref2 => {
    let {
      url
    } = _ref2;
    return url === targetUrl;
  });
}
function openSite(originalUrl, isExternal, title) {
  let url = originalUrl;
  if (!url.startsWith('http:') && !url.startsWith('https:')) {
    url = `https://${url}`;
  }
  if (!isValidUrl(url)) {
    url = `${GOOGLE_SEARCH_URL}${encodeURIComponent(originalUrl)}`;
  } else {
    getActions().addSiteToBrowserHistory({
      url
    });
  }
  void openUrl(url, {
    isExternal,
    title,
    subtitle: getHostnameFromUrl(url)
  });
}
;// ./src/hooks/useHorizontalScroll.ts

function useHorizontalScroll(_ref) {
  let {
    containerRef,
    isDisabled,
    shouldPreventDefault = false,
    contentSelector
  } = _ref;
  teact_useEffect(() => {
    const container = containerRef.current;
    if (isDisabled || !container) {
      return undefined;
    }
    function handleScroll(e) {
      // Ignore horizontal scroll and let it work natively (e.g. on touchpad)
      if (!e.deltaX) {
        const content = contentSelector ? container.querySelector(contentSelector) : container;
        if (!content) return;
        content.scrollLeft += e.deltaY / 4;
        if (shouldPreventDefault) e.preventDefault();
      }
    }
    container.addEventListener('wheel', handleScroll, {
      passive: !shouldPreventDefault
    });
    return () => {
      container.removeEventListener('wheel', handleScroll);
    };
  }, [containerRef, contentSelector, isDisabled, shouldPreventDefault]);
}
/* harmony default export */ const hooks_useHorizontalScroll = (useHorizontalScroll);
;// ./src/hooks/usePrevious2.ts


// This is not render-dependent and will never allow previous to match current
function usePrevious2(current) {
  const prevRef = teact_useRef();
  const lastRef = teact_useRef();
  if (lastRef.current !== current) {
    prevRef.current = lastRef.current;
  }
  lastRef.current = current;
  return prevRef.current;
}
;// ./src/components/explore/Category.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Category_module = ({"root":"Category-module__root","header":"Category-module__header","folder":"Category-module__folder","interactive":"Category-module__interactive","subfolder":"Category-module__subfolder","site":"Category-module__site","small":"Category-module__small","icon":"Category-module__icon","scalable":"Category-module__scalable"});
;// ./src/components/explore/Category.tsx









function Category(_ref) {
  let {
    category,
    sites
  } = _ref;
  const {
    openSiteCategory
  } = getActions();
  const lang = hooks_useLang();
  const [bigSites, smallSites] = teact_useMemo(() => {
    if (sites.length <= 4) {
      return [sites, []];
    }
    return [sites.slice(0, 3), sites.slice(3, 7)];
  }, [sites]);
  function handleCategoryClick() {
    openSiteCategory({
      id: category.id
    });
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Category_module.root
  }, /*#__PURE__*/teact.createElement("h3", {
    className: Category_module.header,
    role: "button",
    tabIndex: 0,
    onClick: handleCategoryClick
  }, lang(category.name)), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Category_module.folder, smallSites.length > 0 && Category_module.interactive),
    onClick: smallSites.length > 0 ? handleCategoryClick : undefined
  }, bigSites.map(site => /*#__PURE__*/teact.createElement("button", {
    key: `${site.url}-${site.name}`,
    type: "button",
    className: buildClassName(Category_module.site, Category_module.scalable),
    onClick: e => {
      stopEvent(e);
      void openUrl(site.url, {
        isExternal: site.isExternal,
        title: site.name,
        subtitle: getHostnameFromUrl(site.url)
      });
    }
  }, /*#__PURE__*/teact.createElement(ui_Image, {
    url: site.icon,
    alt: site.name,
    imageClassName: Category_module.icon
  }))), smallSites.length > 0 && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Category_module.subfolder, Category_module.scalable)
  }, smallSites.map(site => /*#__PURE__*/teact.createElement(ui_Image, {
    key: `${site.url}-${site.name}`,
    url: site.icon,
    alt: site.name,
    className: buildClassName(Category_module.site, Category_module.small),
    imageClassName: Category_module.icon
  })))));
}
/* harmony default export */ const explore_Category = (memo(Category));
;// ./src/util/memo.ts
const MEMO_EMPTY_ARRAY = [];
;// ./src/components/explore/DappFeed.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const DappFeed_module = ({"root":"DappFeed-module__root","feed":"DappFeed-module__feed","feedEmpty":"DappFeed-module__feedEmpty","tiles":"DappFeed-module__tiles","pills":"DappFeed-module__pills","dapp":"DappFeed-module__dapp","icon":"DappFeed-module__icon","dappName":"DappFeed-module__dappName","dappTile":"DappFeed-module__dappTile","dappPill":"DappFeed-module__dappPill","settingsLabel":"DappFeed-module__settingsLabel","iconPill":"DappFeed-module__iconPill","iconTile":"DappFeed-module__iconTile","fallbackIcon":"DappFeed-module__fallbackIcon","settingsButton":"DappFeed-module__settingsButton","settingsIconContainer":"DappFeed-module__settingsIconContainer"});
;// ./src/components/explore/DappFeedItem.tsx










const RERENDER_DAPPS_FEED_DELAY_MS = dateFormat/* SECOND */.Z2;
const POPULAR_DAPP_URL_REPLACEMENTS = [{
  name: 'Fanzee Battles',
  manifestUrl: 'https://battles-tg-app.fanz.ee/tc-manifest.json',
  originalUrl: 'https://t.me/fanzeebattlesbot',
  replacementUrl: 'https://t.me/battlescryptobot?start=myTonWallet'
}, {
  name: 'Hamster Kombat',
  manifestUrl: 'https://hamsterkombatgame.io/tonconnect-manifest.json',
  originalUrl: 'https://hamsterkombatgame.io/',
  replacementUrl: 'https://t.me/hamster_kombat_bot/start'
}, {
  name: 'Dogs',
  manifestUrl: 'https://cdn.onetime.dog/manifest.json',
  originalUrl: 'https://onetime.dog',
  replacementUrl: 'https://t.me/dogshouse_bot/join'
}, {
  name: 'Earn',
  manifestUrl: 'https://cdn.joincommunity.xyz/earn/manifest.json',
  originalUrl: 'https://earncommunity.xyz',
  replacementUrl: 'https://t.me/earn?startapp'
}];
const REPLACEMENTS_BY_URL = POPULAR_DAPP_URL_REPLACEMENTS.reduce((acc, _ref) => {
  let {
    originalUrl,
    replacementUrl
  } = _ref;
  acc[originalUrl] = replacementUrl;
  return acc;
}, {});
function DappFeedItem(_ref2) {
  let {
    iconUrl,
    name,
    url,
    mode,
    isExternal
  } = _ref2;
  const {
    updateDappLastOpenedAt
  } = getActions();
  const lang = hooks_useLang();
  function renderIcon() {
    const iconClassName = mode === 'pill' ? DappFeed_module.iconPill : DappFeed_module.iconTile;
    const fallbackIcon = teact_useMemo(() => /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Dapp_module.dappLogo, Dapp_module.dappLogoIcon, iconClassName)
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(DappFeed_module.fallbackIcon, 'icon-laptop'),
      "aria-hidden": true
    })), [iconClassName]);
    return /*#__PURE__*/teact.createElement(ui_Image, {
      url: iconUrl,
      className: iconClassName,
      imageClassName: DappFeed_module.icon,
      alt: lang('Icon'),
      fallback: fallbackIcon
    });
  }
  const openDapp = useLastCallback(async () => {
    await openUrl(REPLACEMENTS_BY_URL[url] || url, {
      isExternal
    });
    setTimeout(() => void updateDappLastOpenedAt({
      url
    }), RERENDER_DAPPS_FEED_DELAY_MS);
  });
  return /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: buildClassName(DappFeed_module.dapp, mode === 'pill' ? DappFeed_module.dappPill : DappFeed_module.dappTile),
    onClick: openDapp
  }, renderIcon(), /*#__PURE__*/teact.createElement("span", {
    className: DappFeed_module.dappName
  }, name));
}
/* harmony default export */ const explore_DappFeedItem = (memo(DappFeedItem));
;// ./src/components/explore/Explore.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Explore_module = ({"rootSlide":"Explore-module__rootSlide","slide":"Explore-module__slide","list":"Explore-module__list","landscapeList":"Explore-module__landscapeList","suggestionsMenu":"Explore-module__suggestionsMenu","suggestions":"Explore-module__suggestions","suggestion":"Explore-module__suggestion","suggestionIcon":"Explore-module__suggestionIcon","suggestionAddress":"Explore-module__suggestionAddress","clearSuggestion":"Explore-module__clearSuggestion","item":"Explore-module__item","trendingImage":"Explore-module__trendingImage","imageWrapperScalable":"Explore-module__imageWrapperScalable","trending":"Explore-module__trending","badge":"Explore-module__badge","imageWrapper":"Explore-module__imageWrapper","infoWrapper":"Explore-module__infoWrapper","extended":"Explore-module__extended","withBorder":"Explore-module__withBorder","badgeLabel":"Explore-module__badgeLabel","image":"Explore-module__image","title":"Explore-module__title","description":"Explore-module__description","telegram":"Explore-module__telegram","emptyList":"Explore-module__emptyList","emptyListLoading":"Explore-module__emptyListLoading","searchWrapper":"Explore-module__searchWrapper","searchContainer":"Explore-module__searchContainer","searchIcon":"Explore-module__searchIcon","searchInput":"Explore-module__searchInput","sectionHeader":"Explore-module__sectionHeader","trendingSection":"Explore-module__trendingSection","trendingList":"Explore-module__trendingList"});
;// ./src/components/explore/DappFeed.tsx













const MAX_DAPPS_FOR_PILL_MODE = 3;
const HIDDEN_FROM_FEED_DAPP_URLS = new Set(['https://checkin.mytonwallet.org']);
function DappFeed(_ref) {
  let {
    dapps: dappsFromState,
    dappLastOpenedDatesByUrl
  } = _ref;
  const {
    openSettingsWithState,
    closeExplore
  } = getActions();
  const lang = hooks_useLang();
  const containerRef = teact_useRef();
  const dapps = teact_useMemo(() => {
    const sortedDapps = dappsFromState.slice().filter(dapp => !HIDDEN_FROM_FEED_DAPP_URLS.has(dapp.url)).map(dapp => ({
      ...dapp,
      lastOpenedAt: dappLastOpenedDatesByUrl === null || dappLastOpenedDatesByUrl === void 0 ? void 0 : dappLastOpenedDatesByUrl[dapp.url]
    })).sort(compareDapps);

    // Remove duplicates, since we now support multiple connections per dapp. Keep the most recent connection.
    const seen = new Set();
    return sortedDapps.filter(_ref2 => {
      let {
        url
      } = _ref2;
      if (seen.has(url)) return false;
      seen.add(url);
      return true;
    });
  }, [dappLastOpenedDatesByUrl, dappsFromState]);
  const mode = dapps.length > MAX_DAPPS_FOR_PILL_MODE ? 'tile' : 'pill';
  const isPillMode = mode === 'pill';
  const iconWrapperClassName = isPillMode ? DappFeed_module.iconPill : DappFeed_module.iconTile;
  const fullClassName = buildClassName(DappFeed_module.feed, isPillMode ? DappFeed_module.pills : DappFeed_module.tiles, !dapps.length && DappFeed_module.feedEmpty, 'dapps-feed');
  function openSettings() {
    closeExplore(undefined, {
      forceOnHeavyAnimation: true
    });
    openSettingsWithState({
      state: SettingsState.Dapps
    }, {
      forceOnHeavyAnimation: true
    });
  }
  hooks_useHorizontalScroll({
    containerRef,
    isDisabled: windowEnvironment/* IS_TOUCH_ENV */.TF || dapps.length === 0,
    shouldPreventDefault: true,
    contentSelector: '.dapps-feed'
  });
  if (!dapps.length) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: DappFeed_module.root,
    ref: containerRef
  }, /*#__PURE__*/teact.createElement("h2", {
    className: Explore_module.sectionHeader
  }, lang('Connected')), /*#__PURE__*/teact.createElement("div", {
    className: fullClassName
  }, dapps === null || dapps === void 0 ? void 0 : dapps.map(dapp => renderDapp(dapp, mode)), !!dapps.length && /*#__PURE__*/teact.createElement("div", {
    className: DappFeed_module.settingsButton,
    role: "button",
    tabIndex: 0,
    title: isPillMode ? lang('Settings') : undefined,
    "aria-label": isPillMode ? lang('Settings') : undefined,
    onClick: openSettings
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(DappFeed_module.settingsIconContainer, iconWrapperClassName)
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-params",
    "aria-hidden": true
  })), !isPillMode && /*#__PURE__*/teact.createElement("span", {
    className: DappFeed_module.settingsLabel
  }, lang('Settings')))));
}
/* harmony default export */ const explore_DappFeed = (memo(withGlobal(global => {
  const {
    dapps = MEMO_EMPTY_ARRAY
  } = selectCurrentAccountState(global) || {};
  const {
    dappLastOpenedDatesByUrl
  } = selectCurrentAccountState(global) || {};
  return {
    dapps,
    dappLastOpenedDatesByUrl
  };
})(DappFeed)));
function compareDapps(a, b) {
  const aLastOpened = a.lastOpenedAt || 0;
  const bLastOpened = b.lastOpenedAt || 0;
  if (aLastOpened !== bLastOpened) {
    return bLastOpened - aLastOpened;
  }
  return b.connectedAt - a.connectedAt;
}
function renderDapp(dapp, mode) {
  const {
    iconUrl,
    name,
    url
  } = dapp;
  const key = `dapp-${url}-${getDappConnectionUniqueId(dapp)}`;
  return /*#__PURE__*/teact.createElement(explore_DappFeedItem, {
    key: key,
    iconUrl: iconUrl,
    name: name,
    url: url,
    mode: mode,
    isExternal: !!dapp.sse
  });
}
;// ./src/components/ui/MenuItem.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const MenuItem_module = ({"menuItem":"MenuItem-module__menuItem","destructive":"MenuItem-module__destructive"});
;// ./src/components/ui/MenuItem.tsx




const MenuItem = props => {
  const {
    className,
    href,
    children,
    onClick,
    clickArg,
    isDestructive
  } = props;
  const handleClick = useLastCallback(e => {
    if (!onClick) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    onClick(e, clickArg);
  });
  const handleKeyDown = useLastCallback(e => {
    if (e.code !== 'Enter' && e.code !== 'Space') {
      return;
    }
    if (!onClick) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    onClick(e);
  });
  const fullClassName = buildClassName(MenuItem_module.menuItem, className, isDestructive && MenuItem_module.destructive);
  if (href) {
    return /*#__PURE__*/teact.createElement("a", {
      href: href,
      target: "_blank",
      rel: "noopener noreferrer",
      className: fullClassName
    }, children);
  }
  return /*#__PURE__*/teact.createElement("div", {
    role: "button",
    tabIndex: 0,
    className: fullClassName,
    onClick: handleClick,
    onKeyDown: handleKeyDown
  }, children);
};
/* harmony default export */ const ui_MenuItem = (MenuItem);
;// ./src/components/explore/Site.tsx







function Site(_ref) {
  let {
    site: {
      url,
      icon,
      name,
      description,
      isExternal,
      extendedIcon,
      withBorder,
      badgeText
    },
    isTrending,
    isInList,
    className
  } = _ref;
  function handleClick() {
    void vibrate();
    void openUrl(url, {
      isExternal,
      title: name,
      subtitle: getHostnameFromUrl(url)
    });
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Explore_module.item, extendedIcon && isTrending && Explore_module.extended, isTrending && Explore_module.trending, !isInList && withBorder && Explore_module.withBorder, className),
    tabIndex: 0,
    role: "button",
    onClick: handleClick
  }, /*#__PURE__*/teact.createElement(ui_Image, {
    url: extendedIcon && isTrending ? extendedIcon : icon,
    className: buildClassName(Explore_module.imageWrapper, !isTrending && Explore_module.imageWrapperScalable),
    imageClassName: buildClassName(Explore_module.image, isTrending && Explore_module.trendingImage)
  }), /*#__PURE__*/teact.createElement("div", {
    className: Explore_module.infoWrapper
  }, /*#__PURE__*/teact.createElement("b", {
    className: Explore_module.title
  }, name, !isTrending && isTelegramUrl(url) && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Explore_module.telegram, 'icon-telegram-filled'),
    "aria-hidden": true
  }), isInList && badgeText && /*#__PURE__*/teact.createElement("div", {
    className: Explore_module.badgeLabel
  }, badgeText)), /*#__PURE__*/teact.createElement("div", {
    className: Explore_module.description
  }, description)), !isInList && badgeText && /*#__PURE__*/teact.createElement("div", {
    className: Explore_module.badge
  }, badgeText));
}
/* harmony default export */ const explore_Site = (memo(Site));
;// ./src/components/explore/ExploreSearchSuggestions.tsx









function ExploreSearchSuggestions(_ref) {
  var _searchSuggestions$hi, _searchSuggestions$si;
  let {
    isSuggestionsVisible,
    searchSuggestions,
    searchValue,
    onSiteClick,
    onSiteClear,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(ui_Menu, {
    type: "suggestion",
    noBackdrop: true,
    isOpen: Boolean(isSuggestionsVisible && !searchSuggestions.isEmpty),
    className: Explore_module.suggestions,
    bubbleClassName: Explore_module.suggestionsMenu,
    onClose: onClose
  }, searchSuggestions === null || searchSuggestions === void 0 || (_searchSuggestions$hi = searchSuggestions.history) === null || _searchSuggestions$hi === void 0 ? void 0 : _searchSuggestions$hi.map(url => /*#__PURE__*/teact.createElement(ui_MenuItem, {
    key: `history-${url}`,
    className: Explore_module.suggestion,
    onClick: onSiteClick,
    clickArg: url
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Explore_module.suggestionIcon, searchValue.length ? 'icon-search' : 'icon-globe'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", {
    className: Explore_module.suggestionAddress
  }, getHostnameFromUrl(url)), /*#__PURE__*/teact.createElement("button", {
    className: Explore_module.clearSuggestion,
    type: "button",
    "aria-label": lang('Clear'),
    title: lang('Clear'),
    onMouseDown: e => onSiteClear(e, url),
    onClick: stopEvent
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-close",
    "aria-hidden": true
  })))), searchSuggestions === null || searchSuggestions === void 0 || (_searchSuggestions$si = searchSuggestions.sites) === null || _searchSuggestions$si === void 0 ? void 0 : _searchSuggestions$si.map(site => /*#__PURE__*/teact.createElement(explore_Site, {
    key: `site-${site.url}-${site.name}`,
    className: Explore_module.suggestion,
    site: site
  })));
}
/* harmony default export */ const explore_ExploreSearchSuggestions = (memo(ExploreSearchSuggestions));
;// ./src/components/explore/CategoryHeader.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const CategoryHeader_module = ({"root":"CategoryHeader-module__root","backButton":"CategoryHeader-module__backButton","backIcon":"CategoryHeader-module__backIcon","title":"CategoryHeader-module__title"});
;// ./src/components/explore/CategoryHeader.tsx







function CategoryHeader(_ref) {
  let {
    id,
    withNotch,
    categories
  } = _ref;
  const {
    closeSiteCategory
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const category = teact_useMemo(() => {
    var _ref2;
    return (_ref2 = categories || []) === null || _ref2 === void 0 ? void 0 : _ref2.find(item => id === item.id);
  }, [categories, id]);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(CategoryHeader_module.root, isPortrait && 'with-notch-on-scroll', withNotch && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: CategoryHeader_module.backButton,
    isSimple: true,
    isText: true,
    onClick: closeSiteCategory
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(CategoryHeader_module.backIcon, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("h3", {
    className: CategoryHeader_module.title
  }, lang((category === null || category === void 0 ? void 0 : category.name) || '')));
}
/* harmony default export */ const explore_CategoryHeader = (memo(withGlobal(global => {
  var _global$exploreData;
  return {
    categories: (_global$exploreData = global.exploreData) === null || _global$exploreData === void 0 ? void 0 : _global$exploreData.categories
  };
})(CategoryHeader)));
;// ./src/components/explore/SiteList.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SiteList_module = ({"root":"SiteList-module__root","list":"SiteList-module__list"});
;// ./src/components/explore/SiteList.tsx









function SiteList(_ref) {
  let {
    isActive,
    categoryId,
    sites
  } = _ref;
  const {
    closeSiteCategory
  } = getActions();
  const {
    isPortrait
  } = useDeviceScreen();
  useHistoryBack({
    isActive,
    onBack: closeSiteCategory
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  return /*#__PURE__*/teact.createElement("div", {
    onScroll: isPortrait ? handleContentScroll : undefined,
    className: buildClassName(SiteList_module.root, 'custom-scroll')
  }, isPortrait && /*#__PURE__*/teact.createElement(explore_CategoryHeader, {
    id: categoryId,
    withNotch: isScrolled
  }), /*#__PURE__*/teact.createElement("div", {
    className: SiteList_module.list
  }, sites.map(site => /*#__PURE__*/teact.createElement(explore_Site, {
    key: `${site.url}-${site.name}`,
    site: site,
    isInList: true
  }))));
}
/* harmony default export */ const explore_SiteList = (memo(SiteList));
;// ./src/components/explore/Explore.tsx

































const SUGGESTIONS_OPEN_DELAY = 300;
var Explore_SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["main"] = 0] = "main";
  SLIDES[SLIDES["category"] = 1] = "category";
  return SLIDES;
}(Explore_SLIDES || {});
function Explore(_ref) {
  let {
    isActive,
    categories,
    sites: originalSites,
    shouldRestrict,
    browserHistory,
    currentSiteCategoryId,
    onScroll
  } = _ref;
  const {
    loadExploreSites,
    getDapps,
    removeSiteFromBrowserHistory,
    openSiteCategory,
    closeSiteCategory
  } = getActions();
  const inputRef = teact_useRef();
  const suggestionsTimeoutRef = teact_useRef(undefined);
  const transitionRef = teact_useRef();
  const trendingContainerRef = teact_useRef();
  const lang = hooks_useLang();
  const {
    isLandscape,
    isPortrait
  } = useDeviceScreen();
  const [searchValue, setSearchValue] = useState('');
  const [isSearchFocused, markSearchFocused, unmarkSearchFocused] = hooks_useFlag(false);
  const [isSuggestionsVisible, showSuggestions, hideSuggestions] = hooks_useFlag(false);
  const {
    renderingKey
  } = useModalTransitionKeys(currentSiteCategoryId || 0, !!isActive);
  const prevSiteCategoryIdRef = useStateRef(usePrevious2(renderingKey));
  const {
    disableSwipeToClose,
    enableSwipeToClose
  } = useTelegramMiniAppSwipeToClose(isActive);

  // On desktop should be used external scroll detection via `onScroll` prop
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  teact_useEffect(() => renderingKey ? captureEscKeyListener(closeSiteCategory) : undefined, [closeSiteCategory, renderingKey]);
  const filteredSites = teact_useMemo(() => filterSites(originalSites, shouldRestrict), [originalSites, shouldRestrict]);
  const searchSuggestions = teact_useMemo(() => generateSearchSuggestions(searchValue, browserHistory, filteredSites), [browserHistory, searchValue, filteredSites]);
  const {
    trendingSites,
    allSites
  } = teact_useMemo(() => processSites(filteredSites), [filteredSites]);
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF || !(filteredSites !== null && filteredSites !== void 0 && filteredSites.length)) {
      return undefined;
    }
    return captureControlledSwipe(transitionRef.current, {
      onSwipeRightStart: () => {
        closeSiteCategory();
        disableSwipeToClose();
      },
      onCancel: () => {
        openSiteCategory({
          id: prevSiteCategoryIdRef.current
        });
        enableSwipeToClose();
      }
    });
  }, [disableSwipeToClose, enableSwipeToClose, filteredSites === null || filteredSites === void 0 ? void 0 : filteredSites.length, prevSiteCategoryIdRef]);
  hooks_useHorizontalScroll({
    containerRef: trendingContainerRef,
    isDisabled: windowEnvironment/* IS_TOUCH_ENV */.TF || trendingSites.length === 0,
    shouldPreventDefault: true,
    contentSelector: `.${Explore_module.trendingList}`
  });
  const filteredCategories = teact_useMemo(() => {
    return categories === null || categories === void 0 ? void 0 : categories.filter(category => {
      var _allSites$category$id;
      return ((_allSites$category$id = allSites[category.id]) === null || _allSites$category$id === void 0 ? void 0 : _allSites$category$id.length) > 0;
    });
  }, [categories, allSites]);
  teact_useEffect(() => {
    if (!isActive) return;
    getDapps();
    loadExploreSites({
      isLandscape
    });
  }, [isActive, isLandscape]);
  const safeShowSuggestions = useLastCallback(() => {
    if (searchSuggestions.isEmpty) return;

    // Simultaneous opening of the virtual keyboard and display of Saved Addresses causes animation degradation
    if (windowEnvironment/* IS_ANDROID */.Ni) {
      suggestionsTimeoutRef.current = window.setTimeout(showSuggestions, SUGGESTIONS_OPEN_DELAY);
    } else {
      showSuggestions();
    }
  });
  const safeHideSuggestions = useLastCallback(() => {
    if (isSuggestionsVisible) {
      hideSuggestions();
    }
    window.clearTimeout(suggestionsTimeoutRef.current);
  });
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevIsSearchFocused] = _ref2;
    if (prevIsSearchFocused && !isSearchFocused || searchSuggestions.isEmpty) {
      safeHideSuggestions();
    }
    if (isSearchFocused && !searchSuggestions.isEmpty) {
      safeShowSuggestions();
    }
  }, [isSearchFocused, searchSuggestions.isEmpty]);
  const handleSiteClick = useLastCallback((e, url) => {
    void vibrate();
    hideSuggestions();
    const site = findSiteByUrl(originalSites, url);
    openSite(url, site === null || site === void 0 ? void 0 : site.isExternal, site === null || site === void 0 ? void 0 : site.name);
  });
  const handleSiteClear = useLastCallback((e, url) => {
    stopEvent(e);
    removeSiteFromBrowserHistory({
      url
    });
  });
  function handleSearchValueChange(e) {
    setSearchValue(e.target.value);
  }
  const handleMenuClose = useLastCallback(() => {
    var _inputRef$current;
    (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
  });
  function handleSearchSubmit(e) {
    stopEvent(e);
    handleMenuClose();
    if (searchValue.length > 0) {
      openSite(searchValue);
      setSearchValue('');
    }
  }
  function renderSearch() {
    return /*#__PURE__*/teact.createElement("form", {
      action: "#",
      onSubmit: handleSearchSubmit,
      className: Explore_module.searchContainer,
      autoComplete: "off"
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Explore_module.searchIcon, 'icon-search'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("input", {
      name: "explore-search",
      className: Explore_module.searchInput,
      placeholder: lang('Search or enter address'),
      value: searchValue,
      autoCorrect: false,
      autoCapitalize: "none",
      spellCheck: false,
      inputMode: "url",
      onChange: handleSearchValueChange,
      onFocus: markSearchFocused,
      onBlur: unmarkSearchFocused
    }));
  }
  function renderTrending() {
    return /*#__PURE__*/teact.createElement("div", {
      ref: trendingContainerRef,
      className: Explore_module.trendingSection
    }, /*#__PURE__*/teact.createElement("h2", {
      className: Explore_module.sectionHeader
    }, lang('Trending')), /*#__PURE__*/teact.createElement("div", {
      className: Explore_module.trendingList
    }, trendingSites.map(site => /*#__PURE__*/teact.createElement(explore_Site, {
      key: `${site.url}-${site.name}`,
      site: site,
      isTrending: true
    }))));
  }
  function renderContent(isContentActive, isFrom, currentKey) {
    switch (currentKey) {
      case Explore_SLIDES.main:
        return /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Explore_module.slide, 'custom-scroll'),
          onScroll: isPortrait ? handleContentScroll : onScroll
        }, /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Explore_module.searchWrapper, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
        }, renderSearch(), /*#__PURE__*/teact.createElement(explore_ExploreSearchSuggestions, {
          isSuggestionsVisible: isSuggestionsVisible,
          searchSuggestions: searchSuggestions,
          searchValue: searchValue,
          onSiteClick: handleSiteClick,
          onSiteClear: handleSiteClear,
          onClose: handleMenuClose
        })), /*#__PURE__*/teact.createElement(explore_DappFeed, null), Boolean(trendingSites.length) && renderTrending(), Boolean(filteredCategories === null || filteredCategories === void 0 ? void 0 : filteredCategories.length) && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("h2", {
          className: Explore_module.sectionHeader
        }, lang('All Dapps')), /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Explore_module.list, isLandscape && Explore_module.landscapeList)
        }, filteredCategories.map(category => /*#__PURE__*/teact.createElement(explore_Category, {
          key: category.id,
          category: category,
          sites: allSites[category.id]
        })))));
      case Explore_SLIDES.category:
        {
          const currentSiteCategory = allSites[renderingKey];
          if (!currentSiteCategory) return undefined;
          return /*#__PURE__*/teact.createElement(explore_SiteList, {
            key: renderingKey,
            isActive: isContentActive,
            categoryId: renderingKey,
            sites: currentSiteCategory
          });
        }
    }
  }
  if (filteredSites === undefined) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Explore_module.emptyList, Explore_module.emptyListLoading)
    }, /*#__PURE__*/teact.createElement(ui_Spinner, null));
  }
  if (filteredSites.length === 0) {
    return /*#__PURE__*/teact.createElement("div", {
      className: Explore_module.emptyList
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      tgsUrl: ANIMATED_STICKERS_PATHS.happy,
      previewUrl: ANIMATED_STICKERS_PATHS.happyPreview,
      size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
      className: Explore_module.sticker,
      noLoop: false,
      nonInteractive: true
    }), /*#__PURE__*/teact.createElement("p", {
      className: Explore_module.emptyListTitle
    }, lang('No partners yet')));
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    ref: transitionRef,
    name: resolveSlideTransitionName(),
    activeKey: renderingKey ? Explore_SLIDES.category : Explore_SLIDES.main,
    withSwipeControl: true,
    className: Explore_module.rootSlide
  }, renderContent);
}
/* harmony default export */ const explore_Explore = (memo(withGlobal(global => {
  const {
    browserHistory,
    currentSiteCategoryId
  } = selectCurrentAccountState(global) || {};
  const {
    categories,
    sites
  } = global.exploreData || {};
  return {
    sites,
    categories,
    shouldRestrict: global.restrictions.isLimitedRegion && (windowEnvironment/* IS_IOS_APP */.ZH || windowEnvironment/* IS_ANDROID_APP */.xy),
    browserHistory,
    currentSiteCategoryId
  };
})(Explore)));
;// ./src/components/ledger/LedgerSelectWallets.tsx













const LedgerSelectWallets_ACCOUNT_ADDRESS_SHIFT = 4;
const ACCOUNT_BALANCE_DECIMALS = 3;
function LedgerSelectWallets(_ref) {
  let {
    isActive,
    isStatic,
    hardwareWallets,
    accounts,
    onBackButtonClick,
    onCancel,
    onClose
  } = _ref;
  const {
    afterSelectHardwareWallets,
    loadMoreHardwareWallets
  } = getActions();
  const lang = hooks_useLang();
  const [selectedAccountIndices, setSelectedAccountIndices] = useState([]);
  const shouldCloseOnCancel = !onCancel;
  useHistoryBack({
    isActive,
    onBack: onCancel ?? onClose
  });
  const handleAccountToggle = useLastCallback(index => {
    if (selectedAccountIndices.includes(index)) {
      setSelectedAccountIndices(selectedAccountIndices.filter(id => id !== index));
    } else {
      setSelectedAccountIndices(selectedAccountIndices.concat([index]));
    }
  });
  const handleAddLedgerWallets = useLastCallback(() => {
    afterSelectHardwareWallets({
      hardwareSelectedIndices: selectedAccountIndices
    });
    onClose();
  });
  const alreadyConnectedList = teact_useMemo(() => Object.values(accounts ?? []).map(_ref2 => {
    let {
      addressByChain: {
        ton: address
      }
    } = _ref2;
    return address;
  }).filter(Boolean), [accounts]);
  const handleAddWalletClick = useLastCallback(() => {
    var _list;
    const list = hardwareWallets ?? [];
    const lastIndex = ((_list = list[list.length - 1]) === null || _list === void 0 ? void 0 : _list.index) ?? 0;
    loadMoreHardwareWallets({
      lastIndex
    });
  });
  function renderAddAccount() {
    return /*#__PURE__*/teact.createElement(ui_Button, {
      className: LedgerModal_module.addAccountContainer,
      onClick: handleAddWalletClick
    }, lang('Add Wallet'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(LedgerModal_module.addAccountIcon, 'icon-plus'),
      "aria-hidden": true
    }));
  }
  function renderAccount(address, balance, index, isConnected) {
    const isActiveAccount = isConnected || selectedAccountIndices.includes(index);
    return /*#__PURE__*/teact.createElement("div", {
      key: address,
      className: buildClassName(LedgerModal_module.account, isActiveAccount && LedgerModal_module.account_current),
      onClick: isConnected ? undefined : () => handleAccountToggle(index)
    }, /*#__PURE__*/teact.createElement("span", {
      className: LedgerModal_module.accountName
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(LedgerModal_module.accountCurrencyIcon, 'icon-ton'),
      "aria-hidden": true
    }), formatCurrency((0,util_decimals/* toDecimal */.nI)(balance), '', ACCOUNT_BALANCE_DECIMALS)), /*#__PURE__*/teact.createElement("div", {
      className: LedgerModal_module.accountFooter
    }, /*#__PURE__*/teact.createElement("span", {
      className: LedgerModal_module.accountAddress
    }, (0,shortenAddress/* shortenAddress */.W)(address, LedgerSelectWallets_ACCOUNT_ADDRESS_SHIFT, LedgerSelectWallets_ACCOUNT_ADDRESS_SHIFT))), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(LedgerModal_module.accountCheckMark, isActiveAccount && LedgerModal_module.accountCheckMark_active)
    }));
  }
  function renderAccounts() {
    const list = hardwareWallets ?? [];
    const fullClassName = buildClassName(LedgerModal_module.accounts, list.length === 1 && LedgerModal_module.accounts_two, 'custom-scroll');
    return /*#__PURE__*/teact.createElement("div", {
      className: fullClassName
    }, list.map(_ref3 => {
      let {
        address,
        balance,
        index
      } = _ref3;
      return renderAccount(address, balance, index, alreadyConnectedList.includes(address));
    }), renderAddAccount());
  }
  const areAccountsSelected = !selectedAccountIndices.length;
  const title = selectedAccountIndices.length ? lang('%1$d Selected', selectedAccountIndices.length) : lang('Select Ledger Wallets');
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, !isStatic ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: title,
    onBackButtonClick: onBackButtonClick,
    onClose: !onBackButtonClick ? onClose : undefined
  }) : /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: onClose,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, title)), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LedgerModal_module.container, isStatic && LedgerModal_module.containerStatic, isStatic && 'static-container')
  }, renderAccounts(), /*#__PURE__*/teact.createElement("div", {
    className: LedgerModal_module.actionBlock
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: LedgerModal_module.button,
    onClick: shouldCloseOnCancel ? onClose : onCancel
  }, lang(shouldCloseOnCancel ? 'Cancel' : 'Back')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDisabled: areAccountsSelected,
    onClick: handleAddLedgerWallets,
    className: LedgerModal_module.button
  }, lang('Add')))));
}
/* harmony default export */ const ledger_LedgerSelectWallets = (memo(LedgerSelectWallets));
;// ./src/components/ledger/LedgerModal.tsx












var LedgerModalState = /*#__PURE__*/function (LedgerModalState) {
  LedgerModalState[LedgerModalState["Password"] = 0] = "Password";
  LedgerModalState[LedgerModalState["Connect"] = 1] = "Connect";
  LedgerModalState[LedgerModalState["SelectWallets"] = 2] = "SelectWallets";
  return LedgerModalState;
}(LedgerModalState || {});
function LedgerModal(_ref) {
  let {
    isOpen,
    noBackdropClose,
    onClose,
    hardwareWallets,
    accounts,
    areSettingsOpen
  } = _ref;
  const {
    afterSelectHardwareWallets
  } = getActions();
  const [currentSlide, setCurrentSlide] = useState(LedgerModalState.Connect);
  const [nextKey] = useState(LedgerModalState.SelectWallets);
  const handleAddLedgerWallet = useLastCallback(() => {
    afterSelectHardwareWallets({
      hardwareSelectedIndices: [hardwareWallets[0].index]
    });
    onClose();
  });
  const handleConnected = useLastCallback(isSingleWallet => {
    if (isSingleWallet) {
      handleAddLedgerWallet();
      return;
    }
    setCurrentSlide(LedgerModalState.SelectWallets);
  });
  const handleLedgerModalClose = useLastCallback(() => {
    setCurrentSlide(LedgerModalState.Connect);
  });
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case LedgerModalState.Connect:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleConnected,
          onClose: onClose
        });
      case LedgerModalState.SelectWallets:
        return /*#__PURE__*/teact.createElement(ledger_LedgerSelectWallets, {
          isActive: isActive,
          accounts: accounts,
          hardwareWallets: hardwareWallets,
          onClose: onClose
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    hasCloseButton: true,
    onClose: onClose,
    onCloseAnimationEnd: handleLedgerModalClose,
    dialogClassName: buildClassName(LedgerModal_module.modalDialog, areSettingsOpen && LedgerModal_module.modalDialogInsideSettings),
    noBackdropClose: noBackdropClose
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: currentSlide,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const ledger_LedgerModal = (memo(withGlobal(global => {
  const accounts = selectNetworkAccounts(global);
  const {
    hardwareWallets
  } = global.hardware;
  return {
    accounts,
    hardwareWallets,
    areSettingsOpen: global.areSettingsOpen
  };
})(LedgerModal)));
;// ./src/components/main/helpers/calcSafeAreaTop.ts






const WINDOWS_OPERA_EXTENSION_EXTRA_HEIGHT = 30;
function calcSafeAreaTop() {
  const {
    safeAreaTop
  } = windowSize.get();
  const {
    safeAreaInset,
    contentSafeAreaInset
  } = src_config/* IS_TELEGRAM_APP */.tKX ? telegram_getTelegramApp() : {};
  return src_config/* IS_CAPACITOR */.UMQ
  // On some iPhones, the result of `getSafeAreaTop` is greater than the result of `getStatusBarHeight`.
  // Also, the CSS `safeAreaTop` value is calculated with an error due to the specifics of NBS.
  // In turn, some Android devices calculate `getSafeAreaTop` slightly less than `safeAreaTop` from CSS.
  // So we need to take the maximum value between `getSafeAreaTop` , `getStatusBarHeight` and `safeAreaTop` from CSS.
  ? Math.max(capacitor_getSafeAreaTop(), getStatusBarHeight(), safeAreaTop) : src_config/* IS_TELEGRAM_APP */.tKX ? safeAreaInset.top + contentSafeAreaInset.top : safeAreaTop + (windowEnvironment/* IS_ELECTRON */.cp && !windowEnvironment/* IS_LINUX */.ig ? ELECTRON_HEADER_HEIGHT_REM * windowEnvironment/* REM */.$ : 0) + (windowEnvironment/* IS_OPERA */.By && windowEnvironment/* IS_WINDOWS */.H8 && src_config/* IS_EXTENSION */.hL1 ? WINDOWS_OPERA_EXTENSION_EXTRA_HEIGHT : 0);
}
;// ./src/hooks/useElementVisibility.ts

function useElementVisibility(options) {
  const {
    rootMargin,
    threshold = [0],
    isDisabled,
    targetRef,
    cb
  } = options;
  const [isVisible, setIsVisible] = useState(true);
  teact_useEffect(() => {
    if (isDisabled || !targetRef.current) return undefined;
    const observer = new IntersectionObserver(entries => {
      const entry = entries[0];
      setIsVisible(entry.isIntersecting);
      cb === null || cb === void 0 || cb(entry);
    }, {
      rootMargin,
      threshold
    });
    observer.observe(targetRef.current);
    return () => {
      observer.disconnect();
    };
  }, [rootMargin, threshold, isDisabled, targetRef, cb]);
  return {
    isVisible
  };
}
;// ./src/hooks/usePreventPinchZoomGesture.ts



const metaViewport = document.querySelector('meta[name="viewport"]');
const defaultViewportContent = (metaViewport === null || metaViewport === void 0 ? void 0 : metaViewport.getAttribute('content')) || '';
const allowedZoomViewportContent = 'width=device-width, initial-scale=1, shrink-to-fit=no, viewport-fit=cover';
function usePreventPinchZoomGesture() {
  let isDisabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF) {
      return undefined;
    }
    if (isDisabled) {
      // Clean viewport content from values that disable the ability to zoom a webpage
      // https://web.dev/meta-viewport/
      metaViewport === null || metaViewport === void 0 || metaViewport.setAttribute('content', allowedZoomViewportContent);
      return undefined;
    }
    metaViewport === null || metaViewport === void 0 || metaViewport.setAttribute('content', defaultViewportContent);

    // Since iOS 10 `user-scaleable=no` is disabled in Safari for iOS,
    // this is only applicable for the browser and does not apply to the PWA mode.
    // https://newbedev.com/how-do-you-disable-viewport-zooming-on-mobile-safari
    if (windowEnvironment/* IS_IOS */.pz && !windowEnvironment/* IS_PWA */._7) {
      document.addEventListener('gesturestart', stopEvent);
    }
    return () => {
      metaViewport === null || metaViewport === void 0 || metaViewport.setAttribute('content', allowedZoomViewportContent);
      if (windowEnvironment/* IS_IOS */.pz && !windowEnvironment/* IS_PWA */._7) {
        document.removeEventListener('gesturestart', stopEvent);
      }
    };
  }, [isDisabled]);
}
;// ./src/components/common/TransactionBanner.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TransactionBanner_module = ({"root":"TransactionBanner-module__root","purple":"TransactionBanner-module__purple","tokenIcon":"TransactionBanner-module__tokenIcon","chainIcon":"TransactionBanner-module__chainIcon","green":"TransactionBanner-module__green","twoIcons":"TransactionBanner-module__twoIcons","nftIcon":"TransactionBanner-module__nftIcon","stacked":"TransactionBanner-module__stacked","image":"TransactionBanner-module__image","text":"TransactionBanner-module__text","bold":"TransactionBanner-module__bold","nftTitle":"TransactionBanner-module__nftTitle","address":"TransactionBanner-module__address"});
;// ./src/components/common/TransactionBanner.tsx








function TransactionBanner(_ref) {
  let {
    tokenIn,
    imageUrl,
    text,
    withChainIcon,
    tokenOut,
    secondText,
    color,
    className
  } = _ref;
  const lang = hooks_useLang();
  const fullClassName = buildClassName(TransactionBanner_module.root, color && TransactionBanner_module[color], tokenOut && TransactionBanner_module.twoIcons, className);
  const isNftTransaction = !!imageUrl;
  const imageUrls = teact_useMemo(() => {
    return (0,iteratees/* unique */.Am)(Array.isArray(imageUrl) ? imageUrl : [imageUrl]);
  }, [imageUrl]);
  function renderNftIcon() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(TransactionBanner_module.nftIcon, Array.isArray(imageUrl) && imageUrl.length > 1 && TransactionBanner_module.stacked)
    }, imageUrls.map(image => /*#__PURE__*/teact.createElement("img", {
      src: image,
      alt: "",
      key: image,
      className: TransactionBanner_module.image
    })), withChainIcon && (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.chain) && /*#__PURE__*/teact.createElement("img", {
      src: getChainNetworkIcon(tokenIn.chain),
      alt: "",
      className: TransactionBanner_module.chainIcon,
      draggable: false
    }));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: fullClassName
  }, tokenIn && !isNftTransaction && /*#__PURE__*/teact.createElement(common_TokenIcon, {
    token: tokenIn,
    withChainIcon: withChainIcon,
    size: "small",
    className: TransactionBanner_module.tokenIcon
  }), isNftTransaction && renderNftIcon(), /*#__PURE__*/teact.createElement("span", {
    className: TransactionBanner_module.text
  }, secondText ? text ? lang('%amount% to %address%', {
    amount: /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(TransactionBanner_module.bold, isNftTransaction && TransactionBanner_module.nftTitle)
    }, text),
    address: /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(TransactionBanner_module.bold, TransactionBanner_module.address)
    }, secondText)
  }) : lang('$transaction_to', {
    address: /*#__PURE__*/teact.createElement("span", {
      className: TransactionBanner_module.bold
    }, secondText)
  }) : /*#__PURE__*/teact.createElement("span", {
    className: TransactionBanner_module.bold
  }, text)), tokenOut && /*#__PURE__*/teact.createElement(common_TokenIcon, {
    token: tokenOut,
    withChainIcon: withChainIcon,
    size: "small",
    className: TransactionBanner_module.tokenIcon
  }));
}
/* harmony default export */ const common_TransactionBanner = (memo(TransactionBanner));
;// ./src/hooks/useQrScannerSupport.ts





let isQrScannerSupported = (0,windowEnvironment/* getIsMobileTelegramApp */.v3)();
function useQrScannerSupport() {
  const forceUpdate = hooks_useForceUpdate();
  hooks_useEffectOnce(() => {
    if (!src_config/* IS_CAPACITOR */.UMQ || isQrScannerSupported) return;
    void BarcodeScanner.isSupported().then(result => {
      isQrScannerSupported = result.supported;
      forceUpdate();
    });
  });
  return isQrScannerSupported;
}
;// ./src/components/transfer/Transfer.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Transfer_module = ({"modalDialog":"Transfer-module__modalDialog","help":"Transfer-module__help","label":"Transfer-module__label","balanceError":"Transfer-module__balanceError","description":"Transfer-module__description","addressWidget":"Transfer-module__addressWidget","inputReadOnly":"Transfer-module__inputReadOnly","inputReadOnly_words":"Transfer-module__inputReadOnly_words","inputReadOnlyWords":"Transfer-module__inputReadOnly_words","currencySymbol":"Transfer-module__currencySymbol","commentInputWrapper":"Transfer-module__commentInputWrapper","sticker":"Transfer-module__sticker","sticker_sizeSmall":"Transfer-module__sticker_sizeSmall","stickerSizeSmall":"Transfer-module__sticker_sizeSmall","buttonLoading":"Transfer-module__buttonLoading","buttonText":"Transfer-module__buttonText","button-loading-spinner":"Transfer-module__button-loading-spinner","buttonLoadingSpinner":"Transfer-module__button-loading-spinner","savedAddressBubble":"Transfer-module__savedAddressBubble","savedAddressItem":"Transfer-module__savedAddressItem","savedAddressName":"Transfer-module__savedAddressName","savedAddressNameText":"Transfer-module__savedAddressNameText","iconLedger":"Transfer-module__iconLedger","savedAddressAddress":"Transfer-module__savedAddressAddress","savedAddressDelete":"Transfer-module__savedAddressDelete","savedAddressDeleteInner":"Transfer-module__savedAddressDeleteInner","savedAddressDeleteIcon":"Transfer-module__savedAddressDeleteIcon","chainIcon":"Transfer-module__chainIcon","inputStatic":"Transfer-module__inputStatic","inputWithIcon":"Transfer-module__inputWithIcon","footer":"Transfer-module__footer","footer_shifted":"Transfer-module__footer_shifted","footerShifted":"Transfer-module__footer_shifted","buttons":"Transfer-module__buttons","button":"Transfer-module__button","warningTooltipContainer":"Transfer-module__warningTooltipContainer","transactionBanner":"Transfer-module__transactionBanner","infoBox":"Transfer-module__infoBox","burnWarning":"Transfer-module__burnWarning","error":"Transfer-module__error","spinner":"Transfer-module__spinner","formSlide":"Transfer-module__formSlide","formSlide_static":"Transfer-module__formSlide_static","formSlideStatic":"Transfer-module__formSlide_static"});
;// ./src/components/ui/AddressBookItem.tsx






function AddressBookItem(_ref) {
  let {
    address,
    name,
    chain,
    isHardware,
    isSavedAddress,
    deleteLabel,
    onClick,
    onDeleteClick
  } = _ref;
  const handleClick = () => {
    onClick(address);
  };
  const handleDeleteClick = e => {
    stopEvent(e);
    onDeleteClick(address);
  };
  return /*#__PURE__*/teact.createElement("div", {
    tabIndex: -1,
    role: "button",
    onMouseDown: windowEnvironment/* IS_TOUCH_ENV */.TF ? undefined : handleClick,
    onClick: windowEnvironment/* IS_TOUCH_ENV */.TF ? handleClick : undefined,
    className: Transfer_module.savedAddressItem
  }, /*#__PURE__*/teact.createElement("span", {
    className: Transfer_module.savedAddressName
  }, /*#__PURE__*/teact.createElement("span", {
    className: Transfer_module.savedAddressNameText
  }, name || (0,shortenAddress/* shortenAddress */.W)(address)), isHardware && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Transfer_module.iconLedger, 'icon-ledger'),
    "aria-hidden": true
  })), isSavedAddress && onDeleteClick && /*#__PURE__*/teact.createElement("span", {
    className: Transfer_module.savedAddressDelete
  }, /*#__PURE__*/teact.createElement("span", {
    tabIndex: -1,
    role: "button",
    className: Transfer_module.savedAddressDeleteInner,
    onMouseDown: handleDeleteClick
  }, deleteLabel)), name && /*#__PURE__*/teact.createElement("span", {
    className: Transfer_module.savedAddressAddress
  }, chain && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Transfer_module.chainIcon, `icon-chain-${chain}`),
    "aria-hidden": true
  }), (0,shortenAddress/* shortenAddress */.W)(address)), isSavedAddress && onDeleteClick && /*#__PURE__*/teact.createElement("span", {
    className: Transfer_module.savedAddressDeleteIcon,
    role: "button",
    tabIndex: -1,
    onMouseDown: handleDeleteClick,
    onClick: stopEvent,
    "aria-label": deleteLabel
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-trash",
    "aria-hidden": true
  })));
}
/* harmony default export */ const ui_AddressBookItem = (memo(AddressBookItem));
;// ./src/components/ui/AddressBook.tsx









function AddressBook(_ref) {
  let {
    isOpen,
    currentChain,
    currentAddress = '',
    otherAccountIds,
    accounts,
    savedAddresses,
    isMultichainAccount,
    onAddressSelect,
    onSavedAddressDelete,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const renderedSavedAddresses = teact_useMemo(() => {
    if (!savedAddresses || savedAddresses.length === 0) {
      return undefined;
    }
    return savedAddresses.filter(item => {
      return (!currentChain || item.chain === currentChain) && doesSavedAddressFitSearch(item, currentAddress);
    }).map(item => /*#__PURE__*/teact.createElement(ui_AddressBookItem, {
      key: `saved-${item.address}-${item.chain}`,
      address: item.address,
      name: item.name,
      chain: isMultichainAccount ? item.chain : undefined,
      deleteLabel: lang('Delete'),
      isSavedAddress: true,
      onClick: onAddressSelect,
      onDeleteClick: onSavedAddressDelete
    }));
  }, [currentAddress, isMultichainAccount, currentChain, lang, onAddressSelect, onSavedAddressDelete, savedAddresses]);
  const renderedOtherAccounts = teact_useMemo(() => {
    if (!otherAccountIds || otherAccountIds.length === 0) return undefined;
    const addressesToBeIgnored = (savedAddresses === null || savedAddresses === void 0 ? void 0 : savedAddresses.map(item => `${item.chain}:${item.address}`)) ?? [];
    const uniqueAddresses = new Set();
    const otherAccounts = otherAccountIds.reduce((acc, accountId) => {
      const account = accounts[accountId];
      Object.keys(account.addressByChain).forEach(addressChain => {
        const address = account.addressByChain[addressChain];
        const key = `${addressChain}:${address}`;
        if (address && !uniqueAddresses.has(key) && (!currentChain || addressChain === currentChain) && (isMultichainAccount || addressChain === src_config/* TONCOIN */.Tu9.chain) && !addressesToBeIgnored.includes(`${addressChain}:${address}`)) {
          uniqueAddresses.add(key);
          acc.push({
            name: account.title || (0,shortenAddress/* shortenAddress */.W)(address),
            address,
            chain: addressChain,
            isHardware: account.type === 'hardware'
          });
        }
      });
      return acc;
    }, []);
    return otherAccounts.filter(item => doesSavedAddressFitSearch(item, currentAddress)).map(_ref2 => {
      let {
        address,
        name,
        chain: addressChain,
        isHardware
      } = _ref2;
      return /*#__PURE__*/teact.createElement(ui_AddressBookItem, {
        key: `address-${address}-${addressChain}`,
        address: address,
        name: name,
        chain: isMultichainAccount ? addressChain : undefined,
        isHardware: isHardware,
        onClick: onAddressSelect
      });
    });
  }, [otherAccountIds, savedAddresses, accounts, currentChain, isMultichainAccount, currentAddress, onAddressSelect]);
  const shouldRender = Boolean((renderedOtherAccounts === null || renderedOtherAccounts === void 0 ? void 0 : renderedOtherAccounts.length) || (renderedSavedAddresses === null || renderedSavedAddresses === void 0 ? void 0 : renderedSavedAddresses.length));
  if (!shouldRender) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement(ui_Menu, {
    positionX: "right",
    type: "suggestion",
    noBackdrop: true,
    bubbleClassName: Transfer_module.savedAddressBubble,
    isOpen: isOpen,
    onClose: onClose
  }, renderedSavedAddresses, renderedOtherAccounts);
}
/* harmony default export */ const ui_AddressBook = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  return {
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    accounts: selectNetworkAccounts(global)
  };
})(AddressBook)));
function doesSavedAddressFitSearch(savedAddress, search) {
  const searchQuery = search.toLowerCase();
  const {
    address,
    name
  } = savedAddress;
  return address.toLowerCase().startsWith(searchQuery) || address.toLowerCase().endsWith(searchQuery) || name.toLowerCase().split(/\s+/).some(part => part.startsWith(searchQuery));
}
;// ./src/components/ui/AddressInput.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddressInput_module = ({"inputButtonWrapper":"AddressInput-module__inputButtonWrapper","inputButtonWrapperWithFocus":"AddressInput-module__inputButtonWrapperWithFocus","inputButton":"AddressInput-module__inputButton","inputButtonClear":"AddressInput-module__inputButtonClear","inputButtonTransition":"AddressInput-module__inputButtonTransition","addressName":"AddressInput-module__addressName","addressValue":"AddressInput-module__addressValue","addressValueSingle":"AddressInput-module__addressValueSingle","inputStatic":"AddressInput-module__inputStatic","inputWithIcon":"AddressInput-module__inputWithIcon"});
;// ./src/components/ui/AddressInput.tsx





















const INPUT_CLEAR_BUTTON_ID = 'input-clear-button';
const SHORT_ADDRESS_SHIFT = 4;
const SHORT_SINGLE_ADDRESS_SHIFT = 11;
const MIN_ADDRESS_LENGTH_TO_SHORTEN = SHORT_SINGLE_ADDRESS_SHIFT * 2;
const SAVED_ADDRESS_OPEN_DELAY = 300;
function AddressInput(_ref) {
  let {
    ref,
    label,
    value,
    chain,
    isStatic,
    withQrScan,
    address,
    addressName,
    addressBookChain,
    accounts,
    currentAccountId,
    savedAddresses,
    validateAddress,
    error,
    onInput,
    onClose
  } = _ref;
  const {
    showNotification,
    requestOpenQrScanner
  } = getActions();
  const lang = hooks_useLang();
  const addressBookTimeoutRef = teact_useRef();
  const [addressForDeletion, setAddressForDeletion] = useState();
  const [chainForDeletion, setChainForDeletion] = useState();
  const [isAddressBookOpen, openAddressBook, closeAddressBook] = hooks_useFlag();
  const [isFocused, markFocused, unmarkFocused] = hooks_useFlag();
  const [shouldRenderPasteButton, setShouldRenderPasteButton] = useState(windowEnvironment/* IS_CLIPBOARDS_SUPPORTED */.Et);
  const isQrScannerSupported = useQrScannerSupport();
  const inputId = useUniqueId('address-');
  const isAddressValid = chain ? isValidAddressOrDomain(value, chain) : undefined;
  const hasAddressError = value.length > 0 && !isAddressValid;
  const localError = hasAddressError ? lang('Incorrect address') : undefined;
  const addressBookAccountIds = teact_useMemo(() => {
    return accounts ? Object.keys(accounts).filter(accountId => accountId !== currentAccountId) : [];
  }, [currentAccountId, accounts]);
  const shouldUseAddressBook = teact_useMemo(() => {
    return addressBookAccountIds.length > 0 || savedAddresses && savedAddresses.length > 0;
  }, [addressBookAccountIds.length, savedAddresses]);
  const localAddressName = teact_useMemo(() => {
    return chain && value ? getLocalAddressName({
      address: value,
      chain,
      currentAccountId,
      savedAddresses,
      accounts: accounts
    }) : undefined;
  }, [accounts, chain, currentAccountId, savedAddresses, value]);
  const withPasteButton = shouldRenderPasteButton && !value;
  const withQrButton = withQrScan && isQrScannerSupported;
  const withButton = withQrButton || withPasteButton || !!value.length;
  hooks_useEffectOnce(() => {
    return () => {
      if (addressBookTimeoutRef.current) {
        window.clearTimeout(addressBookTimeoutRef.current);
      }
    };
  });
  const addressOverlay = teact_useMemo(() => {
    if (!address) return undefined;
    const renderedAddressName = localAddressName || addressName;
    const addressShort = !renderedAddressName && address.length > MIN_ADDRESS_LENGTH_TO_SHORTEN ? (0,shortenAddress/* shortenAddress */.W)(address, SHORT_SINGLE_ADDRESS_SHIFT) || '' : address;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderedAddressName && /*#__PURE__*/teact.createElement("span", {
      className: AddressInput_module.addressName
    }, renderedAddressName), /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(AddressInput_module.addressValue, !renderedAddressName && AddressInput_module.addressValueSingle)
    }, renderedAddressName ? (0,shortenAddress/* shortenAddress */.W)(address, SHORT_ADDRESS_SHIFT) : addressShort));
  }, [address, localAddressName, addressName]);
  const handlePasteClick = useLastCallback(async () => {
    try {
      const {
        type,
        text
      } = await readClipboardContent();
      if (type === 'text/plain') {
        const newValue = text.trim();
        onInput(newValue, true);
        handleAddressCheck(newValue);
      }
    } catch (err) {
      showNotification({
        message: lang('Error reading clipboard')
      });
      setShouldRenderPasteButton(false);
    }
  });
  const handleQrScanClick = useLastCallback(() => {
    if (windowEnvironment/* IS_IOS */.pz && (0,windowEnvironment/* getIsMobileTelegramApp */.v3)()) {
      alert('Scanning is temporarily not available');
      return;
    }
    requestOpenQrScanner();
    onClose();
  });
  const handleAddressCheck = useLastCallback(address => {
    if (!validateAddress) return;
    if (address && chain && isValidAddressOrDomain(address, chain) || !address) {
      validateAddress({
        address
      });
    }
  });
  const handleAddressFocus = useLastCallback(() => {
    markFocused();
    if (shouldUseAddressBook) {
      // Simultaneous opening of the virtual keyboard and display of Saved Addresses causes animation degradation
      if (windowEnvironment/* IS_ANDROID */.Ni) {
        addressBookTimeoutRef.current = window.setTimeout(openAddressBook, SAVED_ADDRESS_OPEN_DELAY);
      } else {
        openAddressBook();
      }
    }
  });
  const handleAddressBlur = useLastCallback(e => {
    var _e$relatedTarget;
    unmarkFocused();
    if (((_e$relatedTarget = e.relatedTarget) === null || _e$relatedTarget === void 0 ? void 0 : _e$relatedTarget.id) === INPUT_CLEAR_BUTTON_ID) {
      handleAddressBookClose();
      handleAddressCheck(value);
      return;
    }
    let addressToCheck = value;
    if (isDnsDomain(value) && value !== value.toLowerCase()) {
      addressToCheck = value.toLowerCase().trim();
      onInput(addressToCheck);
    } else if (value !== value.trim()) {
      addressToCheck = value.trim();
      onInput(addressToCheck);
    }
    requestAnimationFrame(() => {
      handleAddressBookClose();
      handleAddressCheck(addressToCheck);
    });
  });
  const handleAddressClear = useLastCallback(() => {
    onInput('');
    handleAddressCheck();
  });
  const handleAddressBookClose = useLastCallback(() => {
    if (!shouldUseAddressBook || !isAddressBookOpen) return;
    closeAddressBook();
    if (addressBookTimeoutRef.current) {
      window.clearTimeout(addressBookTimeoutRef.current);
    }
  });
  const handleDeleteSavedAddressClick = useLastCallback(address => {
    setAddressForDeletion(address);
    setChainForDeletion(chain);
    closeAddressBook();
  });
  const handleDeleteSavedAddressModalClose = useLastCallback(() => {
    setAddressForDeletion(undefined);
    setChainForDeletion(undefined);
  });
  const handleAddressBookItemSelect = useLastCallback(address => {
    onInput(address, true);
    closeAddressBook();
  });
  function renderInputActions() {
    const wrapperClassName = buildClassName(AddressInput_module.inputButtonWrapper, isFocused && AddressInput_module.inputButtonWrapperWithFocus);
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      className: AddressInput_module.inputButtonTransition,
      activeKey: value.length ? 0 : 1,
      name: "fade"
    }, value.length ? /*#__PURE__*/teact.createElement("div", {
      className: wrapperClassName
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      id: INPUT_CLEAR_BUTTON_ID,
      className: buildClassName(AddressInput_module.inputButton, AddressInput_module.inputButtonClear),
      onClick: handleAddressClear,
      ariaLabel: lang('Clear')
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-close-filled",
      "aria-hidden": true
    }))) : /*#__PURE__*/teact.createElement("div", {
      className: wrapperClassName
    }, withQrButton && /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      className: AddressInput_module.inputButton,
      onClick: handleQrScanClick,
      ariaLabel: lang('Scan QR Code')
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-qr-scanner-alt",
      "aria-hidden": true
    })), withPasteButton && /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      className: AddressInput_module.inputButton,
      onClick: handlePasteClick,
      ariaLabel: lang('Paste')
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-paste",
      "aria-hidden": true
    }))));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Input, {
    id: inputId,
    ref: ref,
    className: buildClassName(isStatic && AddressInput_module.inputStatic, withButton && AddressInput_module.inputWithIcon),
    isRequired: true,
    isStatic: isStatic,
    label: label,
    placeholder: lang('Wallet address or domain'),
    value: value,
    error: localError || error,
    autoCorrect: false,
    valueOverlay: !localError ? addressOverlay : undefined,
    onInput: onInput,
    onFocus: handleAddressFocus,
    onBlur: handleAddressBlur
  }, renderInputActions()), shouldUseAddressBook && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AddressBook, {
    isOpen: isAddressBookOpen,
    currentChain: addressBookChain,
    currentAddress: value,
    otherAccountIds: addressBookAccountIds,
    onAddressSelect: handleAddressBookItemSelect,
    onSavedAddressDelete: handleDeleteSavedAddressClick,
    onClose: closeAddressBook
  }), /*#__PURE__*/teact.createElement(modals_DeleteSavedAddressModal, {
    isOpen: Boolean(addressForDeletion),
    address: addressForDeletion,
    chain: chainForDeletion,
    onClose: handleDeleteSavedAddressModalClose
  })));
}
/* harmony default export */ const ui_AddressInput = (memo(AddressInput));
;// ./src/components/domain/RenewDomainModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const RenewDomainModal_module = ({"modalDialog":"RenewDomainModal-module__modalDialog","modalTitle":"RenewDomainModal-module__modalTitle","headerTitle":"RenewDomainModal-module__headerTitle","headerDate":"RenewDomainModal-module__headerDate","sticker":"RenewDomainModal-module__sticker","transactionBanner":"RenewDomainModal-module__transactionBanner","nftContainer":"RenewDomainModal-module__nftContainer","multiNftChips":"RenewDomainModal-module__multiNftChips","footer":"RenewDomainModal-module__footer","button":"RenewDomainModal-module__button","buttons":"RenewDomainModal-module__buttons","buttonsAfterNft":"RenewDomainModal-module__buttonsAfterNft"});
;// ./src/components/domain/LinkingDomainModal.tsx




























const FULL_NATIVE_STATES = new Set([DomainLinkingState.Password, DomainLinkingState.ConnectHardware, DomainLinkingState.ConfirmHardware]);
function LinkingDomainModal(_ref) {
  let {
    currentDomainLinking: {
      address,
      state,
      error,
      isLoading,
      realFee,
      walletAddress = '',
      walletAddressName = '',
      resolvedWalletAddress,
      txId
    },
    isMediaViewerOpen,
    byAddress,
    tonBalance,
    accounts,
    savedAddresses,
    currentTonAddress,
    currentLinkedWalletAddress
  } = _ref;
  const {
    startDomainLinking,
    cancelDomainLinking,
    clearDomainLinkingError,
    submitDomainLinking,
    checkDomainLinkingDraft,
    checkLinkingAddress,
    setDomainLinkingWalletAddress,
    showActivityInfo
  } = getActions();
  const lang = hooks_useLang();
  const isOpen = state !== DomainLinkingState.None && !isMediaViewerOpen;
  const {
    renderingKey,
    nextKey
  } = useModalTransitionKeys(state ?? 0, isOpen);
  const domainNft = address ? byAddress === null || byAddress === void 0 ? void 0 : byAddress[address] : undefined;
  const isInsufficientBalance = realFee ? tonBalance < realFee : undefined;
  const forceFullNative = FULL_NATIVE_STATES.has(renderingKey);
  const feeTerms = teact_useMemo(() => realFee ? {
    native: realFee
  } : undefined, [realFee]);
  const modalTitle = currentLinkedWalletAddress ? 'Change Linked Wallet' : 'Link to Wallet';
  const isAddressValid = isValidAddressOrDomain(walletAddress, 'ton');
  const handleWalletAddressInput = useLastCallback(newToAddress => {
    setDomainLinkingWalletAddress({
      address: newToAddress
    });
  });
  const canSubmit = isAddressValid && walletAddress !== currentLinkedWalletAddress && !isInsufficientBalance && !isLoading;
  useSyncEffectWithPrevDeps(_ref2 => {
    let [prevIsOpen] = _ref2;
    if (!prevIsOpen && isOpen) {
      handleWalletAddressInput(walletAddress || currentLinkedWalletAddress || currentTonAddress);
    }
  }, [isOpen, currentLinkedWalletAddress, walletAddress, currentTonAddress]);
  teact_useEffect(() => {
    if (isOpen) {
      checkDomainLinkingDraft({
        nft: domainNft
      });
    }
  }, [domainNft, isOpen]);
  const handlePasswordSubmit = useLastCallback(password => {
    if (canSubmit) {
      submitDomainLinking({
        password
      });
    }
  });
  const handleHardwareSubmit = useLastCallback(() => {
    if (canSubmit) {
      submitDomainLinking();
    }
  });
  const handleInfoClick = useLastCallback(() => {
    cancelDomainLinking();
    showActivityInfo({
      id: txId
    });
  });
  function renderInitialContent() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang(modalTitle),
      onClose: cancelDomainLinking
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement("div", {
      className: RenewDomainModal_module.nftContainer
    }, /*#__PURE__*/teact.createElement(transfer_NftInfo, {
      nft: domainNft,
      withMediaViewer: true
    }), /*#__PURE__*/teact.createElement(ui_AddressInput, {
      withQrScan: true,
      value: walletAddress
      // It is necessary to allow linking of current wallet address to the domain, so pass an empty string
      ,
      currentAccountId: ""
      // Domain linking is available only for TON blockchain
      ,
      addressBookChain: "ton",
      chain: "ton",
      accounts: accounts,
      savedAddresses: savedAddresses,
      validateAddress: checkLinkingAddress,
      label: currentLinkedWalletAddress ? lang('Linked Wallet') : lang('Wallet'),
      address: resolvedWalletAddress || walletAddress,
      addressName: walletAddressName,
      onInput: handleWalletAddressInput,
      onClose: cancelDomainLinking
    })), /*#__PURE__*/teact.createElement(ui_FeeLine, {
      terms: feeTerms,
      token: src_config/* TONCOIN */.Tu9,
      precision: "exact"
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.buttons, RenewDomainModal_module.footer)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isDestructive: isInsufficientBalance,
      isDisabled: !canSubmit,
      isLoading: !realFee || isLoading,
      className: RenewDomainModal_module.button,
      onClick: startDomainLinking
    }, isInsufficientBalance ? lang('Insufficient Balance') : lang('Link')))));
  }
  function renderPasswordForm(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm Linking'),
      onClose: cancelDomainLinking
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      error: error,
      isLoading: isLoading,
      submitLabel: lang('Confirm'),
      cancelLabel: lang('Cancel'),
      onSubmit: handlePasswordSubmit,
      onCancel: cancelDomainLinking,
      onUpdate: clearDomainLinkingError,
      skipAuthScreen: true
    }, /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      imageUrl: domainNft === null || domainNft === void 0 ? void 0 : domainNft.thumbnail,
      text: (domainNft === null || domainNft === void 0 ? void 0 : domainNft.name) ?? '1 domain',
      className: !getDoesUsePinPad() ? RenewDomainModal_module.transactionBanner : undefined
    })));
  }
  function renderComplete(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Domain has been linked!'),
      onClose: cancelDomainLinking
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      noLoop: false,
      nonInteractive: true,
      className: RenewDomainModal_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
      previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
    }), /*#__PURE__*/teact.createElement(transfer_NftInfo, {
      nft: domainNft,
      withMediaViewer: true
    }), !!txId && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(RenewDomainModal_module.buttons, RenewDomainModal_module.buttonsAfterNft)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleInfoClick
    }, lang('Details'))), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: RenewDomainModal_module.button,
      onClick: cancelDomainLinking,
      isPrimary: true
    }, lang('Close')))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case DomainLinkingState.Initial:
        return renderInitialContent();
      case DomainLinkingState.Password:
        return renderPasswordForm(isActive);
      case DomainLinkingState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleHardwareSubmit,
          onClose: cancelDomainLinking
        });
      case DomainLinkingState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onClose: cancelDomainLinking,
          onTryAgain: handleHardwareSubmit
        });
      case DomainLinkingState.Complete:
        return renderComplete(isActive);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    nativeBottomSheetKey: "link-domain",
    forceFullNative: forceFullNative,
    dialogClassName: RenewDomainModal_module.modalDialog,
    onClose: cancelDomainLinking
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const domain_LinkingDomainModal = (memo(withGlobal(global => {
  const {
    currentDomainLinking,
    mediaViewer: {
      mediaId
    }
  } = global;
  const currentAccount = selectCurrentAccount(global);
  const accountState = selectCurrentAccountState(global);
  const {
    byAddress
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {};
  const domainNft = currentDomainLinking.address ? byAddress === null || byAddress === void 0 ? void 0 : byAddress[currentDomainLinking.address] : undefined;
  const currentLinkedWalletAddress = domainNft ? selectTonDnsLinkedAddress(global, domainNft) : '';
  return {
    isMediaViewerOpen: Boolean(mediaId),
    currentDomainLinking,
    byAddress,
    tonBalance: selectCurrentToncoinBalance(global),
    accounts: selectNetworkAccounts(global),
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    currentLinkedWalletAddress,
    currentTonAddress: currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.addressByChain.ton
  };
})(LinkingDomainModal)));
;// ./src/components/transfer/NftChips.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const NftChips_module = ({"root":"NftChips-module__root","static":"NftChips-module__static","nft":"NftChips-module__nft","image":"NftChips-module__image","name":"NftChips-module__name","expander":"NftChips-module__expander"});
;// ./src/components/transfer/NftChips.tsx





const LIMIT = 10;
function NftChips(_ref) {
  let {
    nfts,
    isStatic,
    className
  } = _ref;
  const lang = hooks_useLang();
  const [isCollapsed,, expand] = hooks_useFlag(true);
  const shouldRenderExpander = isCollapsed && nfts.length > LIMIT + 1;
  const renderedNfts = teact_useMemo(() => shouldRenderExpander ? nfts.slice(0, LIMIT) : nfts, [shouldRenderExpander, nfts]);
  function renderNft(nft) {
    return /*#__PURE__*/teact.createElement("div", {
      key: nft.address,
      className: NftChips_module.nft
    }, /*#__PURE__*/teact.createElement("img", {
      src: nft.thumbnail,
      alt: nft.name,
      className: NftChips_module.image
    }), /*#__PURE__*/teact.createElement("span", {
      className: NftChips_module.name
    }, nft.name || nft.address));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(NftChips_module.root, isStatic && NftChips_module.static, 'custom-scroll', className)
  }, renderedNfts.map(renderNft), shouldRenderExpander && /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: NftChips_module.expander,
    onClick: () => expand()
  }, "+", lang('%amount% NFTs', {
    amount: nfts.length - LIMIT
  })));
}
/* harmony default export */ const transfer_NftChips = (memo(NftChips));
;// ./src/components/domain/RenewDomainModal.tsx





























const RenewDomainModal_FULL_NATIVE_STATES = new Set([DomainRenewalState.Password, DomainRenewalState.ConnectHardware, DomainRenewalState.ConfirmHardware]);
const THUMBNAILS_COUNT = 3;
function RenewDomainModal(_ref) {
  let {
    currentDomainRenewal: {
      addresses,
      state,
      error,
      isLoading,
      realFee,
      txId
    },
    isMediaViewerOpen,
    byAddress,
    tonBalance
  } = _ref;
  const {
    startDomainsRenewal,
    cancelDomainsRenewal,
    clearDomainsRenewalError,
    submitDomainsRenewal,
    checkDomainsRenewalDraft,
    showActivityInfo
  } = getActions();
  const lang = hooks_useLang();
  const forceUpdate = hooks_useForceUpdate();
  const isOpen = state !== DomainRenewalState.None && !isMediaViewerOpen;
  const {
    renderingKey,
    nextKey
  } = useModalTransitionKeys(state ?? 0, isOpen);
  const domainNfts = teact_useMemo(() => {
    return (addresses || []).map(address => byAddress === null || byAddress === void 0 ? void 0 : byAddress[address]).filter(Boolean);
  }, [addresses, byAddress]);
  const isInsufficientBalance = realFee ? tonBalance < realFee : undefined;
  const forceFullNative = RenewDomainModal_FULL_NATIVE_STATES.has(renderingKey);
  const feeTerms = teact_useMemo(() => realFee ? {
    native: realFee
  } : undefined, [realFee]);
  const newExpireTimestamp = Date.now() + dateFormat/* YEAR */.UX;
  const domainNftThumbnails = teact_useMemo(() => {
    return domainNfts.map(nft => nft === null || nft === void 0 ? void 0 : nft.thumbnail).filter(Boolean).slice(0, THUMBNAILS_COUNT);
  }, [domainNfts]);
  hooks_useInterval(forceUpdate, isOpen ? dateFormat/* MINUTE */.pY : undefined, true);
  teact_useEffect(() => {
    if (isOpen) {
      checkDomainsRenewalDraft({
        nfts: domainNfts
      });
    }
  }, [domainNfts, isOpen]);
  const handlePasswordSubmit = useLastCallback(password => {
    submitDomainsRenewal({
      password
    });
  });
  const handleHardwareSubmit = useLastCallback(() => {
    submitDomainsRenewal();
  });
  const handleInfoClick = useLastCallback(() => {
    cancelDomainsRenewal();
    showActivityInfo({
      id: txId
    });
  });
  function renderHeader() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.header, Modal_module.header_wideContent)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.title, RenewDomainModal_module.modalTitle)
    }, /*#__PURE__*/teact.createElement("div", {
      className: RenewDomainModal_module.headerTitle
    }, lang(addresses && addresses.length > 1 ? 'Renew Domains' : 'Renew Domain')), !!newExpireTimestamp && /*#__PURE__*/teact.createElement("div", {
      className: RenewDomainModal_module.headerDate
    }, lang('Until %date%', {
      date: [(0,dateFormat/* formatFullDay */.TK)(lang.code, newExpireTimestamp), (0,dateFormat/* formatTime */.fU)(newExpireTimestamp)].join(', ')
    }))), /*#__PURE__*/teact.createElement(ui_Button, {
      isRound: true,
      className: Modal_module.closeButton,
      ariaLabel: lang('Close'),
      onClick: cancelDomainsRenewal
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Modal_module.closeIcon, 'icon-close'),
      "aria-hidden": true
    })));
  }
  function renderInitialContent() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement("div", {
      className: RenewDomainModal_module.nftContainer
    }, domainNfts.length === 1 && /*#__PURE__*/teact.createElement(transfer_NftInfo, {
      nft: domainNfts[0],
      withMediaViewer: true
    }), domainNfts.length > 1 && /*#__PURE__*/teact.createElement(transfer_NftChips, {
      nfts: domainNfts,
      className: RenewDomainModal_module.multiNftChips
    })), /*#__PURE__*/teact.createElement(ui_FeeLine, {
      terms: feeTerms,
      token: src_config/* TONCOIN */.Tu9,
      precision: "exact"
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.buttons, RenewDomainModal_module.footer)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isDestructive: isInsufficientBalance,
      isDisabled: isInsufficientBalance,
      isLoading: !realFee || isLoading,
      className: RenewDomainModal_module.button,
      onClick: startDomainsRenewal
    }, isInsufficientBalance ? lang('Insufficient Balance') : domainNfts.length > 1 ? lang('Renew All') : lang('Renew'))));
  }
  function renderPasswordForm(isActive) {
    var _domainNfts$, _domainNfts$2;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm Renewing'),
      onClose: cancelDomainsRenewal
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      error: error,
      isLoading: isLoading,
      submitLabel: lang('Confirm'),
      cancelLabel: lang('Cancel'),
      onSubmit: handlePasswordSubmit,
      onCancel: cancelDomainsRenewal,
      onUpdate: clearDomainsRenewalError,
      skipAuthScreen: true
    }, /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      imageUrl: domainNftThumbnails,
      text: domainNfts.length === 1 && Boolean((_domainNfts$ = domainNfts[0]) === null || _domainNfts$ === void 0 ? void 0 : _domainNfts$.name) ? (_domainNfts$2 = domainNfts[0]) === null || _domainNfts$2 === void 0 ? void 0 : _domainNfts$2.name : lang('$domains_amount %1$d', domainNfts.length, 'i'),
      className: !getDoesUsePinPad() ? RenewDomainModal_module.transactionBanner : undefined
    })));
  }
  function renderComplete(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: domainNfts.length > 1 ? lang('Domains have been renewed!') : lang('Domain has been renewed!'),
      onClose: cancelDomainsRenewal
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      noLoop: false,
      nonInteractive: true,
      className: RenewDomainModal_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
      previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
    }), /*#__PURE__*/teact.createElement("div", {
      className: RenewDomainModal_module.nftContainer
    }, domainNfts.length === 1 && /*#__PURE__*/teact.createElement(transfer_NftInfo, {
      nft: domainNfts[0],
      withMediaViewer: true
    }), domainNfts.length > 1 && /*#__PURE__*/teact.createElement(transfer_NftChips, {
      nfts: domainNfts
    }), domainNfts.length === 1 && !!txId && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(RenewDomainModal_module.buttons, RenewDomainModal_module.buttonsAfterNft)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleInfoClick
    }, lang('Details')))), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: cancelDomainsRenewal,
      isPrimary: true
    }, lang('Close')))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case DomainRenewalState.Initial:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderHeader(), renderInitialContent());
      case DomainRenewalState.Password:
        return renderPasswordForm(isActive);
      case DomainRenewalState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleHardwareSubmit,
          onClose: cancelDomainsRenewal
        });
      case DomainRenewalState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onClose: cancelDomainsRenewal,
          onTryAgain: handleHardwareSubmit
        });
      case DomainRenewalState.Complete:
        return renderComplete(isActive);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    nativeBottomSheetKey: "renew-domain",
    forceFullNative: forceFullNative,
    dialogClassName: RenewDomainModal_module.modalDialog,
    onClose: cancelDomainsRenewal
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const domain_RenewDomainModal = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  const {
    currentDomainRenewal,
    mediaViewer: {
      mediaId
    }
  } = global;
  const {
    byAddress
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  return {
    isMediaViewerOpen: Boolean(mediaId),
    currentDomainRenewal,
    byAddress,
    tonBalance: selectCurrentToncoinBalance(global)
  };
})(RenewDomainModal)));
;// ./src/util/ton/formatTransferUrl.ts
// https://github.com/toncenter/tonweb/blob/944455da2effaa307a2030d00e19a37e6e94897c/src/utils/index.js#L94-L109
function formatTransferUrl(address, amount, text, jettonAddress) {
  const url = `ton://transfer/${address}`;
  const params = [];
  if (amount) {
    params.push(`amount=${amount}`);
  }
  if (text) {
    params.push(`text=${encodeURIComponent(text)}`);
  }
  if (jettonAddress) {
    params.push(`jetton=${encodeURIComponent(jettonAddress)}`);
  }
  if (params.length === 0) return url;
  return `${url}?${params.join('&')}`;
}
;// ./src/components/common/SelectTokenButton.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SelectTokenButton_module = ({"wrapper":"SelectTokenButton-module__wrapper","slide":"SelectTokenButton-module__slide","button":"SelectTokenButton-module__button","tokenIcon":"SelectTokenButton-module__tokenIcon","content":"SelectTokenButton-module__content","chevronIcon":"SelectTokenButton-module__chevronIcon"});
;// ./src/components/common/SelectTokenButton.tsx









function SelectTokenButton(_ref) {
  let {
    token,
    className,
    noChainIcon,
    onClick
  } = _ref;
  const {
    transitionRef
  } = useSelectorWidth(token);
  const buttonTransitionKeyRef = teact_useRef(0);
  const buttonStateStr = `${token === null || token === void 0 ? void 0 : token.symbol}_${token === null || token === void 0 ? void 0 : token.chain}`;
  useSyncEffect(() => {
    buttonTransitionKeyRef.current++;
  }, [buttonStateStr]);
  function handleClick(e) {
    stopEvent(e);
    onClick();
  }
  function renderToken(tokenToRender) {
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      ref: transitionRef,
      name: "fade",
      activeKey: buttonTransitionKeyRef.current,
      className: buildClassName(SelectTokenButton_module.wrapper, className),
      slideClassName: SelectTokenButton_module.slide
    }, /*#__PURE__*/teact.createElement("button", {
      type: "button",
      className: SelectTokenButton_module.button,
      onClick: handleClick
    }, tokenToRender && /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: tokenToRender,
      withChainIcon: !noChainIcon,
      size: "middle",
      className: SelectTokenButton_module.tokenIcon
    }), /*#__PURE__*/teact.createElement("div", {
      className: SelectTokenButton_module.content
    }, /*#__PURE__*/teact.createElement("span", null, tokenToRender === null || tokenToRender === void 0 ? void 0 : tokenToRender.symbol), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName('icon-chevron-right', SelectTokenButton_module.chevronIcon),
      "aria-hidden": true
    }))));
  }
  return renderToken(token);
}
/* harmony default export */ const common_SelectTokenButton = (memo(SelectTokenButton));
const BUTTON_WIDTH = 70 / windowEnvironment/* REM */.$;
const CHARACTER_WIDTH = 10;
function useSelectorWidth(token) {
  const transitionRef = teact_useRef();
  useLayoutEffect(() => {
    if (!transitionRef.current || !token) return;
    const symbolWidth = token.symbol.length * CHARACTER_WIDTH / windowEnvironment/* REM */.$;
    const minWidth = `${symbolWidth + BUTTON_WIDTH}rem`;
    setExtraStyles(transitionRef.current, {
      minWidth
    });
  }, [token]);
  return {
    transitionRef
  };
}
;// ./src/util/swap/getChainNetworkName.ts
const NETWORK_NAMES_EXCEPTIONS = {
  binance_smart_chain: 'Binance Smart Chain',
  internet_computer: 'Internet Computer',
  ethereum_classic: 'Ethereum Classic',
  bitcoin_cash: 'Bitcoin Cash',
  binance_dex: 'Binance Dex',
  ton: 'TON',
  bitcoin: 'Bitcoin',
  ethereum: 'Ethereum',
  solana: 'Solana',
  tron: 'TRON',
  stellar: 'Stellar',
  doge: 'DOGE',
  eos: 'EOS',
  avalanche: 'Avalanche',
  cardano: 'Cardano',
  monero: 'Monero',
  dash: 'Dash',
  ripple: 'Ripple',
  cosmos: 'Cosmos',
  litecoin: 'Litecoin',
  zcash: 'Zcash',
  polkadot: 'Polkadot',
  iota: 'IOTA'
};
function getChainNetworkName(networkName) {
  if (!networkName) return '';
  return NETWORK_NAMES_EXCEPTIONS[networkName] ?? networkName;
}
;// ./src/components/common/TokenSelector.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TokenSelector_module = ({"tokenSelectInputWrapper":"TokenSelector-module__tokenSelectInputWrapper","tokenSelectSearchIcon":"TokenSelector-module__tokenSelectSearchIcon","tokenSelectSearchResetWrapper":"TokenSelector-module__tokenSelectSearchResetWrapper","tokenSelectSearchReset":"TokenSelector-module__tokenSelectSearchReset","tokenSelectSearchResetIcon":"TokenSelector-module__tokenSelectSearchResetIcon","tokenSelectInput":"TokenSelector-module__tokenSelectInput","tokenSelectContent":"TokenSelector-module__tokenSelectContent","tokenGroupContainer":"TokenSelector-module__tokenGroupContainer","tokenGroupHeader":"TokenSelector-module__tokenGroupHeader","tokenGroupTitle":"TokenSelector-module__tokenGroupTitle","tokenGroupAdditionalTitle":"TokenSelector-module__tokenGroupAdditionalTitle","tokenContainer":"TokenSelector-module__tokenContainer","tokenContainerDisabled":"TokenSelector-module__tokenContainerDisabled","tokenLogoContainer":"TokenSelector-module__tokenLogoContainer","logoContainer":"TokenSelector-module__logoContainer","tokenLogoSkeleton":"TokenSelector-module__tokenLogoSkeleton","tokenLogoSymbol":"TokenSelector-module__tokenLogoSymbol","tokenLogo":"TokenSelector-module__tokenLogo","tokenLogoDisabled":"TokenSelector-module__tokenLogoDisabled","tokenNetworkLogoSkeleton":"TokenSelector-module__tokenNetworkLogoSkeleton","nameContainer":"TokenSelector-module__nameContainer","tokenPriceContainer":"TokenSelector-module__tokenPriceContainer","tokenName":"TokenSelector-module__tokenName","tokenAmount":"TokenSelector-module__tokenAmount","tokenNetwork":"TokenSelector-module__tokenNetwork","tokenValue":"TokenSelector-module__tokenValue","tokenNameSkeleton":"TokenSelector-module__tokenNameSkeleton","tokenValueSkeleton":"TokenSelector-module__tokenValueSkeleton","tokenNotFound":"TokenSelector-module__tokenNotFound","tokenNotFoundTitle":"TokenSelector-module__tokenNotFoundTitle","tokenNotFoundDesc":"TokenSelector-module__tokenNotFoundDesc","tokenTextDisabled":"TokenSelector-module__tokenTextDisabled"});
;// ./src/components/common/TokenSelector.tsx

























var SearchState = /*#__PURE__*/function (SearchState) {
  SearchState[SearchState["Initial"] = 0] = "Initial";
  SearchState[SearchState["Search"] = 1] = "Search";
  SearchState[SearchState["Loading"] = 2] = "Loading";
  SearchState[SearchState["TokenByAddress"] = 3] = "TokenByAddress";
  SearchState[SearchState["Empty"] = 4] = "Empty";
  return SearchState;
}(SearchState || {});
const EMPTY_ARRAY = [];
const EMPTY_OBJECT = {};
function TokenSelector(_ref) {
  let {
    token,
    userTokens: userTokensProp = EMPTY_ARRAY,
    swapTokens = EMPTY_ARRAY,
    popularTokens: popularTokensProp = EMPTY_ARRAY,
    header,
    shouldFilter,
    shouldUseSwapTokens,
    baseCurrency,
    tokenInSlug,
    pairsBySlug,
    shouldShowAllPairs,
    isActive,
    isLoading,
    shouldHideMyTokens,
    shouldHideNotSupportedTokens = false,
    isMultichain,
    availableChains = EMPTY_OBJECT,
    selectedChain,
    isSensitiveDataHidden,
    onTokenSelect,
    onBack,
    onClose
  } = _ref;
  const {
    importToken,
    resetImportToken,
    openSettingsWithState
  } = getActions();
  const lang = hooks_useLang();
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  const scrollContainerRef = teact_useRef();
  const searchInputRef = teact_useRef();
  useHistoryBack({
    isActive,
    onBack
  });
  teact_useEffect(() => {
    if (!isActive) return undefined;
    disableSwipeToClose();
    return enableSwipeToClose;
  }, [isActive]);
  useFocusAfterAnimation(searchInputRef, !isActive);
  const {
    handleScroll: handleContentScroll
  } = useScrolledState();
  const [searchValue, setSearchValue] = useState('');
  const [isResetButtonVisible, setIsResetButtonVisible] = useState(false);
  const [renderingKey, setRenderingKey] = useState(SearchState.Initial);
  const [searchTokenList, setSearchTokenList] = useState([]);

  // It is necessary to use useCallback instead of useLastCallback here
  const filterTokens = teact_useCallback(tokens => {
    return filterAndSortTokens(tokens, isMultichain, tokenInSlug, pairsBySlug, shouldShowAllPairs);
  }, [pairsBySlug, tokenInSlug, isMultichain, shouldShowAllPairs]);
  const userTokens = teact_useMemo(() => filterSupportedTokens(userTokensProp, shouldHideNotSupportedTokens, availableChains, selectedChain), [userTokensProp, shouldHideNotSupportedTokens, availableChains, selectedChain]);
  const allTokens = teact_useMemo(() => filterSupportedTokens(swapTokens, shouldHideNotSupportedTokens, availableChains, selectedChain), [swapTokens, shouldHideNotSupportedTokens, availableChains, selectedChain]);
  const popularTokens = teact_useMemo(() => filterSupportedTokens(popularTokensProp, shouldHideNotSupportedTokens, availableChains, selectedChain), [popularTokensProp, shouldHideNotSupportedTokens, availableChains, selectedChain]);
  const {
    userTokensWithFilter,
    popularTokensWithFilter,
    swapTokensWithFilter
  } = teact_useMemo(() => {
    if (!shouldFilter) {
      return {
        userTokensWithFilter: userTokens,
        popularTokensWithFilter: popularTokens,
        swapTokensWithFilter: swapTokens
      };
    }
    return {
      userTokensWithFilter: filterTokens(userTokens),
      popularTokensWithFilter: filterTokens(popularTokens),
      swapTokensWithFilter: filterTokens(swapTokens)
    };
  }, [filterTokens, popularTokens, shouldFilter, swapTokens, userTokens]);
  const filteredTokenList = teact_useMemo(() => {
    const tokensToFilter = shouldUseSwapTokens ? swapTokensWithFilter : allTokens;
    const untrimmedSearchValue = searchValue.toLowerCase();
    const lowerCaseSearchValue = untrimmedSearchValue.trim();
    if (untrimmedSearchValue.length && !lowerCaseSearchValue.length) {
      return [];
    }
    const filteredTokens = tokensToFilter.filter(_ref2 => {
      let {
        name,
        symbol,
        keywords,
        isDisabled
      } = _ref2;
      if (isDisabled) {
        return false;
      }
      const isName = name.toLowerCase().includes(lowerCaseSearchValue);
      const isSymbol = symbol.toLowerCase().includes(lowerCaseSearchValue);
      const isKeyword = keywords === null || keywords === void 0 ? void 0 : keywords.some(key => key.toLowerCase().includes(lowerCaseSearchValue));
      return isName || isSymbol || isKeyword;
    }) ?? [];
    const sortFactors = filteredTokens.reduce((acc, searchResultToken) => {
      const factors = {
        tickerExactMatch: 0,
        tickerMatchLength: 0,
        nameMatchLength: 0,
        specialOrder: 0 // The higher the value, the higher the position
      };
      const tokenSymbol = searchResultToken.symbol.toLowerCase();
      const tokenName = searchResultToken.name.toLowerCase();
      if (tokenSymbol === lowerCaseSearchValue) {
        factors.tickerExactMatch = 1;
      }
      if (tokenSymbol.includes(lowerCaseSearchValue)) {
        factors.tickerMatchLength = lowerCaseSearchValue.length;
      }
      if (tokenName.includes(lowerCaseSearchValue)) {
        factors.nameMatchLength = lowerCaseSearchValue.length;
      }
      if (searchResultToken.slug === src_config/* TON_USDT_SLUG */.rUK) {
        factors.specialOrder = 2;
      }
      if (searchResultToken.slug === src_config/* TRC20_USDT_MAINNET_SLUG */.QSz || searchResultToken.slug === src_config/* TRC20_USDT_TESTNET_SLUG */.vsz) {
        factors.specialOrder = 1;
      }
      acc[searchResultToken.slug] = factors;
      return acc;
    }, {});
    return filteredTokens.sort((a, b) => {
      const factorA = sortFactors[a.slug];
      const factorB = sortFactors[b.slug];
      const comparisonResult = compareTokens(factorA, factorB);
      if (comparisonResult !== 0) return comparisonResult;
      return Number(b.amount - a.amount);
    });
  }, [allTokens, shouldUseSwapTokens, searchValue, swapTokensWithFilter]);
  const resetSearch = () => {
    setSearchValue('');
  };
  useSyncEffect(() => {
    setIsResetButtonVisible(Boolean(searchValue.length));
    const isValidAddress = isValidAddressOrDomain(searchValue, 'ton');
    let newRenderingKey = SearchState.Initial;
    if (isLoading && isValidAddress) {
      newRenderingKey = SearchState.Loading;
    } else if (token && isValidAddress) {
      newRenderingKey = SearchState.TokenByAddress;
    } else if (searchValue.length && filteredTokenList.length !== 0) {
      newRenderingKey = SearchState.Search;
    } else if (filteredTokenList.length === 0) {
      newRenderingKey = SearchState.Empty;
    }
    setRenderingKey(newRenderingKey);
    if (newRenderingKey !== SearchState.Initial) {
      setSearchTokenList(filteredTokenList);
    }
  }, [searchTokenList.length, isLoading, searchValue, token, filteredTokenList]);
  teact_useEffect(() => {
    if ('ton' in availableChains && isValidAddressOrDomain(searchValue, 'ton')) {
      importToken({
        address: searchValue,
        isSwap: true
      });
      setRenderingKey(SearchState.Loading);
    } else {
      resetImportToken();
    }
  }, [searchValue, availableChains]);
  useLayoutEffect(() => {
    if (!isActive || !scrollContainerRef.current) return;
    scrollContainerRef.current.scrollTop = 0;
  }, [isActive]);
  const handleTokenClick = useLastCallback(selectedToken => {
    var _searchInputRef$curre;
    (_searchInputRef$curre = searchInputRef.current) === null || _searchInputRef$curre === void 0 || _searchInputRef$curre.blur();
    onTokenSelect(selectedToken);
    resetSearch();
    onBack();
  });
  const handleOpenSettings = useLastCallback(() => {
    onClose();
    openSettingsWithState({
      state: SettingsState.Assets
    });
  });
  function renderSearch() {
    return /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenSelectInputWrapper
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(TokenSelector_module.tokenSelectSearchIcon, 'icon-search'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("input", {
      ref: searchInputRef,
      name: "token-search-modal",
      className: TokenSelector_module.tokenSelectInput,
      onChange: e => setSearchValue(e.target.value),
      placeholder: lang('Name or Address...'),
      value: searchValue
    }), /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "fade",
      activeKey: isResetButtonVisible ? 0 : 1,
      className: TokenSelector_module.tokenSelectSearchResetWrapper
    }, isResetButtonVisible && /*#__PURE__*/teact.createElement("button", {
      type: "button",
      className: TokenSelector_module.tokenSelectSearchReset,
      "aria-label": lang('Clear'),
      onClick: resetSearch
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(TokenSelector_module.tokenSelectSearchResetIcon, 'icon-close'),
      "aria-hidden": true
    }))));
  }
  function renderToken(currentToken) {
    const isAvailable = Boolean(!shouldFilter || currentToken.canSwap);
    const withChainIcon = Boolean((isMultichain || shouldUseSwapTokens) && !selectedChain);
    const descriptionText = isAvailable ? getChainNetworkName(currentToken.chain) : lang('Unavailable');
    const tokenPrice = currentToken.price === 0 ? lang('No Price') : formatCurrency(currentToken.price, shortBaseSymbol, undefined, true);
    return /*#__PURE__*/teact.createElement(Token, {
      key: currentToken.slug,
      isAvailable: isAvailable,
      isSensitiveDataHidden: isSensitiveDataHidden,
      withChainIcon: withChainIcon,
      descriptionText: descriptionText,
      token: currentToken,
      tokenPrice: tokenPrice,
      onSelect: handleTokenClick
    });
  }
  function renderTokenGroup(tokens, title, shouldShowSettings) {
    return /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenGroupContainer
    }, /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenGroupHeader
    }, /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenGroupTitle
    }, title), shouldShowSettings && /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenGroupAdditionalTitle,
      onClick: handleOpenSettings
    }, lang('Settings'))), tokens.map(renderToken));
  }
  function renderAllTokens(tokens) {
    return /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenGroupContainer
    }, tokens.map(renderToken));
  }
  function renderTokenSkeleton() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(TokenSelector_module.tokenContainer, TokenSelector_module.tokenContainerDisabled)
    }, /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenLogoContainer
    }, /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.logoContainer
    }, /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenLogoSkeleton
    }), /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenNetworkLogoSkeleton
    })), /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.nameContainer
    }, /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenNameSkeleton
    }), /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenValueSkeleton
    }))), /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenPriceContainer
    }, /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(TokenSelector_module.tokenNameSkeleton, TokenSelector_module.rotateSkeleton)
    }), /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenValueSkeleton
    })));
  }
  function renderNotFound(shouldPlay) {
    return /*#__PURE__*/teact.createElement("div", {
      className: TokenSelector_module.tokenNotFound
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: shouldPlay,
      tgsUrl: ANIMATED_STICKERS_PATHS.noData,
      previewUrl: ANIMATED_STICKERS_PATHS.noDataPreview,
      size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW,
      noLoop: false,
      nonInteractive: true
    }), /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenNotFoundTitle
    }, lang('Not Found')), /*#__PURE__*/teact.createElement("span", {
      className: TokenSelector_module.tokenNotFoundDesc
    }, lang('Try another keyword or address.')));
  }
  function renderSearchResults(tokenToImport) {
    if (tokenToImport) {
      return /*#__PURE__*/teact.createElement("div", {
        className: TokenSelector_module.tokenGroupContainer
      }, renderToken(tokenToImport));
    }
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderTokenSkeleton(), renderTokenSkeleton(), renderTokenSkeleton(), renderTokenSkeleton(), renderTokenSkeleton());
  }
  function renderTokenGroups() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !shouldHideMyTokens && renderTokenGroup(userTokensWithFilter, lang('MY'), true), renderTokenGroup(popularTokensWithFilter, lang('POPULAR')));
  }
  function renderContent(isContentActive, isFrom, currentKey) {
    switch (currentKey) {
      case SearchState.Initial:
        return renderTokenGroups();
      case SearchState.Loading:
        return renderSearchResults();
      case SearchState.Search:
        return renderAllTokens(searchTokenList);
      case SearchState.TokenByAddress:
        return renderSearchResults(token);
      case SearchState.Empty:
        return renderNotFound(isContentActive);
    }
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, header || /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Select Token'),
    onBackButtonClick: onBack,
    onClose: onClose
  }), renderSearch(), /*#__PURE__*/teact.createElement("div", {
    ref: scrollContainerRef,
    className: buildClassName(TokenSelector_module.tokenSelectContent, 'custom-scroll'),
    onScroll: handleContentScroll
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "fade",
    activeKey: renderingKey
  }, renderContent)));
}
/* harmony default export */ const common_TokenSelector = (memo(withGlobal(global => {
  var _global$swapPairs, _selectCurrentAccount;
  const {
    baseCurrency,
    isSensitiveDataHidden
  } = global.settings;
  const {
    isLoading,
    token
  } = global.settings.importToken ?? {};
  const {
    tokenInSlug,
    shouldShowAllPairs
  } = global.currentSwap ?? {};
  const pairsBySlug = (_global$swapPairs = global.swapPairs) === null || _global$swapPairs === void 0 ? void 0 : _global$swapPairs.bySlug;
  const userTokens = selectAvailableUserForSwapTokens(global);
  const popularTokens = selectPopularTokens(global);
  const swapTokens = selectSwapTokens(global);
  const isMultichain = selectIsMultichainAccount(global, global.currentAccountId);
  const availableChains = (_selectCurrentAccount = selectCurrentAccount(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.addressByChain;
  return {
    baseCurrency,
    isLoading,
    token,
    pairsBySlug,
    shouldShowAllPairs,
    tokenInSlug,
    userTokens,
    popularTokens,
    swapTokens,
    isMultichain,
    availableChains,
    isSensitiveDataHidden
  };
})(TokenSelector)));
function Token(_ref3) {
  let {
    token,
    isAvailable,
    isSensitiveDataHidden,
    withChainIcon,
    descriptionText,
    tokenPrice,
    onSelect
  } = _ref3;
  const handleClick = isAvailable ? () => onSelect(token) : undefined;
  const cols = teact_useMemo(() => getPseudoRandomNumber(4, 10, token.slug), [token.slug]);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(TokenSelector_module.tokenContainer, !isAvailable && TokenSelector_module.tokenContainerDisabled),
    onClick: handleClick
  }, /*#__PURE__*/teact.createElement("div", {
    className: TokenSelector_module.tokenLogoContainer
  }, /*#__PURE__*/teact.createElement(common_TokenIcon, {
    token: token,
    withChainIcon: withChainIcon,
    className: buildClassName(TokenSelector_module.tokenLogo, !isAvailable && TokenSelector_module.tokenLogoDisabled)
  }), /*#__PURE__*/teact.createElement("div", {
    className: TokenSelector_module.nameContainer
  }, /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(TokenSelector_module.tokenName, !isAvailable && TokenSelector_module.tokenTextDisabled)
  }, token.name), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(TokenSelector_module.tokenNetwork, !isAvailable && TokenSelector_module.tokenTextDisabled)
  }, descriptionText))), /*#__PURE__*/teact.createElement("div", {
    className: TokenSelector_module.tokenPriceContainer
  }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    cols: cols,
    rows: 2,
    cellSize: 8,
    align: "right",
    className: buildClassName(TokenSelector_module.tokenAmount, !isAvailable && TokenSelector_module.tokenTextDisabled)
  }, formatCurrency((0,util_decimals/* toDecimal */.nI)(token.amount, token === null || token === void 0 ? void 0 : token.decimals), token.symbol)), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(TokenSelector_module.tokenValue, !isAvailable && TokenSelector_module.tokenTextDisabled)
  }, tokenPrice)));
}
function filterAndSortTokens(tokens, isMultichain, tokenInSlug, pairsBySlug, shouldShowAllPairs) {
  if (!tokens.length || !tokenInSlug) return [];
  return tokens.map(token => {
    let canSwap;
    if (shouldShowAllPairs) {
      canSwap = true;
    } else {
      var _pairsBySlug$tokenInS;
      const pair = pairsBySlug === null || pairsBySlug === void 0 || (_pairsBySlug$tokenInS = pairsBySlug[tokenInSlug]) === null || _pairsBySlug$tokenInS === void 0 ? void 0 : _pairsBySlug$tokenInS[token.slug];
      canSwap = Boolean(isMultichain ? pair : pair && !pair.isMultichain);
    }
    return {
      ...token,
      canSwap
    };
  }).sort((a, b) => Number(b.canSwap) - Number(a.canSwap));
}
function compareTokens(a, b) {
  if (a.specialOrder !== b.specialOrder) {
    return b.specialOrder - a.specialOrder;
  }
  if (a.tickerExactMatch !== b.tickerExactMatch) {
    return b.tickerExactMatch - a.tickerExactMatch;
  }
  if (a.tickerMatchLength !== b.tickerMatchLength) {
    return b.tickerMatchLength - a.tickerMatchLength;
  }
  return b.nameMatchLength - a.nameMatchLength;
}
function filterSupportedTokens(tokens, isFilterActive, availableChains, selectedChain) {
  if (!isFilterActive && !selectedChain) {
    return tokens;
  }
  return tokens.filter(token => {
    if (isFilterActive && !(token.chain in availableChains)) {
      return false;
    }
    return !(selectedChain && token.chain !== selectedChain);
  });
}
;// ./src/util/saveCaretPosition.ts
function saveCaretPosition(context, prefixLength, decimals) {
  var _clearedValue$;
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0) {
    return undefined;
  }
  const range = selection.getRangeAt(0);
  range.setStart(context, 0);
  const clearedValue = range.toString().match(new RegExp(`(\\d+(?:[.,]\\d{0,${decimals}})?)`));
  const len = prefixLength + ((clearedValue === null || clearedValue === void 0 || (_clearedValue$ = clearedValue[0]) === null || _clearedValue$ === void 0 ? void 0 : _clearedValue$.length) || range.toString().length || 0);
  return function restore() {
    try {
      const {
        node,
        position
      } = getTextNodeAtPosition(context, len);
      selection.removeAllRanges();
      const newRange = new Range();
      newRange.setStart(node, position);
      newRange.setEnd(node, position);
      selection.addRange(newRange);
    } catch (e) {
      // ignore
    }
  };
}
function getTextNodeAtPosition(root, index) {
  const NODE_TYPE = NodeFilter.SHOW_TEXT;
  const treeWalker = document.createTreeWalker(root, NODE_TYPE, elem => {
    if (index > elem.textContent.length) {
      index -= elem.textContent.length;
      return NodeFilter.FILTER_REJECT;
    }
    return NodeFilter.FILTER_ACCEPT;
  });
  const node = treeWalker.nextNode() ?? treeWalker.currentNode;
  return {
    node,
    // Limiting the position for cases when `index` is outside the `root`.
    // It happens when the prefix disappears after the change.
    position: Math.min(index, node.textContent.length)
  };
}
;// ./src/components/ui/helpers/buildContentHtml.ts


function buildContentHtml(text) {
  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  let decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : src_config/* FRACTION_DIGITS */.I04;
  let withRadix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  text = sanitizeHtml(text);
  prefix = sanitizeHtml(prefix);
  suffix = sanitizeHtml(suffix);
  if (!text) {
    return '';
  }
  const hasDot = text.includes('.');
  const [wholePart = '0', fractionPart] = hasDot ? text.split('.') : [text];
  const formattedWholePart = withRadix ? wholePart.replace(/\d(?=(\d{3})+($|\.))/g, `$&${src_config/* WHOLE_PART_DELIMITER */.MS3}`) : wholePart;
  const fractionStr = hasDot ? `.${(fractionPart || '').substring(0, decimals)}` : '';
  const suffixStr = suffix ? `&thinsp;${suffix}` : '';
  const extraSpan = fractionStr || suffixStr ? `<span class="${Input_module.fractional}">${fractionStr}${suffixStr}</span>` : '';
  return `${prefix}${formattedWholePart}${extraSpan}`;
}
function sanitizeHtml(string) {
  const tempEl = document.createElement('span');
  tempEl.textContent = string;
  return tempEl.innerHTML;
}
;// ./src/hooks/useFontScale.ts




const MIN_SIZE_SCALE = 0.25; // 12px

function useFontScale(inputRef, shouldGetParentWidth) {
  const isFontChangedRef = teact_useRef(false);
  const measureEl = teact_useRef(document.createElement('div'));
  const updateFontScale = useLastCallback(() => {
    const input = inputRef.current;
    (0,stricterdom/* suppressStrict */.bo)(() => {
      if (!(input !== null && input !== void 0 && input.offsetParent)) return;
      let {
        clientWidth: width
      } = shouldGetParentWidth ? input.parentElement : input;
      if (shouldGetParentWidth) {
        const {
          paddingLeft,
          paddingRight
        } = getComputedStyle(input);
        width -= parseFloat(paddingLeft) + parseFloat(paddingRight);
      }
      measureEl.current.className = buildClassName(input.className, 'measure-hidden');
      measureEl.current.style.width = `${width}px`;
      measureEl.current.innerHTML = ''; // `measureEl.current.innerHTML = input.innerHTML` is not used, because it violates the CSP
      measureEl.current.append(...input.cloneNode(true).childNodes);
      document.body.appendChild(measureEl.current);
      let scale = 1;
      while (scale > MIN_SIZE_SCALE) {
        measureEl.current.style.setProperty('--font-size-scale', scale.toString());
        if (measureEl.current.scrollWidth <= width) break;
        scale -= 0.05;
      }
      isFontChangedRef.current = scale < 1;
      document.body.removeChild(measureEl.current);
      measureEl.current.className = '';
      input.style.setProperty('--font-size-scale', scale.toString());
    });
  });
  return {
    updateFontScale,
    isFontChangedRef
  };
}
/* harmony default export */ const hooks_useFontScale = (useFontScale);
;// ./src/components/ui/RichNumberInput.tsx










const MIN_LENGTH_FOR_SHRINK = 5;
function RichNumberInput(_ref) {
  let {
    id,
    labelText,
    hasError,
    isLoading = false,
    prefix = '',
    suffix = '',
    value,
    children,
    className,
    inputClassName,
    labelClassName,
    valueClassName,
    cornerClassName,
    onChange,
    onBlur,
    onFocus,
    onPressEnter,
    onInputClick,
    decimals = src_config/* FRACTION_DIGITS */.I04,
    disabled = false,
    isStatic = false,
    size = 'large'
  } = _ref;
  const inputRef = teact_useRef();
  const placeholderRef = teact_useRef();
  const lang = hooks_useLang();
  const [hasFocus, markHasFocus, unmarkHasFocus] = hooks_useFlag(false);
  const {
    updateFontScale,
    isFontChangedRef
  } = hooks_useFontScale(inputRef);
  const textRef = teact_useRef('');
  const updateHtml = useLastCallback(newText => {
    const input = inputRef.current;
    const html = buildContentHtml(newText, prefix, suffix, decimals);

    // Don't use the :empty pseudo-class to hide the placeholder, because it's noticeable delayed on iOS
    placeholderRef.current.innerHTML = newText ? '' : buildContentHtml('0', prefix, suffix);
    if (html !== input.innerHTML) {
      const restoreCaretPosition = document.activeElement === input ? saveCaretPosition(input, prefix.length, decimals) : undefined;
      input.innerHTML = html;
      restoreCaretPosition === null || restoreCaretPosition === void 0 || restoreCaretPosition();
    }
    if (`${prefix}${newText}${suffix}`.length > MIN_LENGTH_FOR_SHRINK || isFontChangedRef.current) {
      updateFontScale();
    }
  });
  useLayoutEffect(() => {
    const newText = clearText(value);
    if (!newText || !textRef.current.startsWith(newText)) {
      updateHtml(newText);
      textRef.current = newText;
    }
  }, [textRef, value]);
  useLayoutEffect(() => {
    updateHtml(textRef.current);
  }, [prefix, suffix, decimals]);
  function handleChange(e) {
    const newText = clearText(e.currentTarget.textContent ?? undefined);
    updateHtml(newText);
    if (newText !== textRef.current) {
      textRef.current = newText;
      if (onChange && isValidValue(newText)) {
        onChange(newText);
      }
    }
  }
  const handleFocus = useLastCallback(() => {
    if (disabled) return;
    markHasFocus();
    onFocus === null || onFocus === void 0 || onFocus();
  });
  const handleBlur = useLastCallback(() => {
    if (disabled) return;
    unmarkHasFocus();
    onBlur === null || onBlur === void 0 || onBlur();
  });
  const handleKeyDown = e => {
    if (e.key === 'Enter') {
      onPressEnter === null || onPressEnter === void 0 || onPressEnter(e);
    }
  };
  const inputWrapperFullClass = buildClassName(Input_module.input__wrapper, isStatic && Input_module.inputWrapperStatic, hasError && Input_module.error, hasFocus && Input_module.input__wrapper_hasFocus, inputClassName);
  const inputFullClass = buildClassName(Input_module.input, size === 'large' && Input_module.large, valueClassName, disabled && Input_module.disabled, isLoading && Input_module.isLoading, 'rounded-font');
  const labelTextClassName = buildClassName(Input_module.label, hasError && Input_module.error, labelClassName);
  const cornerFullClass = buildClassName(cornerClassName, hasFocus && Input_module.swapCorner, hasError && Input_module.swapCorner_error);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Input_module.wrapper, className)
  }, Boolean(labelText) && /*#__PURE__*/teact.createElement("label", {
    className: labelTextClassName,
    htmlFor: id,
    id: `${id}Label`
  }, labelText), /*#__PURE__*/teact.createElement("div", {
    className: inputWrapperFullClass
  }, /*#__PURE__*/teact.createElement("div", {
    className: Input_module.rich
  }, /*#__PURE__*/teact.createElement("div", {
    ref: inputRef,
    contentEditable: !disabled && !isLoading,
    id: id,
    role: "textbox",
    "aria-required": true,
    "aria-placeholder": lang('Amount value'),
    "aria-labelledby": labelText ? `${id}Label` : undefined,
    tabIndex: 0,
    inputMode: "decimal",
    className: buildClassName(inputFullClass, Input_module.rich__value),
    onKeyDown: handleKeyDown,
    onChange: handleChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onClick: onInputClick
  }), /*#__PURE__*/teact.createElement("div", {
    ref: placeholderRef,
    className: buildClassName(inputFullClass, Input_module.rich__placeholder)
  })), children), cornerClassName && /*#__PURE__*/teact.createElement("div", {
    className: cornerFullClass
  }));
}
function clearText(text) {
  if (!text) return '';
  return text.trim().replace(',', '.') // Replace comma to point
  .replace(/[^\d.]/g, '') // Remove incorrect symbols
  .replace(/^0+(?=([1-9]|0\.))/, '') // Trim extra zeros at beginning
  .replace(/^0+$/, '0') // Trim extra zeros (if only zeros are entered)
  ?? '';
}
function isValidValue(text) {
  return !Number.isNaN(Number(text));
}
/* harmony default export */ const ui_RichNumberInput = (memo(RichNumberInput));
function focusAtTheEnd(inputId) {
  const input = document.getElementById(inputId);
  const selection = window.getSelection();
  if (!input || !selection) {
    return;
  }
  const range = document.createRange();
  range.selectNodeContents(input);
  range.collapse(false);
  selection.removeAllRanges();
  selection.addRange(range);
}
;// ./src/components/receive/ReceiveModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ReceiveModal_module = ({"modalDialog":"ReceiveModal-module__modalDialog","iosModalDialog":"ReceiveModal-module__iosModalDialog","contentWrapper":"ReceiveModal-module__contentWrapper","content":"ReceiveModal-module__content","contentTitle":"ReceiveModal-module__contentTitle","contentTitleQr":"ReceiveModal-module__contentTitleQr","contentTitleLedger":"ReceiveModal-module__contentTitleLedger","contentTitleLedgerStatic":"ReceiveModal-module__contentTitleLedgerStatic","tabsInModal":"ReceiveModal-module__tabsInModal","receiveHeader":"ReceiveModal-module__receiveHeader","receiveHeaderNoTabs":"ReceiveModal-module__receiveHeaderNoTabs","contentStatic":"ReceiveModal-module__contentStatic","tabs":"ReceiveModal-module__tabs","tabsOverlay":"ReceiveModal-module__tabsOverlay","tronActive":"ReceiveModal-module__tronActive","tab":"ReceiveModal-module__tab","tabTon":"ReceiveModal-module__tabTon","tabTron":"ReceiveModal-module__tabTron","qrCode":"ReceiveModal-module__qrCode","qrCodeStatic":"ReceiveModal-module__qrCodeStatic","qrCodeHidden":"ReceiveModal-module__qrCodeHidden","labelForInvoice":"ReceiveModal-module__labelForInvoice","addressWrapper":"ReceiveModal-module__addressWrapper","copyButtonStatic":"ReceiveModal-module__copyButtonStatic","tokenButton":"ReceiveModal-module__tokenButton","invoiceComment":"ReceiveModal-module__invoiceComment","dottedLink":"ReceiveModal-module__dottedLink","actionButtons":"ReceiveModal-module__actionButtons","actionButton":"ReceiveModal-module__actionButton"});
;// ./src/components/receive/InvoiceModal.tsx






















var InvoiceModal_SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["Initial"] = 0] = "Initial";
  SLIDES[SLIDES["Selector"] = 1] = "Selector";
  return SLIDES;
}(InvoiceModal_SLIDES || {});
function InvoiceModal(_ref) {
  let {
    address,
    tokenSlug,
    tokensBySlug,
    isOpen
  } = _ref;
  const {
    changeInvoiceToken,
    closeInvoiceModal
  } = getActions();
  const lang = hooks_useLang();
  const selectedToken = tokensBySlug && tokenSlug ? tokensBySlug[tokenSlug] : src_config/* TONCOIN */.Tu9;
  const [isTokenSelectorOpen, openTokenSelector, closeTokenSelector] = hooks_useFlag(false);
  const [amountValue, setAmountValue] = useState(undefined);
  const [comment, setComment] = useState('');
  const decimals = (selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.decimals) ?? src_config/* TONCOIN */.Tu9.decimals;
  const amount = amountValue ? (0,util_decimals/* fromDecimal */.UH)(amountValue, decimals) : 0n;
  const tokenAddress = 'tokenAddress' in selectedToken ? selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.tokenAddress : undefined;
  const invoiceUrl = address ? formatTransferUrl(address, amount, comment, tokenAddress) : '';
  const handleTokenSelect = useLastCallback(token => {
    changeInvoiceToken({
      tokenSlug: token.slug
    });
  });
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case InvoiceModal_SLIDES.Initial:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Deposit Link'),
          onClose: closeInvoiceModal
        }), /*#__PURE__*/teact.createElement("div", {
          className: ReceiveModal_module.content
        }, /*#__PURE__*/teact.createElement("div", {
          className: ReceiveModal_module.contentTitle
        }, renderText(lang('$receive_invoice_description'))), /*#__PURE__*/teact.createElement(ui_RichNumberInput, {
          key: "amount",
          id: "amount",
          value: amountValue,
          labelText: lang('Amount'),
          onChange: setAmountValue
        }, /*#__PURE__*/teact.createElement(common_SelectTokenButton, {
          noChainIcon: true,
          token: selectedToken,
          className: ReceiveModal_module.tokenButton,
          onClick: openTokenSelector
        })), /*#__PURE__*/teact.createElement(ui_Input, {
          value: comment,
          label: lang('Comment'),
          placeholder: lang('Optional'),
          wrapperClassName: ReceiveModal_module.invoiceComment,
          onInput: setComment
        }), /*#__PURE__*/teact.createElement("p", {
          className: ReceiveModal_module.labelForInvoice
        }, lang('Share this URL to receive %token%', {
          token: selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.symbol
        })), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
          text: invoiceUrl,
          addressUrl: src_config/* IS_CAPACITOR */.UMQ ? invoiceUrl : undefined,
          noExplorer: true,
          withShareInMenu: src_config/* IS_CAPACITOR */.UMQ,
          copyNotification: lang('Invoice link was copied!'),
          className: ReceiveModal_module.invoiceLinkField
        })));
      case InvoiceModal_SLIDES.Selector:
        return /*#__PURE__*/teact.createElement(common_TokenSelector, {
          isActive: isActive,
          shouldHideNotSupportedTokens: true,
          selectedChain: "ton",
          onTokenSelect: handleTokenSelect,
          onBack: closeTokenSelector,
          onClose: closeInvoiceModal
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    dialogClassName: ReceiveModal_module.modalDialog,
    nativeBottomSheetKey: "invoice",
    onClose: closeInvoiceModal,
    onCloseAnimationEnd: closeTokenSelector
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: isTokenSelectorOpen ? InvoiceModal_SLIDES.Selector : InvoiceModal_SLIDES.Initial,
    nextKey: isTokenSelectorOpen ? InvoiceModal_SLIDES.Initial : InvoiceModal_SLIDES.Selector
  }, renderContent));
}
/* harmony default export */ const receive_InvoiceModal = (memo(withGlobal(global => {
  var _selectAccount, _global$tokenInfo;
  const address = (_selectAccount = selectAccount(global, global.currentAccountId)) === null || _selectAccount === void 0 || (_selectAccount = _selectAccount.addressByChain) === null || _selectAccount === void 0 ? void 0 : _selectAccount.ton;
  const {
    invoiceTokenSlug
  } = selectCurrentAccountState(global) || {};
  return {
    isOpen: global.isInvoiceModalOpen,
    tokenSlug: invoiceTokenSlug,
    tokensBySlug: (_global$tokenInfo = global.tokenInfo) === null || _global$tokenInfo === void 0 ? void 0 : _global$tokenInfo.bySlug,
    address
  };
})(InvoiceModal)));
;// ./src/util/animateHorizontalScroll.ts


const animateHorizontalScroll_DEFAULT_DURATION = 300;
const stopById = new Map();
function animateHorizontalScroll(container, left) {
  let duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : animateHorizontalScroll_DEFAULT_DURATION;
  const isRtl = container.getAttribute('dir') === 'rtl';
  const {
    scrollLeft,
    offsetWidth: containerWidth,
    scrollWidth,
    dataset: {
      scrollId
    }
  } = container;
  let path = left - scrollLeft;
  if (path < 0) {
    const remainingPath = -scrollLeft * (isRtl ? -1 : 1);
    path = Math.max(path, remainingPath);
  } else if (path > 0) {
    const remainingPath = scrollWidth - (scrollLeft + containerWidth);
    path = Math.min(path, remainingPath);
  }
  if (path === 0) {
    return Promise.resolve();
  }
  if (scrollId && stopById.has(scrollId)) {
    stopById.get(scrollId)();
  }
  const target = scrollLeft + path;
  return new Promise(resolve => {
    (0,fasterdom/* requestMutation */.RK)(() => {
      if (duration === 0) {
        container.scrollLeft = target;
        resolve();
        return;
      }
      let isStopped = false;
      const id = Math.random().toString();
      container.dataset.scrollId = id;
      stopById.set(id, () => {
        isStopped = true;
      });
      container.style.scrollSnapType = 'none';
      const startAt = Date.now();
      (0,animation/* animate */.i0)(() => {
        if (isStopped) return false;
        const t = Math.min((Date.now() - startAt) / duration, 1);
        const currentPath = path * (1 - transition(t));
        container.scrollLeft = Math.round(target - currentPath);
        if (t >= 1) {
          container.style.scrollSnapType = '';
          delete container.dataset.scrollId;
          stopById.delete(id);
          resolve();
        }
        return t < 1;
      }, fasterdom/* requestMutation */.RK);
    });
  });
}
function transition(t) {
  return 1 - (1 - t) ** 3.5;
}
;// ./src/components/ui/Tab.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Tab_module = ({"Tab":"Tab-module__Tab","tab":"Tab-module__Tab","Tab_active":"Tab-module__Tab_active","tabActive":"Tab-module__Tab_active","content":"Tab-module__content","interactive":"Tab-module__interactive","menuItem":"Tab-module__menuItem","icon":"Tab-module__icon","caretIcon":"Tab-module__caretIcon"});
;// ./src/components/ui/Tab.tsx





function Tab(_ref) {
  let {
    isActive,
    icon,
    title,
    menuItems,
    className,
    onClick,
    clickArg,
    onMenuItemClick,
    onActiveClick
  } = _ref;
  const menuRef = teact_useRef();
  const contentRef = teact_useRef();
  const [menuAnchor, setMenuAnchor] = useState();
  const hasMenu = Boolean(menuItems === null || menuItems === void 0 ? void 0 : menuItems.length);
  const isMenuOpen = Boolean(menuAnchor);
  const getTriggerElement = useLastCallback(() => contentRef.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true
  }));
  const closeMenu = useLastCallback(() => setMenuAnchor(undefined));
  const handleClick = useLastCallback(() => {
    if (isActive && !hasMenu) {
      onActiveClick === null || onActiveClick === void 0 || onActiveClick();
      return;
    }
    if (!isActive) {
      onClick(clickArg);
      return;
    }
    if (isMenuOpen) {
      closeMenu();
    } else {
      const {
        right: x,
        y,
        height
      } = contentRef.current.getBoundingClientRect();
      setMenuAnchor({
        x,
        y: y + height
      });
    }
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Tab_module.Tab, isActive && Tab_module.Tab_active, className, hasMenu && Tab_module.interactive),
    onClick: handleClick
  }, /*#__PURE__*/teact.createElement("span", {
    className: Tab_module.content,
    ref: contentRef
  }, icon && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(icon, Tab_module.icon),
    "aria-hidden": true
  }), title, hasMenu && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-caret-down', Tab_module.caretIcon),
    "aria-hidden": true
  })), hasMenu && /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isMenuOpen,
    ref: menuRef,
    items: menuItems,
    withPortal: true,
    buttonClassName: Tab_module.menuItem,
    menuPositionX: "right",
    menuAnchor: menuAnchor,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    onSelect: onMenuItemClick,
    onClose: closeMenu
  }));
}
/* harmony default export */ const ui_Tab = (Tab);
;// ./src/components/ui/TabList.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TabList_module = ({"container":"TabList-module__container","clipPathContainer":"TabList-module__clipPathContainer"});
;// ./src/components/ui/TabList.tsx










const TAB_SCROLL_THRESHOLD_PX = 16;
// Should match duration from `--slide-transition` CSS variable
const SCROLL_DURATION = windowEnvironment/* IS_IOS */.pz ? 450 : windowEnvironment/* IS_ANDROID */.Ni ? 400 : 300;
const CLIP_PATH_CONTAINER_CLASS_NAME = 'clip-path-container';
function TabList(_ref) {
  let {
    isActive,
    tabs,
    activeTab,
    className,
    overlayClassName,
    onSwitchTab,
    onActiveTabClick
  } = _ref;
  const lang = hooks_useLang();
  const containerRef = teact_useRef();
  const {
    width: appWidth
  } = useWindowSize();
  const fullClassName = buildClassName(TabList_module.container, 'no-scrollbar', className);
  hooks_useHorizontalScroll({
    containerRef,
    shouldPreventDefault: true
  });
  useActiveTabCentering(activeTab, containerRef.current);
  teact_useEffect(() => {
    var _containerRef$current;
    const container = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector(`.${CLIP_PATH_CONTAINER_CLASS_NAME}`);
    const activeTabElement = container === null || container === void 0 ? void 0 : container.childNodes[activeTab];
    if (container && activeTabElement) {
      const clipPath = calculateClipPath(activeTabElement, container);
      (0,fasterdom/* requestMutation */.RK)(() => {
        container.style.clipPath = clipPath;
      });
    }
    // When the following dependencies change, `clipPath` must be updated
  }, [isActive, activeTab, tabs, lang, containerRef, appWidth]);
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    className: fullClassName
  }, tabs.map((tab, i) => /*#__PURE__*/teact.createElement(ui_Tab, {
    key: tab.title,
    title: tab.title,
    isActive: i === activeTab,
    className: tab === null || tab === void 0 ? void 0 : tab.className,
    menuItems: tab === null || tab === void 0 ? void 0 : tab.menuItems,
    onMenuItemClick: tab === null || tab === void 0 ? void 0 : tab.onMenuItemClick,
    onActiveClick: onActiveTabClick,
    onClick: onSwitchTab,
    clickArg: tab.id,
    icon: tab.icon
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(TabList_module.clipPathContainer, overlayClassName, CLIP_PATH_CONTAINER_CLASS_NAME),
    "aria-hidden": true
  }, tabs.map((tab, i) => /*#__PURE__*/teact.createElement(ui_Tab, {
    key: tab.title,
    title: tab.title,
    isActive: i === activeTab,
    className: buildClassName(tab === null || tab === void 0 ? void 0 : tab.className, i === activeTab && 'current-tab'),
    menuItems: tab === null || tab === void 0 ? void 0 : tab.menuItems,
    onActiveClick: onActiveTabClick,
    onMenuItemClick: tab === null || tab === void 0 ? void 0 : tab.onMenuItemClick,
    onClick: onSwitchTab,
    clickArg: tab.id,
    icon: tab.icon
  }))));
}
/* harmony default export */ const ui_TabList = (memo(TabList));
function calculateClipPath(activeElement, container) {
  const {
    paddingTop,
    paddingBottom
  } = getComputedStyle(activeElement);
  const {
    offsetLeft,
    offsetWidth
  } = activeElement;
  const clipLeft = offsetLeft;
  const clipRight = offsetLeft + offsetWidth;
  const rightPosition = Number(100 - clipRight / container.offsetWidth * 100).toFixed(3);
  const leftPosition = Number(clipLeft / container.offsetWidth * 100).toFixed(3);
  return `inset(${parseInt(paddingTop)}px ${rightPosition}% ${parseInt(paddingBottom)}px ${leftPosition}% round 1rem)`;
}

// Scroll container to place active tab in the center
function useActiveTabCentering(activeTab, container) {
  teact_useEffect(() => {
    if (!container) return;
    const {
      scrollWidth,
      offsetWidth,
      scrollLeft
    } = container;
    if (scrollWidth <= offsetWidth) {
      return;
    }
    const activeTabElement = container.childNodes[activeTab];
    if (!activeTabElement) {
      return;
    }
    const {
      offsetLeft: activeTabOffsetLeft,
      offsetWidth: activeTabOffsetWidth
    } = activeTabElement;
    const newLeft = activeTabOffsetLeft - offsetWidth / 2 + activeTabOffsetWidth / 2;

    // Prevent scrolling by only a couple of pixels, which doesn't look smooth
    if (Math.abs(newLeft - scrollLeft) < TAB_SCROLL_THRESHOLD_PX) {
      return;
    }
    void animateHorizontalScroll(container, newLeft, SCROLL_DURATION);
  }, [activeTab, container]);
}
;// ./src/components/receive/content/TonActions.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TonActions_module = ({"actionSheetDialog":"TonActions-module__actionSheetDialog","actionButtons":"TonActions-module__actionButtons","actionButtonStatic":"TonActions-module__actionButtonStatic","actionButton":"TonActions-module__actionButton","disabled":"TonActions-module__disabled","actionIcon":"TonActions-module__actionIcon","iconChevronRight":"TonActions-module__iconChevronRight"});
;// ./src/components/receive/content/TonActions.tsx







function TonActions(_ref) {
  let {
    className,
    isStatic,
    isTestnet,
    isLedger,
    isSwapDisabled,
    isOnRampDisabled,
    onClose
  } = _ref;
  const {
    startSwap,
    openOnRampWidgetModal,
    openInvoiceModal,
    closeReceiveModal
  } = getActions();
  const lang = hooks_useLang();
  const isSwapAllowed = !isTestnet && !isLedger && !isSwapDisabled;
  const isOnRampAllowed = !isTestnet && !isOnRampDisabled;
  const handleBuyFiat = useLastCallback(() => {
    openOnRampWidgetModal({
      chain: 'ton'
    });
    onClose === null || onClose === void 0 || onClose();
  });
  const handleSwapClick = useLastCallback(() => {
    startSwap({
      tokenInSlug: src_config/* DEFAULT_CEX_SWAP_SECOND_TOKEN_SLUG */.Czf,
      tokenOutSlug: src_config/* TONCOIN */.Tu9.slug,
      amountIn: '100'
    });
    onClose === null || onClose === void 0 || onClose();
  });
  const handleReceiveClick = useLastCallback(() => {
    closeReceiveModal();
    openInvoiceModal();
    onClose === null || onClose === void 0 || onClose();
  });
  const contentClassName = buildClassName(TonActions_module.actionButtons, isStatic && TonActions_module.actionButtonStatic, className);
  return /*#__PURE__*/teact.createElement("div", {
    className: contentClassName
  }, isOnRampAllowed && /*#__PURE__*/teact.createElement("div", {
    className: TonActions_module.actionButton,
    onClick: handleBuyFiat
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.actionIcon, 'icon-card'),
    "aria-hidden": true
  }), lang('Buy with Card'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })), isSwapAllowed && /*#__PURE__*/teact.createElement("div", {
    className: TonActions_module.actionButton,
    onClick: handleSwapClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.actionIcon, 'icon-crypto'),
    "aria-hidden": true
  }), lang('Buy with Crypto'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("div", {
    className: TonActions_module.actionButton,
    onClick: handleReceiveClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.actionIcon, 'icon-link'),
    "aria-hidden": true
  }), lang('Create Deposit Link'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })));
}
/* harmony default export */ const content_TonActions = (memo(withGlobal(global => {
  const {
    isSwapDisabled,
    isOnRampDisabled
  } = global.restrictions;
  return {
    isTestnet: global.settings.isTestnet,
    isSwapDisabled,
    isOnRampDisabled
  };
})(TonActions)));
;// ./src/hooks/useQrCode.ts





const QR_SIZE = 600;
let qrCode;
function useQrCode(_ref) {
  let {
    address,
    chain,
    isActive,
    hiddenClassName,
    hideLogo,
    withFormatTransferUrl
  } = _ref;
  const [isInitialized, setIsInitialized] = useState(!!qrCode);
  const logoUrl = src_config/* IS_CORE_WALLET */.TI6 ? './coreWallet/logo.svg' : './logo.svg';
  const qrCodeRef = teact_useRef();
  teact_useEffect(() => {
    if (isInitialized) return;
    void __webpack_require__.e(/* import() */ 283).then(__webpack_require__.t.bind(__webpack_require__, 97283, 23)).then(_ref2 => {
      let {
        default: QrCodeStyling
      } = _ref2;
      qrCode = new QrCodeStyling({
        width: QR_SIZE,
        height: QR_SIZE,
        image: chain ? getChainNetworkIcon(chain) : logoUrl,
        margin: 0,
        type: 'canvas',
        dotsOptions: {
          type: 'rounded'
        },
        cornersSquareOptions: {
          type: 'extra-rounded'
        },
        imageOptions: {
          imageSize: 0.4,
          margin: 8,
          crossOrigin: 'anonymous'
        },
        qrOptions: {
          errorCorrectionLevel: 'M'
        },
        data: formatTransferUrl('')
      });
      setIsInitialized(true);
    });
  }, [chain, isInitialized, logoUrl]);
  useLayoutEffect(() => {
    if (!isActive || !isInitialized) return;
    if (qrCodeRef.current && hiddenClassName) removeExtraClass(qrCodeRef.current, hiddenClassName);
    if (qrCodeRef.current) {
      var _qrCode;
      (_qrCode = qrCode) === null || _qrCode === void 0 || _qrCode.append(qrCodeRef.current);
      qrCode._options.image = hideLogo ? undefined : chain ? getChainNetworkIcon(chain) : logoUrl;
    }
  }, [isActive, isInitialized, hiddenClassName, hideLogo, chain, logoUrl]);
  teact_useEffect(() => {
    if (!address || !isActive || !qrCode || !isInitialized) return;
    qrCode.update({
      data: withFormatTransferUrl ? formatTransferUrl(address) : address
    });
  }, [address, isActive, isInitialized, withFormatTransferUrl]);
  return {
    qrCodeRef,
    isInitialized
  };
}
;// ./src/components/receive/content/TonContent.tsx









function TonContent(_ref) {
  let {
    isActive,
    isStatic,
    isLedger,
    address,
    onClose
  } = _ref;
  const {
    verifyHardwareAddress
  } = getActions();
  const lang = hooks_useLang();
  const {
    qrCodeRef,
    isInitialized
  } = useQrCode({
    address,
    chain: 'ton',
    isActive,
    hiddenClassName: ReceiveModal_module.qrCodeHidden,
    withFormatTransferUrl: true
  });
  const qrClassNames = buildClassName(ReceiveModal_module.qrCode, isStatic && ReceiveModal_module.qrCodeStatic, !isInitialized && ReceiveModal_module.qrCodeHidden);
  const handleVerify = e => {
    e.preventDefault();
    e.stopPropagation();
    verifyHardwareAddress();
  };
  return /*#__PURE__*/teact.createElement("div", null, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(ReceiveModal_module.contentTitle, ReceiveModal_module.contentTitleQr)
  }, renderText(lang('$receive_ton_description'))), /*#__PURE__*/teact.createElement("div", {
    className: qrClassNames,
    ref: qrCodeRef
  }), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
    chain: "ton",
    address: address,
    className: isStatic ? ReceiveModal_module.copyButtonStatic : ReceiveModal_module.addressWrapper,
    copyNotification: lang('Your address was copied!'),
    noSavedAddress: true,
    noDimming: true
  }), isLedger && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(ReceiveModal_module.contentTitle, ReceiveModal_module.contentTitleLedger, isStatic && ReceiveModal_module.contentTitleLedgerStatic)
  }, renderText(lang('$ledger_verify_address')), ' ', /*#__PURE__*/teact.createElement("a", {
    href: "#",
    onClick: handleVerify,
    className: ReceiveModal_module.dottedLink
  }, lang('Verify now'))), !isStatic && /*#__PURE__*/teact.createElement(content_TonActions, {
    isLedger: isLedger,
    onClose: onClose
  }));
}
/* harmony default export */ const content_TonContent = (memo(TonContent));
;// ./src/components/receive/content/TronActions.tsx







function TronActions(_ref) {
  let {
    className,
    isStatic,
    isTestnet,
    isLedger,
    isSwapDisabled,
    isOnRampDisabled,
    countryCode,
    onClose
  } = _ref;
  const {
    startSwap,
    openOnRampWidgetModal
  } = getActions();
  const lang = hooks_useLang();
  const canBuyWithCard = countryCode !== 'RU';
  const isSwapAllowed = !isTestnet && !isLedger && !isSwapDisabled;
  // TRX purchase is not possible via the Dreamwalkers service (Russian), however in static mode we show the buy button
  const isOnRampAllowed = !isTestnet && !isOnRampDisabled && (canBuyWithCard || isStatic);
  const shouldRender = Boolean(isSwapAllowed || isOnRampAllowed || isStatic);
  const handleBuyFiat = useLastCallback(() => {
    openOnRampWidgetModal({
      chain: 'tron'
    });
    onClose === null || onClose === void 0 || onClose();
  });
  const handleSwapClick = useLastCallback(() => {
    startSwap({
      tokenInSlug: src_config/* DEFAULT_TRX_SWAP_FIRST_TOKEN_SLUG */.iX4,
      tokenOutSlug: src_config/* TRX */.X7T.slug,
      amountIn: '10'
    });
    onClose === null || onClose === void 0 || onClose();
  });
  const contentClassName = buildClassName(TonActions_module.actionButtons, isStatic && TonActions_module.actionButtonStatic, className);
  if (!shouldRender) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: contentClassName
  }, isOnRampAllowed && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(TonActions_module.actionButton, !canBuyWithCard && TonActions_module.disabled),
    onClick: canBuyWithCard ? handleBuyFiat : undefined
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.actionIcon, 'icon-card'),
    "aria-hidden": true
  }), lang('Buy with Card'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })), isSwapAllowed && /*#__PURE__*/teact.createElement("div", {
    className: TonActions_module.actionButton,
    onClick: handleSwapClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.actionIcon, 'icon-crypto'),
    "aria-hidden": true
  }), lang('Buy with Crypto'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })), isStatic && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(TonActions_module.actionButton, TonActions_module.disabled)
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.actionIcon, 'icon-link'),
    "aria-hidden": true
  }), lang('Create Deposit Link'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(TonActions_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })));
}
/* harmony default export */ const content_TronActions = (memo(withGlobal(global => {
  const {
    isSwapDisabled,
    isOnRampDisabled,
    countryCode
  } = global.restrictions;
  return {
    isTestnet: global.settings.isTestnet,
    isSwapDisabled,
    isOnRampDisabled,
    countryCode
  };
})(TronActions)));
;// ./src/components/receive/content/TronContent.tsx








function TronContent(_ref) {
  let {
    isActive,
    isStatic,
    address,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const {
    qrCodeRef,
    isInitialized
  } = useQrCode({
    address,
    chain: 'tron',
    isActive,
    hiddenClassName: ReceiveModal_module.qrCodeHidden,
    withFormatTransferUrl: false
  });
  const qrClassNames = buildClassName(ReceiveModal_module.qrCode, isStatic && ReceiveModal_module.qrCodeStatic, !isInitialized && ReceiveModal_module.qrCodeHidden);
  return /*#__PURE__*/teact.createElement("div", null, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(ReceiveModal_module.contentTitle, ReceiveModal_module.contentTitleQr)
  }, renderText(lang('$receive_tron_description'))), /*#__PURE__*/teact.createElement("div", {
    className: qrClassNames,
    ref: qrCodeRef
  }), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
    chain: "tron",
    address: address,
    className: isStatic ? ReceiveModal_module.copyButtonStatic : ReceiveModal_module.addressWrapper,
    copyNotification: lang('Your address was copied!'),
    noSavedAddress: true,
    noDimming: true
  }), !isStatic && /*#__PURE__*/teact.createElement(content_TronActions, {
    onClose: onClose
  }));
}
/* harmony default export */ const content_TronContent = (memo(TronContent));
;// ./src/components/receive/Content.tsx














const TON_TAB_ID = 0;
const TRON_TAB_ID = 1;
function Content(_ref) {
  let {
    isOpen,
    addressByChain,
    chain,
    isStatic,
    isLedger,
    onClose
  } = _ref;
  const {
    setReceiveActiveTab
  } = getActions();

  // `lang.code` is used to force redrawing of the `Transition` content,
  // since the height of the content differs from translation to translation.
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const tabs = teact_useMemo(() => {
    const result = [];
    if (addressByChain !== null && addressByChain !== void 0 && addressByChain.ton) {
      result.push({
        id: TON_TAB_ID,
        title: 'TON',
        className: buildClassName(ReceiveModal_module.tab, ReceiveModal_module.tabTon)
      });
    }
    if (addressByChain !== null && addressByChain !== void 0 && addressByChain.tron) {
      result.push({
        id: TRON_TAB_ID,
        title: 'TRON',
        className: buildClassName(ReceiveModal_module.tab, ReceiveModal_module.tabTron)
      });
    }
    return result;
  }, [addressByChain === null || addressByChain === void 0 ? void 0 : addressByChain.ton, addressByChain === null || addressByChain === void 0 ? void 0 : addressByChain.tron]);
  const activeTab = teact_useMemo(() => {
    if (!chain) return tabs.length ? tabs[0].id : TON_TAB_ID;
    return chain === 'tron' ? TRON_TAB_ID : TON_TAB_ID;
  }, [chain, tabs]);
  const handleSwitchTab = useLastCallback(tabId => {
    const newChain = tabId === TRON_TAB_ID ? 'tron' : 'ton';
    setReceiveActiveTab({
      chain: newChain
    });
  });
  function renderActions() {
    const currentTab = tabs.find(tab => tab.id === activeTab);
    if ((currentTab === null || currentTab === void 0 ? void 0 : currentTab.id) === TRON_TAB_ID) {
      return /*#__PURE__*/teact.createElement(content_TronActions, {
        isStatic: true
      });
    }
    return /*#__PURE__*/teact.createElement(content_TonActions, {
      isStatic: true,
      isLedger: isLedger
    });
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case TON_TAB_ID:
        return /*#__PURE__*/teact.createElement(content_TonContent, {
          isActive: isOpen && isActive,
          isStatic: isStatic,
          isLedger: isLedger,
          address: addressByChain.ton,
          onClose: onClose
        });
      case TRON_TAB_ID:
        return /*#__PURE__*/teact.createElement(content_TronContent, {
          isActive: isOpen && isActive,
          isStatic: isStatic,
          address: addressByChain.tron,
          onClose: onClose
        });
    }
  }
  if (!tabs.length) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, isStatic && renderActions(), tabs.length > 1 && /*#__PURE__*/teact.createElement(ui_TabList, {
    tabs: tabs,
    activeTab: activeTab,
    className: buildClassName(ReceiveModal_module.tabs, !isStatic && ReceiveModal_module.tabsInModal),
    overlayClassName: buildClassName(ReceiveModal_module.tabsOverlay, activeTab === TRON_TAB_ID && ReceiveModal_module.tronActive),
    onSwitchTab: handleSwitchTab
  }), /*#__PURE__*/teact.createElement(ui_Transition, {
    key: `content_${lang.code}`,
    activeKey: activeTab,
    name: isPortrait ? 'slide' : 'slideFade',
    className: ReceiveModal_module.contentWrapper,
    slideClassName: buildClassName(ReceiveModal_module.content, isStatic && ReceiveModal_module.contentStatic, 'custom-scroll'),
    shouldRestoreHeight: isStatic
  }, renderContent));
}
/* harmony default export */ const receive_Content = (memo(withGlobal(global => {
  const account = selectAccount(global, global.currentAccountId);
  const {
    receiveModalChain
  } = selectCurrentAccountState(global) || {};
  return {
    addressByChain: account === null || account === void 0 ? void 0 : account.addressByChain,
    isLedger: Boolean(account === null || account === void 0 ? void 0 : account.ledger),
    chain: receiveModalChain
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Content)));
;// ./src/components/receive/ReceiveModal.tsx











function ReceiveModal(_ref) {
  let {
    isOpen,
    isTestnet,
    isLedger,
    isSwapDisabled,
    isOnRampDisabled,
    isMultichainAccount
  } = _ref;
  const {
    closeReceiveModal
  } = getActions();
  const lang = hooks_useLang();
  const {
    isLandscape
  } = useDeviceScreen();
  const isSwapAllowed = !isTestnet && !isLedger && !isSwapDisabled;
  const isOnRampAllowed = !isTestnet && !isOnRampDisabled;
  const modalTitle = lang(isSwapAllowed || isOnRampAllowed ? 'Add / Buy' : 'Add');
  teact_useEffect(() => {
    if (isOpen && isLandscape) {
      closeReceiveModal();
    }
  }, [isLandscape, isOpen]);
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    dialogClassName: windowEnvironment/* IS_IOS_APP */.ZH ? ReceiveModal_module.iosModalDialog : ReceiveModal_module.modalDialog,
    nativeBottomSheetKey: "receive",
    onClose: closeReceiveModal
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: modalTitle,
    className: buildClassName(ReceiveModal_module.receiveHeader, !isMultichainAccount && ReceiveModal_module.receiveHeaderNoTabs),
    onClose: closeReceiveModal
  }), /*#__PURE__*/teact.createElement(receive_Content, {
    isOpen: isOpen,
    onClose: closeReceiveModal
  }));
}
/* harmony default export */ const receive_ReceiveModal = (memo(withGlobal(global => {
  const {
    isSwapDisabled,
    isOnRampDisabled
  } = global.restrictions;
  const account = selectCurrentAccount(global);
  return {
    isOpen: global.isReceiveModalOpen,
    isTestnet: global.settings.isTestnet,
    isSwapDisabled,
    isOnRampDisabled,
    isLedger: Boolean(account === null || account === void 0 ? void 0 : account.ledger),
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId)
  };
})(ReceiveModal)));
;// ./src/components/common/TransferResult.tsx











function TransferResult(_ref) {
  let {
    isSensitiveDataHidden,
    playAnimation,
    amount = 0n,
    tokenSymbol = src_config/* TONCOIN */.Tu9.symbol,
    decimals = src_config/* TONCOIN */.Tu9.decimals,
    noSign,
    color,
    firstButtonText,
    secondButtonText,
    onFirstButtonClick,
    onSecondButtonClick
  } = _ref;
  const amountString = (0,util_decimals/* toDecimal */.nI)(amount, decimals);
  const [wholePart, fractionPart] = formatCurrencyExtended(amountString, '', noSign, decimals).split('.');
  const amountCols = teact_useMemo(() => getPseudoRandomNumber(5, 13, tokenSymbol), [tokenSymbol]);
  function renderButtons() {
    if (!firstButtonText && !secondButtonText) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: TransferResult_module.buttons
    }, firstButtonText && /*#__PURE__*/teact.createElement(ui_Button, {
      className: TransferResult_module.button,
      onClick: onFirstButtonClick
    }, firstButtonText), secondButtonText && /*#__PURE__*/teact.createElement(ui_Button, {
      className: TransferResult_module.button,
      onClick: onSecondButtonClick
    }, secondButtonText));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: playAnimation,
    noLoop: false,
    nonInteractive: true,
    className: TransferResult_module.sticker,
    tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
    previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
  }), /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    cols: amountCols,
    rows: 3,
    cellSize: 18,
    align: "center",
    maskSkin: "green",
    className: buildClassName(TransferResult_module.amount, color && TransferResult_module[`amount_${color}`], 'rounded-font')
  }, wholePart.trim().replace('\u202F', '').replace('-', 'âˆ’'), fractionPart && /*#__PURE__*/teact.createElement("span", {
    className: TransferResult_module.amountFraction
  }, ".", fractionPart.trim()), /*#__PURE__*/teact.createElement("span", {
    className: TransferResult_module.amountSymbol
  }, tokenSymbol)), renderButtons());
}
/* harmony default export */ const common_TransferResult = (memo(TransferResult));
;// ./src/global/helpers/getHelpCenterUrl.ts

function getHelpCenterUrl(langCode, type) {
  var _HELP_CENTER_URL$type;
  if (!langCode) return '';
  return ((_HELP_CENTER_URL$type = src_config/* HELP_CENTER_URL */.mEK[type]) === null || _HELP_CENTER_URL$type === void 0 ? void 0 : _HELP_CENTER_URL$type[langCode]) ?? src_config/* HELP_CENTER_URL */.mEK[type].en;
}
;// ./src/util/ton/calcJettonStakingApr.ts


function calcJettonStakingApr(_ref) {
  let {
    tvl,
    dailyReward,
    decimals
  } = _ref;
  if (!tvl) {
    return 0;
  }
  const apr = (0,util_decimals/* toBig */.CF)(dailyReward, decimals).div((0,util_decimals/* toBig */.CF)(tvl, decimals)).mul(DAYS_IN_YEAR).mul(100).toFixed(2);
  return Number(apr);
}
;// ./src/components/ui/hooks/useAmountInputState.ts








/**
 * Provides the stateful functionality for `AmountInput`. It is not embedded into `AmountInput`, because sometimes
 * `<AmountInput>` has to be remounted while its state must persist.
 */
function useAmountInputState(input) {
  const {
    baseCurrency,
    onAmountChange
  } = input;
  const {
    isBaseCurrency,
    switchCurrency,
    ...output
  } = useCurrencySwitch(input);
  const onMaxAmountClick = useLastCallback(maxAmount => {
    if (maxAmount === undefined) {
      return;
    }
    void vibrate();
    switchCurrency(false);
    onAmountChange(maxAmount, true);
  });
  const onAlternativeAmountClick = useLastCallback(() => {
    void vibrate();
    switchCurrency(!isBaseCurrency);
  });
  return {
    ...output,
    isBaseCurrency,
    baseCurrency,
    onMaxAmountClick,
    onAlternativeAmountClick
  };
}
function useCurrencySwitch(_ref) {
  let {
    baseCurrency,
    amount: tokenAmountBI,
    token,
    isAmountReadonly,
    onAmountChange,
    onTokenChange: setToken
  } = _ref;
  const [isBaseCurrency, setIsBaseCurrency] = useState(false);
  const tokenAmountRef = teact_useRef();
  const currencyAmountRef = teact_useRef();
  const currencyDecimals = src_config/* CURRENCIES */.yR2[baseCurrency].decimals;
  const setAmountsFromToken = tokenAmount => {
    tokenAmountRef.current = tokenAmount;
    currencyAmountRef.current = tokenAmountToCurrencyAmount(tokenAmount, token === null || token === void 0 ? void 0 : token.price, currencyDecimals);
  };
  const setAmountsFromCurrency = currencyAmount => {
    tokenAmountRef.current = currencyAmountToTokenAmount(currencyAmount, token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.decimals);
    currencyAmountRef.current = currencyAmount;
  };
  const setAndReportAmountFromPrice = (price, decimals) => {
    if (isBaseCurrency && !isAmountReadonly) {
      const newTokenAmount = currencyAmountToTokenAmount(currencyAmountRef.current, price, decimals);
      if (newTokenAmount !== formalizeStringAmount(tokenAmountRef.current)) {
        tokenAmountRef.current = newTokenAmount; // If not set, the render following the `onAmountChange` call may change the input value
        onAmountChange(tokenAmountToBigInt(newTokenAmount, decimals));
      }
    } else {
      currencyAmountRef.current = tokenAmountToCurrencyAmount(tokenAmountRef.current, price, currencyDecimals);
    }
  };

  // Actualizes both values when a new token amount arrives from the parent
  useSyncEffect(() => {
    const newTokenAmount = tokenAmountFromBigInt(tokenAmountBI, token === null || token === void 0 ? void 0 : token.decimals);
    if (newTokenAmount !== formalizeStringAmount(tokenAmountRef.current)) {
      setAmountsFromToken(newTokenAmount);
    }
  }, [tokenAmountBI, token === null || token === void 0 ? void 0 : token.decimals]); // eslint-disable-line react-hooks-static-deps/exhaustive-deps

  // Actualizes the alternative (below the input) value when the token price changes.
  // If the input is readonly, actualizes only the currency value regardless of `isBaseCurrency`
  useSyncEffect(() => {
    setAndReportAmountFromPrice(token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.decimals);
  }, [token === null || token === void 0 ? void 0 : token.price, token === null || token === void 0 ? void 0 : token.decimals, currencyDecimals]); // eslint-disable-line react-hooks-static-deps/exhaustive-deps

  const onInputChange = useLastCallback(value => {
    value ||= undefined;
    if (isBaseCurrency) {
      setAmountsFromCurrency(value);
    } else {
      setAmountsFromToken(value);
    }
    onAmountChange(tokenAmountToBigInt(tokenAmountRef.current, token === null || token === void 0 ? void 0 : token.decimals));
  });
  const onTokenChange = useLastCallback((id, newToken) => {
    setToken === null || setToken === void 0 || setToken(id);
    if (newToken) {
      // The goal is to make the new token and the new amount arrive in the same next render.
      // Otherwise, the token amount won't change until the next render (by an above `useSyncEffect`).
      // This could cause unwanted visual glitches like a blinking balance error.
      setAndReportAmountFromPrice(newToken.price, newToken.decimals);
    }
  });
  return {
    isBaseCurrency,
    isAmountReadonly,
    inputValue: isBaseCurrency ? currencyAmountRef.current : tokenAmountRef.current,
    alternativeValue: isBaseCurrency ? tokenAmountRef.current : currencyAmountRef.current,
    switchCurrency: setIsBaseCurrency,
    onInputChange,
    onTokenChange
  };
}
function tokenAmountToCurrencyAmount(amount, tokenPrice, currencyDecimals) {
  return amount && tokenPrice !== undefined ? (0,big_js/* Big */.z)(amount).mul(tokenPrice).round(currencyDecimals).toString() : undefined;
}
function currencyAmountToTokenAmount(amount, tokenPrice, tokenDecimals) {
  // Avoiding dividing by zero for tokens with price 0
  return amount && tokenPrice ? (0,big_js/* Big */.z)(amount).div(tokenPrice).round(tokenDecimals ?? constants/* DEFAULT_DECIMALS */.fI).toString() : undefined;
}
function tokenAmountToBigInt(amount, decimals) {
  return amount ? (0,util_decimals/* fromDecimal */.UH)(amount, decimals) : undefined;
}
function tokenAmountFromBigInt(amount, decimals) {
  return amount === undefined ? undefined : (0,util_decimals/* toDecimal */.nI)(amount, decimals);
}

/** For example, turns '1.2300' into '1.23' */
function formalizeStringAmount(amount) {
  if (!amount) {
    return undefined;
  }
  if (!amount.includes('.')) {
    return amount;
  }
  let end = amount.length;
  while (amount[end - 1] === '0') {
    end--;
  }
  if (amount[end - 1] === '.') {
    end--;
  }
  return amount.slice(0, end);
}
;// ./src/components/staking/hooks/useTokenDropdown.ts


function useTokenDropdown(_ref) {
  let {
    tokenBySlug,
    states,
    shouldUseNominators,
    selectedStakingId,
    isViewMode
  } = _ref;
  const selectableTokens = teact_useMemo(() => {
    if (!tokenBySlug || !states) {
      return [];
    }
    let tokens = getStakingTokens(tokenBySlug, states, shouldUseNominators);
    if (isViewMode) {
      tokens = tokens.filter(_ref2 => {
        let {
          id
        } = _ref2;
        return id === selectedStakingId;
      });
    }
    return tokens;
  }, [tokenBySlug, states, shouldUseNominators, isViewMode, selectedStakingId]);
  const selectedToken = teact_useMemo(() => selectableTokens.find(token => token.id === selectedStakingId), [selectableTokens, selectedStakingId]);
  return [selectedToken, selectableTokens];
}
function getStakingTokens(tokenBySlug, states, shouldUseNominators) {
  const hasNominatorsStake = states.some(state => state.type === 'nominators' && getIsActiveStakingState(state));
  const hasLiquidStake = states.some(state => state.type === 'liquid' && getIsActiveStakingState(state));
  if (shouldUseNominators && !hasLiquidStake) {
    states = states.filter(state => state.type !== 'liquid');
  }
  if (!shouldUseNominators && !hasNominatorsStake) {
    states = states.filter(state => state.type !== 'nominators');
  }
  return states.filter(state => tokenBySlug[state.tokenSlug]).map(state => ({
    ...tokenBySlug[state.tokenSlug],
    id: state.id
  }));
}
;// ./src/hooks/useTransitionActiveKey.ts


// Use this hook to bind `<Transition />` animation to changes in the dependency array.
// Use optional parameter `noAnimation` if you want to prevent the animation even if the dependency array changes.
function useTransitionActiveKey(deps, noAnimation) {
  const activeKey = teact_useRef(0);
  teact_useMemo(() => {
    if (!noAnimation) activeKey.current += 1;
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, deps);
  return activeKey.current;
}
;// ./src/components/ui/AmountInputMaxButton.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AmountInputMaxButton_module = ({"container":"AmountInputMaxButton-module__container","content":"AmountInputMaxButton-module__content","link":"AmountInputMaxButton-module__link"});
;// ./src/components/ui/AmountInputMaxButton.tsx







/**
 * Put the element right above a <RichNumberInput />, it will take the space right to the input label without moving the
 * around content.
 */
function AmountInputMaxButton(_ref) {
  let {
    maxAmount,
    token,
    isLoading,
    isSensitiveDataHidden,
    isAllMode,
    onAmountClick
  } = _ref;
  const lang = hooks_useLang();
  const content = isLoading ? lang('Loading...') : !token || maxAmount === undefined ? '' : isSensitiveDataHidden ? `*** ${token.symbol}` : isAllMode ? formatCurrencySimple(maxAmount, token.symbol, token.decimals) : formatCurrency((0,util_decimals/* toDecimal */.nI)(maxAmount, token.decimals), token.symbol);
  const transitionKey = useTransitionActiveKey([!content, token === null || token === void 0 ? void 0 : token.symbol, isLoading, isSensitiveDataHidden]);
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "fade",
    activeKey: transitionKey,
    shouldCleanup: true,
    className: AmountInputMaxButton_module.container
  }, content && /*#__PURE__*/teact.createElement("span", {
    className: AmountInputMaxButton_module.content
  }, lang(isAllMode ? '$all_balance' : '$max_balance', {
    balance: /*#__PURE__*/teact.createElement("div", {
      role: "button",
      tabIndex: 0,
      onClick: () => onAmountClick(maxAmount),
      className: AmountInputMaxButton_module.link
    }, content)
  })));
}
/* harmony default export */ const ui_AmountInputMaxButton = (memo(AmountInputMaxButton));
;// ./src/components/ui/TokenDropdown.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TokenDropdown_module = ({"dropdown":"TokenDropdown-module__dropdown","dropdown__prefix":"TokenDropdown-module__dropdown__prefix","dropdownPrefix":"TokenDropdown-module__dropdown__prefix","prefix":"TokenDropdown-module__prefix","purple":"TokenDropdown-module__purple"});
;// ./src/components/ui/TokenDropdown.tsx







const EMPTY_TOKEN_LIST = [];
function TokenDropdown(_ref) {
  let {
    selectedToken,
    allTokens = EMPTY_TOKEN_LIST,
    isMultichainAccount,
    theme,
    isInMode,
    onChange
  } = _ref;
  const lang = hooks_useLang();
  const buttonPrefixText = lang('$in_currency', {
    currency: ''
  });
  const buttonPrefix = teact_useMemo(() => {
    return isInMode && /*#__PURE__*/teact.createElement("span", {
      className: TokenDropdown_module.prefix
    }, buttonPrefixText);
  }, [isInMode, buttonPrefixText]);
  const items = teact_useMemo(() => allTokens.map(token => tokenToDropdownItem(token, isMultichainAccount)), [allTokens, isMultichainAccount]);
  const tokenById = teact_useMemo(() => allTokens.reduce((byId, token) => {
    byId[getTokenId(token)] = token;
    return byId;
  }, {}), [allTokens]);
  const handleChange = useLastCallback(id => {
    const token = tokenById[id];
    onChange === null || onChange === void 0 || onChange(id, token);
  });
  if (!items.length) {
    return undefined;
  }
  const selectedTokenId = !selectedToken || typeof selectedToken === 'string' ? selectedToken : getTokenId(selectedToken);
  return /*#__PURE__*/teact.createElement(ui_Dropdown, {
    items: items,
    selectedValue: selectedTokenId,
    buttonPrefix: buttonPrefix,
    className: TokenDropdown_module.dropdown,
    menuClassName: theme && TokenDropdown_module[theme],
    onChange: handleChange
  });
}
/* harmony default export */ const ui_TokenDropdown = (memo(TokenDropdown));
function getTokenId(token) {
  return token.id ?? token.slug;
}
function tokenToDropdownItem(token, isMultichainAccount) {
  return {
    value: getTokenId(token),
    icon: ASSET_LOGO_PATHS[token.symbol.toLowerCase()] || token.image,
    overlayIcon: isMultichainAccount ? getChainNetworkIcon(token.chain) : undefined,
    name: token.symbol
  };
}
;// ./src/components/ui/AmountInput.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AmountInput_module = ({"container":"AmountInput-module__container","container__slide":"AmountInput-module__container__slide","containerSlide":"AmountInput-module__container__slide","input":"AmountInput-module__input","bottom":"AmountInput-module__bottom","bottom__right":"AmountInput-module__bottom__right","bottomRight":"AmountInput-module__bottom__right","alternative":"AmountInput-module__alternative","alternative__icon":"AmountInput-module__alternative__icon","alternativeIcon":"AmountInput-module__alternative__icon"});
;// ./src/components/ui/AmountInput.tsx














function AmountInput(_ref) {
  let {
    isBaseCurrency,
    inputValue,
    alternativeValue,
    baseCurrency,
    maxAmount,
    token,
    allTokens,
    isStatic,
    hasError,
    isMultichainAccount,
    isSensitiveDataHidden,
    isMaxAmountLoading,
    isMaxAmountAllMode,
    renderBottomRight,
    isAmountReadonly,
    labelText,
    onTokenChange,
    onPressEnter,
    onInputChange,
    onMaxAmountClick,
    onAlternativeAmountClick
  } = _ref;
  const lang = hooks_useLang();
  const transitionKey = isBaseCurrency ? 0 : 1;
  const {
    inputId,
    onInputFocus,
    onInputBlur,
    onClick: keepInputFocus
  } = useKeepInputFocus(transitionKey);
  const handleMaxAmountClick = useLastCallback(() => {
    onMaxAmountClick(maxAmount);
    keepInputFocus();
  });
  function renderBalance() {
    return /*#__PURE__*/teact.createElement(ui_AmountInputMaxButton, {
      maxAmount: isAmountReadonly ? undefined : maxAmount,
      token: token,
      isLoading: isMaxAmountLoading,
      isAllMode: isMaxAmountAllMode,
      isSensitiveDataHidden: isSensitiveDataHidden,
      onAmountClick: handleMaxAmountClick
    });
  }
  function renderInput() {
    let prefix;
    let suffix;
    if (isBaseCurrency) {
      const {
        shortSymbol
      } = src_config/* CURRENCIES */.yR2[baseCurrency];
      if (shortSymbol) {
        prefix = shortSymbol;
      } else {
        suffix = baseCurrency;
      }
    }
    return /*#__PURE__*/teact.createElement(ui_RichNumberInput, {
      id: inputId,
      hasError: hasError,
      value: inputValue,
      labelText: labelText ?? lang('Amount'),
      decimals: isBaseCurrency ? src_config/* CURRENCIES */.yR2[baseCurrency].decimals : token === null || token === void 0 ? void 0 : token.decimals,
      className: AmountInput_module.input,
      isStatic: isStatic,
      prefix: prefix,
      suffix: suffix,
      disabled: isAmountReadonly,
      onChange: onInputChange,
      onPressEnter: onPressEnter,
      onFocus: onInputFocus,
      onBlur: onInputBlur
    }, renderTokens());
  }
  function renderTokens() {
    return /*#__PURE__*/teact.createElement(ui_TokenDropdown, {
      selectedToken: token,
      allTokens: allTokens,
      isInMode: isBaseCurrency,
      isMultichainAccount: isMultichainAccount,
      onChange: onTokenChange
    });
  }
  function renderAlternativeAmount() {
    const symbol = isBaseCurrency ? (token === null || token === void 0 ? void 0 : token.symbol) ?? '' : getShortCurrencySymbol(baseCurrency);
    const onClick = () => {
      onAlternativeAmountClick();
      keepInputFocus();
    };

    // The main reason to use <button> is preventing the comment type selector (which is also a <button>) from hijacking
    // the clicks on touch screens.
    return /*#__PURE__*/teact.createElement("button", {
      type: "button",
      className: AmountInput_module.alternative,
      onClick: onClick
    }, "\u2248\u2009", formatCurrency(alternativeValue ?? 0, symbol, undefined, true), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(AmountInput_module.alternative__icon, 'icon-switch'),
      "aria-hidden": true
    }));
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: transitionKey,
    name: "semiFade",
    shouldCleanup: true,
    className: AmountInput_module.container,
    slideClassName: AmountInput_module.container__slide
  }, renderBalance(), renderInput(), /*#__PURE__*/teact.createElement("div", {
    className: AmountInput_module.bottom
  }, renderAlternativeAmount(), renderBottomRight(AmountInput_module.bottom__right)));
}
/* harmony default export */ const ui_AmountInput = (memo(AmountInput));

/**
 * Clicking the currency switch button un-focuses the input. This creates a bad UX with virtual keyboard.
 * To improve the UX, we focus the input back when the user clicks the currency switch button.
 * We focus only if the input was focused before the click, because Native Bottom Sheet renders a couple blank
 * frames when the virtual keyboard is not open and the focus is triggered programmatically.
 */
function useKeepInputFocus(transitionKey) {
  const inputId = `${useUniqueId()}_${transitionKey}`;
  const isFocused = teact_useRef(false);
  const cancelFocusTimer = teact_useRef();
  const inputFocusPersistDuration = 0.5 * SEC;
  const onInputFocus = useLastCallback(() => {
    var _cancelFocusTimer$cur;
    (_cancelFocusTimer$cur = cancelFocusTimer.current) === null || _cancelFocusTimer$cur === void 0 || _cancelFocusTimer$cur.call(cancelFocusTimer);
    isFocused.current = true;
  });
  const onInputBlur = useLastCallback(() => {
    var _cancelFocusTimer$cur2;
    (_cancelFocusTimer$cur2 = cancelFocusTimer.current) === null || _cancelFocusTimer$cur2 === void 0 || _cancelFocusTimer$cur2.call(cancelFocusTimer);
    cancelFocusTimer.current = (0,schedulers/* setCancellableTimeout */.Gf)(inputFocusPersistDuration, () => {
      isFocused.current = false;
    });
  });
  const onClick = () => {
    if (isFocused.current) {
      focusAtTheEnd(inputId); // To keep the virtual keyboard open
    }
  };

  // The input element is replaced as a result of the transition, so we need to focus the new input
  teact_useEffect(() => {
    if (isFocused.current) {
      focusAtTheEnd(inputId);
    }
  }, [transitionKey]); // eslint-disable-line react-hooks-static-deps/exhaustive-deps

  return {
    inputId,
    onInputFocus,
    onInputBlur,
    onClick
  };
}
;// ./src/global/helpers/number.ts


const getNumberRegex = (0,withCache/* default */.A)(decimals => {
  return decimals === 0 ? /^(\d+)/ : new RegExp(`^(\\d+)([.,])?(\\d{1,${decimals}})?`);
});
function getNumberParts(value) {
  let decimals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : src_config/* TONCOIN */.Tu9.decimals;
  const regex = getNumberRegex(decimals);
  return value.match(regex) || undefined;
}
;// ./src/components/ui/RichNumberField.tsx









const RichNumberField_MIN_LENGTH_FOR_SHRINK = 5;
function RichNumberField(_ref) {
  let {
    id,
    labelText,
    value,
    error,
    prefix,
    suffix,
    zeroValue,
    decimals = src_config/* FRACTION_DIGITS */.I04,
    className,
    isSensitiveData,
    isSensitiveDataHidden,
    sensitiveDataMaskSkin,
    isStatic,
    inputClassName,
    labelClassName,
    valueClassName,
    children
  } = _ref;
  const contentRef = teact_useRef();
  const prevValueRef = teact_useRef('');
  const {
    updateFontScale,
    isFontChangedRef
  } = hooks_useFontScale(contentRef, true);
  const renderValue = useLastCallback(function () {
    let inputValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    let noFallbackToPrev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const contentEl = contentRef.current;
    const valueRegex = getNumberRegex(decimals);
    const values = inputValue.match(valueRegex);

    // eslint-disable-next-line no-null/no-null
    if (values === null || values.length < 4 || values[0] === '') {
      if (noFallbackToPrev || inputValue === '') {
        prevValueRef.current = '';
        contentEl.innerText = '';
      } else {
        renderValue(prevValueRef.current, true);
      }
      return;
    }
    const textContent = (values === null || values === void 0 ? void 0 : values[0]) || '';
    prevValueRef.current = inputValue;
    contentEl.innerHTML = buildContentHtml(inputValue, prefix, suffix, decimals, true);
    if (textContent.length > RichNumberField_MIN_LENGTH_FOR_SHRINK || isFontChangedRef.current) {
      updateFontScale();
    }
  });
  useLayoutEffect(() => {
    if (value) {
      renderValue(value);
    } else if (zeroValue) {
      contentRef.current.textContent = zeroValue;
    }
  }, [prefix, suffix, decimals, renderValue, value, zeroValue]);
  const inputWrapperFullClass = buildClassName(Input_module.input__wrapper, isStatic && Input_module.inputWrapperStatic, inputClassName);
  const inputFullClass = buildClassName(Input_module.rich__value, Input_module.input, Input_module.large, Input_module.disabled, error && Input_module.error, 'rounded-font', valueClassName);
  const labelTextClassName = buildClassName(Input_module.label, labelClassName);
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Input_module.wrapper, className)
  }, error && /*#__PURE__*/teact.createElement("label", {
    className: buildClassName(Input_module.label, Input_module.label_error, Input_module.error),
    htmlFor: id
  }, error), labelText && /*#__PURE__*/teact.createElement("label", {
    className: labelTextClassName,
    htmlFor: id,
    id: `${id}Label`
  }, labelText), /*#__PURE__*/teact.createElement("div", {
    className: inputWrapperFullClass
  }, isSensitiveData ? /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    cols: 8,
    rows: 3,
    cellSize: 16,
    maskSkin: sensitiveDataMaskSkin
    // Adding `.large` to remove the excessive bottom padding created by SensitiveData (the `height` property does the job)
    ,
    className: buildClassName(Input_module.rich, Input_module.large),
    maskClassName: Input_module.mask
  }, /*#__PURE__*/teact.createElement("div", {
    ref: contentRef,
    id: id,
    className: inputFullClass
  })) : /*#__PURE__*/teact.createElement("div", {
    className: Input_module.rich
  }, /*#__PURE__*/teact.createElement("div", {
    ref: contentRef,
    id: id,
    className: inputFullClass
  })), children));
}
/* harmony default export */ const ui_RichNumberField = (memo(RichNumberField));
;// ./src/components/staking/Staking.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Staking_module = ({"modalDialog":"Staking-module__modalDialog","welcome":"Staking-module__welcome","welcome_static":"Staking-module__welcome_static","welcomeStatic":"Staking-module__welcome_static","welcomeInformation":"Staking-module__welcomeInformation","welcomeInformation_static":"Staking-module__welcomeInformation_static","welcomeInformationStatic":"Staking-module__welcomeInformation_static","stakingApy":"Staking-module__stakingApy","textButton":"Staking-module__textButton","sticker":"Staking-module__sticker","sticker_static":"Staking-module__sticker_static","stickerStatic":"Staking-module__sticker_static","stakingSafeDialog":"Staking-module__stakingSafeDialog","amountBottomRight":"Staking-module__amountBottomRight","amountBottomRight_error":"Staking-module__amountBottomRight_error","amountBottomRightError":"Staking-module__amountBottomRight_error","amountBottomRight_slide":"Staking-module__amountBottomRight_slide","amountBottomRightSlide":"Staking-module__amountBottomRight_slide","animating":"Staking-module__animating","from":"Staking-module__from","to":"Staking-module__to","balanceError":"Staking-module__balanceError","historyTotalValue":"Staking-module__historyTotalValue","stakingBalance":"Staking-module__stakingBalance","balanceResultWrapper":"Staking-module__balanceResultWrapper","balanceResultWrapper__slide":"Staking-module__balanceResultWrapper__slide","balanceResultWrapperSlide":"Staking-module__balanceResultWrapper__slide","balanceResultInput":"Staking-module__balanceResultInput","balanceResultLabel":"Staking-module__balanceResultLabel","balanceStakedLabel":"Staking-module__balanceStakedLabel","balanceStakedResult":"Staking-module__balanceStakedResult","balanceResult":"Staking-module__balanceResult","stakingInfoModal":"Staking-module__stakingInfo_modal","stakingInfoModal_withHistory":"Staking-module__stakingInfoModal_withHistory","stakingInfoModalWithHistory":"Staking-module__stakingInfoModal_withHistory","stakingInfo":"Staking-module__stakingInfo","stakingInfo_modal":"Staking-module__stakingInfo_modal","stakingInfoNoHistory":"Staking-module__stakingInfoNoHistory","stakingInfoModalContent":"Staking-module__stakingInfoModalContent","history":"Staking-module__history","historyList":"Staking-module__historyList","withBackground":"Staking-module__withBackground","stakingInfoLoading":"Staking-module__stakingInfoLoading","stakingInfoLoadingAnimation":"Staking-module__stakingInfoLoadingAnimation","stakingInfoClose":"Staking-module__stakingInfoClose","stakingInfoButtons":"Staking-module__stakingInfoButtons","stakingInfoButtons_withMargin":"Staking-module__stakingInfoButtons_withMargin","stakingInfoButtonsWithMargin":"Staking-module__stakingInfoButtons_withMargin","stakingInfoButtons_adaptiveWidth":"Staking-module__stakingInfoButtons_adaptiveWidth","stakingInfoButtonsAdaptiveWidth":"Staking-module__stakingInfoButtons_adaptiveWidth","stakingInfoButton":"Staking-module__stakingInfoButton","checkEligibilityButton":"Staking-module__checkEligibilityButton","insufficientBalance":"Staking-module__insufficientBalance","unstakeTime":"Staking-module__unstakeTime","unstakeTime_purple":"Staking-module__unstakeTime_purple","unstakeTimePurple":"Staking-module__unstakeTime_purple","unstakeTimeIcon":"Staking-module__unstakeTimeIcon","history_static":"Staking-module__history_static","historyStatic":"Staking-module__history_static","historyTotal":"Staking-module__historyTotal","historyTitle":"Staking-module__historyTitle","historyList_static":"Staking-module__historyList_static","historyListStatic":"Staking-module__historyList_static","transactionBanner":"Staking-module__transactionBanner","unstakeInfoTransition":"Staking-module__unstakeInfoTransition","unstakeInfo":"Staking-module__unstakeInfo"});
;// ./src/components/staking/StakingInitial.tsx
function StakingInitial_extends() { return StakingInitial_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, StakingInitial_extends.apply(null, arguments); }






































var BottomRightSlide = /*#__PURE__*/function (BottomRightSlide) {
  BottomRightSlide[BottomRightSlide["Fee"] = 0] = "Fee";
  BottomRightSlide[BottomRightSlide["InsufficientBalance"] = 1] = "InsufficientBalance";
  BottomRightSlide[BottomRightSlide["InsufficientFee"] = 2] = "InsufficientFee";
  BottomRightSlide[BottomRightSlide["BelowMinimumAmount"] = 3] = "BelowMinimumAmount";
  BottomRightSlide[BottomRightSlide["ApiError"] = 4] = "ApiError";
  return BottomRightSlide;
}(BottomRightSlide || {});
const ACTIVE_STATES = new Set([StakingState.StakeInitial, StakingState.None]);
const runThrottled = (0,schedulers/* throttle */.nF)(cb => cb(), 1500, true);
function StakingInitial(_ref) {
  let {
    isActive,
    isStatic,
    isLoading,
    isViewMode,
    apiError,
    tokens,
    tokenBySlug,
    stakingState,
    states,
    shouldUseNominators,
    isSensitiveDataHidden,
    baseCurrency
  } = _ref;
  const {
    submitStakingInitial,
    fetchStakingFee,
    cancelStaking,
    changeCurrentStaking
  } = getActions();
  const lang = hooks_useLang();
  const [isSafeInfoModalOpen, openSafeInfoModal, closeSafeInfoModal] = hooks_useFlag();
  const [amount, setAmount] = useState();
  let isIncorrectAmount = false;
  let isInsufficientBalance = false;
  let isInsufficientFee = false;
  let isBelowMinimumAmount = false;
  const {
    id: stakingId,
    type: stakingType,
    tokenSlug
  } = stakingState ?? {};
  const token = teact_useMemo(() => {
    if (!tokenSlug || !tokens || !tokenBySlug) return undefined;
    let userToken = tokens.find(_ref2 => {
      let {
        slug
      } = _ref2;
      return slug === tokenSlug;
    });
    if (!userToken && tokenSlug in tokenBySlug) {
      userToken = buildUserToken(tokenBySlug[tokenSlug]);
    }
    return userToken;
  }, [tokenSlug, tokens, tokenBySlug]);
  const {
    amount: balance = 0n,
    symbol,
    decimals = src_config/* TONCOIN */.Tu9.decimals
  } = token ?? {};
  let {
    annualYield = 0
  } = stakingState ?? {};
  let annualYieldText = `${annualYield}%`;
  if ((stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'jetton' && amount) {
    annualYield = calcJettonStakingApr({
      tvl: stakingState.tvl + amount,
      dailyReward: stakingState.dailyReward,
      decimals
    });
  } else if ((stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'ethena') {
    const {
      annualYieldStandard,
      annualYieldVerified
    } = stakingState;
    annualYieldText = `${annualYieldStandard}%â€“${annualYieldVerified}%`;
  }
  const isNativeToken = getIsNativeToken(token === null || token === void 0 ? void 0 : token.slug);
  const nativeToken = teact_useMemo(() => {
    if (!tokens || !token) return undefined;
    if (isNativeToken) return token;
    const nativeSlug = getNativeToken(token.chain).slug;
    return tokens.find(_ref3 => {
      let {
        slug
      } = _ref3;
      return slug === nativeSlug;
    });
  }, [tokens, token, isNativeToken]);
  const nativeBalance = (nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.amount) ?? 0n;
  const minAmount = getStakingMinAmount(stakingType);
  const {
    gas: networkFee,
    real: realFee
  } = getTonStakingFees(stakingState === null || stakingState === void 0 ? void 0 : stakingState.type).stake;
  const nativeAmount = isNativeToken && amount ? amount + networkFee : networkFee;
  const doubleNetworkFee = networkFee * 2n;
  const shouldLeaveForUnstake = isNativeToken && balance >= doubleNetworkFee;
  const maxAmount = (() => {
    let value = balance;
    if (isNativeToken && value) {
      value -= shouldLeaveForUnstake ? doubleNetworkFee : networkFee;
    }
    return (0,bigint/* bigintMax */._O)(0n, value);
  })();
  const title = getStakingTitle();
  if (amount !== undefined) {
    if (Number.isNaN(amount) || amount < 0) {
      isIncorrectAmount = true;
    } else if (amount < minAmount) {
      isBelowMinimumAmount = true;
    } else if (!maxAmount || amount > balance) {
      isInsufficientBalance = true;
    } else if (nativeBalance < networkFee || isNativeToken && nativeAmount > balance) {
      isInsufficientFee = true;
    }
  }
  const [selectedToken, selectableTokens] = useTokenDropdown({
    tokenBySlug,
    states,
    shouldUseNominators,
    selectedStakingId: stakingId
  });
  const handleHelpCenterClick = useLastCallback(() => {
    const url = getHelpCenterUrl(lang.code, 'ethenaStaking');
    void openUrl(url, {
      title: lang('Help Center'),
      subtitle: getHostnameFromUrl(url)
    });
  });
  teact_useEffect(() => {
    if (!amount) {
      return;
    }
    runThrottled(() => {
      fetchStakingFee({
        amount
      });
    });
  }, [amount, fetchStakingFee]);
  useSyncEffect(() => {
    if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return;
    if (isSafeInfoModalOpen) {
      let text;
      switch (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) {
        case 'jetton':
          text = [
          // We use `replace` instead of `lang` argument to avoid JSX output
          `${lang('$safe_staking_description_jetton1').replace('%jvault_link%', 'JVault')}`, `${lang('$safe_staking_description_jetton2')}`];
          break;
        case 'ethena':
          text = [`1. ${lang('$safe_staking_ethena_description1')}`, `2. ${lang('$safe_staking_ethena_description2')}`, `3. ${lang('$safe_staking_ethena_description3')}`];
          break;
        default:
          text = [`1. ${lang('$safe_staking_description1')}`, `2. ${lang('$safe_staking_description2')}`, `3. ${lang('$safe_staking_description3')}`];
      }
      if ((stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'ethena') {
        void Dialog.confirm({
          title: lang(title),
          message: text.join('\n\n').replace(/\*\*/g, ''),
          okButtonTitle: lang('Close'),
          cancelButtonTitle: lang('Help Center')
        }).then(result => {
          closeSafeInfoModal();
          if (!result.value) {
            handleHelpCenterClick();
          }
        });
      } else {
        void Dialog.alert({
          title: lang(title),
          message: text.join('\n\n').replace(/\*\*/g, '')
        }).then(closeSafeInfoModal);
      }
    }
  }, [isSafeInfoModalOpen, lang, stakingState, title]);
  const canSubmit = amount && maxAmount && !isViewMode && !isIncorrectAmount && !isBelowMinimumAmount && !isInsufficientFee && !isInsufficientBalance;
  const handleSubmit = useLastCallback(e => {
    stopEvent(e);
    if (!canSubmit) {
      return;
    }
    void vibrate();
    submitStakingInitial({
      amount
    });
  });
  const handleCheckEligibility = useLastCallback(() => {
    void openUrl(src_config/* ETHENA_ELIGIBILITY_CHECK_URL */.lsx);
  });
  const [error, errorTransitionKey] = teact_useMemo(() => {
    if (isInsufficientBalance) {
      return [lang('Insufficient balance'), BottomRightSlide.InsufficientBalance];
    }
    if (isInsufficientFee) {
      return [lang('$insufficient_fee', {
        fee: formatCurrency((0,util_decimals/* toDecimal */.nI)(networkFee), (nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.symbol) ?? '')
      }), BottomRightSlide.InsufficientFee];
    }
    if (isBelowMinimumAmount) {
      return [lang('$min_value', {
        value: formatCurrency((0,util_decimals/* toDecimal */.nI)(minAmount, decimals), symbol ?? '')
      }), BottomRightSlide.BelowMinimumAmount];
    }
    return apiError ? [lang(apiError), BottomRightSlide.ApiError] : [undefined, BottomRightSlide.Fee];
  }, [apiError, decimals, isBelowMinimumAmount, isInsufficientBalance, isInsufficientFee, lang, minAmount, nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.symbol, networkFee, symbol]);

  // It is necessary to use useCallback instead of useLastCallback here
  const renderBottomRight = teact_useCallback(className => {
    let content = ' ';
    if (error) {
      content = /*#__PURE__*/teact.createElement("span", {
        className: Staking_module.balanceError
      }, error);
    } else {
      content = token ? lang('$fee_value', {
        fee: /*#__PURE__*/teact.createElement(ui_Fee, {
          terms: {
            native: realFee
          },
          precision: "approximate",
          token: token
        })
      }) : '';
    }
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      className: buildClassName(Staking_module.amountBottomRight, isIncorrectAmount && Staking_module.amountBottomRight_error, className),
      slideClassName: Staking_module.amountBottomRight_slide,
      name: "semiFade",
      activeKey: errorTransitionKey
    }, content);
  }, [error, errorTransitionKey, isIncorrectAmount, lang, realFee, token]);
  function renderJettonDescription() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_description_jetton1', {
      jvault_link: /*#__PURE__*/teact.createElement("a", {
        href: src_config/* JVAULT_URL */.dCY,
        target: "_blank",
        rel: "noreferrer"
      }, /*#__PURE__*/teact.createElement("b", null, "JVault"))
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_description_jetton2'))));
  }
  function renderTonDescription() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_description1'))), /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_description2'))), /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_description3'))));
  }
  function renderEthenaDescription() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_ethena_description1'))), /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_ethena_description2'))), /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang('$safe_staking_ethena_description3'))));
  }
  function renderSafeDescription() {
    switch (stakingState.type) {
      case 'jetton':
        return renderJettonDescription();
      case 'ethena':
        return renderEthenaDescription();
      default:
        return renderTonDescription();
    }
  }
  function renderSafeInfoModal() {
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return undefined;
    return /*#__PURE__*/teact.createElement(ui_Modal, {
      isCompact: true,
      isOpen: isSafeInfoModalOpen,
      title: lang(title),
      onClose: closeSafeInfoModal,
      dialogClassName: Staking_module.stakingSafeDialog
    }, !!stakingState && renderSafeDescription(), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, stakingState.type === 'ethena' && /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleHelpCenterClick
    }, lang('Help Center')), /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: closeSafeInfoModal
    }, lang('Close'))));
  }
  function renderStakingResult() {
    const amountBig = (0,util_decimals/* toBig */.CF)(amount ?? 0, decimals);
    let currentAmount;
    let prefix;
    let suffix;
    if (amountInputProps.isBaseCurrency) {
      currentAmount = amountBig.mul((token === null || token === void 0 ? void 0 : token.price) ?? 0);
      const {
        shortSymbol
      } = src_config/* CURRENCIES */.yR2[baseCurrency];
      if (shortSymbol) {
        prefix = shortSymbol;
      } else {
        suffix = baseCurrency;
      }
    } else {
      currentAmount = amountBig;
    }
    const balanceResult = currentAmount.mul(annualYield / 100 + 1).toString();
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      activeKey: amountInputProps.isBaseCurrency ? 0 : 1,
      name: "semiFade",
      className: Staking_module.balanceResultWrapper,
      slideClassName: Staking_module.balanceResultWrapper__slide,
      shouldCleanup: true
    }, /*#__PURE__*/teact.createElement(ui_RichNumberField, {
      labelText: lang('Est. balance in a year'),
      zeroValue: "...",
      value: balanceResult,
      decimals: src_config/* SHORT_FRACTION_DIGITS */.Vxu,
      prefix: prefix,
      suffix: suffix,
      isStatic: isStatic,
      inputClassName: Staking_module.balanceResultInput,
      labelClassName: Staking_module.balanceResultLabel,
      valueClassName: Staking_module.balanceResult
    }));
  }
  const handleChangeStaking = useLastCallback(id => {
    cancelStaking();
    changeCurrentStaking({
      stakingId: id,
      shouldReopenModal: !isStatic
    });
  });
  const amountInputProps = useAmountInputState({
    amount,
    token,
    baseCurrency,
    onAmountChange: setAmount,
    onTokenChange: handleChangeStaking
  });
  return /*#__PURE__*/teact.createElement("form", {
    className: isStatic ? undefined : Modal_module.transitionContent,
    onSubmit: handleSubmit
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Staking_module.welcome, isStatic && Staking_module.welcome_static)
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    size: isStatic ? src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW : src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp,
    play: isActive,
    noLoop: false,
    nonInteractive: true,
    className: buildClassName(Staking_module.sticker, isStatic && Staking_module.sticker_static),
    tgsUrl: ANIMATED_STICKERS_PATHS.wait,
    previewUrl: ANIMATED_STICKERS_PATHS.waitPreview
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Staking_module.welcomeInformation, isStatic && Staking_module.welcomeInformation_static)
  }, /*#__PURE__*/teact.createElement("div", null, lang('Earn from your tokens while holding them', {
    symbol
  })), /*#__PURE__*/teact.createElement("div", {
    className: Staking_module.stakingApy
  }, lang('Est. %annual_yield%', {
    annual_yield: annualYieldText
  })), stakingType === 'ethena' && /*#__PURE__*/teact.createElement(ui_Button, {
    isText: true,
    className: Staking_module.textButton,
    onClick: handleCheckEligibility
  }, lang('Check eligibility')), /*#__PURE__*/teact.createElement(ui_Button, {
    isText: true,
    className: Staking_module.textButton,
    onClick: openSafeInfoModal
  }, lang(getStakingTitle(stakingType))))), /*#__PURE__*/teact.createElement(ui_AmountInput, StakingInitial_extends({}, amountInputProps, {
    maxAmount: maxAmount,
    token: selectedToken,
    allTokens: selectableTokens,
    isStatic: isStatic,
    hasError: isIncorrectAmount || isInsufficientBalance,
    isMaxAmountLoading: !selectedToken,
    isSensitiveDataHidden: isSensitiveDataHidden,
    renderBottomRight: renderBottomRight,
    onPressEnter: handleSubmit
  })), renderStakingResult(), !isViewMode && /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isSubmit: true,
    isDisabled: !canSubmit,
    isLoading: isLoading
  }, lang('$stake_asset', {
    symbol: token === null || token === void 0 ? void 0 : token.symbol
  }))), renderSafeInfoModal());
}
/* harmony default export */ const staking_StakingInitial = (memo(withGlobal(global => {
  var _accountState$staking;
  const accountId = global.currentAccountId;
  const accountState = selectCurrentAccountState(global);
  const tokens = selectCurrentAccountTokens(global);
  const tokenBySlug = global.tokenInfo.bySlug;
  const {
    baseCurrency = src_config/* DEFAULT_PRICE_CURRENCY */.wOb,
    isSensitiveDataHidden
  } = global.settings;
  const {
    state,
    isLoading,
    error: apiError
  } = global.currentStaking;
  const states = accountId ? selectAccountStakingStates(global, accountId) : undefined;
  const stakingState = selectAccountStakingState(global, global.currentAccountId);
  return {
    isViewMode: selectIsCurrentAccountViewMode(global),
    isLoading: isLoading && ACTIVE_STATES.has(state),
    tokens,
    tokenBySlug,
    apiError,
    stakingState,
    states,
    shouldUseNominators: accountState === null || accountState === void 0 || (_accountState$staking = accountState.staking) === null || _accountState$staking === void 0 ? void 0 : _accountState$staking.shouldUseNominators,
    isSensitiveDataHidden,
    baseCurrency
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(StakingInitial)));
;// ./src/components/staking/StakeModal.tsx

























const IS_OPEN_STATES = new Set([StakingState.StakeInitial, StakingState.StakePassword, StakingState.StakeConnectHardware, StakingState.StakeConfirmHardware, StakingState.StakeComplete]);
function StakeModal(_ref) {
  let {
    state,
    stakingState,
    isLoading,
    amount,
    error,
    tokenBySlug,
    isMultichainAccount
  } = _ref;
  const {
    startStaking,
    setStakingScreen,
    cancelStaking,
    clearStakingError,
    submitStaking,
    openStakingInfo
  } = getActions();
  const {
    tokenSlug
  } = stakingState ?? {};
  const token = tokenSlug && tokenBySlug ? tokenBySlug[tokenSlug] : undefined;
  const lang = hooks_useLang();
  const isOpen = IS_OPEN_STATES.has(state);
  const [renderedStakingAmount, setRenderedStakingAmount] = useState(amount);
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const handleBackClick = useLastCallback(() => {
    if (state === StakingState.StakePassword) {
      clearStakingError();
      setStakingScreen({
        state: StakingState.StakeInitial
      });
    }
  });
  const handleLedgerConnect = useLastCallback(() => {
    setRenderedStakingAmount(amount);
    submitStaking();
  });
  const handleTransferSubmit = useLastCallback(password => {
    setRenderedStakingAmount(amount);
    submitStaking({
      password
    });
  });
  const handleViewStakingInfoClick = useLastCallback(() => {
    cancelStaking();
    openStakingInfo();
  });
  function renderTransactionBanner() {
    if (!token || !amount) return undefined;
    return /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      tokenIn: token,
      withChainIcon: isMultichainAccount,
      color: "purple",
      text: formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, token.decimals), token.symbol),
      className: !getDoesUsePinPad() ? Staking_module.transactionBanner : undefined
    });
  }
  function renderPassword(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm Staking'),
      onClose: cancelStaking
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      isLoading: isLoading,
      error: error,
      withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
      operationType: "staking",
      placeholder: "Confirm operation with your password",
      submitLabel: lang('Confirm'),
      cancelLabel: lang('Back'),
      onSubmit: handleTransferSubmit,
      onCancel: handleBackClick,
      onUpdate: clearStakingError,
      skipAuthScreen: true
    }, renderTransactionBanner()));
  }
  function renderComplete(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Coins have been staked!'),
      onClose: cancelStaking
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement(common_TransferResult, {
      color: "purple",
      playAnimation: isActive,
      amount: renderedStakingAmount,
      decimals: token === null || token === void 0 ? void 0 : token.decimals,
      tokenSymbol: token === null || token === void 0 ? void 0 : token.symbol,
      noSign: true,
      firstButtonText: lang('View'),
      secondButtonText: lang('Stake More'),
      onFirstButtonClick: handleViewStakingInfoClick,
      onSecondButtonClick: startStaking
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: cancelStaking,
      isPrimary: true
    }, lang('Close')))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case StakingState.StakeInitial:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('$stake_asset', {
            symbol: token === null || token === void 0 ? void 0 : token.symbol
          }),
          onClose: cancelStaking
        }), /*#__PURE__*/teact.createElement(staking_StakingInitial, {
          isActive: isActive
        }));
      case StakingState.StakePassword:
        return renderPassword(isActive);
      case StakingState.StakeConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleLedgerConnect,
          onClose: cancelStaking
        });
      case StakingState.StakeConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm operation on your Ledger'),
          error: error,
          onClose: cancelStaking,
          onTryAgain: handleLedgerConnect
        });
      case StakingState.StakeComplete:
        return renderComplete(isActive);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    hasCloseButton: true,
    noBackdropClose: true,
    dialogClassName: Staking_module.modalDialog,
    nativeBottomSheetKey: "stake"
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    ,
    forceFullNative: renderingKey === StakingState.StakePassword,
    onClose: cancelStaking,
    onCloseAnimationEnd: updateNextKey
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const staking_StakeModal = (memo(withGlobal(global => {
  const accountId = global.currentAccountId;
  const isMultichainAccount = selectIsMultichainAccount(global, accountId);
  const stakingState = selectAccountStakingState(global, accountId);
  const tokenBySlug = global.tokenInfo.bySlug;
  return {
    ...global.currentStaking,
    stakingState,
    tokenBySlug,
    isMultichainAccount
  };
})(StakeModal)));
;// ./src/components/staking/StakingClaimModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const StakingClaimModal_module = ({"modalDialog":"StakingClaimModal-module__modalDialog","passwordModalDialog":"StakingClaimModal-module__passwordModalDialog","transactionBanner":"StakingClaimModal-module__transactionBanner","operationInfoFee":"StakingClaimModal-module__operationInfoFee","operationInfoFeeWithGap":"StakingClaimModal-module__operationInfoFeeWithGap","unstakeInfo":"StakingClaimModal-module__unstakeInfo"});
;// ./src/components/staking/StakingClaimModal.tsx



























const StakingClaimModal_IS_OPEN_STATES = new Set([StakingState.ClaimPassword, StakingState.ClaimConfirmHardware, StakingState.ClaimConnectHardware, StakingState.ClaimComplete]);
function StakingClaimModal(_ref) {
  let {
    stakingState,
    isOpen,
    tokens,
    isLoading,
    address,
    error,
    state = StakingState.ClaimPassword,
    isHardwareAccount,
    isMultichainAccount,
    isSensitiveDataHidden
  } = _ref;
  const {
    submitStakingClaim,
    cancelStakingClaim,
    clearStakingError
  } = getActions();
  const {
    tokenSlug
  } = stakingState ?? {};
  const rewardAmount = stakingState && 'unclaimedRewards' in stakingState ? stakingState.unclaimedRewards : (stakingState === null || stakingState === void 0 ? void 0 : stakingState.unstakeRequestAmount) ?? 0n;
  const lang = hooks_useLang();
  const token = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref2 => {
    let {
      slug
    } = _ref2;
    return slug === tokenSlug;
  }), [tokens, tokenSlug]);
  const nativeToken = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref3 => {
    let {
      slug
    } = _ref3;
    return slug === src_config/* TONCOIN */.Tu9.slug;
  }), [tokens]);
  const nativeBalance = (nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.amount) ?? 0n;
  const {
    gas: networkFee,
    real: realNetworkFee
  } = getTonStakingFees(stakingState === null || stakingState === void 0 ? void 0 : stakingState.type).claim;
  const isNativeEnough = nativeBalance > networkFee;
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, Boolean(isOpen));
  const withModalHeader = state === StakingState.ClaimComplete || !isHardwareAccount && !getDoesUsePinPad();
  const modalTitle = withModalHeader ? lang(state === StakingState.ClaimComplete ? 'Coins have been unstaked!' : (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'ethena' ? 'Confirm Unstaking' : 'Confirm Rewards Claim') : undefined;
  const handleSubmit = useLastCallback(password => {
    if (!isNativeEnough) return;
    submitStakingClaim({
      password
    });
  });
  const handleHardwareSubmit = useLastCallback(() => {
    if (!isNativeEnough) return;
    submitStakingClaim();
  });
  function renderInfo() {
    const feeClassName = buildClassName(StakingClaimModal_module.operationInfoFee, !getDoesUsePinPad() && StakingClaimModal_module.operationInfoFeeWithGap);
    const content = isSensitiveDataHidden ? `*** ${token.symbol}` : formatCurrency((0,util_decimals/* toDecimal */.nI)(rewardAmount, token.decimals), token.symbol, src_config/* SHORT_FRACTION_DIGITS */.Vxu);
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      tokenIn: token,
      withChainIcon: isMultichainAccount,
      text: content,
      className: !getDoesUsePinPad() ? StakingClaimModal_module.transactionBanner : undefined,
      secondText: address && (0,shortenAddress/* shortenAddress */.W)(address)
    }), /*#__PURE__*/teact.createElement("div", {
      className: feeClassName
    }, token && renderText(lang('$fee_value_bold', {
      fee: /*#__PURE__*/teact.createElement(ui_Fee, {
        terms: {
          native: isNativeEnough ? realNetworkFee : networkFee
        },
        precision: isNativeEnough ? 'approximate' : 'lessThan',
        token: token
      })
    }))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case StakingState.ClaimConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleHardwareSubmit,
          onClose: cancelStakingClaim
        });
      case StakingState.ClaimConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onClose: cancelStakingClaim,
          onTryAgain: handleHardwareSubmit
        });
      case StakingState.ClaimPassword:
        return /*#__PURE__*/teact.createElement(ui_PasswordForm, {
          isActive: Boolean(isOpen),
          isLoading: isLoading,
          withCloseButton: true,
          operationType: "claim",
          error: !isNativeEnough ? lang('Insufficient Balance for Fee') : error,
          submitLabel: lang('Confirm'),
          onSubmit: handleSubmit,
          onCancel: cancelStakingClaim,
          onUpdate: clearStakingError,
          skipAuthScreen: true
        }, renderInfo());
      case StakingState.ClaimComplete:
        return /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(common_TransferResult, {
          isSensitiveDataHidden: isSensitiveDataHidden,
          color: "green",
          playAnimation: isActive,
          amount: rewardAmount,
          tokenSymbol: token === null || token === void 0 ? void 0 : token.symbol,
          decimals: token === null || token === void 0 ? void 0 : token.decimals,
          noSign: true
        }), /*#__PURE__*/teact.createElement("div", {
          className: StakingClaimModal_module.unstakeInfo
        }, lang('$unstake_information_instantly')), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          onClick: cancelStakingClaim,
          isPrimary: true
        }, lang('Close'))));
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    title: modalTitle,
    hasCloseButton: withModalHeader,
    forceFullNative: true,
    nativeBottomSheetKey: "staking-claim",
    contentClassName: StakingClaimModal_module.passwordModalDialog,
    onClose: cancelStakingClaim
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const staking_StakingClaimModal = (memo(withGlobal(global => {
  const accountId = global.currentAccountId;
  const {
    addressByChain
  } = selectAccount(global, accountId) || {};
  const isHardwareAccount = selectIsHardwareAccount(global);
  const {
    state,
    isLoading,
    error
  } = (global === null || global === void 0 ? void 0 : global.currentStaking) || {};
  const stakingState = accountId ? selectAccountStakingState(global, accountId) : undefined;
  const tokens = selectCurrentAccountTokens(global);
  const canBeClaimed = (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'jetton' || (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'ethena';
  return {
    stakingState: canBeClaimed ? stakingState : undefined,
    isOpen: StakingClaimModal_IS_OPEN_STATES.has(state),
    state,
    tokens,
    isLoading,
    error,
    address: addressByChain === null || addressByChain === void 0 ? void 0 : addressByChain.ton,
    isHardwareAccount,
    isMultichainAccount: selectIsMultichainAccount(global, accountId),
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden
  };
})(StakingClaimModal)));
;// ./src/components/staking/StakingProfileItem.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const StakingProfileItem_module = ({"item":"StakingProfileItem-module__item","icon":"StakingProfileItem-module__icon","leftBlock":"StakingProfileItem-module__leftBlock","amount":"StakingProfileItem-module__amount","operationName":"StakingProfileItem-module__operationName","date":"StakingProfileItem-module__date"});
;// ./src/components/staking/StakingProfitItem.tsx








function StakingProfitItem(_ref) {
  let {
    tonToken,
    timestamp,
    profit,
    isSensitiveDataHidden
  } = _ref;
  const lang = hooks_useLang();
  const amountCols = teact_useMemo(() => getPseudoRandomNumber(4, 10, timestamp.toString()), [timestamp]);
  return /*#__PURE__*/teact.createElement("div", {
    className: StakingProfileItem_module.item
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(StakingProfileItem_module.icon, 'icon-earn'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("div", {
    className: StakingProfileItem_module.leftBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: StakingProfileItem_module.operationName
  }, lang('Earned')), /*#__PURE__*/teact.createElement("div", {
    className: StakingProfileItem_module.date
  }, (0,dateFormat/* formatHumanDay */.N5)(lang, timestamp), ", ", (0,dateFormat/* formatTime */.fU)(timestamp))), /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    cellSize: 8,
    rows: 2,
    cols: amountCols,
    align: "right",
    className: StakingProfileItem_module.amount
  }, formatCurrencyExtended(profit, tonToken.symbol)));
}
/* harmony default export */ const staking_StakingProfitItem = (memo(StakingProfitItem));
;// ./src/components/staking/StakingInfoContent.tsx





























const UPDATE_UNSTAKE_DATE_INTERVAL_MS = 30000; // 30 sec
const HISTORY_SCROLL_APPEARANCE_HEIGHT_PX = 640;
const StakingInfoContent_FRACTION_DIGITS = 2;
function StakingInfoContent(_ref) {
  let {
    states,
    stakingState,
    isActive,
    isStatic,
    totalProfit,
    stakingHistory,
    tokens,
    tokenBySlug,
    theme,
    shouldUseNominators,
    isViewMode,
    isSensitiveDataHidden,
    onClose
  } = _ref;
  const {
    startStaking,
    startUnstaking,
    startStakingClaim,
    fetchStakingHistory,
    changeCurrentStaking
  } = getActions();
  const {
    id: stakingId,
    tokenSlug,
    balance: amount,
    annualYield = 0,
    unstakeRequestAmount,
    type: stakingType
  } = stakingState ?? {};
  const unstakeTime = getUnstakeTime(stakingState);
  const canBeClaimed = stakingState ? getStakingStateStatus(stakingState) === 'readyToClaim' : undefined;
  const token = teact_useMemo(() => {
    return tokenSlug ? tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref2 => {
      let {
        slug
      } = _ref2;
      return tokenSlug === slug;
    }) : undefined;
  }, [tokenSlug, tokens]);
  const {
    decimals,
    symbol
  } = token ?? {};
  const lang = hooks_useLang();
  const isLoading = amount === undefined;
  const hasHistory = Boolean(stakingHistory === null || stakingHistory === void 0 ? void 0 : stakingHistory.length);
  const {
    shouldRender: shouldRenderSpinner,
    ref: spinnerRef
  } = useShowTransition({
    isOpen: isLoading && isActive,
    withShouldRender: true
  });
  const tonToken = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref3 => {
    let {
      slug
    } = _ref3;
    return slug === src_config/* TONCOIN */.Tu9.slug;
  }), [tokens]);
  const forceUpdate = hooks_useForceUpdate();
  const {
    height
  } = useWindowSize();
  const appTheme = hooks_useAppTheme(theme);
  const {
    shouldRender: shouldRenderTotalAmount,
    ref: totalAmountRef
  } = useShowTransition({
    isOpen: !isSensitiveDataHidden,
    withShouldRender: true
  });
  const unclaimedRewards = (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'jetton' ? stakingState.unclaimedRewards : undefined;

  // Updates the unstaking countdown
  hooks_useInterval(forceUpdate, unstakeRequestAmount ? UPDATE_UNSTAKE_DATE_INTERVAL_MS : undefined);
  teact_useEffect(() => {
    if (isActive) {
      fetchStakingHistory();
    }
  }, [fetchStakingHistory, isActive]);
  const handleStakeClick = useLastCallback(() => {
    onClose === null || onClose === void 0 || onClose();
    startStaking();
  });
  const handleUnstakeClick = useLastCallback(() => {
    onClose === null || onClose === void 0 || onClose();
    startUnstaking();
  });
  const handleClaimClick = useLastCallback(() => {
    onClose === null || onClose === void 0 || onClose();
    startStakingClaim();
  });
  let stakingResult = '0';
  let balanceResult = '0';
  if (amount) {
    stakingResult = (0,util_decimals/* toBig */.CF)(amount, decimals).round(src_config/* SHORT_FRACTION_DIGITS */.Vxu).toString();
    balanceResult = (0,util_decimals/* toBig */.CF)(amount, decimals).mul(annualYield / 100 + 1).round(src_config/* SHORT_FRACTION_DIGITS */.Vxu).toString();
  }
  const handleCheckEligibility = useLastCallback(() => {
    void openUrl(src_config/* ETHENA_ELIGIBILITY_CHECK_URL */.lsx);
  });
  const [selectedToken, selectableTokens] = useTokenDropdown({
    tokenBySlug,
    states,
    shouldUseNominators,
    selectedStakingId: stakingId,
    isViewMode
  });
  function renderUnstakeDescription() {
    let text;
    if (unstakeTime) {
      let textKey = '$unstaking_when_receive_with_amount';
      if (stakingType === 'ethena') {
        textKey = '$unstaking_when_receive_with_amount_ethena';
      } else if (stakingType === 'nominators') {
        textKey = '$unstaking_when_receive';
      }
      text = lang(textKey, {
        time: /*#__PURE__*/teact.createElement("strong", null, (0,dateFormat/* formatRelativeHumanDateTime */.YG)(lang.code, unstakeTime)),
        amount: /*#__PURE__*/teact.createElement("strong", null, formatCurrency((0,util_decimals/* toDecimal */.nI)(unstakeRequestAmount ?? 0n, decimals), symbol).replace(' ', '\u00A0'))
      });
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Staking_module.unstakeTime, Staking_module.unstakeTime_purple)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      className: Staking_module.unstakeTimeIcon,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClockPurple,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClockPurple
    }), /*#__PURE__*/teact.createElement("div", null, text));
  }
  function renderHistory() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Staking_module.history, isStatic && Staking_module.history_static)
    }, shouldRenderTotalAmount && /*#__PURE__*/teact.createElement("div", {
      ref: totalAmountRef,
      className: Staking_module.historyTotal
    }, lang('$total', {
      value: /*#__PURE__*/teact.createElement("span", {
        className: Staking_module.historyTotalValue
      }, formatCurrency((0,util_decimals/* toDecimal */.nI)(totalProfit), src_config/* TONCOIN */.Tu9.symbol))
    })), /*#__PURE__*/teact.createElement("div", {
      className: Staking_module.historyTitle
    }, lang('Earning History')), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Staking_module.historyList, isStatic && Staking_module.historyList_static, isStatic && 'custom-scroll', !isStatic && height >= HISTORY_SCROLL_APPEARANCE_HEIGHT_PX && 'custom-scroll')
    }, stakingHistory === null || stakingHistory === void 0 ? void 0 : stakingHistory.map(record => /*#__PURE__*/teact.createElement(staking_StakingProfitItem, {
      key: record.timestamp,
      profit: record.profit,
      timestamp: record.timestamp,
      tonToken: tonToken,
      isSensitiveDataHidden: isSensitiveDataHidden
    }))));
  }
  const fullClassName = buildClassName(Staking_module.stakingInfo, !isStatic && Staking_module.stakingInfo_modal, !hasHistory && Staking_module.stakingInfoNoHistory, isStatic && 'staking-info');
  const handleChangeStaking = useLastCallback(id => {
    onClose === null || onClose === void 0 || onClose();
    changeCurrentStaking({
      stakingId: id,
      shouldReopenModal: !isStatic
    });
  });
  function renderRewards() {
    const rewardString = (0,util_decimals/* toDecimal */.nI)(unclaimedRewards, decimals);
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_RichNumberField, {
      isSensitiveData: true,
      isSensitiveDataHidden: isSensitiveDataHidden,
      sensitiveDataMaskSkin: "purple",
      labelText: lang('Accumulated Rewards'),
      zeroValue: "...",
      value: rewardString,
      decimals: decimals,
      suffix: symbol,
      labelClassName: Staking_module.balanceStakedLabel,
      valueClassName: Staking_module.balanceResult
    }), !isViewMode && /*#__PURE__*/teact.createElement("div", {
      className: Staking_module.stakingInfoButtons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Staking_module.stakingInfoButton,
      isDisabled: isLoading,
      onClick: handleClaimClick
    }, lang('Claim'))));
  }
  function render() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: fullClassName
    }, !isStatic && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Staking'),
      closeClassName: Staking_module.stakingInfoClose,
      onClose: onClose
    }), /*#__PURE__*/teact.createElement(ui_RichNumberField, {
      isSensitiveData: true,
      isSensitiveDataHidden: isSensitiveDataHidden,
      sensitiveDataMaskSkin: "purple",
      labelText: lang('Currently Staked'),
      zeroValue: "...",
      value: stakingResult,
      decimals: decimals,
      className: Staking_module.stakingBalance,
      labelClassName: Staking_module.balanceStakedLabel,
      valueClassName: Staking_module.balanceStakedResult
    }, /*#__PURE__*/teact.createElement("div", {
      className: Staking_module.stakingInfoLoading
    }, shouldRenderSpinner && /*#__PURE__*/teact.createElement(ui_Spinner, {
      ref: spinnerRef,
      className: Staking_module.stakingInfoLoadingAnimation
    })), /*#__PURE__*/teact.createElement(ui_TokenDropdown, {
      selectedToken: selectedToken,
      allTokens: selectableTokens,
      theme: "purple",
      onChange: handleChangeStaking
    })), unstakeRequestAmount && unstakeRequestAmount > 0n && stakingType !== 'ethena' ? renderUnstakeDescription() : /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_RichNumberField, {
      isSensitiveData: true,
      isSensitiveDataHidden: isSensitiveDataHidden,
      sensitiveDataMaskSkin: "purple",
      labelText: lang('Est. balance in a year'),
      zeroValue: "...",
      value: balanceResult,
      decimals: decimals,
      suffix: symbol,
      labelClassName: Staking_module.balanceStakedLabel,
      valueClassName: Staking_module.balanceResult
    }), stakingType === 'ethena' && !canBeClaimed && !!unstakeRequestAmount && renderUnstakeDescription(), !isViewMode && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Staking_module.stakingInfoButtons, stakingType === 'ethena' && Staking_module.stakingInfoButtonsAdaptiveWidth, !!unclaimedRewards && Staking_module.stakingInfoButtonsWithMargin)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Staking_module.stakingInfoButton,
      isPrimary: true,
      isDisabled: isLoading,
      onClick: handleStakeClick
    }, lang('Stake More')), (stakingType !== 'ethena' || !canBeClaimed) && /*#__PURE__*/teact.createElement(ui_Button, {
      className: Staking_module.stakingInfoButton,
      isDisabled: isLoading,
      onClick: handleUnstakeClick
    }, lang(stakingType === 'ethena' ? 'Request Unstaking' : 'Unstake')), canBeClaimed && /*#__PURE__*/teact.createElement(ui_Button, {
      className: Staking_module.stakingInfoButton,
      isDisabled: isLoading,
      onClick: handleClaimClick
    }, lang('Unstake %amount%', {
      amount: isSensitiveDataHidden ? `*** ${symbol}` : formatCurrency((0,util_decimals/* toDecimal */.nI)(unstakeRequestAmount, decimals), symbol, StakingInfoContent_FRACTION_DIGITS)
    }))), !isViewMode && stakingType === 'ethena' && /*#__PURE__*/teact.createElement(ui_Button, {
      isText: true,
      className: Staking_module.checkEligibilityButton,
      onClick: handleCheckEligibility
    }, lang('Check eligibility for max APY')), !!unclaimedRewards && renderRewards())), hasHistory && renderHistory());
  }

  // No need to animate if it's in modal (`!isStatic`), because the modal is animated itself
  const activeKey = useTransitionActiveKey([isStatic, stakingId], !isStatic);
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "fade",
    activeKey: activeKey,
    shouldCleanup: true,
    className: Staking_module.stakingTransition,
    slideClassName: isStatic ? 'staking-info' : undefined
  }, render());
}
/* harmony default export */ const staking_StakingInfoContent = (memo(withGlobal(global => {
  var _accountState$staking;
  const accountId = global.currentAccountId;
  const {
    settings: {
      theme,
      isSensitiveDataHidden
    },
    tokenInfo: {
      bySlug: tokenBySlug
    }
  } = global;
  const accountState = selectCurrentAccountState(global);
  const states = accountId ? selectAccountStakingStates(global, accountId) : undefined;
  const stakingState = accountId ? selectAccountStakingState(global, accountId) : undefined;
  const stakingHistory = accountId ? selectAccountStakingHistory(global, accountId) : undefined;
  const totalProfit = accountId ? selectAccountStakingTotalProfit(global, accountId) : 0n;
  return {
    stakingState,
    states,
    totalProfit,
    stakingHistory,
    tokens: selectCurrentAccountTokens(global),
    tokenBySlug,
    theme,
    shouldUseNominators: accountState === null || accountState === void 0 || (_accountState$staking = accountState.staking) === null || _accountState$staking === void 0 ? void 0 : _accountState$staking.shouldUseNominators,
    isSensitiveDataHidden,
    isViewMode: selectIsCurrentAccountViewMode(global)
  };
})(StakingInfoContent)));
;// ./src/components/staking/StakingInfoModal.tsx








function StakingInfoModal(_ref) {
  let {
    isOpen,
    tokenSlug,
    hasHistory,
    onClose
  } = _ref;
  const {
    fetchStakingHistory
  } = getActions();
  const withBackground = tokenSlug !== src_config/* TONCOIN */.Tu9.slug;
  teact_useEffect(() => {
    if (isOpen) {
      fetchStakingHistory();
    }
  }, [fetchStakingHistory, isOpen]);
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    contentClassName: buildClassName(Staking_module.stakingInfoModalContent, withBackground && Staking_module.withBackground),
    nativeBottomSheetKey: "staking-info",
    onClose: onClose,
    forceFullNative: hasHistory
  }, /*#__PURE__*/teact.createElement(staking_StakingInfoContent, {
    isActive: isOpen,
    onClose: onClose
  }));
}
/* harmony default export */ const staking_StakingInfoModal = (memo(withGlobal(global => {
  const accountId = global.currentAccountId;
  const stakingHistory = accountId ? selectAccountStakingHistory(global, accountId) : undefined;
  const stakingState = accountId ? selectAccountStakingState(global, accountId) : undefined;
  return {
    tokenSlug: stakingState === null || stakingState === void 0 ? void 0 : stakingState.tokenSlug,
    hasHistory: Boolean(stakingHistory === null || stakingHistory === void 0 ? void 0 : stakingHistory.length)
  };
})(StakingInfoModal)));
;// ./src/components/staking/UnstakeModal.tsx
function UnstakeModal_extends() { return UnstakeModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, UnstakeModal_extends.apply(null, arguments); }







































const UnstakeModal_IS_OPEN_STATES = new Set([StakingState.UnstakeInitial, StakingState.UnstakePassword, StakingState.UnstakeConnectHardware, StakingState.UnstakeConfirmHardware, StakingState.UnstakeComplete]);
const FULL_SIZE_NBS_STATES = new Set([StakingState.UnstakePassword, StakingState.UnstakeConnectHardware, StakingState.UnstakeConfirmHardware]);
const UnstakeModal_UPDATE_UNSTAKE_DATE_INTERVAL_MS = 30000; // 30 sec

function UnstakeModal(_ref) {
  let {
    state,
    isViewMode,
    isLoading,
    error,
    tokens,
    baseCurrency,
    isNominators,
    isMultichainAccount,
    theme,
    amount,
    stakingState,
    isSensitiveDataHidden
  } = _ref;
  const {
    setStakingScreen,
    cancelStaking,
    clearStakingError,
    submitStakingInitial,
    submitStaking,
    fetchStakingHistory
  } = getActions();
  const {
    type: stakingType,
    tokenSlug,
    balance: stakingBalance
  } = stakingState ?? {};
  const lang = hooks_useLang();
  const isOpen = UnstakeModal_IS_OPEN_STATES.has(state);
  const {
    gas: networkFee,
    real: realFee
  } = getTonStakingFees(stakingState === null || stakingState === void 0 ? void 0 : stakingState.type).unstake;
  const nativeToken = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref2 => {
    let {
      slug
    } = _ref2;
    return slug === src_config/* TONCOIN */.Tu9.slug;
  }), [tokens]);
  const isNativeEnough = nativeToken && nativeToken.amount >= networkFee;
  const instantAvailable = (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'liquid' ? stakingState.instantAvailable : undefined;
  const token = teact_useMemo(() => {
    return tokenSlug ? tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref3 => {
      let {
        slug
      } = _ref3;
      return slug === tokenSlug;
    }) : undefined;
  }, [tokenSlug, tokens]);
  let hasAmountError = false;
  let isInsufficientBalance = false;
  const isOnlyFullAmount = isNominators;
  const [unstakeAmount, setUnstakeAmount] = useState(isOnlyFullAmount ? stakingBalance : undefined);
  const [successUnstakeAmount, setSuccessUnstakeAmount] = useState(undefined);
  const unstakeTime = getUnstakeTime(stakingState);
  const isLongUnstake = stakingState ? getIsLongUnstake(stakingState, unstakeAmount) : undefined;
  const [unstakeDate, setUnstakeDate] = useState(unstakeTime ?? Date.now() + src_config/* VALIDATION_PERIOD_MS */.NFS);
  const forceUpdate = hooks_useForceUpdate();
  const appTheme = hooks_useAppTheme(theme);
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const isUnstakeDisabled = !isNativeEnough || isInsufficientBalance || !unstakeAmount;
  teact_useEffect(() => {
    if (isOpen) {
      fetchStakingHistory();
      setUnstakeAmount(isOnlyFullAmount ? stakingBalance : undefined);
    }
  }, [isOpen, fetchStakingHistory, isOnlyFullAmount, stakingBalance]);
  useSyncEffect(() => {
    if (unstakeTime) {
      setUnstakeDate(unstakeTime);
    }
  }, [unstakeTime]);
  if (error === types/* ApiTransactionDraftError */.KL.InsufficientBalance) {
    isInsufficientBalance = true;
  }
  const refreshUnstakeDate = useLastCallback(() => {
    if (unstakeDate < Date.now()) {
      fetchStakingHistory();
    }
    forceUpdate();
  });
  hooks_useInterval(refreshUnstakeDate, UnstakeModal_UPDATE_UNSTAKE_DATE_INTERVAL_MS);
  const handleBackClick = useLastCallback(() => {
    if (state === StakingState.UnstakePassword) {
      setStakingScreen({
        state: StakingState.UnstakeInitial
      });
    }
  });
  const handleStartUnstakeClick = useLastCallback(() => {
    submitStakingInitial({
      isUnstaking: true,
      amount: unstakeAmount
    });
  });
  const handleTransferSubmit = useLastCallback(password => {
    setSuccessUnstakeAmount(amount);
    submitStaking({
      password,
      isUnstaking: true
    });
  });
  const handleLedgerConnect = useLastCallback(() => {
    setSuccessUnstakeAmount(amount);
    submitStaking({
      isUnstaking: true
    });
  });
  function renderTransactionBanner() {
    if (!token || !unstakeAmount) return undefined;
    return /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      tokenIn: token,
      withChainIcon: isMultichainAccount,
      color: "green",
      text: formatCurrency((0,util_decimals/* toDecimal */.nI)(unstakeAmount, token.decimals), token.symbol),
      className: !getDoesUsePinPad() ? Staking_module.transactionBanner : undefined
    });
  }
  if (unstakeAmount !== undefined) {
    if (unstakeAmount < 0) {
      hasAmountError = true;
    } else if (!stakingBalance || unstakeAmount > stakingBalance) {
      hasAmountError = true;
      isInsufficientBalance = true;
    }
  }
  const amountInputProps = useAmountInputState({
    amount: unstakeAmount,
    token,
    baseCurrency,
    isAmountReadonly: isOnlyFullAmount,
    onAmountChange: setUnstakeAmount
  });

  // Wa want to render just the token name, not a token select button. To achieve that, we rely on the fact that
  // `Dropdown` renders with no button border when there is only 1 item.
  const selectableTokens = teact_useMemo(() => token && [token], [token]);

  // It is necessary to use useCallback instead of useLastCallback here
  const renderBottomRight = teact_useCallback(className => {
    const activeKey = isInsufficientBalance ? 0 : !isNativeEnough ? 1 : instantAvailable ? 2 : 3;
    let content = token ? lang('$fee_value', {
      fee: /*#__PURE__*/teact.createElement(ui_Fee, {
        terms: {
          native: realFee
        },
        precision: "approximate",
        token: token
      })
    }) : '';
    if (token) {
      if (isInsufficientBalance) {
        content = /*#__PURE__*/teact.createElement("span", {
          className: Staking_module.balanceError
        }, lang('Insufficient balance'));
      } else if (!isNativeEnough) {
        content = /*#__PURE__*/teact.createElement("span", {
          className: Staking_module.balanceError
        }, lang('$insufficient_fee', {
          fee: formatCurrency((0,util_decimals/* toBig */.CF)(networkFee), (nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.symbol) ?? '')
        }));
      } else if (instantAvailable) {
        content = lang('$unstake_up_to_information', {
          value: formatCurrency((0,util_decimals/* toDecimal */.nI)(instantAvailable, token.decimals), token.symbol)
        });
      }
    }
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      className: buildClassName(Staking_module.amountBottomRight, className),
      slideClassName: Staking_module.amountBottomRight_slide,
      name: "semiFade",
      activeKey: activeKey
    }, content);
  }, [instantAvailable, isInsufficientBalance, isNativeEnough, lang, nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.symbol, networkFee, realFee, token]);
  function renderUnstakeTimer() {
    const unstakeDateText = stakingType === 'ethena' ? renderText(lang('$unstaking_when_receive_ethena')) : lang('$unstaking_when_receive', {
      time: /*#__PURE__*/teact.createElement("strong", null, (0,dateFormat/* formatRelativeHumanDateTime */.YG)(lang.code, unstakeDate))
    });
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Staking_module.unstakeTime)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isOpen,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      className: Staking_module.unstakeTimeIcon,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClockGray,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClockGray
    }), /*#__PURE__*/teact.createElement("div", null, unstakeDateText));
  }
  function renderUnstakeInfo() {
    const shouldShowInfo = !isInsufficientBalance && unstakeAmount;
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "fade",
      activeKey: !shouldShowInfo ? 0 : !isLongUnstake ? 1 : 2,
      className: Staking_module.unstakeInfoTransition
    }, !shouldShowInfo ? undefined : !isLongUnstake ? /*#__PURE__*/teact.createElement("div", {
      className: Staking_module.unstakeInfo
    }, lang('$unstake_information_instantly')) : renderUnstakeTimer());
  }
  function renderInitial() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('$unstake_asset', {
        symbol: token === null || token === void 0 ? void 0 : token.symbol
      }),
      onClose: cancelStaking
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement(ui_AmountInput, UnstakeModal_extends({}, amountInputProps, {
      labelText: lang('Amount to unstake'),
      maxAmount: stakingBalance,
      token: token,
      allTokens: selectableTokens,
      hasError: hasAmountError,
      isMaxAmountLoading: stakingBalance === undefined || !token,
      isMaxAmountAllMode: true,
      isSensitiveDataHidden: isSensitiveDataHidden,
      renderBottomRight: renderBottomRight
    })), renderUnstakeInfo(), !isViewMode && /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isLoading: isLoading,
      isDisabled: isUnstakeDisabled,
      onClick: handleStartUnstakeClick
    }, lang('Unstake')))));
  }
  function renderPassword(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirm Unstaking'),
      onClose: cancelStaking
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      isLoading: isLoading,
      withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
      operationType: "unstaking",
      error: error,
      placeholder: "Confirm operation with your password",
      submitLabel: lang('Confirm'),
      cancelLabel: lang('Back'),
      onSubmit: handleTransferSubmit,
      onCancel: handleBackClick,
      onUpdate: clearStakingError,
      skipAuthScreen: true
    }, renderTransactionBanner()));
  }
  function renderComplete(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: (0,windowEnvironment/* getIsMobileTelegramApp */.v3)() ? lang('Request is sent!') : stakingType === 'ethena' ? lang('Request for unstaking is sent!') : lang('Coins have been unstaked!'),
      onClose: cancelStaking
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement(common_TransferResult, {
      color: stakingType !== 'ethena' ? 'green' : undefined,
      playAnimation: isActive,
      amount: successUnstakeAmount,
      tokenSymbol: token === null || token === void 0 ? void 0 : token.symbol,
      decimals: token === null || token === void 0 ? void 0 : token.decimals,
      noSign: true
    }), isLongUnstake && renderUnstakeTimer(), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: cancelStaking,
      isPrimary: true
    }, lang('Close')))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case StakingState.UnstakeInitial:
        return renderInitial();
      case StakingState.UnstakePassword:
        return renderPassword(isActive);
      case StakingState.UnstakeConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleLedgerConnect,
          onClose: cancelStaking
        });
      case StakingState.UnstakeConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm operation on your Ledger'),
          error: error,
          onClose: cancelStaking,
          onTryAgain: handleLedgerConnect
        });
      case StakingState.UnstakeComplete:
        return renderComplete(isActive);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    hasCloseButton: true,
    noBackdropClose: true,
    dialogClassName: Staking_module.modalDialog,
    nativeBottomSheetKey: "unstake",
    forceFullNative: FULL_SIZE_NBS_STATES.has(renderingKey),
    onClose: cancelStaking,
    onCloseAnimationEnd: updateNextKey
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const staking_UnstakeModal = (memo(withGlobal(global => {
  const accountId = global.currentAccountId;
  const tokens = selectCurrentAccountTokens(global);
  const {
    baseCurrency = src_config/* DEFAULT_PRICE_CURRENCY */.wOb,
    isSensitiveDataHidden
  } = global.settings;
  const isMultichainAccount = selectIsMultichainAccount(global, accountId);
  const stakingState = selectAccountStakingState(global, accountId);
  const isNominators = (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'nominators';
  return {
    ...global.currentStaking,
    tokens,
    baseCurrency,
    isNominators,
    theme: global.settings.theme,
    isMultichainAccount,
    stakingState,
    isSensitiveDataHidden,
    isViewMode: selectIsCurrentAccountViewMode(global)
  };
})(UnstakeModal)));
;// ./src/components/ui/UpdateAvailable.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const UpdateAvailable_module = ({"wrapper":"UpdateAvailable-module__wrapper","icon":"UpdateAvailable-module__icon"});
;// ./src/components/ui/UpdateAvailable.tsx









function UpdateAvailable(_ref) {
  let {
    isAppUpdateAvailable,
    newAppVersion,
    isAppUpdateRequired
  } = _ref;
  const lang = hooks_useLang();
  const {
    shouldRender,
    ref
  } = useShowTransition({
    isOpen: src_config/* IS_ANDROID_DIRECT */.VL7 && isAppUpdateAvailable || isAppUpdateRequired,
    withShouldRender: true
  });
  const handleClick = () => {
    if (windowEnvironment/* IS_WEB */.u2) {
      window.location.reload();
      return;
    }
    void openUrl(getUrl(newAppVersion), {
      isExternal: true
    });
  };
  if (!shouldRender) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("button", {
    ref: ref,
    type: "button",
    className: UpdateAvailable_module.wrapper,
    onClick: handleClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon icon-download-filled', UpdateAvailable_module.icon),
    "aria-hidden": true
  }), lang('Update %app_name%', {
    app_name: src_config/* APP_NAME */.C39
  }));
}
/* harmony default export */ const ui_UpdateAvailable = (memo(withGlobal(global => ({
  isAppUpdateAvailable: global.isAppUpdateAvailable,
  newAppVersion: global.latestAppVersion,
  isAppUpdateRequired: global.isAppUpdateRequired
}))(UpdateAvailable)));
function getUrl(appVersion) {
  if (src_config/* IS_ANDROID_DIRECT */.VL7) {
    return appVersion ? `${src_config/* APP_REPO_URL */.V3_}/releases/download/v${encodeURIComponent(appVersion || '')}/${encodeURIComponent(src_config/* APP_NAME */.C39)}.apk` : 'https://github.com/mytonwallet-org/mytonwallet/releases/latest';
  }
  if (windowEnvironment/* IS_ANDROID_APP */.xy) {
    return `${src_config/* APP_INSTALL_URL */.W1_}android-store`;
  }
  if (windowEnvironment/* IS_IOS_APP */.ZH) {
    return `${src_config/* APP_INSTALL_URL */.W1_}ios`;
  }
  if (windowEnvironment/* IS_CHROME_EXTENSION */.iF) {
    return `${src_config/* APP_INSTALL_URL */.W1_}${windowEnvironment/* IS_EDGE */.pr ? 'edge-extension' : 'chrome-extension'}`;
  }
  if (src_config/* IS_FIREFOX_EXTENSION */.v5B) {
    return `${src_config/* APP_INSTALL_URL */.W1_}firefox-extension`;
  }
  return src_config/* APP_INSTALL_URL */.W1_;
}
;// ./src/components/main/helpers/calcVestingAmountByStatus.ts
function calcVestingAmountByStatus(vesting, statuses) {
  return vesting.reduce((acc, currentVesting) => {
    return acc + currentVesting.parts.reduce((currentAcc, part) => {
      return currentAcc + (statuses.includes(part.status) ? part.amount : 0);
    }, 0);
  }, 0).toString();
}
;// ./src/components/vesting/VestingModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const VestingModal_module = ({"modalDialog":"VestingModal-module__modalDialog","modalHeader":"VestingModal-module__modalHeader","passwordModalDialog":"VestingModal-module__passwordModalDialog","amountWrapper":"VestingModal-module__amountWrapper","close":"VestingModal-module__close","inputWrapper":"VestingModal-module__inputWrapper","inputLabel":"VestingModal-module__inputLabel","inputValue":"VestingModal-module__inputValue","unfreezeInput":"VestingModal-module__unfreezeInput","unfreezeResult":"VestingModal-module__unfreezeResult","buttons":"VestingModal-module__buttons","button":"VestingModal-module__button","unfreezeTime":"VestingModal-module__unfreezeTime","unfreezeTimeIcon":"VestingModal-module__unfreezeTimeIcon","actions":"VestingModal-module__actions","actionsTitle":"VestingModal-module__actionsTitle","actionsList":"VestingModal-module__actionsList","block":"VestingModal-module__block","vestingInfo":"VestingModal-module__vestingInfo","blockTitle":"VestingModal-module__blockTitle","blockSubtitle":"VestingModal-module__blockSubtitle","part":"VestingModal-module__part","partInteractive":"VestingModal-module__partInteractive","active":"VestingModal-module__active","partIcon":"VestingModal-module__partIcon","partValue":"VestingModal-module__partValue","transactionBanner":"VestingModal-module__transactionBanner","operationInfoFee":"VestingModal-module__operationInfoFee","operationInfoFeeWithGap":"VestingModal-module__operationInfoFeeWithGap","partName":"VestingModal-module__partName","bold":"VestingModal-module__bold","date":"VestingModal-module__date"});
;// ./src/components/vesting/VestingModal.tsx




















const VestingModal_UPDATE_UNSTAKE_DATE_INTERVAL_MS = 30000; // 30 sec
const MY_TOKEN_SYMBOL = 'MY';
function VestingModal(_ref) {
  let {
    isOpen,
    isViewMode,
    isUnfreezeRequested,
    vesting,
    mycoin,
    theme
  } = _ref;
  const {
    fetchStakingHistory,
    closeVestingModal,
    startClaimingVesting
  } = getActions();
  const lang = hooks_useLang();
  const forceUpdate = hooks_useForceUpdate();
  const currentlyFrozenAmount = teact_useMemo(() => {
    if (!vesting) return '0';
    return calcVestingAmountByStatus(vesting, ['frozen', 'ready']);
  }, [vesting]);
  const currentlyReadyToUnfreezeAmount = teact_useMemo(() => {
    if (!vesting) return '0';
    return calcVestingAmountByStatus(vesting, ['ready']);
  }, [vesting]);
  const isDisabledUnfreeze = currentlyReadyToUnfreezeAmount === '0';
  const appTheme = hooks_useAppTheme(theme);
  hooks_useInterval(forceUpdate, isUnfreezeRequested ? VestingModal_UPDATE_UNSTAKE_DATE_INTERVAL_MS : undefined);
  teact_useEffect(() => {
    if (isOpen) {
      fetchStakingHistory();
    }
  }, [fetchStakingHistory, isOpen]);
  const handleStartClaimingVesting = useLastCallback(() => {
    startClaimingVesting();
  });
  if (!mycoin) {
    return undefined;
  }
  function renderUnfrozenDescription() {
    return /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.unfreezeTime
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isOpen,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      className: VestingModal_module.unfreezeTimeIcon,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClockBlue,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClockBlue
    }), /*#__PURE__*/teact.createElement("div", null, lang('You will receive your unfrozen coins in a few minutes.')));
  }
  function renderVestingInfo(info) {
    return /*#__PURE__*/teact.createElement("div", {
      key: info.id,
      className: VestingModal_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.vestingInfo
    }, /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.blockTitle
    }, info.title), /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.blockSubtitle
    }, lang('%volume% in %amount% parts', {
      volume: /*#__PURE__*/teact.createElement("b", null, formatCurrency(info.initialAmount, mycoin.symbol, mycoin.decimals)),
      amount: info.parts.length.toString()
    }))), info.parts.map(part => {
      const icon = part.status === 'frozen' ? 'icon-snow' : part.status === 'missed' ? 'icon-missed' : part.status === 'unfrozen' ? 'icon-check' : 'icon-fire';
      const title = part.status === 'frozen' ? 'Frozen' : part.status === 'missed' ? 'Missed' : part.status === 'unfrozen' ? 'Unfrozen' : 'Ready to Unfreeze';
      const isInteractive = !isViewMode && !isUnfreezeRequested && part.status === 'ready';
      const endsAt = part.status === 'frozen' ? part.time : part.status === 'ready' ? part.timeEnd : undefined;
      return /*#__PURE__*/teact.createElement("div", {
        key: part.id,
        role: isInteractive ? 'button' : undefined,
        className: buildClassName(VestingModal_module.part, part.status, isInteractive && VestingModal_module.partInteractive),
        onClick: isInteractive ? handleStartClaimingVesting : undefined
      }, /*#__PURE__*/teact.createElement("i", {
        className: buildClassName(VestingModal_module.partIcon, icon, part.status),
        "aria-hidden": true
      }), /*#__PURE__*/teact.createElement("div", {
        className: VestingModal_module.partName
      }, lang(title), Boolean(endsAt) && /*#__PURE__*/teact.createElement("div", {
        className: VestingModal_module.date
      }, lang('until %date%', {
        date: /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
          className: VestingModal_module.bold
        }, (0,dateFormat/* formatFullDay */.TK)(lang.code, endsAt)), ",", ' ', (0,dateFormat/* formatTime */.fU)(endsAt))
      }))), /*#__PURE__*/teact.createElement("div", {
        className: buildClassName(VestingModal_module.partValue, part.status)
      }, formatCurrency(part.amount, mycoin.symbol, mycoin.decimals)));
    }));
  }
  function renderVestingSchedule() {
    return /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.actions
    }, /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.actionsTitle
    }, lang('Vesting Schedule')), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(VestingModal_module.actionsList, 'custom-scroll')
    }, vesting === null || vesting === void 0 ? void 0 : vesting.map(renderVestingInfo)));
  }
  function renderContent() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.amountWrapper
    }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Vesting'),
      className: VestingModal_module.modalHeader,
      closeClassName: VestingModal_module.close,
      onClose: closeVestingModal
    }), /*#__PURE__*/teact.createElement(ui_RichNumberField, {
      labelText: lang('Vesting Balance'),
      zeroValue: "...",
      value: currentlyFrozenAmount || '0',
      decimals: src_config/* SHORT_FRACTION_DIGITS */.Vxu,
      suffix: MY_TOKEN_SYMBOL,
      className: VestingModal_module.inputWrapper,
      labelClassName: VestingModal_module.inputLabel,
      valueClassName: VestingModal_module.inputValue
    }), isUnfreezeRequested ? renderUnfrozenDescription() : /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_RichNumberField, {
      labelText: lang('Ready to Unfreeze'),
      zeroValue: "...",
      value: currentlyReadyToUnfreezeAmount,
      decimals: src_config/* SHORT_FRACTION_DIGITS */.Vxu,
      suffix: MY_TOKEN_SYMBOL,
      className: VestingModal_module.inputWrapper,
      inputClassName: VestingModal_module.unfreezeInput,
      labelClassName: VestingModal_module.inputLabel,
      valueClassName: VestingModal_module.unfreezeResult
    }), !isViewMode && /*#__PURE__*/teact.createElement("div", {
      className: VestingModal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: VestingModal_module.button,
      isPrimary: true,
      isDisabled: isDisabledUnfreeze,
      onClick: !isDisabledUnfreeze ? handleStartClaimingVesting : undefined
    }, lang('Unfreeze'))))), renderVestingSchedule());
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    contentClassName: VestingModal_module.modalDialog,
    nativeBottomSheetKey: "vesting-info",
    forceFullNative: true,
    onClose: closeVestingModal
  }, renderContent());
}
/* harmony default export */ const vesting_VestingModal = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  const {
    info: vesting,
    unfreezeRequestedIds
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.vesting) || {};
  return {
    isOpen: global.isVestingModalOpen,
    isViewMode: selectIsCurrentAccountViewMode(global),
    vesting,
    isUnfreezeRequested: Boolean(unfreezeRequestedIds === null || unfreezeRequestedIds === void 0 ? void 0 : unfreezeRequestedIds.length),
    mycoin: selectMycoin(global),
    theme: global.settings.theme
  };
})(VestingModal)));
;// ./src/components/vesting/VestingPasswordModal.tsx
























function VestingPasswordModal(_ref) {
  let {
    isOpen,
    vesting,
    tokens,
    isLoading,
    address,
    error,
    mycoin,
    state = VestingUnfreezeState.Password,
    isHardwareAccount,
    isMultichainAccount
  } = _ref;
  const {
    submitClaimingVesting,
    cancelClaimingVesting,
    clearVestingError
  } = getActions();
  const lang = hooks_useLang();
  const {
    amount: balance
  } = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref2 => {
    let {
      slug
    } = _ref2;
    return slug === src_config/* TONCOIN */.Tu9.slug;
  }), [tokens]) || {};
  const claimAmount = (0,util_decimals/* toBig */.CF)(src_config/* CLAIM_AMOUNT */.aEZ);
  const hasAmountError = !balance || balance < src_config/* CLAIM_AMOUNT */.aEZ;
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, Boolean(isOpen));
  const withModalHeader = !isHardwareAccount && !getDoesUsePinPad();
  const currentlyReadyToUnfreezeAmount = teact_useMemo(() => {
    if (!vesting) return '0';
    return calcVestingAmountByStatus(vesting, ['ready']);
  }, [vesting]);
  const handleSubmit = useLastCallback(password => {
    if (hasAmountError) return;
    submitClaimingVesting({
      password
    });
  });
  const handleHardwareSubmit = useLastCallback(() => {
    if (hasAmountError) return;
    submitClaimingVesting();
  });
  if (!mycoin) {
    return undefined;
  }
  function renderInfo() {
    const feeClassName = buildClassName(VestingModal_module.operationInfoFee, !getDoesUsePinPad() && VestingModal_module.operationInfoFeeWithGap);
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      tokenIn: mycoin,
      withChainIcon: isMultichainAccount,
      text: formatCurrency(currentlyReadyToUnfreezeAmount, mycoin.symbol, mycoin.decimals),
      className: !getDoesUsePinPad() ? VestingModal_module.transactionBanner : undefined,
      secondText: address && (0,shortenAddress/* shortenAddress */.W)(address)
    }), /*#__PURE__*/teact.createElement("div", {
      className: feeClassName
    }, renderText(lang('$fee_value_bold', {
      fee: formatCurrency(claimAmount, src_config/* TONCOIN */.Tu9.symbol)
    }))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case VestingUnfreezeState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleHardwareSubmit,
          onClose: cancelClaimingVesting
        });
      case VestingUnfreezeState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onClose: cancelClaimingVesting,
          onTryAgain: handleHardwareSubmit
        });
      case VestingUnfreezeState.Password:
        return /*#__PURE__*/teact.createElement(ui_PasswordForm, {
          isActive: Boolean(isOpen),
          isLoading: isLoading,
          withCloseButton: true,
          operationType: "unfreeze",
          error: hasAmountError ? lang('Insufficient Balance for Fee') : error,
          submitLabel: lang('Confirm'),
          onSubmit: handleSubmit,
          onCancel: cancelClaimingVesting,
          onUpdate: clearVestingError
        }, renderInfo());
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    title: withModalHeader ? lang('Confirm Unfreezing') : undefined,
    hasCloseButton: withModalHeader,
    forceFullNative: true,
    nativeBottomSheetKey: "vesting-confirm",
    contentClassName: VestingModal_module.passwordModalDialog,
    onClose: cancelClaimingVesting
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const vesting_VestingPasswordModal = (memo(withGlobal(global => {
  const {
    addressByChain
  } = selectAccount(global, global.currentAccountId) || {};
  const accountState = selectCurrentAccountState(global);
  const isHardwareAccount = selectIsHardwareAccount(global);
  const {
    isConfirmRequested: isOpen,
    info: vesting,
    isLoading,
    error,
    unfreezeState
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.vesting) || {};
  const tokens = selectCurrentAccountTokens(global);
  return {
    isOpen,
    vesting,
    tokens,
    isLoading,
    error,
    address: addressByChain === null || addressByChain === void 0 ? void 0 : addressByChain.ton,
    state: unfreezeState,
    mycoin: selectMycoin(global),
    isHardwareAccount,
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId)
  };
})(VestingPasswordModal)));
;// ./src/components/main/sections/Actions/helpers/sendMenu.ts





const SEND_CONTEXT_MENU_ITEMS = [{
  name: 'Multisend',
  fontIcon: 'menu-multisend',
  value: 'multisend'
}];
function handleSendMenuItemClick(value) {
  if (value === 'multisend') {
    void vibrate();
    void openUrl(src_config/* MYTONWALLET_MULTISEND_DAPP_URL */.JDR, {
      title: getTranslation('Multisend'),
      subtitle: getHostnameFromUrl(src_config/* MYTONWALLET_MULTISEND_DAPP_URL */.JDR)
    });
  }
}
;// ./src/components/common/FeeDetailsModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const FeeDetailsModal_module = ({"content":"FeeDetailsModal-module__content","chartLabels":"FeeDetailsModal-module__chartLabels","chartLabel":"FeeDetailsModal-module__chartLabel","realFee":"FeeDetailsModal-module__realFee","excessFee":"FeeDetailsModal-module__excessFee","chartLines":"FeeDetailsModal-module__chartLines","chartLine":"FeeDetailsModal-module__chartLine","explanation":"FeeDetailsModal-module__explanation"});
;// ./src/components/common/FeeDetailsModal.tsx
function FeeDetailsModal_extends() { return FeeDetailsModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, FeeDetailsModal_extends.apply(null, arguments); }











function FeeDetailsModal(_ref) {
  let {
    isOpen,
    onClose,
    title,
    ...restProps
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    onClose: onClose,
    isCompact: true,
    title: title ?? lang('Blockchain Fee Details'),
    contentClassName: FeeDetailsModal_module.content
  }, /*#__PURE__*/teact.createElement(FeeDetailsContent, FeeDetailsModal_extends({
    onClose: onClose
  }, restProps)));
}
/* harmony default export */ const common_FeeDetailsModal = (memo(FeeDetailsModal));
function FeeDetailsContent(_ref2) {
  let {
    onClose,
    fullFee,
    realFee,
    realFeePrecision = 'exact',
    excessFee,
    excessFeePrecision = 'exact',
    token,
    extraContent
  } = _ref2;
  const chain = token && getChainBySlug(token.slug);
  const nativeToken = chain && getChainConfig(chain).nativeToken;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", null, /*#__PURE__*/teact.createElement("div", {
    className: FeeDetailsModal_module.chartLabels
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(FeeDetailsModal_module.chartLabel, FeeDetailsModal_module.realFee)
  }, lang('Final Fee')), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(FeeDetailsModal_module.chartLabel, FeeDetailsModal_module.excessFee)
  }, lang('Excess'))), /*#__PURE__*/teact.createElement("div", {
    className: FeeDetailsModal_module.chartLines
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(FeeDetailsModal_module.chartLine, FeeDetailsModal_module.realFee)
  }, realFee && token && /*#__PURE__*/teact.createElement(ui_Fee, {
    terms: realFee,
    precision: realFeePrecision,
    token: token,
    shouldPreferIcons: true
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(FeeDetailsModal_module.chartLine, FeeDetailsModal_module.excessFee)
  }, excessFee !== undefined && token && /*#__PURE__*/teact.createElement(ui_Fee, {
    terms: {
      native: excessFee
    },
    precision: excessFeePrecision,
    token: token,
    shouldPreferIcons: true
  })))), /*#__PURE__*/teact.createElement("div", {
    className: FeeDetailsModal_module.explanation
  }, /*#__PURE__*/teact.createElement("div", null, renderText(lang('$fee_details', {
    full_fee: fullFee && token && /*#__PURE__*/teact.createElement("b", null, /*#__PURE__*/teact.createElement(ui_Fee, {
      terms: fullFee,
      precision: "exact",
      token: token
    })),
    excess_symbol: /*#__PURE__*/teact.createElement("b", null, nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.symbol),
    chain_name: chain === null || chain === void 0 ? void 0 : chain.toUpperCase()
  }))), extraContent), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: Modal_module.button,
    onClick: onClose
  }, lang('Got It'))));
}
;// ./src/hooks/useAsyncResolvers.ts



function useThrottledResolver(resolver, deps, msOrSchedulerFn) {
  let noFirst = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  return useThrottledCallback(setValue => {
    setValue(resolver());
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, deps, msOrSchedulerFn, noFirst);
}
function useThrottledSignal(getValue, ms) {
  let noFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  const throttledResolver = useThrottledResolver(() => getValue(), [getValue], ms, noFirst);
  return hooks_useDerivedSignal(throttledResolver, [throttledResolver, getValue], true);
}
function useDebouncedResolver(resolver, deps, ms) {
  let noFirst = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let noLast = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  return useDebouncedCallback(setValue => {
    setValue(resolver());
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, deps, ms, noFirst, noLast);
}
function useDebouncedSignal(getValue, ms) {
  let noFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let noLast = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const debouncedResolver = useDebouncedResolver(() => getValue(), [getValue], ms, noFirst, noLast);
  return useDerivedSignal(debouncedResolver, [debouncedResolver, getValue], true);
}
;// ./src/components/swap/Swap.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Swap_module = ({"modalDialog":"Swap-module__modalDialog","scrollContent":"Swap-module__scrollContent","amountInput":"Swap-module__amountInput","amountInputBuy":"Swap-module__amountInputBuy","inputLabel":"Swap-module__inputLabel","amountInputInner":"Swap-module__amountInputInner","advancedSlippageContainer":"Swap-module__advancedSlippageContainer","content":"Swap-module__content","inputContainer":"Swap-module__inputContainer","advancedSlippageButton":"Swap-module__advancedSlippageButton","swapButtonWrapper":"Swap-module__swapButtonWrapper","swapButtonWrapperStatic":"Swap-module__swapButtonWrapperStatic","swapButton":"Swap-module__swapButton","footerBlock":"Swap-module__footerBlock","footerBlockStatic":"Swap-module__footerBlockStatic","dot":"Swap-module__dot","advancedBlock":"Swap-module__advancedBlock","advancedRow":"Swap-module__advancedRow","advancedDescription":"Swap-module__advancedDescription","advancedTooltip":"Swap-module__advancedTooltip","advancedTooltipContainer":"Swap-module__advancedTooltipContainer","advancedValue":"Swap-module__advancedValue","advancedSlippageError":"Swap-module__advancedSlippageError","advancedSlippage":"Swap-module__advancedSlippage","advancedInput":"Swap-module__advancedInput","advancedInputValue":"Swap-module__advancedInputValue","isEmpty":"Swap-module__isEmpty","advancedError":"Swap-module__advancedError","advancedLink":"Swap-module__advancedLink","advancedLinkIcon":"Swap-module__advancedLinkIcon","advancedPlaceholder":"Swap-module__advancedPlaceholder","footerButtonWrapper":"Swap-module__footerButtonWrapper","footerButton":"Swap-module__footerButton","footerButtonInner":"Swap-module__footerButtonInner","swapArrowIcon":"Swap-module__swapArrowIcon","changellyInfo":"Swap-module__changellyInfo","priceImpact":"Swap-module__priceImpact","feeLine":"Swap-module__feeLine","priceImpactSticker":"Swap-module__priceImpactSticker","priceImpactContent":"Swap-module__priceImpactContent","priceImpactTitle":"Swap-module__priceImpactTitle","priceImpactArrow":"Swap-module__priceImpactArrow","priceImpactDescription":"Swap-module__priceImpactDescription","swapCornerTop":"Swap-module__swapCornerTop","swapCornerBottom":"Swap-module__swapCornerBottom","swapCornerStaticTop":"Swap-module__swapCornerStaticTop","swapCornerStaticBottom":"Swap-module__swapCornerStaticBottom","selectBlockchainBlock":"Swap-module__selectBlockchainBlock","inputAddressWrapper":"Swap-module__inputAddressWrapper","inputAddress":"Swap-module__inputAddress","blockchainHintWrapper":"Swap-module__blockchainHintWrapper","changellyDescription":"Swap-module__changellyDescription","blockchainHintText":"Swap-module__blockchainHintText","blockchainHintTextError":"Swap-module__blockchainHintTextError","inputButton":"Swap-module__inputButton","inputButtonShifted":"Swap-module__inputButtonShifted","changellyInfoStatic":"Swap-module__changellyInfoStatic","priceImpactStatic":"Swap-module__priceImpactStatic","changellyInfoTitle":"Swap-module__changellyInfoTitle","changellyInfoDescription":"Swap-module__changellyInfoDescription","changellyIcon":"Swap-module__changellyIcon","changellyInfoBlock":"Swap-module__changellyInfoBlock","blockchainButtons":"Swap-module__blockchainButtons","changellyTextField":"Swap-module__changellyTextField","textFieldWrapperFullWidth":"Swap-module__textFieldWrapperFullWidth","changellyImportantRed":"Swap-module__changellyImportantRed","arrowContainer":"Swap-module__arrowContainer","arrowContainerInverted":"Swap-module__arrowContainerInverted","arrow":"Swap-module__arrow","arrowNew":"Swap-module__arrowNew","arrowOld":"Swap-module__arrowOld","animateDisappear":"Swap-module__animateDisappear","arrow-disappear":"Swap-module__arrow-disappear","arrowDisappear":"Swap-module__arrow-disappear","animateAppear":"Swap-module__animateAppear","arrow-appear":"Swap-module__arrow-appear","arrowAppear":"Swap-module__arrow-appear","transactionBanner":"Swap-module__transactionBanner","changellyDescriptionBold":"Swap-module__changellyDescriptionBold","qrCode":"Swap-module__qrCode","qrCodeHidden":"Swap-module__qrCodeHidden","textFieldLabel":"Swap-module__textFieldLabel"});
;// ./src/components/swap/components/SwapSubmitButton.tsx












const BUTTON_ANIMATION_DURATION = 250 + src_config/* ANIMATION_END_DELAY */.xB5;
function SwapSubmitButton(_ref) {
  let {
    tokenIn,
    tokenOut,
    amountIn,
    amountOut,
    swapType,
    isEstimating,
    isSending,
    isNotEnoughNative,
    nativeToken,
    dieselStatus,
    isPriceImpactError,
    canSubmit,
    errorType,
    limits
  } = _ref;
  const lang = hooks_useLang();
  const isErrorExist = errorType !== undefined;
  const shouldSendingBeVisible = isSending && swapType === SwapType.CrosschainToWallet;
  const isDisabled = !canSubmit || shouldSendingBeVisible;
  const isLoading = isEstimating || shouldSendingBeVisible;
  const errorMsgByType = {
    [SwapErrorType.UnexpectedError]: lang('Unexpected Error'),
    [SwapErrorType.InvalidPair]: lang('Invalid Pair'),
    [SwapErrorType.NotEnoughLiquidity]: lang('Insufficient liquidity'),
    [SwapErrorType.ChangellyMinSwap]: lang('Minimum amount', {
      value: formatCurrencySimple((limits === null || limits === void 0 ? void 0 : limits.fromMin) ?? '0', (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol) ?? '', tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.decimals)
    }),
    [SwapErrorType.ChangellyMaxSwap]: lang('Maximum amount', {
      value: formatCurrencySimple((limits === null || limits === void 0 ? void 0 : limits.fromMax) ?? '0', (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol) ?? '', tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.decimals)
    }),
    [SwapErrorType.NotEnoughForFee]: lang('Not Enough %symbol%', {
      symbol: tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol
    }),
    [SwapErrorType.TooSmallAmount]: lang('$swap_too_small_amount')
  };
  const isTouched = Boolean(amountIn || amountOut);
  let text = '$swap_from_to';
  if (isTouched) {
    if (isErrorExist) {
      text = errorMsgByType[errorType];
    } else if (nativeToken) {
      if (isNotEnoughNative && (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.chain) === 'ton' && tokenIn !== null && tokenIn !== void 0 && tokenIn.tokenAddress) {
        if (dieselStatus === 'not-available') {
          text = lang('Not Enough %symbol%', {
            symbol: 'TON'
          });
        } else if (dieselStatus === 'pending-previous') {
          text = lang('Awaiting Previous Fee');
        } else if (dieselStatus === 'not-authorized') {
          text = lang('Authorize %token% Fee', {
            token: tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol
          });
        }
      } else if (isNotEnoughNative) {
        text = lang('Not Enough %symbol%', {
          symbol: nativeToken === null || nativeToken === void 0 ? void 0 : nativeToken.symbol
        });
      }
    }
  }
  const textStr = Array.isArray(text) ? text.join('') : text;
  const shouldShowError = !isEstimating && (isPriceImpactError || isErrorExist || nativeToken && isNotEnoughNative && (!dieselStatus || dieselStatus === 'not-available' || dieselStatus === 'pending-previous'));
  const isDestructive = isTouched && shouldShowError;
  const transitionKeyRef = teact_useRef(0);
  const render = hooks_useDerivedSignal(() => {
    const renderedText = textStr === '$swap_from_to' ? lang('$swap_from_to', {
      from: tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol,
      icon: /*#__PURE__*/teact.createElement("i", {
        className: buildClassName('icon-chevron-right', Swap_module.swapArrowIcon),
        "aria-hidden": true
      }),
      to: tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.symbol
    }) : textStr;
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "semiFade",
      className: Swap_module.footerButtonWrapper,
      activeKey: transitionKeyRef.current++
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      isSubmit: true,
      className: Swap_module.footerButton,
      isDisabled: isDisabled,
      isLoading: isLoading,
      isDestructive: isDestructive
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.footerButtonInner
    }, renderedText)));
  }, [isDestructive, isDisabled, isLoading, lang, textStr, tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol, tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.symbol]);
  const renderThrottled = useThrottledSignal(render, BUTTON_ANIMATION_DURATION);
  const rendered = hooks_useDerivedState(renderThrottled);
  return rendered;
}
/* harmony default export */ const components_SwapSubmitButton = (memo(SwapSubmitButton));
;// ./src/components/swap/SwapDexChooser.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SwapDexChooser_module = ({"root":"SwapDexChooser-module__root","container":"SwapDexChooser-module__container","content":"SwapDexChooser-module__content","button":"SwapDexChooser-module__button","static":"SwapDexChooser-module__static","label":"SwapDexChooser-module__label","labelText":"SwapDexChooser-module__labelText","iconArrowRight":"SwapDexChooser-module__iconArrowRight","dexList":"SwapDexChooser-module__dexList","dexItem":"SwapDexChooser-module__dexItem","bestRate":"SwapDexChooser-module__bestRate","current":"SwapDexChooser-module__current","dexValue":"SwapDexChooser-module__dexValue","dexTitle":"SwapDexChooser-module__dexTitle","dexIcon":"SwapDexChooser-module__dexIcon","dexValueFractional":"SwapDexChooser-module__dexValueFractional","dexExchangeRate":"SwapDexChooser-module__dexExchangeRate","dexInfo":"SwapDexChooser-module__dexInfo","dexInfoDisabled":"SwapDexChooser-module__dexInfoDisabled","bestLabel":"SwapDexChooser-module__bestLabel","dexSubmitSlide":"SwapDexChooser-module__dexSubmitSlide","dexSubmitButtons":"SwapDexChooser-module__dexSubmitButtons","dexBestRateButton":"SwapDexChooser-module__dexBestRateButton"});
;// ./src/assets/logo/dedust.png
const dedust_namespaceObject = __webpack_require__.p + "dedust.76618cc56dfd6341f305.png";
;// ./src/assets/logo/stonfi.png
const stonfi_namespaceObject = __webpack_require__.p + "stonfi.bf33a92c06cc67840d20.png";
;// ./src/components/swap/SwapDexChooser.tsx






















const IS_WHOLE_PART_BIG_REGEX = /^\d{5,}([.,]|$)/;
function SwapDexChooser(_ref) {
  let {
    tokenIn,
    tokenOut,
    isStatic,
    currentSwap: {
      amountOut,
      amountIn,
      estimates,
      currentDexLabel,
      bestRateDexLabel,
      inputSource,
      ourFeePercent = src_config/* DEFAULT_OUR_SWAP_FEE */.YDh
    },
    swapVersion
  } = _ref;
  const {
    setSwapDex
  } = getActions();
  const lang = hooks_useLang();
  const [isModalOpen, openModal, closeModal] = hooks_useFlag(false);
  const [selectedDexLabel, setSelectedDexLabel] = useState(currentDexLabel);
  const renderedDexItems = useCurrentOrPrev(estimates !== null && estimates !== void 0 && estimates.length ? estimates : undefined, true);
  const renderedCurrentDexLabel = useCurrentOrPrev(currentDexLabel, true);
  const renderedBestRateDexLabel = useCurrentOrPrev(bestRateDexLabel, true);
  const isBestRateSelected = Boolean(bestRateDexLabel && bestRateDexLabel === selectedDexLabel);
  const confirmLabel = isBestRateSelected ? lang('Use Best Rate') : lang('Switch to %dex_name%', {
    dex_name: selectedDexLabel ? src_config/* SWAP_DEX_LABELS */.S7e[selectedDexLabel] : ''
  });
  const shouldRenderForSwapV2 = !!(estimates !== null && estimates !== void 0 && estimates.length) && !!tokenOut && !!amountOut && !!amountIn;
  const {
    shouldRender,
    ref: rootRef
  } = useShowTransition({
    isOpen: swapVersion === 2 && shouldRenderForSwapV2,
    withShouldRender: true
  });
  const handleDexConfirm = useLastCallback(() => {
    if (selectedDexLabel) {
      setSwapDex({
        dexLabel: selectedDexLabel
      });
    }
    closeModal();
  });
  function toggleDexMenu() {
    if (isModalOpen) {
      closeModal();
    } else {
      setSelectedDexLabel(currentDexLabel);
      openModal();
    }
  }
  const {
    shouldRender: shouldRenderBenefit,
    value: benefitAmount
  } = teact_useMemo(() => {
    return calculateBenefitAmount({
      ourFeePercent,
      decimals: inputSource === SwapInputSource.In ? tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.decimals : tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.decimals,
      estimates,
      inputSource,
      bestRateDexLabel: renderedBestRateDexLabel
    });
  }, [renderedBestRateDexLabel, estimates, inputSource, ourFeePercent, tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.decimals, tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.decimals]);
  const renderedAmounts = teact_useMemo(() => {
    if (!(renderedDexItems !== null && renderedDexItems !== void 0 && renderedDexItems.length) || renderedDexItems.length < 2) return undefined;
    return renderedDexItems.reduce((acc, item) => {
      const {
        fromAmount,
        toAmount,
        dexLabel
      } = item;
      const amount = inputSource === SwapInputSource.In ? toAmount : fromAmount;
      const token = inputSource === SwapInputSource.In ? tokenOut : tokenIn;
      if (IS_WHOLE_PART_BIG_REGEX.test(amount)) {
        const formattedAmount = formatDexItemAmount(amount, token);
        if (formattedAmount) {
          acc[dexLabel] = formattedAmount;
        }
      } else {
        acc[dexLabel] = formatCurrency(amount, token.symbol);
      }
      return acc;
    }, {});
  }, [inputSource, renderedDexItems, tokenIn, tokenOut]);
  if (!shouldRender || !(renderedDexItems !== null && renderedDexItems !== void 0 && renderedDexItems.length)) return undefined;
  const buttonContent = /*#__PURE__*/teact.createElement(teact.Fragment, null, renderedBestRateDexLabel === renderedCurrentDexLabel && renderedDexItems.length > 1 && /*#__PURE__*/teact.createElement("span", {
    className: SwapDexChooser_module.label
  }, /*#__PURE__*/teact.createElement("span", {
    className: SwapDexChooser_module.labelText
  }, lang('Best Rate'))), lang('via %dex_name%', {
    dex_name: /*#__PURE__*/teact.createElement("strong", null, src_config/* SWAP_DEX_LABELS */.S7e[renderedCurrentDexLabel])
  }), renderedDexItems.length > 1 && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-chevron-right', SwapDexChooser_module.iconArrowRight),
    "aria-hidden": true
  }));
  if (renderedDexItems.length === 1) {
    return /*#__PURE__*/teact.createElement("div", {
      ref: rootRef,
      className: SwapDexChooser_module.root
    }, /*#__PURE__*/teact.createElement("div", {
      className: SwapDexChooser_module.container
    }, /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(SwapDexChooser_module.content, isStatic && SwapDexChooser_module.static)
    }, buttonContent)));
  }
  function renderedDexItem(item) {
    const rate = getSwapRate(item.fromAmount, item.toAmount, tokenIn, tokenOut);
    return /*#__PURE__*/teact.createElement("div", {
      key: item.dexLabel,
      tabIndex: 0,
      role: "button",
      className: buildClassName(SwapDexChooser_module.dexItem, renderedBestRateDexLabel === item.dexLabel && SwapDexChooser_module.bestRate, selectedDexLabel === item.dexLabel && SwapDexChooser_module.current),
      onClick: () => {
        setSelectedDexLabel(item.dexLabel);
      }
    }, /*#__PURE__*/teact.createElement("div", {
      className: SwapDexChooser_module.dexTitle
    }, /*#__PURE__*/teact.createElement("img", {
      src: item.dexLabel === 'dedust' ? dedust_namespaceObject : stonfi_namespaceObject,
      alt: src_config/* SWAP_DEX_LABELS */.S7e[item.dexLabel],
      className: SwapDexChooser_module.dexIcon
    }), src_config/* SWAP_DEX_LABELS */.S7e[item.dexLabel]), /*#__PURE__*/teact.createElement("div", {
      className: SwapDexChooser_module.dexValue
    }, renderedAmounts === null || renderedAmounts === void 0 ? void 0 : renderedAmounts[item.dexLabel]), /*#__PURE__*/teact.createElement("div", {
      className: SwapDexChooser_module.dexExchangeRate
    }, rate ? /*#__PURE__*/teact.createElement(teact.Fragment, null, rate.firstCurrencySymbol, "\xA0\u2248 ", rate.price, "\xA0", rate.secondCurrencySymbol) : undefined), item.dexLabel === renderedBestRateDexLabel && /*#__PURE__*/teact.createElement("span", {
      className: SwapDexChooser_module.bestLabel
    }, lang('Best')));
  }
  function renderBenefitAmount() {
    if (inputSource === SwapInputSource.Out) {
      return /*#__PURE__*/teact.createElement("p", {
        className: buildClassName(SwapDexChooser_module.dexInfo, !isBestRateSelected && SwapDexChooser_module.dexInfoDisabled)
      }, renderText(lang('You will spend %amount% **less**.', {
        amount: /*#__PURE__*/teact.createElement("strong", null, formatCurrency(benefitAmount, tokenIn.symbol))
      })));
    }
    return /*#__PURE__*/teact.createElement("p", {
      className: buildClassName(SwapDexChooser_module.dexInfo, !isBestRateSelected && SwapDexChooser_module.dexInfoDisabled)
    }, renderText(lang('You will receive %amount% **more**.', {
      amount: /*#__PURE__*/teact.createElement("strong", null, formatCurrency(benefitAmount, tokenOut.symbol))
    })));
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: rootRef,
    className: SwapDexChooser_module.root
  }, /*#__PURE__*/teact.createElement("div", {
    className: SwapDexChooser_module.container
  }, /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: buildClassName(SwapDexChooser_module.button, isStatic && SwapDexChooser_module.static),
    onClick: toggleDexMenu
  }, buttonContent), /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isModalOpen,
    isCompact: true,
    title: lang('Built-in DEX Aggregator'),
    onClose: closeModal
  }, /*#__PURE__*/teact.createElement("div", {
    className: SwapDexChooser_module.dexList
  }, renderedDexItems.map(item => renderedDexItem(item))), /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(SwapDexChooser_module.dexInfo, !isBestRateSelected && SwapDexChooser_module.dexInfoDisabled)
  }, renderText(lang('$swap_dex_chooser_rate_title'))), shouldRenderBenefit && renderBenefitAmount(), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.buttons, SwapDexChooser_module.dexSubmitButtons)
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: isBestRateSelected ? 0 : 1,
    name: "semiFade",
    slideClassName: SwapDexChooser_module.dexSubmitSlide
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: buildClassName(Modal_module.buttonFullWidth, isBestRateSelected && SwapDexChooser_module.dexBestRateButton),
    onClick: handleDexConfirm
  }, confirmLabel))))));
}
/* harmony default export */ const swap_SwapDexChooser = (memo(withGlobal(global => {
  return {
    currentSwap: global.currentSwap,
    swapVersion: global.swapVersion
  };
})(SwapDexChooser)));
function calculateBenefitAmount(_ref2) {
  let {
    ourFeePercent,
    decimals,
    bestRateDexLabel,
    estimates,
    inputSource
  } = _ref2;
  if (!estimates || estimates.length < 2) {
    return {
      shouldRender: false,
      value: '0'
    };
  }
  const bestRateEstimate = estimates.find(_ref3 => {
    let {
      dexLabel
    } = _ref3;
    return dexLabel === bestRateDexLabel;
  });
  const otherEstimate = estimates.find(_ref4 => {
    let {
      dexLabel
    } = _ref4;
    return dexLabel !== bestRateDexLabel;
  });
  if (!otherEstimate || !bestRateEstimate) {
    return {
      shouldRender: false,
      value: '0'
    };
  }
  const isDirectSwap = inputSource === SwapInputSource.In;
  const amountKey = isDirectSwap ? 'toAmount' : 'fromAmount';
  const ourFeeValue = Number(bestRateEstimate[amountKey]) / 100 * ourFeePercent;
  const benefit = ((0,util_decimals/* fromDecimal */.UH)(bestRateEstimate[amountKey], decimals) - (0,util_decimals/* fromDecimal */.UH)(otherEstimate[amountKey], decimals)) * (isDirectSwap ? 1n : -1n);
  const shouldRender = benefit - (0,util_decimals/* fromDecimal */.UH)(ourFeeValue, decimals) > 0n;
  return {
    shouldRender,
    value: (0,util_decimals/* toDecimal */.nI)(benefit, decimals)
  };
}
function formatDexItemAmount(toAmount, tokenOut) {
  const parts = getNumberParts(toAmount, src_config/* SHORT_FRACTION_DIGITS */.Vxu);
  if (!parts) return undefined;
  const [, wholePartRaw, dotPart, fractionPart] = parts;
  const fractionStr = fractionPart || dotPart ? `.${(fractionPart || '').substring(0, src_config/* SHORT_FRACTION_DIGITS */.Vxu)}` : '';
  const formattedWholePart = wholePartRaw.replace(/\d(?=(\d{3})+($))/g, `$&${src_config/* WHOLE_PART_DELIMITER */.MS3}`);
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, formattedWholePart, /*#__PURE__*/teact.createElement("span", {
    className: SwapDexChooser_module.dexValueFractional
  }, fractionStr, "\u2009", tokenOut.symbol));
}
;// ./src/components/swap/SwapSettingsModal.tsx
function SwapSettingsModal_extends() { return SwapSettingsModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, SwapSettingsModal_extends.apply(null, arguments); }





















const SLIPPAGE_VALUES = [0.5, 1, 2, 5, 10];
const MAX_SLIPPAGE_VALUE = 50;
const MAX_PRICE_IMPACT_VALUE = 5;
function SwapSettingsContent(_ref) {
  let {
    onClose,
    amountIn,
    amountOut,
    swapType,
    tokenIn,
    tokenOut,
    slippage,
    priceImpact,
    networkFee,
    realNetworkFee,
    amountOutMin,
    ourFee,
    ourFeePercent = src_config/* DEFAULT_OUR_SWAP_FEE */.YDh,
    dieselStatus,
    dieselFee,
    nativeTokenInBalance,
    showFullNetworkFee,
    onNetworkFeeClick
  } = _ref;
  const {
    setSlippage
  } = getActions();
  const lang = hooks_useLang();
  const canEditSlippage = swapType === SwapType.OnChain;

  // In order to reset this state when the modal is closed, we rely on the fact that Modal unmounts the content when
  // it's closed.
  const [currentSlippage, setCurrentSlippage] = useState(slippage);
  const priceImpactError = (priceImpact ?? 0) >= MAX_PRICE_IMPACT_VALUE;
  const slippageError = currentSlippage === undefined ? 'Slippage not specified' : currentSlippage > MAX_SLIPPAGE_VALUE ? 'Slippage too high' : '';
  const handleSave = useLastCallback(() => {
    setSlippage({
      slippage: currentSlippage
    });
    onClose();
  });
  const handleInputChange = useLastCallback(stringValue => {
    const value = stringValue ? Number(stringValue) : undefined;
    setCurrentSlippage(value);
  });
  const explainedFee = teact_useMemo(() => explainSwapFee({
    swapType,
    tokenInSlug: tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.slug,
    networkFee,
    realNetworkFee,
    ourFee,
    dieselStatus,
    dieselFee,
    nativeTokenInBalance
  }), [swapType, tokenIn, networkFee, realNetworkFee, ourFee, dieselStatus, dieselFee, nativeTokenInBalance]);
  function renderSlippageValues() {
    const slippageList = SLIPPAGE_VALUES.map((value, index) => {
      return /*#__PURE__*/teact.createElement("div", {
        key: value,
        className: Swap_module.advancedSlippageButton
      }, /*#__PURE__*/teact.createElement("div", {
        role: "button",
        tabIndex: 0,
        onClick: () => setCurrentSlippage(value),
        className: Swap_module.balanceLink
      }, value, "%"), index + 1 !== SLIPPAGE_VALUES.length && /*#__PURE__*/teact.createElement("i", {
        className: Swap_module.dot,
        "aria-hidden": true
      }));
    });
    return /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.advancedSlippageContainer
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.advancedSlippage
    }, slippageList));
  }
  function renderSlippageError() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.advancedSlippageError
    }, /*#__PURE__*/teact.createElement("span", null, lang(slippageError)));
  }
  function renderRate() {
    const rate = getSwapRate(amountIn, amountOut, tokenIn, tokenOut, true);
    return /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.advancedRow
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.advancedDescription
    }, lang('Exchange Rate')), /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.advancedValue
    }, rate ? `${rate.firstCurrencySymbol} â‰ˆ ${rate.price} ${rate.secondCurrencySymbol}` : /*#__PURE__*/teact.createElement(ValuePlaceholder, null)));
  }
  function renderNetworkFee() {
    const actualFee = showFullNetworkFee ? explainedFee.fullFee : explainedFee.realFee;
    let feeElement = actualFee && tokenIn && /*#__PURE__*/teact.createElement(ui_Fee, {
      terms: actualFee.networkTerms,
      precision: actualFee.precision,
      token: tokenIn
    });
    if (feeElement && onNetworkFeeClick) {
      feeElement = /*#__PURE__*/teact.createElement("span", {
        role: "button",
        tabIndex: 0,
        className: Swap_module.advancedLink,
        onClick: () => onNetworkFeeClick()
      }, /*#__PURE__*/teact.createElement("span", null, feeElement), /*#__PURE__*/teact.createElement("i", {
        className: buildClassName('icon-chevron-right', Swap_module.advancedLinkIcon),
        "aria-hidden": true
      }));
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.advancedRow
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.advancedDescription
    }, lang('Blockchain Fee')), /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.advancedValue
    }, feeElement || /*#__PURE__*/teact.createElement(ValuePlaceholder, null)));
  }
  function renderSlippageLabel() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, lang('Slippage'), /*#__PURE__*/teact.createElement(Tooltip, {
      isError: Boolean(slippageError)
    }, /*#__PURE__*/teact.createElement("span", null, lang('$swap_slippage_tooltip1')), /*#__PURE__*/teact.createElement("span", null, lang('$swap_slippage_tooltip2'))));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, canEditSlippage && /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.advancedInput
  }, renderSlippageValues(), /*#__PURE__*/teact.createElement(ui_RichNumberInput, {
    labelText: renderSlippageLabel(),
    labelClassName: Swap_module.slippageLabel,
    value: currentSlippage === null || currentSlippage === void 0 ? void 0 : currentSlippage.toString(),
    hasError: Boolean(slippageError),
    decimals: 2,
    suffix: "%",
    size: "normal",
    onChange: handleInputChange
  }), renderSlippageError()), /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.advancedBlock
  }, renderRate(), renderNetworkFee(), explainedFee.shouldShowOurFee && /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.advancedRow
  }, /*#__PURE__*/teact.createElement("span", {
    className: Swap_module.advancedDescription
  }, lang('Aggregator Fee'), /*#__PURE__*/teact.createElement(Tooltip, null, /*#__PURE__*/teact.createElement("span", null, renderText(lang('$swap_aggregator_fee_tooltip', {
    percent: `${ourFeePercent}%`
  }))))), /*#__PURE__*/teact.createElement("span", {
    className: Swap_module.advancedValue
  }, ourFee !== undefined ? formatCurrency(ourFee, (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol) ?? '', undefined, true) : /*#__PURE__*/teact.createElement(ValuePlaceholder, null))), swapType === SwapType.OnChain && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.advancedRow
  }, /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Swap_module.advancedDescription, priceImpactError && Swap_module.advancedError)
  }, lang('Price Impact'), /*#__PURE__*/teact.createElement(Tooltip, {
    isError: Boolean(priceImpactError)
  }, /*#__PURE__*/teact.createElement("span", null, lang('$swap_price_impact_tooltip1')), /*#__PURE__*/teact.createElement("span", null, lang('$swap_price_impact_tooltip2')))), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Swap_module.advancedValue, priceImpactError && Swap_module.advancedError)
  }, priceImpact !== undefined ? `${priceImpact}%` : /*#__PURE__*/teact.createElement(ValuePlaceholder, null))), /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.advancedRow
  }, /*#__PURE__*/teact.createElement("span", {
    className: Swap_module.advancedDescription
  }, lang('Minimum Received'), /*#__PURE__*/teact.createElement(Tooltip, null, /*#__PURE__*/teact.createElement("span", null, lang('$swap_minimum_received_tooltip1')), /*#__PURE__*/teact.createElement("span", null, lang('$swap_minimum_received_tooltip2')))), /*#__PURE__*/teact.createElement("span", {
    className: Swap_module.advancedValue
  }, amountOutMin !== undefined && tokenOut ? formatCurrency(amountOutMin, tokenOut.symbol) : /*#__PURE__*/teact.createElement(ValuePlaceholder, null))))), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Modal_module.button,
    onClick: onClose
  }, lang('Close')), canEditSlippage && /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDisabled: Boolean(slippageError),
    className: Modal_module.button,
    onClick: handleSave
  }, lang('Save'))));
}
const SwapSettings = memo(withGlobal(global => {
  var _findChainConfig;
  const {
    tokenInSlug,
    amountIn,
    amountOut,
    networkFee,
    realNetworkFee,
    slippage,
    priceImpact,
    amountOutMin,
    ourFee,
    ourFeePercent,
    dieselStatus,
    dieselFee
  } = global.currentSwap;
  const nativeToken = tokenInSlug ? (_findChainConfig = findChainConfig(getChainBySlug(tokenInSlug))) === null || _findChainConfig === void 0 ? void 0 : _findChainConfig.nativeToken : undefined;
  const nativeTokenInBalance = nativeToken ? selectCurrentAccountTokenBalance(global, nativeToken.slug) : undefined;
  return {
    amountIn,
    amountOut,
    networkFee,
    realNetworkFee,
    swapType: selectSwapType(global),
    tokenIn: selectCurrentSwapTokenIn(global),
    tokenOut: selectCurrentSwapTokenOut(global),
    slippage,
    priceImpact,
    amountOutMin,
    ourFee,
    ourFeePercent,
    dieselStatus,
    dieselFee,
    nativeTokenInBalance
  };
})(SwapSettingsContent));
function SwapSettingsModal(_ref2) {
  let {
    isOpen,
    onClose,
    ...restProps
  } = _ref2;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    onClose: onClose,
    isCompact: true,
    title: lang('Swap Details')
  }, /*#__PURE__*/teact.createElement(SwapSettings, SwapSettingsModal_extends({
    onClose: onClose
  }, restProps)));
}
function ValuePlaceholder() {
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement("span", {
    className: Swap_module.advancedPlaceholder
  }, lang('No Data'));
}
function Tooltip(_ref3) {
  let {
    children,
    isError
  } = _ref3;
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, ' ', /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
    message: children,
    size: "small",
    iconClassName: buildClassName(Swap_module.advancedTooltip, isError && Swap_module.advancedError),
    tooltipClassName: Swap_module.advancedTooltipContainer
  }));
}
;// ./src/components/swap/SwapInitial.tsx




























const ESTIMATE_REQUEST_INTERVAL = 1_000;
const SET_AMOUNT_DEBOUNCE_TIME = 500;
function SwapInitial(_ref) {
  var _findChainConfig, _explainedFee$fullFee, _explainedFee$fullFee2, _explainedFee$fullFee3, _explainedFee$realFee, _explainedFee$realFee2;
  let {
    currentSwap: {
      tokenInSlug,
      tokenOutSlug,
      amountIn,
      amountOut,
      errorType,
      isEstimating,
      networkFee,
      realNetworkFee,
      priceImpact = 0,
      inputSource,
      limits,
      isLoading,
      dieselStatus,
      ourFee,
      ourFeePercent,
      dieselFee
    },
    addressByChain,
    tokens,
    isActive,
    isStatic,
    isMultichainAccount,
    swapType,
    isSensitiveDataHidden,
    pairsBySlug
  } = _ref;
  const {
    setDefaultSwapParams,
    setSwapAmountIn,
    setSwapAmountOut,
    switchSwapTokens,
    estimateSwap,
    setSwapScreen,
    setSwapCexAddress,
    authorizeDiesel,
    showNotification
  } = getActions();
  const lang = hooks_useLang();
  const inputInRef = teact_useRef();
  const inputOutRef = teact_useRef();
  const currentTokenInSlug = tokenInSlug ?? src_config/* TONCOIN */.Tu9.slug;
  const currentTokenOutSlug = tokenOutSlug ?? src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC;
  const tokenIn = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(token => token.slug === currentTokenInSlug), [currentTokenInSlug, tokens]);
  const tokenOut = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(token => token.slug === currentTokenOutSlug), [currentTokenOutSlug, tokens]);
  const nativeTokenInSlug = isMultichainAccount || (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.chain) === 'ton' ? (_findChainConfig = findChainConfig(tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.chain)) === null || _findChainConfig === void 0 ? void 0 : _findChainConfig.nativeToken.slug : undefined;
  const nativeUserTokenIn = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(token => token.slug === nativeTokenInSlug), [nativeTokenInSlug, tokens]);
  const nativeTokenInBalance = (nativeUserTokenIn === null || nativeUserTokenIn === void 0 ? void 0 : nativeUserTokenIn.amount) ?? 0n;
  const amountInBigint = amountIn && tokenIn ? (0,util_decimals/* fromDecimal */.UH)(amountIn, tokenIn.decimals) : undefined;
  const amountOutBigint = amountOut && tokenOut ? (0,util_decimals/* fromDecimal */.UH)(amountOut, tokenOut.decimals) : undefined;
  const balanceIn = (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.amount) ?? 0n;
  const explainedFee = teact_useMemo(() => explainSwapFee({
    swapType,
    tokenInSlug,
    networkFee,
    realNetworkFee,
    ourFee,
    dieselStatus,
    dieselFee,
    nativeTokenInBalance
  }), [swapType, tokenInSlug, networkFee, realNetworkFee, ourFee, dieselStatus, dieselFee, nativeTokenInBalance]);
  const maxAmount = getMaxSwapAmount({
    swapType,
    tokenInBalance: balanceIn,
    tokenIn,
    fullNetworkFee: (_explainedFee$fullFee = explainedFee.fullFee) === null || _explainedFee$fullFee === void 0 ? void 0 : _explainedFee$fullFee.networkTerms,
    ourFeePercent
  });

  // Note: this constant has 3 distinct meaningful values
  const isEnoughBalance = isBalanceSufficientForSwap({
    swapType,
    tokenInBalance: balanceIn,
    tokenIn,
    fullNetworkFee: (_explainedFee$fullFee2 = explainedFee.fullFee) === null || _explainedFee$fullFee2 === void 0 ? void 0 : _explainedFee$fullFee2.networkTerms,
    ourFeePercent,
    amountIn,
    nativeTokenInBalance
  });
  const networkFeeBigint = networkFee !== undefined && nativeUserTokenIn ? (0,util_decimals/* fromDecimal */.UH)(networkFee, nativeUserTokenIn.decimals) : 0n;
  const isEnoughNative = nativeTokenInBalance >= networkFeeBigint;
  const isDieselNotAuthorized = explainedFee.isGasless && dieselStatus === 'not-authorized';
  const canSubmit = isDieselNotAuthorized || (amountInBigint ?? 0n) > 0n && (amountOutBigint ?? 0n) > 0n && isEnoughBalance && (!explainedFee.isGasless || dieselStatus === 'available' || dieselStatus === 'stars-fee') && !isEstimating && errorType === undefined;
  const hasAmountInError = amountInBigint !== undefined && maxAmount !== undefined && amountInBigint > maxAmount;
  const amountOutValue = (amountInBigint ?? 0n) <= 0n && inputSource === SwapInputSource.In ? '' : amountOut === null || amountOut === void 0 ? void 0 : amountOut.toString();
  const isAmountGreaterThanBalance = balanceIn !== undefined && amountInBigint !== undefined && amountInBigint > balanceIn;
  const hasInsufficientFeeError = isEnoughBalance === false && !isAmountGreaterThanBalance && dieselStatus !== 'not-authorized' && dieselStatus !== 'pending-previous';
  const isPriceImpactError = priceImpact >= MAX_PRICE_IMPACT_VALUE;
  const isCrosschain = swapType === SwapType.CrosschainFromWallet || swapType === SwapType.CrosschainToWallet;
  const [isBuyAmountInputDisabled, handleBuyAmountInputClick] = useReverseProhibited(isCrosschain, pairsBySlug, currentTokenInSlug, currentTokenOutSlug, showNotification, lang);
  const handleEstimateSwap = useLastCallback(() => {
    if ((!isActive || isBackgroundModeActive()) && !isEstimating) return;
    estimateSwap();
  });
  const debounceSetAmountIn = useDebouncedCallback_useDebouncedCallback(setSwapAmountIn, [setSwapAmountIn], SET_AMOUNT_DEBOUNCE_TIME, true);
  const debounceSetAmountOut = useDebouncedCallback_useDebouncedCallback(setSwapAmountOut, [setSwapAmountOut], SET_AMOUNT_DEBOUNCE_TIME, true);
  const [currentSubModal, openSettingsModal, openFeeModal, closeSubModal] = useSubModals(explainedFee);
  teact_useEffect(() => {
    if (!tokenInSlug && !tokenOutSlug) {
      setDefaultSwapParams();
    }
  }, [tokenInSlug, tokenOutSlug]);
  teact_useEffect(() => {
    if (isEstimating) {
      handleEstimateSwap();
    }
    const intervalId = setInterval(handleEstimateSwap, ESTIMATE_REQUEST_INTERVAL);
    return () => clearInterval(intervalId);
  }, [isEstimating]);
  const handleAmountInChange = useLastCallback(amount => {
    debounceSetAmountIn({
      amount: amount || undefined
    });
  });
  const handleSelectTokenInModalOpen = useLastCallback(() => {
    setSwapScreen({
      state: SwapState.SelectTokenFrom
    });
  });
  const handleSelectTokenOutModalOpen = useLastCallback(() => {
    setSwapScreen({
      state: SwapState.SelectTokenTo
    });
  });
  const handleAmountOutChange = useLastCallback(amount => {
    debounceSetAmountOut({
      amount: amount || undefined
    });
  });
  const handleMaxAmountClick = useLastCallback(() => {
    if (maxAmount === undefined) {
      return;
    }
    void vibrate();
    const amount = (0,util_decimals/* toDecimal */.nI)(maxAmount, tokenIn.decimals);
    setSwapAmountIn({
      amount,
      isMaxAmount: true
    });
  });
  const handleSubmit = useLastCallback(e => {
    stopEvent(e);
    if (!canSubmit) {
      return;
    }
    if (isDieselNotAuthorized) {
      authorizeDiesel();
      return;
    }
    void vibrate();
    if (isCrosschain) {
      setSwapCexAddress({
        toAddress: ''
      });
      if (swapType === SwapType.CrosschainToWallet) {
        setSwapScreen({
          state: SwapState.Password
        });
      } else if (isMultichainAccount && addressByChain[tokenIn.chain] && addressByChain[tokenOut.chain]) {
        setSwapCexAddress({
          toAddress: addressByChain[tokenOut.chain]
        });
        setSwapScreen({
          state: SwapState.Password
        });
      } else {
        setSwapScreen({
          state: SwapState.Blockchain
        });
      }
      return;
    }
    setSwapScreen({
      state: SwapState.Password
    });
  });
  const handleSwitchTokens = useLastCallback(() => {
    void vibrate();
    switchSwapTokens();
  });
  function renderBalance() {
    return /*#__PURE__*/teact.createElement(ui_AmountInputMaxButton, {
      maxAmount: maxAmount,
      token: tokenIn,
      isSensitiveDataHidden: isSensitiveDataHidden,
      onAmountClick: handleMaxAmountClick
    });
  }
  function renderFee() {
    const shouldShow = amountIn && amountOut // We aim to synchronize the disappearing of the fee with the DEX chooser disappearing
    || (amountIn || amountOut) && errorType; // Without this sub-condition the fee wouldn't be shown when the amount is outside the Changelly limits

    let terms;
    let precision = 'exact';
    if (shouldShow) {
      const actualFee = hasInsufficientFeeError ? explainedFee.fullFee : undefined;
      if (actualFee) {
        ({
          terms,
          precision
        } = actualFee);
      }
    }
    return /*#__PURE__*/teact.createElement(ui_FeeLine, {
      isStatic: isStatic,
      terms: terms,
      token: tokenIn,
      precision: precision,
      keepDetailsButtonWithoutFee: true,
      onDetailsClick: openSettingsModal,
      className: Swap_module.feeLine
    });
  }
  function renderPriceImpactWarning() {
    if (!priceImpact || !isPriceImpactError || isCrosschain) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Swap_module.priceImpact, isStatic && Swap_module.priceImpactStatic),
      onClick: openSettingsModal
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      tgsUrl: ANIMATED_STICKERS_PATHS.run,
      previewUrl: ANIMATED_STICKERS_PATHS.runPreview,
      noLoop: false,
      nonInteractive: true,
      size: src_config/* ANIMATED_STICKER_TINY_SIZE_PX */.YO8,
      className: Swap_module.priceImpactSticker
    }), /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.priceImpactContent
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.priceImpactTitle
    }, lang('The exchange rate is below market value!', {
      value: `${priceImpact}%`
    }), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Swap_module.priceImpactArrow, 'icon-chevron-right'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.priceImpactDescription
    }, lang('We do not recommend to perform an exchange, try to specify a lower amount.'))));
  }
  function renderChangellyInfo() {
    if (!isCrosschain) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Swap_module.changellyInfo, isStatic && Swap_module.changellyInfoStatic)
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.changellyInfoTitle
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName('icon-changelly', Swap_module.changellyIcon),
      "aria-hidden": true
    }), lang('Cross-chain exchange provided by Changelly')), /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.changellyInfoDescription
    }, lang('$swap_changelly_agreement_message', {
      terms: /*#__PURE__*/teact.createElement("a", {
        href: src_config/* CHANGELLY_TERMS_OF_USE */.Kq_,
        target: "_blank",
        rel: "noreferrer"
      }, lang('$swap_changelly_terms_of_use')),
      policy: /*#__PURE__*/teact.createElement("a", {
        href: src_config/* CHANGELLY_PRIVACY_POLICY */.kuw,
        target: "_blank",
        rel: "noreferrer"
      }, lang('$swap_changelly_privacy_policy')),
      kyc: /*#__PURE__*/teact.createElement("a", {
        href: src_config/* CHANGELLY_AML_KYC */.BZS,
        target: "_blank",
        rel: "noreferrer"
      }, "Changelly AML/KYC")
    })));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("form", {
    className: isStatic ? undefined : Modal_module.transitionContent,
    onSubmit: handleSubmit
  }, /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.content
  }, /*#__PURE__*/teact.createElement("div", {
    ref: inputInRef,
    className: Swap_module.inputContainer
  }, renderBalance(), /*#__PURE__*/teact.createElement(ui_RichNumberInput, {
    id: "swap-sell",
    labelText: lang('You sell'),
    className: Swap_module.amountInput,
    hasError: hasAmountInError,
    value: amountIn === null || amountIn === void 0 ? void 0 : amountIn.toString(),
    isLoading: isEstimating && inputSource === SwapInputSource.Out,
    onChange: handleAmountInChange,
    onPressEnter: handleSubmit,
    decimals: tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.decimals,
    labelClassName: Swap_module.inputLabel,
    inputClassName: Swap_module.amountInputInner,
    cornerClassName: buildClassName(Swap_module.swapCornerTop, isStatic && Swap_module.swapCornerStaticTop),
    isStatic: isStatic
  }, /*#__PURE__*/teact.createElement(common_SelectTokenButton, {
    token: tokenIn,
    onClick: handleSelectTokenInModalOpen
  }))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Swap_module.swapButtonWrapper, isStatic && Swap_module.swapButtonWrapperStatic)
  }, /*#__PURE__*/teact.createElement(AnimatedArrows, {
    onClick: handleSwitchTokens
  })), /*#__PURE__*/teact.createElement("div", {
    ref: inputOutRef,
    className: Swap_module.inputContainer
  }, /*#__PURE__*/teact.createElement(ui_RichNumberInput, {
    id: "swap-buy",
    labelText: lang('You buy'),
    className: Swap_module.amountInputBuy,
    value: amountOutValue,
    isLoading: isEstimating && inputSource === SwapInputSource.In,
    disabled: isBuyAmountInputDisabled,
    onChange: handleAmountOutChange,
    onPressEnter: handleSubmit,
    onInputClick: handleBuyAmountInputClick,
    decimals: tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.decimals,
    labelClassName: Swap_module.inputLabel,
    inputClassName: Swap_module.amountInputInner,
    cornerClassName: buildClassName(Swap_module.swapCornerBottom, isStatic && Swap_module.swapCornerStaticBottom),
    isStatic: isStatic
  }, /*#__PURE__*/teact.createElement(common_SelectTokenButton, {
    token: tokenOut,
    onClick: handleSelectTokenOutModalOpen
  })))), /*#__PURE__*/teact.createElement(swap_SwapDexChooser, {
    tokenIn: tokenIn,
    tokenOut: tokenOut,
    isStatic: isStatic
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Swap_module.footerBlock, isStatic && Swap_module.footerBlockStatic)
  }, renderFee(), renderPriceImpactWarning(), renderChangellyInfo(), /*#__PURE__*/teact.createElement(components_SwapSubmitButton, {
    tokenIn: tokenIn,
    tokenOut: tokenOut,
    amountIn: amountIn,
    amountOut: amountOut,
    swapType: swapType,
    isEstimating: isEstimating,
    isNotEnoughNative: !isEnoughNative,
    nativeToken: nativeUserTokenIn,
    dieselStatus: dieselStatus,
    isSending: isLoading,
    isPriceImpactError: isPriceImpactError,
    canSubmit: canSubmit,
    errorType: errorType,
    limits: limits
  }))), /*#__PURE__*/teact.createElement(SwapSettingsModal, {
    isOpen: currentSubModal === 'settings',
    onClose: closeSubModal,
    onNetworkFeeClick: openFeeModal,
    showFullNetworkFee: hasInsufficientFeeError
  }), /*#__PURE__*/teact.createElement(common_FeeDetailsModal, {
    isOpen: currentSubModal === 'feeDetails',
    onClose: closeSubModal,
    fullFee: (_explainedFee$fullFee3 = explainedFee.fullFee) === null || _explainedFee$fullFee3 === void 0 ? void 0 : _explainedFee$fullFee3.networkTerms,
    realFee: (_explainedFee$realFee = explainedFee.realFee) === null || _explainedFee$realFee === void 0 ? void 0 : _explainedFee$realFee.networkTerms,
    realFeePrecision: (_explainedFee$realFee2 = explainedFee.realFee) === null || _explainedFee$realFee2 === void 0 ? void 0 : _explainedFee$realFee2.precision,
    excessFee: explainedFee.excessFee,
    excessFeePrecision: "approximate",
    token: tokenIn
  }));
}
/* harmony default export */ const swap_SwapInitial = (memo(withGlobal(global => {
  var _global$swapPairs;
  const account = selectCurrentAccount(global);
  return {
    currentSwap: global.currentSwap,
    tokens: selectSwapTokens(global),
    addressByChain: account === null || account === void 0 ? void 0 : account.addressByChain,
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    swapType: selectSwapType(global),
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden,
    pairsBySlug: (_global$swapPairs = global.swapPairs) === null || _global$swapPairs === void 0 ? void 0 : _global$swapPairs.bySlug
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(SwapInitial)));
function useReverseProhibited(isCrosschain, pairsBySlug, currentTokenInSlug, currentTokenOutSlug, showNotification, lang) {
  var _pairsBySlug$currentT;
  const isReverseProhibited = isCrosschain || (pairsBySlug === null || pairsBySlug === void 0 || (_pairsBySlug$currentT = pairsBySlug[currentTokenInSlug]) === null || _pairsBySlug$currentT === void 0 || (_pairsBySlug$currentT = _pairsBySlug$currentT[currentTokenOutSlug]) === null || _pairsBySlug$currentT === void 0 ? void 0 : _pairsBySlug$currentT.isReverseProhibited);
  const isBuyAmountInputDisabled = isReverseProhibited;
  const handleBuyAmountInputClick = teact_useMemo(() => {
    return isReverseProhibited ? () => {
      void vibrate();
      showNotification({
        message: lang('$swap_reverse_prohibited')
      });
    } : undefined;
  }, [isReverseProhibited, lang, showNotification]);
  return [isBuyAmountInputDisabled, handleBuyAmountInputClick];
}
function AnimatedArrows(_ref2) {
  let {
    onClick
  } = _ref2;
  const animationLevel = getGlobal().settings.animationLevel;
  const shouldAnimate = animationLevel === src_config/* ANIMATION_LEVEL_MAX */.zP3;
  const [hasAnimation, startAnimation, stopAnimation] = hooks_useFlag(false);
  const handleClick = useLastCallback(() => {
    if (shouldAnimate) {
      startAnimation();
      window.setTimeout(() => {
        stopAnimation();
      }, 350);
    }
    onClick === null || onClick === void 0 || onClick();
  });
  function renderArrow(isInverted) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Swap_module.arrowContainer, isInverted && Swap_module.arrowContainerInverted)
    }, /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.arrow
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-arrow-up-swap",
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Swap_module.arrowOld, hasAnimation && Swap_module.animateDisappear)
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-arrow-up-swap",
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Swap_module.arrowNew, hasAnimation && Swap_module.animateAppear)
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-arrow-up-swap",
      "aria-hidden": true
    })));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Swap_module.swapButton,
    onClick: handleClick
  }, renderArrow(), renderArrow(true));
}
function useSubModals(explainedFee) {
  var _explainedFee$realFee3;
  const isFeeModalAvailable = ((_explainedFee$realFee3 = explainedFee.realFee) === null || _explainedFee$realFee3 === void 0 ? void 0 : _explainedFee$realFee3.precision) !== 'exact';
  const [currentModal, setCurrentModal] = useState();
  const openSettings = useLastCallback(() => setCurrentModal('settings'));
  const openFeeDetailsIfAvailable = teact_useMemo(() => isFeeModalAvailable ? () => setCurrentModal('feeDetails') : undefined, [isFeeModalAvailable]);
  const close = useLastCallback(() => setCurrentModal(undefined));
  return [currentModal, openSettings, openFeeDetailsIfAvailable, close];
}
;// ./src/util/text.ts
function trimStringByMaxBytes(str, maxBytes) {
  const decoder = new TextDecoder('utf-8');
  const encoded = new TextEncoder().encode(str);
  const sliced = encoded.slice(0, maxBytes);
  return decoder.decode(sliced).replace(/\uFFFD/g, '');
}
;// ./src/components/transfer/CommentSection.tsx









const COMMENT_DROPDOWN_ITEMS = [{
  value: 'raw',
  name: 'Comment or Memo'
}, {
  value: 'encrypted',
  name: 'Encrypted Message'
}];
function CommentSection(_ref) {
  let {
    comment,
    shouldEncrypt,
    binPayload,
    stateInit,
    chain,
    isStatic,
    isCommentRequired,
    isEncryptedCommentSupported,
    onCommentChange
  } = _ref;
  const {
    setTransferShouldEncrypt
  } = getActions();
  const lang = hooks_useLang();
  const handleCommentOptionsChange = useLastCallback(option => {
    setTransferShouldEncrypt({
      shouldEncrypt: option === 'encrypted'
    });
  });
  const dropdownItems = teact_useMemo(() => isEncryptedCommentSupported ? COMMENT_DROPDOWN_ITEMS : COMMENT_DROPDOWN_ITEMS.slice(0, 1), [isEncryptedCommentSupported]);
  function renderCommentLabel() {
    return /*#__PURE__*/teact.createElement(ui_Dropdown, {
      items: dropdownItems,
      selectedValue: COMMENT_DROPDOWN_ITEMS[shouldEncrypt ? 1 : 0].value,
      theme: "inherit",
      disabled: chain === 'tron',
      menuPositionX: "left",
      shouldTranslateOptions: true,
      onChange: handleCommentOptionsChange
    });
  }
  if (binPayload || stateInit) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, binPayload && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, lang('Signing Data')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      text: binPayload,
      copyNotification: lang('Data was copied!'),
      className: Transfer_module.addressWidget
    })), stateInit && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, lang('Contract Initialization Data')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      text: stateInit,
      copyNotification: lang('Data was copied!'),
      className: Transfer_module.addressWidget
    })), /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.error
    }, renderText(lang('$signature_warning'))));
  }
  return /*#__PURE__*/teact.createElement(ui_Input, {
    wrapperClassName: Transfer_module.commentInputWrapper,
    className: isStatic ? Transfer_module.inputStatic : undefined,
    label: renderCommentLabel(),
    placeholder: isCommentRequired ? lang('Required') : lang('Optional'),
    value: comment,
    isMultiline: true,
    isDisabled: chain === 'tron',
    onInput: onCommentChange,
    isRequired: isCommentRequired
  });
}
/* harmony default export */ const transfer_CommentSection = (memo(CommentSection));
;// ./src/components/transfer/TransferInitial.tsx
function TransferInitial_extends() { return TransferInitial_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, TransferInitial_extends.apply(null, arguments); }


































const COMMENT_MAX_SIZE_BYTES = 5000;
const TransferInitial_ACTIVE_STATES = new Set([TransferState.Initial, TransferState.None]);
const AUTHORIZE_DIESEL_INTERVAL_MS = dateFormat/* SECOND */.Z2;
const TransferInitial_runDebounce = (0,schedulers/* debounce */.sg)(cb => cb(), 500, false);
function TransferInitial(_ref) {
  var _explainedFee$fullFee, _explainedFee$fullFee2, _explainedFee$fullFee3, _explainedFee$realFee, _explainedFee$realFee2;
  let {
    isStatic,
    slideClassName,
    tokenSlug,
    toAddress = '',
    resolvedAddress,
    toAddressName = '',
    amount,
    comment = '',
    shouldEncrypt,
    tokens,
    fee,
    realFee,
    savedAddresses,
    accounts,
    nativeTokenBalance,
    currentAccountId,
    isEncryptedCommentSupported,
    isMemoRequired,
    isActive,
    isLoading,
    baseCurrency,
    nfts,
    binPayload,
    stateInit,
    diesel,
    isDieselAuthorizationStarted,
    isMultichainAccount,
    isMultisig,
    isSensitiveDataHidden,
    scamWarningType,
    isAllowSuspiciousActions
  } = _ref;
  const {
    submitTransferInitial,
    fetchTransferFee,
    fetchNftFee,
    changeTransferToken,
    setTransferAmount,
    setTransferToAddress,
    setTransferComment,
    setTransferShouldEncrypt,
    cancelTransfer,
    showDialog,
    authorizeDiesel,
    fetchTransferDieselState,
    checkTransferAddress,
    dismissTransferScamWarning
  } = getActions();
  const isNftTransfer = Boolean(nfts === null || nfts === void 0 ? void 0 : nfts.length);
  if (isNftTransfer) {
    // Token and amount can't be selected in the NFT transfer form, so they are overwritten once for convenience
    tokenSlug = src_config/* TONCOIN */.Tu9.slug;
    amount = undefined;
  }
  const lang = hooks_useLang();
  const transferToken = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(token => token.slug === tokenSlug), [tokenSlug, tokens]);
  const {
    amount: balance,
    symbol,
    chain
  } = transferToken || {};
  const renderedScamWarningType = useCurrentOrPrev(scamWarningType, true);
  const isDisabledDebounce = teact_useRef(false);
  const isToncoin = tokenSlug === src_config/* TONCOIN */.Tu9.slug;
  const isAddressValid = chain ? isValidAddressOrDomain(toAddress, chain) : undefined;
  const doesSupportComment = chain === 'ton';
  const transitionKey = useTransitionActiveKey(nfts !== null && nfts !== void 0 && nfts.length ? nfts : [tokenSlug]);
  const handleAddressInput = useLastCallback((newToAddress, isValueReplaced) => {
    // If value is replaced, callbacks must be executed immediately, without debounce
    if (isValueReplaced) {
      isDisabledDebounce.current = true;
    }
    setTransferToAddress({
      toAddress: newToAddress
    });
  });
  const shouldDisableClearButton = !toAddress && !(comment || binPayload) && !shouldEncrypt && !(isNftTransfer ? isStatic : amount !== undefined);
  const explainedFee = teact_useMemo(() => explainApiTransferFee({
    fee,
    realFee,
    diesel,
    tokenSlug
  }), [fee, realFee, diesel, tokenSlug]);

  // Note: this constant has 3 distinct meaningful values
  const isEnoughBalance = isBalanceSufficientForTransfer({
    tokenBalance: balance,
    nativeTokenBalance,
    transferAmount: isNftTransfer ? 0n : amount,
    fullFee: (_explainedFee$fullFee = explainedFee.fullFee) === null || _explainedFee$fullFee === void 0 ? void 0 : _explainedFee$fullFee.terms,
    canTransferFullBalance: explainedFee.canTransferFullBalance
  });
  const isAmountMissing = !isNftTransfer && !amount;
  const maxAmount = getMaxTransferAmount({
    tokenBalance: balance,
    tokenSlug,
    fullFee: (_explainedFee$fullFee2 = explainedFee.fullFee) === null || _explainedFee$fullFee2 === void 0 ? void 0 : _explainedFee$fullFee2.terms,
    canTransferFullBalance: explainedFee.canTransferFullBalance
  });
  const isDieselNotAuthorized = (diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'not-authorized';
  const authorizeDieselInterval = isDieselNotAuthorized && isDieselAuthorizationStarted ? AUTHORIZE_DIESEL_INTERVAL_MS : undefined;
  const updateDieselState = useLastCallback(() => {
    fetchTransferDieselState({
      tokenSlug
    });
  });
  hooks_useInterval(updateDieselState, authorizeDieselInterval);
  teact_useEffect(() => {
    if (isToncoin && balance && amount && fee && amount < balance && fee < balance && amount + fee >= balance) {
      setTransferAmount({
        amount: balance - fee
      });
    }
  }, [isToncoin, amount, balance, fee]);

  // Note: this effect doesn't watch amount changes mainly because it's tricky to program a fee recalculation avoidance
  // when the amount changes due to a fee change. And it's not needed because the fee doesn't depend on the amount.
  teact_useEffect(() => {
    if (isAmountMissing || !isAddressValid) {
      return;
    }
    const runFunction = () => {
      if (isNftTransfer) {
        fetchNftFee({
          toAddress,
          comment,
          nfts: nfts ?? []
        });
      } else {
        fetchTransferFee({
          tokenSlug,
          toAddress,
          comment,
          shouldEncrypt,
          binPayload,
          stateInit
        });
      }
    };
    if (!isDisabledDebounce.current) {
      TransferInitial_runDebounce(runFunction);
    } else {
      isDisabledDebounce.current = false;
      runFunction();
    }
  }, [isAmountMissing, binPayload, comment, shouldEncrypt, isAddressValid, isNftTransfer, nfts, stateInit, toAddress, tokenSlug]);
  teact_useEffect(() => {
    if (getIsServiceToken(transferToken)) {
      showDialog({
        title: lang('Warning!'),
        message: lang('$service_token_transfer_warning'),
        noBackdropClose: true
      });
    }
  }, [lang, transferToken]);
  const handleTokenChange = useLastCallback(slug => {
    changeTransferToken({
      tokenSlug: slug
    });
  });
  function clearForm() {
    handleAddressInput('');
    checkTransferAddress({
      address: ''
    });
    setTransferAmount({
      amount: undefined
    });
    setTransferComment({
      comment: undefined
    });
    setTransferShouldEncrypt({
      shouldEncrypt: false
    });
  }
  const handleClear = useLastCallback(() => {
    if (isStatic) {
      cancelTransfer({
        shouldReset: true
      });
    } else {
      clearForm();
    }
  });
  const handleScamWarningModalClose = useLastCallback(() => {
    dismissTransferScamWarning();
    if (isStatic) {
      clearForm();
    } else {
      cancelTransfer({
        shouldReset: true
      });
    }
  });
  const handleAmountChange = (amount, isValueReplaced) => {
    // The amount input may change the amount when it's in the base currency mode and the token price changes.
    // Meanwhile, the amount in the global state must not change after the transfer form is submitted.
    if (!isActive) {
      return;
    }
    if (amount !== undefined && amount < 0) {
      return;
    }

    // If the value is replaced, callbacks must be executed immediately, without debounce
    if (isValueReplaced) {
      isDisabledDebounce.current = true;
    }
    setTransferAmount({
      amount
    });
  };
  const handlePaste = useLastCallback(() => {
    isDisabledDebounce.current = true;
  });
  const handleCommentChange = useLastCallback(value => {
    setTransferComment({
      comment: trimStringByMaxBytes(value, COMMENT_MAX_SIZE_BYTES)
    });
  });
  const isAmountGreaterThanBalance = !isNftTransfer && balance !== undefined && amount !== undefined && amount > balance;
  const hasInsufficientFeeError = isEnoughBalance === false && !isAmountGreaterThanBalance && (diesel === null || diesel === void 0 ? void 0 : diesel.status) !== 'not-authorized' && (diesel === null || diesel === void 0 ? void 0 : diesel.status) !== 'pending-previous';
  const hasAmountError = !isNftTransfer && amount !== undefined && (maxAmount !== undefined && amount > maxAmount || hasInsufficientFeeError // Ideally, the insufficient fee error message should be displayed somewhere else
  );
  const isCommentRequired = Boolean(toAddress) && isMemoRequired;
  const hasCommentError = isCommentRequired && !comment;
  const canSubmit = isDieselNotAuthorized || Boolean(isAddressValid && !isAmountMissing && !hasAmountError && isEnoughBalance && !hasCommentError && !isMultisig && (!explainedFee.isGasless || (diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'available' || (diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'stars-fee') && !(isNftTransfer && !(nfts !== null && nfts !== void 0 && nfts.length)));
  const handleSubmit = useLastCallback(e => {
    if (e) stopEvent(e);
    if (scamWarningType) return;
    if (isDieselNotAuthorized) {
      authorizeDiesel();
      return;
    }
    if (!canSubmit) {
      return;
    }
    void vibrate();
    submitTransferInitial({
      tokenSlug,
      amount: amount ?? 0n,
      toAddress,
      comment,
      binPayload,
      shouldEncrypt,
      nfts,
      withDiesel: explainedFee.isGasless,
      isGaslessWithStars: (diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'stars-fee',
      stateInit
    });
  });
  const [isFeeModalOpen, openFeeModal, closeFeeModal] = useFeeModal(explainedFee);
  const tokensToSelect = teact_useMemo(() => (tokens ?? []).filter(token => isSelectableToken(token, tokenSlug)), [tokens, tokenSlug]);
  const amountInputProps = useAmountInputState({
    amount,
    token: transferToken,
    baseCurrency,
    onAmountChange: handleAmountChange,
    onTokenChange: handleTokenChange
  });

  // It is necessary to use useCallback instead of useLastCallback here
  const renderBottomRight = teact_useCallback(className => {
    let transitionKey = 0;
    let content = ' ';
    if (isMultisig) {
      transitionKey = 1;
      content = /*#__PURE__*/teact.createElement("span", {
        className: Transfer_module.balanceError
      }, lang('Multisig sending disabled'));
    } else if (amount) {
      if (isAmountGreaterThanBalance) {
        transitionKey = 2;
        content = /*#__PURE__*/teact.createElement("span", {
          className: Transfer_module.balanceError
        }, lang('Insufficient balance'));
      } else if (hasInsufficientFeeError) {
        transitionKey = 3;
        content = /*#__PURE__*/teact.createElement("span", {
          className: Transfer_module.balanceError
        }, lang('Insufficient fee'));
      }
    }
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      className: className,
      name: "fade",
      activeKey: transitionKey
    }, content);
  }, [amount, hasInsufficientFeeError, isAmountGreaterThanBalance, isMultisig, lang]);
  function renderButtonText() {
    if ((diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'not-authorized') {
      return lang('Authorize %token% Fee', {
        token: symbol
      });
    }
    if ((diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'pending-previous') {
      return lang('Awaiting Previous Fee');
    }
    return lang('$send_token_symbol', isNftTransfer ? 'NFT' : symbol || 'TON');
  }
  function renderFee() {
    let terms;
    let precision = 'exact';
    if (!isAmountMissing) {
      const actualFee = hasInsufficientFeeError ? explainedFee.fullFee : explainedFee.realFee;
      if (actualFee) {
        ({
          terms,
          precision
        } = actualFee);
      }
    }
    return /*#__PURE__*/teact.createElement(ui_FeeLine, {
      isStatic: isStatic,
      terms: terms,
      token: transferToken,
      precision: precision,
      onDetailsClick: openFeeModal
    });
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("form", {
    className: isStatic ? undefined : Modal_module.transitionContent,
    onSubmit: handleSubmit,
    onPaste: handlePaste
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: transitionKey,
    name: "semiFade",
    direction: isStatic && !doesSupportComment ? 'inverse' : undefined,
    shouldCleanup: true,
    slideClassName: buildClassName(Transfer_module.formSlide, isStatic && Transfer_module.formSlide_static, slideClassName)
  }, (nfts === null || nfts === void 0 ? void 0 : nfts.length) === 1 && /*#__PURE__*/teact.createElement(transfer_NftInfo, {
    nft: nfts[0],
    isStatic: isStatic,
    withMediaViewer: true
  }), Boolean(nfts === null || nfts === void 0 ? void 0 : nfts.length) && nfts.length > 1 && /*#__PURE__*/teact.createElement(transfer_NftChips, {
    nfts: nfts,
    isStatic: isStatic
  }), /*#__PURE__*/teact.createElement(ui_AddressInput, {
    label: lang('Recipient Address'),
    value: toAddress,
    chain: chain
    // NFT transfers are available only on the TON blockchain on this moment
    ,
    addressBookChain: isNftTransfer ? 'ton' : undefined,
    currentAccountId: currentAccountId,
    accounts: accounts,
    savedAddresses: savedAddresses,
    validateAddress: checkTransferAddress,
    isStatic: isStatic,
    withQrScan: true,
    address: resolvedAddress || toAddress,
    addressName: toAddressName,
    onInput: handleAddressInput,
    onClose: cancelTransfer
  }), !isNftTransfer && /*#__PURE__*/teact.createElement(ui_AmountInput, TransferInitial_extends({}, amountInputProps, {
    maxAmount: maxAmount,
    token: transferToken,
    allTokens: tokensToSelect,
    isStatic: isStatic,
    hasError: hasAmountError,
    isMultichainAccount: isMultichainAccount,
    isMaxAmountLoading: maxAmount === undefined,
    isSensitiveDataHidden: isSensitiveDataHidden,
    renderBottomRight: renderBottomRight,
    onPressEnter: handleSubmit
  })), doesSupportComment && /*#__PURE__*/teact.createElement(transfer_CommentSection, {
    comment: comment,
    shouldEncrypt: shouldEncrypt,
    binPayload: binPayload,
    stateInit: stateInit,
    chain: chain,
    isStatic: isStatic,
    isCommentRequired: isCommentRequired,
    isEncryptedCommentSupported: isEncryptedCommentSupported,
    onCommentChange: handleCommentChange
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Transfer_module.footer, isStatic && chain !== 'ton' && Transfer_module.footer_shifted)
  }, renderFee(), /*#__PURE__*/teact.createElement("div", {
    className: Transfer_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isDisabled: shouldDisableClearButton || isLoading,
    className: Transfer_module.button,
    onClick: handleClear
  }, lang('Clear')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isSubmit: true,
    isDisabled: !canSubmit,
    isLoading: isLoading,
    className: Transfer_module.button
  }, renderButtonText()))))), /*#__PURE__*/teact.createElement(common_FeeDetailsModal, {
    isOpen: isFeeModalOpen,
    onClose: closeFeeModal,
    fullFee: (_explainedFee$fullFee3 = explainedFee.fullFee) === null || _explainedFee$fullFee3 === void 0 ? void 0 : _explainedFee$fullFee3.terms,
    realFee: (_explainedFee$realFee = explainedFee.realFee) === null || _explainedFee$realFee === void 0 ? void 0 : _explainedFee$realFee.terms,
    realFeePrecision: (_explainedFee$realFee2 = explainedFee.realFee) === null || _explainedFee$realFee2 === void 0 ? void 0 : _explainedFee$realFee2.precision,
    excessFee: explainedFee.excessFee,
    excessFeePrecision: "approximate",
    token: transferToken
  }), /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: Boolean(scamWarningType),
    isCompact: true,
    title: lang('Warning!'),
    noBackdropClose: true,
    onClose: handleScamWarningModalClose
  }, /*#__PURE__*/teact.createElement("div", null, getScamWarning(lang, renderedScamWarningType)), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.footerButtons
  }, isAllowSuspiciousActions ? /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Modal_module.button,
    onClick: handleScamWarningModalClose
  }, lang('Close')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDestructive: true,
    className: Modal_module.button,
    onClick: dismissTransferScamWarning
  }, lang('Continue'))) : /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: handleScamWarningModalClose
  }, lang('Close')))));
}
/* harmony default export */ const transfer_TransferInitial = (memo(withGlobal(global => {
  const {
    toAddress,
    resolvedAddress,
    toAddressName,
    amount,
    comment,
    shouldEncrypt,
    fee,
    realFee,
    tokenSlug,
    isLoading,
    state,
    nfts,
    binPayload,
    isMemoRequired,
    diesel,
    stateInit,
    scamWarningType
  } = global.currentTransfer;
  const isLedger = selectIsHardwareAccount(global);
  const accountState = selectCurrentAccountState(global);
  const {
    baseCurrency = src_config/* DEFAULT_PRICE_CURRENCY */.wOb,
    isSensitiveDataHidden
  } = global.settings;
  const isActive = TransferInitial_ACTIVE_STATES.has(state);
  const chain = getChainBySlug(tokenSlug);
  return {
    toAddress,
    resolvedAddress,
    toAddressName,
    amount,
    comment,
    shouldEncrypt,
    fee,
    realFee,
    nfts,
    tokenSlug,
    binPayload,
    stateInit,
    tokens: selectCurrentAccountTokens(global),
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    isEncryptedCommentSupported: !isLedger && !(nfts !== null && nfts !== void 0 && nfts.length) && !isMemoRequired,
    isMemoRequired,
    isActive,
    isLoading: isLoading && isActive,
    baseCurrency,
    currentAccountId: global.currentAccountId,
    accounts: selectNetworkAccounts(global),
    nativeTokenBalance: selectCurrentAccountTokenBalance(global, getNativeToken(chain).slug),
    diesel,
    isDieselAuthorizationStarted: accountState === null || accountState === void 0 ? void 0 : accountState.isDieselAuthorizationStarted,
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    isMultisig: selectIsMultisigAccount(global, global.currentAccountId, chain),
    isSensitiveDataHidden,
    scamWarningType,
    isAllowSuspiciousActions: selectIsAllowSuspiciousActions(global, global.currentAccountId)
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(TransferInitial)));
function useFeeModal(explainedFee) {
  var _explainedFee$realFee3;
  const isAvailable = ((_explainedFee$realFee3 = explainedFee.realFee) === null || _explainedFee$realFee3 === void 0 ? void 0 : _explainedFee$realFee3.precision) !== 'exact';
  const [isOpen, open, close] = hooks_useFlag(false);
  const openIfAvailable = isAvailable ? open : undefined;
  return [isOpen, openIfAvailable, close];
}
function isSelectableToken(token, selectedTokenSlug) {
  return token.type !== 'lp_token' || token.amount > 0 && !token.isDisabled || token.slug === selectedTokenSlug;
}
function getScamWarning(lang, scamWarning) {
  if (!scamWarning) return undefined;
  return lang(scamWarning === ScamWarningType.DomainLike ? '$domain_like_scam_warning' : '$seed_phrase_scam_warning', {
    help_center_link: /*#__PURE__*/teact.createElement("a", {
      href: getHelpCenterUrl(lang.code, scamWarning === ScamWarningType.DomainLike ? 'domainScam' : 'seedScam'),
      target: "_blank",
      rel: "noreferrer"
    }, /*#__PURE__*/teact.createElement("b", null, lang('$help_center_prepositional')))
  });
}
;// ./src/hooks/useContextMenuHandlers.ts







const LONG_TAP_DURATION_MS = 200;
const IOS_PWA_CONTEXT_MENU_DELAY_MS = 100;
const useContextMenuHandlers = _ref => {
  let {
    elementRef,
    isMenuDisabled,
    shouldDisableOnLink,
    shouldDisableOnLongTap,
    shouldDisablePropagation
  } = _ref;
  const [isContextMenuOpen, setIsContextMenuOpen] = useState(false);
  const [contextMenuAnchor, setContextMenuAnchor] = useState(undefined);
  const [contextMenuTarget, setContextMenuTarget] = useState(undefined);
  const handleBeforeContextMenu = useLastCallback(e => {
    if (!isMenuDisabled && e.button === 2) {
      (0,fasterdom/* requestMutation */.RK)(() => {
        addExtraClass(e.target, 'no-selection');
      });
    }
  });
  const handleContextMenu = useLastCallback(e => {
    (0,fasterdom/* requestMutation */.RK)(() => {
      removeExtraClass(e.target, 'no-selection');
    });
    if (isMenuDisabled || shouldDisableOnLink && e.target.matches('a[href]')) {
      return;
    }
    stopEvent(e);
    if (contextMenuAnchor) {
      return;
    }
    setIsContextMenuOpen(true);
    setContextMenuAnchor({
      x: e.clientX,
      y: e.clientY
    });
    setContextMenuTarget(e.target);
    void vibrate();
  });
  const handleContextMenuClose = useLastCallback(() => {
    setIsContextMenuOpen(false);
  });
  const handleContextMenuHide = useLastCallback(() => {
    setContextMenuAnchor(undefined);
  });
  const handleTouchMove = useLastCallback(e => {
    if (isContextMenuOpen) {
      stopEvent(e);
    }
  });

  // Support context menu on touch devices
  teact_useEffect(() => {
    if (isMenuDisabled || !windowEnvironment/* IS_TOUCH_ENV */.TF || shouldDisableOnLongTap) {
      return undefined;
    }
    const element = elementRef.current;
    if (!element) {
      return undefined;
    }
    let timer;
    const clearLongPressTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = undefined;
      }
    };
    const clearLongPressTimerAndStopEvent = origialEvent => {
      clearLongPressTimer();
      handleTouchMove(origialEvent);
    };
    const emulateContextMenuEvent = originalEvent => {
      clearLongPressTimer();
      const {
        clientX,
        clientY,
        target
      } = originalEvent.touches[0];
      if (contextMenuAnchor || shouldDisableOnLink && target.matches('a[href]')) {
        return;
      }

      // Temporarily intercept and clear the next click
      document.addEventListener('touchend', e => {
        // On iOS in PWA mode, the context menu may cause click-through to the element in the menu upon opening
        if (windowEnvironment/* IS_IOS */.pz && windowEnvironment/* IS_PWA */._7) {
          setTimeout(() => {
            document.removeEventListener('mousedown', stopEvent, {
              capture: true
            });
            document.removeEventListener('click', stopEvent, {
              capture: true
            });
          }, IOS_PWA_CONTEXT_MENU_DELAY_MS);
        }
        stopEvent(e);
      }, {
        once: true,
        capture: true
      });

      // On iOS15, in PWA mode, the context menu immediately closes after opening
      if (windowEnvironment/* IS_PWA */._7 && windowEnvironment/* IS_IOS */.pz) {
        document.addEventListener('mousedown', stopEvent, {
          once: true,
          capture: true
        });
        document.addEventListener('click', stopEvent, {
          once: true,
          capture: true
        });
      }
      setIsContextMenuOpen(true);
      setContextMenuAnchor({
        x: clientX,
        y: clientY
      });
      void vibrate();
    };
    const startLongPressTimer = e => {
      if (isMenuDisabled) {
        return;
      }
      if (shouldDisablePropagation) e.stopPropagation();
      clearLongPressTimer();
      timer = window.setTimeout(() => emulateContextMenuEvent(e), LONG_TAP_DURATION_MS);
    };

    // @perf Consider event delegation
    element.addEventListener('touchstart', startLongPressTimer, {
      passive: true
    });
    element.addEventListener('touchcancel', clearLongPressTimer, true);
    element.addEventListener('touchend', clearLongPressTimer, true);
    // `useCapture` is needed to prevent the content from scrolling behind the context menu
    element.addEventListener('touchmove', clearLongPressTimerAndStopEvent, true);
    return () => {
      clearLongPressTimer();
      element.removeEventListener('touchstart', startLongPressTimer);
      element.removeEventListener('touchcancel', clearLongPressTimer, true);
      element.removeEventListener('touchend', clearLongPressTimer, true);
      element.removeEventListener('touchmove', clearLongPressTimerAndStopEvent, true);
    };
  }, [contextMenuAnchor, isMenuDisabled, shouldDisableOnLongTap, elementRef, shouldDisableOnLink, shouldDisablePropagation]);
  return {
    isContextMenuOpen,
    contextMenuAnchor,
    contextMenuTarget,
    handleBeforeContextMenu,
    handleContextMenu,
    handleContextMenuClose,
    handleContextMenuHide
  };
};
/* harmony default export */ const hooks_useContextMenuHandlers = (useContextMenuHandlers);
;// ./src/components/ui/WithContextMenu.tsx






function WithContextMenu(_ref) {
  let {
    items,
    rootRef,
    onItemClick,
    children,
    menuClassName,
    menuPositionY = 'bottom'
  } = _ref;
  const buttonRef = teact_useRef();
  const menuRef = teact_useRef();
  const {
    isPortrait
  } = useDeviceScreen();
  const getTriggerElement = useLastCallback(() => buttonRef.current);
  const getRootElement = useLastCallback(() => (rootRef === null || rootRef === void 0 ? void 0 : rootRef.current) ?? document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true,
    doNotCoverTrigger: true,
    centerHorizontally: true
  }));
  const {
    isContextMenuOpen,
    contextMenuAnchor,
    handleBeforeContextMenu,
    handleContextMenu,
    handleContextMenuClose,
    handleContextMenuHide
  } = hooks_useContextMenuHandlers({
    elementRef: buttonRef,
    shouldDisablePropagation: true
  });
  const handleMenuItemSelect = useLastCallback(value => {
    onItemClick(value);
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, isPortrait && /*#__PURE__*/teact.createElement(ui_MenuBackdrop, {
    isMenuOpen: isContextMenuOpen,
    contentRef: buttonRef,
    contentClassName: menuClassName
  }), children({
    ref: buttonRef,
    onMouseDown: handleBeforeContextMenu,
    onContextMenu: handleContextMenu
  }, isContextMenuOpen), !!contextMenuAnchor && /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    ref: menuRef,
    withPortal: true,
    shouldTranslateOptions: true,
    isOpen: isContextMenuOpen,
    items: items,
    menuPositionY: menuPositionY,
    menuAnchor: contextMenuAnchor,
    bubbleClassName: menuClassName,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    onSelect: handleMenuItemSelect,
    onClose: handleContextMenuClose,
    onCloseAnimationEnd: handleContextMenuHide
  }));
}
;// ./src/components/main/sections/Actions/LandscapeActions.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const LandscapeActions_module = ({"container":"LandscapeActions-module__container","tabs":"LandscapeActions-module__tabs","notAllTabs":"LandscapeActions-module__notAllTabs","tab":"LandscapeActions-module__tab","active":"LandscapeActions-module__active","tab_purple":"LandscapeActions-module__tab_purple","tabPurple":"LandscapeActions-module__tab_purple","tab_purpleText":"LandscapeActions-module__tab_purpleText","tabPurpleText":"LandscapeActions-module__tab_purpleText","tabDelimiter":"LandscapeActions-module__tabDelimiter","withContextMenu":"LandscapeActions-module__withContextMenu","tabDecoration":"LandscapeActions-module__tabDecoration","tabIcon":"LandscapeActions-module__tabIcon","tabText":"LandscapeActions-module__tabText","contentHeader":"LandscapeActions-module__contentHeader","firstActive":"LandscapeActions-module__firstActive","contentHeaderInner":"LandscapeActions-module__contentHeaderInner","lastActive":"LandscapeActions-module__lastActive","contentBg":"LandscapeActions-module__contentBg","contentFooter":"LandscapeActions-module__contentFooter","contentSlideStaked":"LandscapeActions-module__contentSlideStaked","tab-0":"LandscapeActions-module__tab-0","tab0":"LandscapeActions-module__tab-0","tab-1":"LandscapeActions-module__tab-1","tab1":"LandscapeActions-module__tab-1","slideContent":"LandscapeActions-module__slideContent","transitionContent":"LandscapeActions-module__transitionContent","slideContentAddBuy":"LandscapeActions-module__slideContentAddBuy","spinner":"LandscapeActions-module__spinner","menu":"LandscapeActions-module__menu"});
;// ./src/components/main/sections/Actions/LandscapeActions.tsx
function LandscapeActions_extends() { return LandscapeActions_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, LandscapeActions_extends.apply(null, arguments); }



























const TABS = [ActiveTab.Receive, ActiveTab.Transfer, ActiveTab.Swap, ActiveTab.Stake];
const ANIMATED_STICKER_SPEED = 2;
const STAKING_TAB_TEXT_VARIANTS = {
  inactive: 'Earn',
  active: 'Earning',
  unstakeRequested: '$unstaking_short',
  readyToClaim: '$unstaking_short'
};
function LandscapeActions(_ref) {
  let {
    containerRef,
    stakingStatus,
    isLedger,
    theme,
    activeTabIndex = src_config/* DEFAULT_LANDSCAPE_ACTION_TAB_ID */.Dde,
    isTestnet,
    isSwapDisabled,
    isOnRampDisabled,
    isStakingDisabled,
    accentColorIndex
  } = _ref;
  const {
    setLandscapeActionsActiveTabIndex: setActiveTabIndex
  } = getActions();
  const lang = hooks_useLang();
  const isStaking = activeTabIndex === ActiveTab.Stake && stakingStatus !== 'inactive';
  const transferSlideClassName = `transfer_slide_${useUniqueId()}`;
  const {
    renderedBgHelpers,
    transitionRef
  } = useTabHeightAnimation(LandscapeActions_module.slideContent, transferSlideClassName, isStaking ? LandscapeActions_module.contentSlideStaked : undefined, isStaking);
  const isOnRampAllowed = !isTestnet && !isOnRampDisabled;
  const areNotAllTabs = isSwapDisabled || isStakingDisabled;
  const isLastTab = isStakingDisabled && isSwapDisabled && activeTabIndex === ActiveTab.Transfer || isStakingDisabled && !isSwapDisabled && activeTabIndex === ActiveTab.Swap || !isStakingDisabled && activeTabIndex === ActiveTab.Stake;
  const [isAddBuyAnimating, playAddBuyAnimation, stopAddBuyAnimation] = hooks_useFlag();
  const [isSendAnimating, playSendAnimation, stopSendAnimation] = hooks_useFlag();
  const [isSwapAnimating, playSwapAnimation, stopSwapAnimation] = hooks_useFlag();
  const [isStakeAnimating, playStakeAnimation, stopStakeAnimation] = hooks_useFlag();
  const appTheme = hooks_useAppTheme(theme);
  const stickerPaths = ANIMATED_STICKERS_PATHS[appTheme];
  const accentColor = accentColorIndex ? ACCENT_COLORS[appTheme][accentColorIndex] : undefined;
  const buttonTransitionKeyRef = teact_useRef(0);
  useSyncEffect(() => {
    buttonTransitionKeyRef.current++;
  }, [accentColor]);
  teact_useEffect(() => {
    if (isSwapDisabled && activeTabIndex === ActiveTab.Swap || isStakingDisabled && activeTabIndex === ActiveTab.Stake) {
      setActiveTabIndex({
        index: ActiveTab.Transfer
      });
    }
  }, [activeTabIndex, isTestnet, isLedger, isSwapDisabled, isStakingDisabled]);
  function renderCurrentTab(isActive) {
    switch (activeTabIndex) {
      case ActiveTab.Receive:
        return /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(LandscapeActions_module.slideContent, LandscapeActions_module.slideContentAddBuy)
        }, /*#__PURE__*/teact.createElement(receive_Content, {
          isOpen: isActive,
          isStatic: true
        }));
      case ActiveTab.Transfer:
        return /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(LandscapeActions_module.slideContent, LandscapeActions_module.slideContentTransfer)
        }, /*#__PURE__*/teact.createElement(transfer_TransferInitial, {
          isStatic: true,
          slideClassName: transferSlideClassName
        }));
      case ActiveTab.Swap:
        return /*#__PURE__*/teact.createElement("div", {
          className: LandscapeActions_module.slideContent
        }, /*#__PURE__*/teact.createElement(swap_SwapInitial, {
          isStatic: true,
          isActive: isActive
        }));
      case ActiveTab.Stake:
        return /*#__PURE__*/teact.createElement("div", {
          className: LandscapeActions_module.slideContent
        }, stakingStatus === 'inactive' ? /*#__PURE__*/teact.createElement(staking_StakingInitial, {
          isStatic: true,
          isActive: isActive
        }) : /*#__PURE__*/teact.createElement(staking_StakingInfoContent, {
          isStatic: true,
          isActive: isActive
        }));
      default:
        return undefined;
    }
  }
  function handleSelectTab(index, onTouchStart) {
    if (windowEnvironment/* IS_TOUCH_ENV */.TF) onTouchStart();
    setActiveTabIndex({
      index
    }, {
      forceOnHeavyAnimation: true
    });
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: LandscapeActions_module.container
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LandscapeActions_module.tabs, areNotAllTabs && LandscapeActions_module.notAllTabs)
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LandscapeActions_module.tab, activeTabIndex === ActiveTab.Receive && LandscapeActions_module.active),
    onMouseEnter: !windowEnvironment/* IS_TOUCH_ENV */.TF ? playAddBuyAnimation : undefined,
    onContextMenu: stopEvent,
    onClick: () => {
      handleSelectTab(ActiveTab.Receive, playAddBuyAnimation);
    }
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isAddBuyAnimating,
    size: src_config/* ANIMATED_STICKER_ICON_PX */.lk4,
    speed: ANIMATED_STICKER_SPEED,
    className: LandscapeActions_module.tabIcon,
    key: accentColor,
    color: accentColor,
    nonInteractive: true,
    forceOnHeavyAnimation: true,
    tgsUrl: stickerPaths.iconAdd,
    iconPreviewClass: "icon-action-add",
    onEnded: stopAddBuyAnimation
  }), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabText
  }, lang(!isSwapDisabled || isOnRampAllowed ? 'Add / Buy' : 'Add')), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabDecoration,
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(WithContextMenu, {
    items: SEND_CONTEXT_MENU_ITEMS,
    rootRef: containerRef,
    menuClassName: LandscapeActions_module.menu,
    onItemClick: handleSendMenuItemClick
  }, _ref2 => {
    let {
      ref,
      ...restButtonProps
    } = _ref2;
    return /*#__PURE__*/teact.createElement("div", LandscapeActions_extends({}, restButtonProps, {
      ref: ref,
      className: buildClassName(LandscapeActions_module.tab, activeTabIndex === ActiveTab.Transfer && LandscapeActions_module.active, LandscapeActions_module.withContextMenu),
      onMouseEnter: !windowEnvironment/* IS_TOUCH_ENV */.TF ? playSendAnimation : undefined,
      onClick: () => {
        handleSelectTab(ActiveTab.Transfer, playSendAnimation);
      }
    }), /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isSendAnimating,
      size: src_config/* ANIMATED_STICKER_ICON_PX */.lk4,
      speed: ANIMATED_STICKER_SPEED,
      className: LandscapeActions_module.tabIcon,
      key: accentColor,
      color: accentColor,
      nonInteractive: true,
      forceOnHeavyAnimation: true,
      tgsUrl: stickerPaths.iconSend,
      iconPreviewClass: "icon-action-send",
      onEnded: stopSendAnimation
    }), /*#__PURE__*/teact.createElement("span", {
      className: LandscapeActions_module.tabText
    }, lang('Send')), /*#__PURE__*/teact.createElement("span", {
      className: LandscapeActions_module.tabDecoration,
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", {
      className: LandscapeActions_module.tabDelimiter,
      "aria-hidden": true
    }));
  }), !isSwapDisabled && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LandscapeActions_module.tab, activeTabIndex === ActiveTab.Swap && LandscapeActions_module.active),
    onMouseEnter: !windowEnvironment/* IS_TOUCH_ENV */.TF ? playSwapAnimation : undefined,
    onContextMenu: stopEvent,
    onClick: () => {
      handleSelectTab(ActiveTab.Swap, playSwapAnimation);
    }
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isSwapAnimating,
    size: src_config/* ANIMATED_STICKER_ICON_PX */.lk4,
    speed: ANIMATED_STICKER_SPEED,
    className: LandscapeActions_module.tabIcon,
    key: accentColor,
    color: accentColor,
    nonInteractive: true,
    forceOnHeavyAnimation: true,
    tgsUrl: stickerPaths.iconSwap,
    iconPreviewClass: "icon-action-swap",
    onEnded: stopSwapAnimation
  }), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabText
  }, lang('Swap')), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabDecoration,
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabDelimiter,
    "aria-hidden": true
  })), !isStakingDisabled && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LandscapeActions_module.tab, activeTabIndex === ActiveTab.Stake && LandscapeActions_module.active, isStaking && LandscapeActions_module.tab_purple, stakingStatus !== 'inactive' && LandscapeActions_module.tab_purpleText),
    onMouseEnter: !windowEnvironment/* IS_TOUCH_ENV */.TF ? playStakeAnimation : undefined,
    onContextMenu: stopEvent,
    onClick: () => {
      handleSelectTab(ActiveTab.Stake, playStakeAnimation);
    }
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isStakeAnimating,
    size: src_config/* ANIMATED_STICKER_ICON_PX */.lk4,
    speed: ANIMATED_STICKER_SPEED,
    className: LandscapeActions_module.tabIcon,
    key: accentColor,
    color: accentColor,
    nonInteractive: true,
    forceOnHeavyAnimation: true,
    tgsUrl: stickerPaths[stakingStatus !== 'inactive' ? 'iconEarnPurple' : 'iconEarn'],
    iconPreviewClass: buildClassName('icon-action-earn', stakingStatus !== 'inactive' && LandscapeActions_module.tab_purpleText),
    onEnded: stopStakeAnimation
  }), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabText
  }, lang(STAKING_TAB_TEXT_VARIANTS[stakingStatus])), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabDecoration,
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", {
    className: LandscapeActions_module.tabDelimiter,
    "aria-hidden": true
  }))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LandscapeActions_module.contentHeader, activeTabIndex === ActiveTab.Receive && LandscapeActions_module.firstActive, isLastTab && LandscapeActions_module.lastActive)
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(LandscapeActions_module.contentHeaderInner, isStaking && LandscapeActions_module.contentSlideStaked)
  })), renderedBgHelpers, /*#__PURE__*/teact.createElement(ui_Transition, {
    ref: transitionRef,
    name: "slideFade",
    activeKey: activeTabIndex,
    renderCount: TABS.length,
    className: buildClassName(LandscapeActions_module.transitionContent, 'static-container')
  }, renderCurrentTab));
}
function useTabHeightAnimation(slideClassName, transferSlideClassName, contentBackgroundClassName) {
  let isUnstaking = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  const transitionRef = teact_useRef();
  const contentBgRef = teact_useRef();
  const contentFooterRef = teact_useRef();
  const lastHeightRef = teact_useRef();
  const adjustBg = useLastCallback(function () {
    var _transitionRef$curren, _transitionRef$curren2;
    let noTransition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const activeSlideSelector = `.${slideClassName}.${ACTIVE_SLIDE_CLASS_NAME}`;
    const toSlideSelector = `.${slideClassName}.${TO_SLIDE_CLASS_NAME}`;
    const suffix = isUnstaking ? ' .staking-info' : '';
    // eslint-disable-next-line @stylistic/max-len
    const transferQuery = `${activeSlideSelector} .${transferSlideClassName}.${TO_SLIDE_CLASS_NAME}, ${activeSlideSelector} .${transferSlideClassName}.${ACTIVE_SLIDE_CLASS_NAME}`;
    const query = `${toSlideSelector}${suffix}, ${activeSlideSelector}${suffix}`;
    const slide = ((_transitionRef$curren = transitionRef.current) === null || _transitionRef$curren === void 0 ? void 0 : _transitionRef$curren.querySelector(transferQuery)) || ((_transitionRef$curren2 = transitionRef.current) === null || _transitionRef$curren2 === void 0 ? void 0 : _transitionRef$curren2.querySelector(query));
    const rect = slide.getBoundingClientRect();
    const shouldRenderWithoutTransition = !lastHeightRef.current || noTransition;
    if (lastHeightRef.current === rect.height || !contentBgRef.current) return;
    (0,fasterdom/* requestMutation */.RK)(() => {
      if (!contentBgRef.current || !contentFooterRef.current) return;
      const contentBgStyle = contentBgRef.current.style;
      const contentFooterStyle = contentFooterRef.current.style;
      if (shouldRenderWithoutTransition) {
        contentBgStyle.transition = 'none';
        contentFooterStyle.transition = 'none';
      }
      contentBgStyle.transform = `scaleY(calc(${rect.height} / 100))`;
      contentFooterStyle.transform = `translateY(${Math.floor(rect.height)}px)`;
      if (shouldRenderWithoutTransition) {
        (0,fasterdom/* requestMutation */.RK)(() => {
          if (!contentBgRef.current || !contentFooterRef.current) return;
          contentBgRef.current.style.transition = '';
          contentFooterRef.current.style.transition = '';
        });
      }
      lastHeightRef.current = rect.height;
    });
  });
  teact_useEffect(() => {
    adjustBg(true);
    const componentObserver = new ResizeObserver(entries => {
      if (!entries.length) return;
      adjustBg();
    });
    if (transitionRef.current) {
      componentObserver.observe(transitionRef.current);
    }
    return () => {
      componentObserver.disconnect();
    };
  }, [adjustBg]);
  const renderedBgHelpers = teact_useMemo(() => {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      ref: contentBgRef,
      className: buildClassName(LandscapeActions_module.contentBg, contentBackgroundClassName)
    }), /*#__PURE__*/teact.createElement("div", {
      ref: contentFooterRef,
      className: buildClassName(LandscapeActions_module.contentFooter, contentBackgroundClassName)
    }));
  }, [contentBackgroundClassName]);
  return {
    renderedBgHelpers,
    transitionRef
  };
}
/* harmony default export */ const Actions_LandscapeActions = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  const accountState = accounts_selectAccountState(global, global.currentAccountId) ?? {};
  const {
    isOnRampDisabled
  } = global.restrictions;
  return {
    activeTabIndex: accountState === null || accountState === void 0 ? void 0 : accountState.landscapeActionsActiveTabIndex,
    isTestnet: global.settings.isTestnet,
    isSwapDisabled: selectIsSwapDisabled(global),
    isStakingDisabled: selectIsStakingDisabled(global),
    isOnRampDisabled,
    accentColorIndex: (_selectCurrentAccount = selectCurrentAccountSettings(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.accentColorIndex
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(LandscapeActions)));
;// ./src/components/main/sections/Actions/PortraitActions.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const PortraitActions_module = ({"container":"PortraitActions-module__container","buttons":"PortraitActions-module__buttons","button":"PortraitActions-module__button","button_purple":"PortraitActions-module__button_purple","buttonPurple":"PortraitActions-module__button_purple","buttonActive":"PortraitActions-module__buttonActive","buttonIcon":"PortraitActions-module__buttonIcon","menu":"PortraitActions-module__menu"});
;// ./src/components/main/sections/Actions/PortraitActions.tsx
function PortraitActions_extends() { return PortraitActions_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, PortraitActions_extends.apply(null, arguments); }












function PortraitActions(_ref) {
  let {
    isTestnet,
    stakingStatus,
    isStakingDisabled,
    isSwapDisabled,
    isOnRampDisabled,
    containerRef,
    onEarnClick
  } = _ref;
  const {
    startTransfer,
    startSwap,
    openReceiveModal
  } = getActions();
  const lang = hooks_useLang();
  const isOnRampAllowed = !isTestnet && !isOnRampDisabled;
  const addBuyButtonName = src_config/* IS_CORE_WALLET */.TI6 ? 'Receive' : !isSwapDisabled || isOnRampAllowed ? 'Add / Buy' : 'Add';
  const handleStartSwap = useLastCallback(() => {
    void vibrate();
    startSwap();
  });
  const handleStartTransfer = useLastCallback(() => {
    void vibrate();
    startTransfer({
      isPortrait: true
    });
  });
  const handleAddBuyClick = useLastCallback(() => {
    void vibrate();
    openReceiveModal();
  });
  const handleEarnClick = useLastCallback(() => {
    void vibrate();
    onEarnClick();
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: PortraitActions_module.container
  }, /*#__PURE__*/teact.createElement("div", {
    className: PortraitActions_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    className: PortraitActions_module.button,
    onClick: handleAddBuyClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(PortraitActions_module.buttonIcon, 'icon-action-add'),
    "aria-hidden": true
  }), lang(addBuyButtonName)), /*#__PURE__*/teact.createElement(WithContextMenu, {
    rootRef: containerRef,
    items: SEND_CONTEXT_MENU_ITEMS,
    menuClassName: PortraitActions_module.menu,
    onItemClick: handleSendMenuItemClick
  }, (buttonProps, isMenuOpen) => /*#__PURE__*/teact.createElement(ui_Button, PortraitActions_extends({}, buttonProps, {
    isSimple: true,
    className: buildClassName(PortraitActions_module.button, isMenuOpen && PortraitActions_module.buttonActive),
    onClick: handleStartTransfer,
    ref: buttonProps.ref
  }), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(PortraitActions_module.buttonIcon, 'icon-action-send'),
    "aria-hidden": true
  }), lang('Send'))), !isSwapDisabled && /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    className: PortraitActions_module.button,
    onClick: handleStartSwap
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(PortraitActions_module.buttonIcon, 'icon-action-swap'),
    "aria-hidden": true
  }), lang('Swap')), !isStakingDisabled && /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    className: buildClassName(PortraitActions_module.button, stakingStatus !== 'inactive' && PortraitActions_module.button_purple),
    onClick: handleEarnClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(PortraitActions_module.buttonIcon, 'icon-action-earn'),
    "aria-hidden": true
  }), lang(STAKING_TAB_TEXT_VARIANTS[stakingStatus]))));
}
/* harmony default export */ const Actions_PortraitActions = (memo(PortraitActions));
;// ./src/components/main/sections/Actions/index.ts


;// ./src/util/calcChangeValue.ts

function calcChangeValue(currentPrice, changeFactor) {
  return currentPrice - currentPrice / (1 + changeFactor);
}
function calcBigChangeValue(currentPrice, changeFactor) {
  currentPrice = (0,big_js/* Big */.z)(currentPrice);
  changeFactor = (0,big_js/* Big */.z)(changeFactor);
  return currentPrice.minus(currentPrice.div(changeFactor.plus(1)));
}
;// ./src/components/main/sections/Card/helpers/calculateFullBalance.ts








function calculateFullBalance(tokens, stakingStates) {
  const stakingStateBySlug = (0,iteratees/* buildCollectionByKey */.dU)(stakingStates ?? [], 'tokenSlug');
  const primaryValue = tokens.reduce((acc, token) => {
    if (src_config/* STAKED_TOKEN_SLUGS */.Svl.has(token.slug)) {
      // Cost of staked tokens is already taken into account
      return acc;
    }
    const stakingState = stakingStateBySlug[token.slug];
    if (stakingState) {
      const stakingAmount = (0,util_decimals/* toBig */.CF)(getFullStakingBalance(stakingState), token.decimals);
      acc = acc.plus(stakingAmount.mul(token.price));
    }
    return acc.plus(token.totalValue);
  }, (0,big_js/* Big */.z)(0));
  const [primaryWholePart, primaryFractionPart] = formatNumber(primaryValue).split('.');
  const changeValue = tokens.reduce((acc, token) => {
    return acc.plus(calcBigChangeValue(token.totalValue, token.change24h));
  }, (0,big_js/* Big */.z)(0)).round(4).toNumber();
  const changePercent = math_round(primaryValue ? changeValue / (primaryValue.toNumber() - changeValue) * 100 : 0, 2);
  const changePrefix = changeValue > 0 ? 'up' : changeValue < 0 ? 'down' : undefined;
  return {
    primaryValue: primaryValue.toString(),
    primaryWholePart,
    primaryFractionPart,
    changePrefix,
    changePercent,
    changeValue
  };
}
;// ./src/components/main/sections/Card/helpers/getSensitiveDataMaskSkinFromCardNft.ts
function getSensitiveDataMaskSkinFromCardNft(cardNft) {
  const {
    mtwCardType,
    mtwCardTextType
  } = (cardNft === null || cardNft === void 0 ? void 0 : cardNft.metadata) || {};
  return mtwCardType === 'gold' ? 'cardGoldText' : mtwCardType === 'silver' || mtwCardTextType === 'dark' ? 'cardDarkText' : 'cardLightText';
}
;// ./src/hooks/useUpdateIndicator.ts




const ONE_SECOND = 1000;
const SHOW_INDICATOR_DELAY_MS = 2 * ONE_SECOND;
function useUpdateIndicator(updateStartedAtKey) {
  const [isUpdating, setIsUpdating] = useState(false);
  hooks_useInterval(() => {
    var _selectCurrentAccount;
    const updateStartedAt = (_selectCurrentAccount = selectCurrentAccountState(getGlobal())) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount[updateStartedAtKey];
    if (!updateStartedAt) {
      setIsUpdating(false);
      return;
    }
    const timeElapsedSinceLastUpdateStarted = Date.now() - updateStartedAt;
    setIsUpdating(timeElapsedSinceLastUpdateStarted > SHOW_INDICATOR_DELAY_MS);
  }, ONE_SECOND, false);
  return isUpdating;
}
;// ./src/components/ui/ClockIcon.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ClockIcon_module = ({"icon":"ClockIcon-module__icon"});
;// ./src/components/ui/ClockIcon.tsx



function ClockIcon(_ref) {
  let {
    className,
    noAnimation
  } = _ref;
  const svgMaskId = useUniqueId('transparentMask-');
  return /*#__PURE__*/teact.createElement("svg", {
    width: "1em",
    height: "1em",
    viewBox: "0 0 32 32",
    xmlns: "http://www.w3.org/2000/svg",
    className: className
  }, /*#__PURE__*/teact.createElement("mask", {
    id: svgMaskId
  }, /*#__PURE__*/teact.createElement("rect", {
    width: "32",
    height: "32",
    fill: "black"
  }), /*#__PURE__*/teact.createElement("circle", {
    cx: "16",
    cy: "16",
    r: "16",
    fill: "white"
  }), /*#__PURE__*/teact.createElement("path", {
    d: "M17.375 8.87438C17.375 8.11563 16.7594 7.5 16 7.5C15.2406 7.5 14.625 8.11563 14.625 8.87438V16.0006C14.625 16.76 15.2406 17.375 16 17.375C16.7594 17.375 17.375 16.76 17.375 16.0006V8.87438Z",
    fill: "black"
  }, !noAnimation && /*#__PURE__*/teact.createElement("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    from: "0 16 16",
    to: "360 16 16",
    dur: "2s",
    repeatCount: "indefinite"
  })), /*#__PURE__*/teact.createElement("path", {
    d: "M17.375 11.985C17.375 11.2337 16.7594 10.625 16 10.625C15.2406 10.625 14.625 11.2337 14.625 11.985V16.015C14.625 16.7662 15.2406 17.375 16 17.375C16.7594 17.375 17.375 16.7662 17.375 16.015V11.985Z",
    fill: "black"
  }, !noAnimation && /*#__PURE__*/teact.createElement("animateTransform", {
    attributeName: "transform",
    type: "rotate",
    from: "0 16 16",
    to: "360 16 16",
    dur: "12s",
    repeatCount: "indefinite"
  }))), /*#__PURE__*/teact.createElement("rect", {
    className: ClockIcon_module.icon,
    width: "32",
    height: "32",
    mask: `url(#${svgMaskId})`
  }));
}
/* harmony default export */ const ui_ClockIcon = (memo(ClockIcon));
;// ./src/components/mintCard/MintCardButton.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const MintCardButton_module = ({"button":"MintCardButton-module__button","icon":"MintCardButton-module__icon"});
;// ./src/components/mintCard/MintCardButton.tsx








function MintCardButton(_ref) {
  let {
    isCardMinting,
    hasCardsInfo,
    noAnimation
  } = _ref;
  const {
    openMintCardModal
  } = getActions();
  const lang = hooks_useLang();
  const {
    shouldRender: shouldRenderMintCardsButton,
    ref: mintCardsButtonRef
  } = useShowTransition({
    isOpen: hasCardsInfo || isCardMinting,
    withShouldRender: true
  });
  if (!shouldRenderMintCardsButton) return undefined;
  return /*#__PURE__*/teact.createElement("button", {
    ref: mintCardsButtonRef,
    type: "button",
    className: MintCardButton_module.button,
    "aria-label": lang('Mint Cards'),
    title: lang('Mint Cards'),
    onClick: () => openMintCardModal()
  }, /*#__PURE__*/teact.createElement("i", {
    className: isCardMinting ? 'icon-magic-wand-loading' : 'icon-magic-wand',
    "aria-hidden": true
  }), isCardMinting && /*#__PURE__*/teact.createElement(ui_ClockIcon, {
    className: MintCardButton_module.icon,
    noAnimation: noAnimation
  }));
}
/* harmony default export */ const mintCard_MintCardButton = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  const {
    config
  } = selectCurrentAccountState(global) || {};
  const animationLevel = global.settings.animationLevel;
  return {
    hasCardsInfo: Boolean(config === null || config === void 0 ? void 0 : config.cardsInfo),
    isCardMinting: accountState === null || accountState === void 0 ? void 0 : accountState.isCardMinting,
    noAnimation: animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp
  };
})(MintCardButton)));
;// ./src/components/ui/AnimatedCounter.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AnimatedCounter_module = ({"root":"AnimatedCounter-module__root","character-container":"AnimatedCounter-module__character-container","characterContainer":"AnimatedCounter-module__character-container","character":"AnimatedCounter-module__character","character-old":"AnimatedCounter-module__character-old","characterOld":"AnimatedCounter-module__character-old","character-disappear":"AnimatedCounter-module__character-disappear","characterDisappear":"AnimatedCounter-module__character-disappear","character-new":"AnimatedCounter-module__character-new","characterNew":"AnimatedCounter-module__character-new","character-appear":"AnimatedCounter-module__character-appear","characterAppear":"AnimatedCounter-module__character-appear"});
;// ./src/components/ui/AnimatedCounter.tsx









const ANIMATION_TIME = 200;
const MAX_SIMULTANEOUS_ANIMATIONS = 10;
let scheduledAnimationsCounter = 0;
const resetCounterOnTickEnd = (0,schedulers/* throttleWithTickEnd */.Fe)(() => {
  scheduledAnimationsCounter = 0;
});
const AnimatedCounter = _ref => {
  let {
    text,
    isDisabled
  } = _ref;
  const animationLevel = getGlobal().settings.animationLevel;
  const {
    isRtl
  } = hooks_useLang();
  const prevText = hooks_usePrevious(text);
  const forceUpdate = hooks_useForceUpdate();
  const shouldAnimate = scheduleAnimation(!isDisabled && animationLevel === src_config/* ANIMATION_LEVEL_MAX */.zP3 && prevText !== undefined && prevText !== text);
  const characters = teact_useMemo(() => {
    return shouldAnimate ? renderAnimatedCharacters(text, prevText) : text;
  }, [shouldAnimate, prevText, text]);
  teact_useEffect(() => {
    if (!shouldAnimate) return undefined;
    const timeoutId = window.setTimeout(() => {
      forceUpdate();
    }, ANIMATION_TIME);
    return () => {
      window.clearTimeout(timeoutId);
    };
  }, [shouldAnimate, text]);
  return /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(!isDisabled && AnimatedCounter_module.root),
    dir: isRtl ? 'rtl' : undefined
  }, characters);
};
/* harmony default export */ const ui_AnimatedCounter = (memo(AnimatedCounter));
function scheduleAnimation(condition) {
  if (!condition || scheduledAnimationsCounter >= MAX_SIMULTANEOUS_ANIMATIONS) return false;
  if (scheduledAnimationsCounter === 0) {
    resetCounterOnTickEnd();
  }
  scheduledAnimationsCounter++;
  return true;
}
function renderAnimatedCharacters(text, prevText) {
  const elements = [];
  const textLength = text.length;
  const prevTextLength = (prevText === null || prevText === void 0 ? void 0 : prevText.length) ?? 0;
  for (let i = 0; i <= textLength; i++) {
    const charIndex = textLength - i;
    const prevTextCharIndex = prevTextLength - i;
    if (prevText && prevTextCharIndex >= 0 && text[charIndex] !== prevText[prevTextCharIndex]) {
      elements.unshift(/*#__PURE__*/teact.createElement("div", {
        className: AnimatedCounter_module.characterContainer
      }, /*#__PURE__*/teact.createElement("div", {
        className: AnimatedCounter_module.character
      }, text[charIndex] ?? ''), /*#__PURE__*/teact.createElement("div", {
        className: AnimatedCounter_module.characterOld
      }, prevText[prevTextCharIndex]), /*#__PURE__*/teact.createElement("div", {
        className: AnimatedCounter_module.characterNew
      }, text[charIndex] ?? '')));
    } else {
      elements.unshift(/*#__PURE__*/teact.createElement("span", null, text[charIndex] ?? ''));
    }
  }
  return elements;
}
;// ./src/components/main/sections/Card/Card.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Card_module = ({"containerWrapper":"Card-module__containerWrapper","isLoading":"Card-module__isLoading","center":"Card-module__center","container":"Card-module__container","backstage":"Card-module__backstage","tokenCard":"Card-module__tokenCard","containerInner":"Card-module__containerInner","balanceSlide":"Card-module__balanceSlide","balanceTransition":"Card-module__balanceTransition","currencySymbol":"Card-module__currencySymbol","primaryValue":"Card-module__primaryValue","primaryFractionPart":"Card-module__primaryFractionPart","iconCaret":"Card-module__iconCaret","iconCaretSmall":"Card-module__iconCaretSmall","iconCaretFraction":"Card-module__iconCaretFraction","currencySwitcher":"Card-module__currencySwitcher","currencySwitcherMenu":"Card-module__currencySwitcherMenu","addressContainer":"Card-module__addressContainer","addressLabel":"Card-module__addressLabel","icon":"Card-module__icon","address":"Card-module__address","menuItem":"Card-module__menuItem","menuIcon":"Card-module__menuIcon","menuItemName":"Card-module__menuItemName","menuFontIcon":"Card-module__menuFontIcon","menuExplorerIcon":"Card-module__menuExplorerIcon","addressMenuBubble":"Card-module__addressMenuBubble","domainText":"Card-module__domainText","addressText":"Card-module__addressText","separator":"Card-module__separator","explorerButton":"Card-module__explorerButton","changeSpoiler":"Card-module__changeSpoiler","blurred":"Card-module__blurred","change":"Card-module__change","changePrefix":"Card-module__changePrefix","chainIcon":"Card-module__chainIcon","multichainIcon":"Card-module__multichainIcon","tokenInfo":"Card-module__tokenInfo","tokenLogo":"Card-module__tokenLogo","tokenInfoHeader":"Card-module__tokenInfoHeader","tokenInfoSubheader":"Card-module__tokenInfoSubheader","tokenAmount":"Card-module__tokenAmount","tokenName":"Card-module__tokenName","tokenValue":"Card-module__tokenValue","tokenChange":"Card-module__tokenChange","tokenChangeSensitiveData":"Card-module__tokenChangeSensitiveData","tokenChangeSpoiler":"Card-module__tokenChangeSpoiler","tokenTitle":"Card-module__tokenTitle","tokenHistoryPrice":"Card-module__tokenHistoryPrice","tokenCurrentPrice":"Card-module__tokenCurrentPrice","tokenPriceDate":"Card-module__tokenPriceDate","apy":"Card-module__apy","interactive":"Card-module__interactive","tokenExplorerButton":"Card-module__tokenExplorerButton","chart":"Card-module__chart","chartImg":"Card-module__chartImg","backButton":"Card-module__backButton","periodChooser":"Card-module__periodChooser","periodChooserHidden":"Card-module__periodChooserHidden","periodItem":"Card-module__periodItem","periodItem_active":"Card-module__periodItem_active","periodItemActive":"Card-module__periodItem_active","periodInput":"Card-module__periodInput","loadingDotsContainer":"Card-module__loadingDotsContainer","cardCustomBackground":"Card-module__cardCustomBackground","visible":"Card-module__visible","black":"Card-module__black","platinum":"Card-module__platinum","gold":"Card-module__gold","silver":"Card-module__silver","borderShine_down":"Card-module__borderShine_down","borderShineDown":"Card-module__borderShine_down","borderShine_left":"Card-module__borderShine_left","borderShineLeft":"Card-module__borderShine_left","borderShine_up":"Card-module__borderShine_up","borderShineUp":"Card-module__borderShine_up","borderShine_right":"Card-module__borderShine_right","borderShineRight":"Card-module__borderShine_right"});
;// ./src/assets/multichain_account.svg
const multichain_account_namespaceObject = __webpack_require__.p + "multichain_account.18e8f6e7ee28b26527ba.svg";
;// ./src/components/main/sections/Card/CardAddress.tsx

















const MOUSE_LEAVE_TIMEOUT = 150;
function CardAddress(_ref) {
  let {
    addressByChain,
    domainByChain,
    isTestnet,
    accountType,
    withTextGradient
  } = _ref;
  const {
    showNotification
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const ref = teact_useRef();
  const menuRef = teact_useRef();
  const [menuAnchor, setMenuAnchor] = useState();
  const isMenuOpen = Boolean(menuAnchor);
  const chains = teact_useMemo(() => Object.keys(addressByChain || {}), [addressByChain]);
  const isHardwareAccount = accountType === 'hardware';
  const isViewAccount = accountType === 'view';
  const explorerTitle = lang('View on Explorer');
  const chainDropdownItems = teact_useMemo(() => {
    const hasDomain = chains[0] && (domainByChain === null || domainByChain === void 0 ? void 0 : domainByChain[chains[0]]);
    if (chains.length < 2 && !hasDomain) return undefined;
    return chains.map(chain => ({
      value: addressByChain[chain],
      address: (0,shortenAddress/* shortenAddress */.W)(addressByChain[chain], domainByChain !== null && domainByChain !== void 0 && domainByChain[chain] ? 4 : undefined),
      ...((domainByChain === null || domainByChain === void 0 ? void 0 : domainByChain[chain]) && {
        domain: domainByChain[chain]
      }),
      icon: getChainNetworkIcon(chain),
      fontIcon: 'copy',
      chain,
      label: lang('View address on %ton_explorer_name%', {
        ton_explorer_name: getExplorerName(chain)
      }).join('')
    }));
  }, [addressByChain, domainByChain, chains, lang]);
  const openMenu = () => {
    const {
      left,
      width,
      bottom: y
    } = ref.current.getBoundingClientRect();
    setMenuAnchor({
      x: left + width / 2,
      y
    });
  };
  const closeMenu = () => {
    setMenuAnchor(undefined);
  };
  const handleCopyAddress = useLastCallback(address => {
    showNotification({
      message: lang('Address was copied!'),
      icon: 'icon-copy'
    });
    void copyTextToClipboard(address);
  });
  const handleItemClick = useLastCallback((e, address) => {
    handleCopyAddress(address);
    closeMenu();
  });
  const handleDomainClick = useLastCallback((e, domain) => {
    showNotification({
      message: lang('Domain was copied!'),
      icon: 'icon-copy'
    });
    void copyTextToClipboard(domain);
    closeMenu();
  });
  const handleExplorerClick = useLastCallback((e, chain, address) => {
    void openUrl(getExplorerAddressUrl(chain, address, isTestnet));
    closeMenu();
  });
  const closeTimeoutRef = teact_useRef();
  const handleMouseEnter = useLastCallback(() => {
    if (closeTimeoutRef.current) {
      clearTimeout(closeTimeoutRef.current);
    }
    openMenu();
  });
  const handleMouseLeave = useLastCallback(() => {
    closeTimeoutRef.current = window.setTimeout(closeMenu, MOUSE_LEAVE_TIMEOUT);
  });
  const getTriggerElement = useLastCallback(() => ref.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true,
    centerHorizontally: isPortrait,
    preferredPositionX: 'left',
    doNotCoverTrigger: isPortrait
  }));
  function renderAddressMenu() {
    return /*#__PURE__*/teact.createElement(ui_Menu, {
      menuRef: menuRef,
      isOpen: isMenuOpen,
      type: "dropdown",
      withPortal: true,
      getTriggerElement: getTriggerElement,
      getRootElement: getRootElement,
      getMenuElement: getMenuElement,
      getLayout: getLayout,
      anchor: menuAnchor,
      bubbleClassName: Card_module.addressMenuBubble,
      noBackdrop: !windowEnvironment/* IS_TOUCH_ENV */.TF,
      onMouseEnter: !windowEnvironment/* IS_TOUCH_ENV */.TF ? handleMouseEnter : undefined,
      onMouseLeave: !windowEnvironment/* IS_TOUCH_ENV */.TF ? handleMouseLeave : undefined,
      onClose: closeMenu
    }, chainDropdownItems.map((item, index) => {
      const fullItemClassName = buildClassName(Dropdown_module.item, index > 0 && Dropdown_module.separator, Card_module.menuItem);
      return /*#__PURE__*/teact.createElement("div", {
        key: item.value,
        className: fullItemClassName
      }, chainDropdownItems.length > 1 && /*#__PURE__*/teact.createElement("img", {
        src: item.icon,
        alt: "",
        className: buildClassName('icon', Dropdown_module.itemIcon, Card_module.menuIcon)
      }), /*#__PURE__*/teact.createElement("span", {
        className: buildClassName(Dropdown_module.itemName, Card_module.menuItemName)
      }, item.domain && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
        tabIndex: 0,
        role: "button",
        className: Card_module.domainText,
        onClick: e => handleDomainClick(e, item.domain)
      }, item.domain), /*#__PURE__*/teact.createElement("span", {
        className: Card_module.separator
      }, "\xB7")), /*#__PURE__*/teact.createElement("span", {
        tabIndex: 0,
        role: "button",
        onClick: e => handleItemClick(e, item.value),
        className: item.domain && Card_module.addressText
      }, item.address), /*#__PURE__*/teact.createElement("i", {
        className: buildClassName(`icon icon-${item.fontIcon}`, Dropdown_module.fontIcon, Card_module.menuFontIcon),
        "aria-hidden": true,
        onClick: e => handleItemClick(e, item.value)
      })), /*#__PURE__*/teact.createElement("i", {
        tabIndex: 0,
        role: "button",
        className: buildClassName(Dropdown_module.close, 'icon icon-tonexplorer-small', Card_module.menuExplorerIcon),
        "aria-label": item.label,
        onClick: e => handleExplorerClick(e, item.chain, item.value)
      }));
    }));
  }
  if (chainDropdownItems) {
    const chain = chains[0];
    const domain = domainByChain === null || domainByChain === void 0 ? void 0 : domainByChain[chain];
    const buttonText = chains.length === 1 && domain ? domain : lang('Multichain');
    return /*#__PURE__*/teact.createElement("div", {
      ref: ref,
      className: Card_module.addressContainer
    }, isViewAccount && /*#__PURE__*/teact.createElement("span", {
      className: Card_module.addressLabel
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Card_module.icon, 'icon-eye-filled'),
      "aria-hidden": true
    }), lang('$view_mode')), isHardwareAccount && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Card_module.icon, 'icon-ledger'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("button", {
      type: "button",
      className: buildClassName(Card_module.address, withTextGradient && 'gradientText'),
      onMouseEnter: !windowEnvironment/* IS_TOUCH_ENV */.TF ? handleMouseEnter : undefined,
      onMouseLeave: !windowEnvironment/* IS_TOUCH_ENV */.TF ? handleMouseLeave : undefined,
      onClick: openMenu
    }, chains.length > 1 ? /*#__PURE__*/teact.createElement("img", {
      src: multichain_account_namespaceObject,
      alt: "",
      className: Card_module.multichainIcon
    }) : /*#__PURE__*/teact.createElement("img", {
      src: getChainNetworkIcon(chain),
      alt: "",
      className: Card_module.chainIcon
    }), /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Card_module.itemName, 'itemName')
    }, buttonText), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Card_module.iconCaretSmall, 'icon-caret-down'),
      "aria-hidden": true
    })), renderAddressMenu());
  }
  const chain = chains[0];
  if (!chain) return undefined;
  const address = addressByChain[chain];
  const domain = domainByChain === null || domainByChain === void 0 ? void 0 : domainByChain[chain];
  const displayText = domain || (0,shortenAddress/* shortenAddress */.W)(address);
  return /*#__PURE__*/teact.createElement("div", {
    className: Card_module.addressContainer
  }, isViewAccount && /*#__PURE__*/teact.createElement("span", {
    className: Card_module.addressLabel
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Card_module.icon, 'icon-eye-filled'),
    "aria-hidden": true
  }), lang('$view_mode')), isHardwareAccount && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Card_module.icon, 'icon-ledger'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: buildClassName(Card_module.address, withTextGradient && 'gradientText'),
    "aria-label": lang('Copy wallet address'),
    onClick: () => handleCopyAddress(address)
  }, /*#__PURE__*/teact.createElement("img", {
    src: getChainNetworkIcon(chain),
    alt: "",
    className: Card_module.chainIcon
  }), displayText, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Card_module.icon, 'icon-copy'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("a", {
    href: getExplorerAddressUrl(chain, address, isTestnet),
    className: Card_module.explorerButton,
    title: explorerTitle,
    "aria-label": explorerTitle,
    target: "_blank",
    rel: "noreferrer noopener",
    onClick: handleUrlClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Card_module.icon, 'icon-tonexplorer-small'),
    "aria-hidden": true
  })));
}
/* harmony default export */ const Card_CardAddress = (memo(withGlobal(global => {
  const {
    type: accountType,
    addressByChain,
    domainByChain
  } = selectAccount(global, global.currentAccountId) || {};
  return {
    addressByChain,
    domainByChain,
    isTestnet: global.settings.isTestnet,
    accountType
  };
})(CardAddress)));
;// ./src/components/main/sections/Card/CurrencySwitcherMenu.tsx





function CurrencySwitcherMenu(_ref) {
  let {
    isOpen,
    triggerRef,
    anchor,
    currentCurrency,
    excludedCurrency,
    menuPositionX,
    className,
    onClose,
    onChange
  } = _ref;
  const {
    changeBaseCurrency
  } = getActions();
  const menuRef = teact_useRef();
  const currencyList = teact_useMemo(() => Object.entries(src_config/* CURRENCIES */.yR2).filter(_ref2 => {
    let [currency] = _ref2;
    return currency !== excludedCurrency;
  }).map(_ref3 => {
    let [currency, {
      name
    }] = _ref3;
    return {
      value: currency,
      name
    };
  }), [excludedCurrency]);
  const handleBaseCurrencyChange = useLastCallback(currency => {
    onClose();
    if (currency === currentCurrency) return;
    changeBaseCurrency({
      currency: currency
    });
    onChange === null || onChange === void 0 || onChange(currency);
  });
  const getTriggerElement = useLastCallback(() => triggerRef.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true,
    centerHorizontally: !menuPositionX,
    preferredPositionX: menuPositionX || 'left',
    doNotCoverTrigger: true
  }));
  return /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    withPortal: true,
    ref: menuRef,
    isOpen: isOpen,
    items: currencyList,
    shouldTranslateOptions: true,
    selectedValue: currentCurrency,
    menuPositionX: menuPositionX,
    menuAnchor: anchor,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    className: className,
    onClose: onClose,
    onSelect: handleBaseCurrencyChange
  });
}
/* harmony default export */ const Card_CurrencySwitcherMenu = (memo(withGlobal(global => {
  return {
    currentCurrency: global.settings.baseCurrency
  };
})(CurrencySwitcherMenu)));
;// ./src/components/main/sections/Card/CustomCardBackground.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const CustomCardBackground_module = ({"root":"CustomCardBackground-module__root","sticky":"CustomCardBackground-module__sticky","image":"CustomCardBackground-module__image","borderShine_down":"CustomCardBackground-module__borderShine_down","borderShineDown":"CustomCardBackground-module__borderShine_down","borderShine_left":"CustomCardBackground-module__borderShine_left","borderShineLeft":"CustomCardBackground-module__borderShine_left","borderShine_up":"CustomCardBackground-module__borderShine_up","borderShineUp":"CustomCardBackground-module__borderShine_up","borderShine_right":"CustomCardBackground-module__borderShine_right","borderShineRight":"CustomCardBackground-module__borderShine_right","borderShine_radioactive":"CustomCardBackground-module__borderShine_radioactive","borderShineRadioactive":"CustomCardBackground-module__borderShine_radioactive","shadow":"CustomCardBackground-module__shadow"});
;// ./src/components/main/sections/Card/CustomCardBackground.tsx








function CustomCardBackground(_ref) {
  var _nft$metadata;
  let {
    isSticky,
    nft,
    noShowAnimation,
    shouldHide,
    onLoad,
    onTransitionEnd
  } = _ref;
  const {
    imageUrl
  } = useCachedImage(nft ? getCardNftImageUrl(nft) : undefined);
  const [isLoaded, markLoaded] = hooks_useFlag();
  const ref = useMediaTransition(noShowAnimation || isLoaded && !shouldHide);
  const {
    borderShineType,
    withTextGradient,
    classNames: cardClassName
  } = useCardCustomization(nft);
  function handleLoad() {
    markLoaded();
    onLoad === null || onLoad === void 0 || onLoad(withTextGradient, cardClassName);
  }
  const rootClassName = buildClassName(CustomCardBackground_module.root, isSticky && CustomCardBackground_module.sticky, cardClassName, borderShineType && CustomCardBackground_module[`borderShine_${borderShineType}`], isLoaded && !shouldHide && CustomCardBackground_module.loaded, shouldHide && CustomCardBackground_module.hide);
  const withShadow = ((_nft$metadata = nft.metadata) === null || _nft$metadata === void 0 ? void 0 : _nft$metadata.mtwCardType) === 'standard';
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: rootClassName,
    onTransitionEnd: onTransitionEnd
  }, imageUrl && /*#__PURE__*/teact.createElement("img", {
    src: imageUrl,
    alt: nft.name,
    className: CustomCardBackground_module.image,
    onLoad: handleLoad
  }), withShadow && /*#__PURE__*/teact.createElement("div", {
    className: CustomCardBackground_module.shadow
  }));
}
/* harmony default export */ const Card_CustomCardBackground = (memo(CustomCardBackground));
;// ./src/components/main/sections/Card/CustomCardManager.tsx





function CustomCardManager(_ref) {
  let {
    isSticky,
    nft,
    onCardChange
  } = _ref;
  const prevNftRef = teact_useRef(undefined);
  const forceUpdate = hooks_useForceUpdate();
  useSyncEffectWithPrevDeps(_ref2 => {
    let [prevNft, prevNftAddress] = _ref2;
    if ((nft === null || nft === void 0 ? void 0 : nft.address) !== prevNftAddress) {
      prevNftRef.current = prevNft;
    }
    if (!nft) {
      onCardChange(false, undefined);
    }
  }, [nft, nft === null || nft === void 0 ? void 0 : nft.address]);
  const prevNft = prevNftRef.current;
  const isMountRef = teact_useRef(true);
  const noShowAnimation = nft && isMountRef.current;
  isMountRef.current = false;
  const handleTransitionEnd = useLastCallback(() => {
    prevNftRef.current = undefined;
    forceUpdate();
  });
  return /*#__PURE__*/teact.createElement("div", {
    teactFastList: true
  }, prevNft && /*#__PURE__*/teact.createElement(Card_CustomCardBackground, {
    key: prevNft.address,
    isSticky: isSticky,
    nft: prevNft,
    shouldHide: !nft,
    onTransitionEnd: handleTransitionEnd
  }), nft && /*#__PURE__*/teact.createElement(Card_CustomCardBackground, {
    key: nft.address,
    isSticky: isSticky,
    nft: nft,
    noShowAnimation: noShowAnimation,
    onLoad: onCardChange,
    onTransitionEnd: handleTransitionEnd
  }));
}
/* harmony default export */ const Card_CustomCardManager = (memo(CustomCardManager));
;// ./src/components/main/helpers/cardColors.ts


const TOKEN_CARD_COLORS = {
  green: [80, 135, 51],
  orange: [173, 84, 54],
  pink: [154, 60, 144],
  purple: [104, 48, 149],
  red: [156, 52, 75],
  sea: [43, 116, 123],
  tegro: [3, 93, 229],
  blue: [47, 108, 173]
};
const TOKEN_EXCEPTION_COLORS = {
  [src_config/* TONCOIN */.Tu9.slug]: 'blue',
  [src_config/* TRX */.X7T.slug]: 'red',
  [src_config/* TON_USDT_SLUG */.rUK]: 'sea',
  [src_config/* TRC20_USDT_MAINNET_SLUG */.QSz]: 'sea',
  [src_config/* TRC20_USDT_TESTNET_SLUG */.vsz]: 'sea',
  [src_config/* STAKED_TON_SLUG */.Bqy]: 'green'
};
const DISTANCE_THRESHOLD = 35;
function calculateTokenCardColor(token) {
  let closestColor = 'blue';
  let smallestDistance = Infinity;
  if (!token) return closestColor;
  if (TOKEN_EXCEPTION_COLORS[token.slug]) {
    return TOKEN_EXCEPTION_COLORS[token.slug];
  }
  if (!token.color) return closestColor;
  const tokenRgbColor = hex2rgb(token.color);
  Object.entries(TOKEN_CARD_COLORS).forEach(_ref => {
    let [colorName, colorValue] = _ref;
    const distance = deltaE(tokenRgbColor, colorValue);
    if (distance < smallestDistance) {
      smallestDistance = distance;
      closestColor = colorName;
    }
  });
  if (smallestDistance > DISTANCE_THRESHOLD) {
    return 'blue';
  }
  return closestColor;
}
;// ./src/components/common/TokenPriceChart.tsx





const IS_SMOOTH = true;
const PATH_SMOOTHING = 0.0001;
const MIN_CHART_HEIGHT = 0.000000001;
function TokenPriceChart(_ref) {
  let {
    width,
    height,
    prices,
    selectedIndex,
    className,
    imgClassName,
    onSelectIndex,
    isUpdating
  } = _ref;
  const lang = hooks_useLang();
  const boundingPoints = teact_useMemo(() => {
    const priceValues = prices.map(_ref2 => {
      let [, price] = _ref2;
      return price;
    });
    const min = Math.min(...priceValues);
    const max = Math.max(...priceValues);
    return {
      width: prices.length - 1,
      height: Math.max(MIN_CHART_HEIGHT, max - min),
      min
    };
  }, [prices]);
  const points = teact_useMemo(() => {
    const scaleX = width / boundingPoints.width;
    const scaleY = height / boundingPoints.height;
    return prices.map((_ref3, i) => {
      let [, y] = _ref3;
      return {
        x: i * scaleX + 3,
        y: (y - boundingPoints.min) * scaleY + 3
      };
    });
  }, [boundingPoints.height, boundingPoints.min, boundingPoints.width, height, width, prices]);
  function getBasisPoint(i) {
    const indexesCount = points.length - 1;
    const index = i < 0 ? 0 : i > indexesCount ? indexesCount : i;
    const point = points[index];
    const ratio = 1 - PATH_SMOOTHING;
    const tangent = index / indexesCount;
    const firstPoint = points[0];
    const distance = {
      x: points[indexesCount].x - firstPoint.x,
      y: points[indexesCount].y - firstPoint.y
    };
    return {
      x: ratio * point.x + (1 - ratio) * (firstPoint.x + tangent * distance.x),
      y: ratio * point.y + (1 - ratio) * (firstPoint.y + tangent * distance.y)
    };
  }
  function getCurvePath(i) {
    const pCurrent = getBasisPoint(i);
    const pMinus1 = getBasisPoint(i - 1);
    const pMinus2 = getBasisPoint(i - 2);
    const x1 = (2 * pMinus2.x + pMinus1.x) / 3;
    const y1 = (2 * pMinus2.y + pMinus1.y) / 3;
    const x2 = (pMinus2.x + 2 * pMinus1.x) / 3;
    const y2 = (pMinus2.y + 2 * pMinus1.y) / 3;
    const x3 = (pMinus2.x + 4 * pMinus1.x + pCurrent.x) / 6;
    const y3 = (pMinus2.y + 4 * pMinus1.y + pCurrent.y) / 6;
    return `C ${x1} ${y1} ${x2} ${y2} ${x3} ${y3}`;
  }
  function getLinePath(point) {
    return `L ${point.x} ${point.y}`;
  }
  function getPath() {
    let d = points.reduce((acc, point, i) => {
      const partialPath = IS_SMOOTH ? getCurvePath(i) : getLinePath(point);
      return i === 0 ? `M ${point.x} ${point.y} ` : `${acc} ${partialPath} `;
    }, '');
    if (IS_SMOOTH) {
      d += getCurvePath(points.length);
      d += getLinePath(points[points.length - 1]);
    }
    return d;
  }
  function renderSvg() {
    const activePoint = points[selectedIndex] || points[points.length - 1];
    const svg = `<svg viewBox="0 0 ${width + 6} ${height + 6}" height="${height + 6}" width="${width + 6}"
        xmlns="http://www.w3.org/2000/svg" style="transform: scale(1,-1)">
        <g fill="none" stroke="white">
          <path stroke-linejoin="round" stroke-width="1.5" d="${getPath()}" style="stroke-linecap: round" />
          <circle r="2.5" fill="white" cx="${activePoint.x}" cy="${activePoint.y}" />
        </g>
      </svg>`;
    return `data:image/svg+xml;utf8,${svg}`;
  }
  function handleMouseMove(e) {
    const {
      x: containerX,
      width: containerWidth
    } = e.currentTarget.getBoundingClientRect();
    const {
      clientX
    } = 'touches' in e ? e.touches[0] : e;
    const segmentHalfWidth = containerWidth / points.length / 2;
    const x = clientX - containerX - segmentHalfWidth;
    const nextIndex = Math.max(0, Math.min(Math.round(points.length * (x / containerWidth)), points.length - 1));
    onSelectIndex(nextIndex);
  }
  function handleTouchStart(e) {
    handleMouseMove(e);
    disableTelegramMiniAppSwipeToClose();
  }
  function handleMouseLeave() {
    onSelectIndex(-1);
    enableTelegramMiniAppSwipeToClose();
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: className,
    onMouseMove: handleMouseMove,
    onMouseLeave: handleMouseLeave,
    onTouchStart: handleTouchStart,
    onTouchMove: handleMouseMove,
    onTouchEnd: handleMouseLeave,
    onTouchCancel: handleMouseLeave
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: isUpdating ? 1 : 0,
    name: "semiFade",
    shouldCleanup: true
  }, /*#__PURE__*/teact.createElement("img", {
    src: renderSvg(),
    className: buildClassName(imgClassName, isUpdating && 'glare-image'),
    alt: lang('Currency History')
  })));
}
/* harmony default export */ const common_TokenPriceChart = (memo(TokenPriceChart));
;// ./src/components/main/sections/Card/ChartHistorySwitcher.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ChartHistorySwitcher_module = ({"menuWrapper":"ChartHistorySwitcher-module__menuWrapper","menu":"ChartHistorySwitcher-module__menu","menuItem":"ChartHistorySwitcher-module__menuItem"});
;// ./src/components/main/sections/Card/ChartHistorySwitcher.tsx








const ITEMS = src_config/* HISTORY_PERIODS */.Kfi.map(key => ({
  value: key,
  name: key === 'ALL' ? 'All' : key
}));
function ChartHistorySwitcher(_ref) {
  let {
    isOpen,
    currentPeriod,
    onClose,
    onChange
  } = _ref;
  const {
    setCurrentTokenPeriod
  } = getActions();
  const handlePeriodChange = useLastCallback(period => {
    onClose();
    if (period === currentPeriod) return;
    void vibrate();
    setCurrentTokenPeriod({
      period: period
    });
    onChange === null || onChange === void 0 || onChange(period);
  });
  return /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isOpen,
    onClose: onClose,
    items: ITEMS,
    className: ChartHistorySwitcher_module.menuWrapper,
    bubbleClassName: ChartHistorySwitcher_module.menu,
    buttonClassName: ChartHistorySwitcher_module.menuItem,
    selectedValue: currentPeriod,
    menuPositionX: "right",
    onSelect: handlePeriodChange
  });
}
/* harmony default export */ const Card_ChartHistorySwitcher = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  return {
    currentPeriod: accountState === null || accountState === void 0 ? void 0 : accountState.currentTokenPeriod
  };
})(ChartHistorySwitcher)));
;// ./src/components/main/sections/Card/TokenCard.tsx
































const OFFLINE_TIMEOUT = 120000; // 2 minutes

const CHART_DIMENSIONS = {
  width: 300,
  height: 64
};
const TokenCard_INTERVAL = 5 * dateFormat/* SECOND */.Z2;
const DEFAULT_PERIOD = src_config/* HISTORY_PERIODS */.Kfi[0];
function TokenCard(_ref) {
  let {
    ref,
    isTestnet,
    token,
    classNames,
    period = DEFAULT_PERIOD,
    isUpdating,
    baseCurrency,
    historyPeriods,
    tokenAddress,
    stakingStates,
    isSensitiveDataHidden,
    onYieldClick,
    onClose
  } = _ref;
  const {
    loadPriceHistory
  } = getActions();
  const lang = hooks_useLang();
  const forceUpdate = hooks_useForceUpdate();
  const amountRef = teact_useRef();
  const [currencyMenuAnchor, setCurrencyMenuAnchor] = useState();
  const [isHistoryMenuOpen, openHistoryMenu, closeHistoryMenu] = hooks_useFlag(false);
  const shouldUseDefaultCurrency = baseCurrency === undefined || baseCurrency === token.symbol;
  const chartCurrency = shouldUseDefaultCurrency ? src_config/* DEFAULT_PRICE_CURRENCY */.wOb : baseCurrency;
  const currencySymbol = getShortCurrencySymbol(chartCurrency);
  const [selectedHistoryIndex, setSelectedHistoryIndex] = useState(-1);
  useSyncEffect(_ref2 => {
    let [prevHistoryIndex] = _ref2;
    if (!windowEnvironment/* IS_IOS */.pz) return;
    if (prevHistoryIndex !== undefined) {
      void vibrate();
    }
  }, [selectedHistoryIndex]);
  const {
    slug,
    symbol,
    amount,
    name,
    price: lastPrice,
    decimals
  } = token;
  const {
    annualYield,
    yieldType,
    id: stakingId
  } = teact_useMemo(() => {
    if (src_config/* IS_CORE_WALLET */.TI6) return undefined;
    return stakingStates === null || stakingStates === void 0 ? void 0 : stakingStates.reduce((bestState, state) => {
      if (state.tokenSlug === slug && (!bestState || state.balance > bestState.balance)) {
        return state;
      }
      return bestState;
    }, undefined);
  }, [stakingStates, slug]) ?? {};
  const refreshHistory = useLastCallback(newPeriod => {
    loadPriceHistory({
      slug,
      period: newPeriod ?? period
    });
  });
  const handleCurrencyChange = useLastCallback(currency => {
    loadPriceHistory({
      slug,
      period,
      currency
    });
  });
  const openCurrencyMenu = () => {
    const {
      left,
      width,
      bottom: y
    } = amountRef.current.getBoundingClientRect();
    setCurrencyMenuAnchor({
      x: left + width,
      y
    });
  };
  const closeCurrencyMenu = useLastCallback(() => {
    setCurrencyMenuAnchor(undefined);
  });
  hooks_useInterval(refreshHistory, TokenCard_INTERVAL);
  const history = historyPeriods === null || historyPeriods === void 0 ? void 0 : historyPeriods[period];
  const tokenLastUpdatedAt = history !== null && history !== void 0 && history.length ? history[history.length - 1][0] * 1000 : undefined;
  const tokenLastHistoryPrice = history !== null && history !== void 0 && history.length ? history[history.length - 1][1] : lastPrice;
  const selectedHistoryPoint = history === null || history === void 0 ? void 0 : history[selectedHistoryIndex];
  const price = (selectedHistoryPoint === null || selectedHistoryPoint === void 0 ? void 0 : selectedHistoryPoint[1]) ?? (shouldUseDefaultCurrency ? tokenLastHistoryPrice : undefined) ?? lastPrice;
  // To prevent flickering with spoiler
  const tokenChangePrice = isSensitiveDataHidden ? lastPrice : price;
  const isLoading = !tokenLastUpdatedAt || Date.now() - tokenLastUpdatedAt > OFFLINE_TIMEOUT;
  const dateStr = selectedHistoryPoint ? (0,dateFormat/* formatShortDay */.mf)(lang.code, selectedHistoryPoint[0] * 1000, true, true) : isLoading && tokenLastUpdatedAt ? (0,dateFormat/* formatShortDay */.mf)(lang.code, tokenLastUpdatedAt, true, false) : lang('Now');
  hooks_useTimeout(forceUpdate, isLoading ? undefined : OFFLINE_TIMEOUT, [tokenLastUpdatedAt]);
  const initialPrice = teact_useMemo(() => {
    var _history$find;
    return history === null || history === void 0 || (_history$find = history.find(_ref3 => {
      let [, value] = _ref3;
      return Boolean(value);
    })) === null || _history$find === void 0 ? void 0 : _history$find[1];
  }, [history]);
  const valueBig = (0,util_decimals/* toBig */.CF)(amount, decimals).mul(price);
  const value = valueBig.toString();
  const change = initialPrice && price ? price - initialPrice : 0;
  const changeFactor = initialPrice && tokenChangePrice ? tokenChangePrice / initialPrice - 1 : 0;
  const amountChange = initialPrice && tokenChangePrice ? calcBigChangeValue(valueBig, changeFactor).toNumber() : 0;
  const changePrefix = change === undefined ? change : change > 0 ? 'â†‘' : change < 0 ? 'â†“' : 0;
  const changeValue = amountChange ? Math.abs(round(amountChange, 4)) : 0;
  const changePercent = change ? Math.abs(round(change / initialPrice * 100, 2)) : 0;
  const withChange = Boolean(change !== undefined);
  const historyStartDay = history !== null && history !== void 0 && history.length ? new Date(history[0][0] * 1000) : undefined;
  const withExplorerButton = Boolean(token.cmcSlug || tokenAddress);
  const shouldHideChartPeriodSwitcher = !(history !== null && history !== void 0 && history.length) && token.priceUsd === 0;
  const color = teact_useMemo(() => calculateTokenCardColor(token), [token]);
  function renderExplorerLink() {
    const url = getExplorerTokenUrl(token.chain, token.cmcSlug, tokenAddress, isTestnet);
    if (!url) return undefined;
    const title = lang('Open on %ton_explorer_name%', {
      ton_explorer_name: getExplorerName(token.chain)
    }).join('');
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, ' Â· ', /*#__PURE__*/teact.createElement("a", {
      href: url,
      title: title,
      "aria-label": title,
      target: "_blank",
      rel: "noreferrer",
      className: Card_module.tokenExplorerButton,
      onClick: handleUrlClick
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-tonexplorer-small",
      "aria-hidden": true
    })));
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: buildClassName(Card_module.container, Card_module.tokenCard, classNames, color, 'token-card')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenInfo
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Card_module.backButton,
    isSimple: true,
    onClick: onClose,
    ariaLabel: lang('Back')
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-chevron-left",
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(common_TokenIcon, {
    token: token,
    size: "x-large",
    className: Card_module.tokenLogo
  }), /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenInfoHeader,
    ref: amountRef
  }, /*#__PURE__*/teact.createElement("b", {
    className: Card_module.tokenAmount
  }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    maskSkin: "cardLightText",
    cols: 10,
    rows: 2,
    cellSize: 8
  }, formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, token.decimals), symbol))), withChange && /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenValue
  }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    maskSkin: "cardLightText",
    align: "right",
    cols: 10,
    rows: 2,
    cellSize: 8
  }, /*#__PURE__*/teact.createElement("div", {
    className: Card_module.currencySwitcher,
    role: "button",
    tabIndex: 0,
    onClick: openCurrencyMenu
  }, "\u2248\u2009", formatCurrency(value, currencySymbol, undefined, true), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon', 'icon-caret-down', Card_module.iconCaretSmall),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(Card_CurrencySwitcherMenu, {
    isOpen: Boolean(currencyMenuAnchor),
    triggerRef: amountRef,
    anchor: currencyMenuAnchor,
    menuPositionX: "right",
    excludedCurrency: token.symbol,
    onClose: closeCurrencyMenu,
    onChange: handleCurrencyChange
  })))), /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenInfoSubheader
  }, /*#__PURE__*/teact.createElement("span", {
    className: Card_module.tokenTitle
  }, /*#__PURE__*/teact.createElement("span", {
    className: Card_module.tokenName
  }, name), yieldType && /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Card_module.apy, onYieldClick && Card_module.interactive),
    onClick: onYieldClick ? () => onYieldClick(stakingId) : undefined
  }, yieldType, " ", round(annualYield ?? 0, 2), "%")), withChange && Boolean(changeValue) && /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenChange
  }, changePrefix, "\u2009", Math.abs(changePercent), "% \xB7", /*#__PURE__*/teact.createElement(ui_SensitiveData, {
    isActive: isSensitiveDataHidden,
    align: "right",
    maskSkin: "cardLightText",
    cols: 6,
    rows: 2,
    cellSize: 8,
    className: Card_module.tokenChangeSensitiveData,
    maskClassName: Card_module.tokenChangeSpoiler
  }, formatCurrency(Math.abs(changeValue), currencySymbol))))), /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: !history ? 0 : history.length ? src_config/* HISTORY_PERIODS */.Kfi.indexOf(period) + 1 : -1,
    name: "fade"
  }, !history ? /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Card_module.isLoading)
  }, /*#__PURE__*/teact.createElement(ui_Spinner, {
    color: "white",
    className: Card_module.center
  })) : history !== null && history !== void 0 && history.length ? /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(common_TokenPriceChart, {
    className: Card_module.chart,
    imgClassName: Card_module.chartImg,
    width: CHART_DIMENSIONS.width,
    height: CHART_DIMENSIONS.height,
    prices: history,
    selectedIndex: selectedHistoryIndex,
    onSelectIndex: setSelectedHistoryIndex,
    isUpdating: isUpdating
  }), /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenHistoryPrice
  }, formatCurrency(history[0][1], currencySymbol, 2, true), /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenPriceDate
  }, (0,dateFormat/* formatShortDay */.mf)(lang.code, historyStartDay)))) : undefined), /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Card_module.periodChooser, shouldHideChartPeriodSwitcher && Card_module.periodChooserHidden),
    role: "button",
    tabIndex: 0,
    onClick: openHistoryMenu
  }, period === 'ALL' ? 'All' : period, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon', 'icon-caret-down', Card_module.iconCaretSmall),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement(Card_ChartHistorySwitcher, {
    isOpen: isHistoryMenuOpen,
    onChange: refreshHistory,
    onClose: closeHistoryMenu
  })), /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenCurrentPrice
  }, formatCurrency(price, currencySymbol, selectedHistoryIndex === -1 ? 2 : 4, true), /*#__PURE__*/teact.createElement("div", {
    className: Card_module.tokenPriceDate
  }, dateStr, withExplorerButton && renderExplorerLink())));
}
/* harmony default export */ const Card_TokenCard = (memo(withGlobal((global, ownProps) => {
  var _global$tokenInfo$byS;
  const slug = ownProps.token.slug;
  const accountState = selectCurrentAccountState(global);
  const tokenAddress = (_global$tokenInfo$byS = global.tokenInfo.bySlug[slug]) === null || _global$tokenInfo$byS === void 0 ? void 0 : _global$tokenInfo$byS.tokenAddress;
  const stakingStates = selectAccountStakingStates(global, global.currentAccountId);
  return {
    isTestnet: global.settings.isTestnet,
    period: accountState === null || accountState === void 0 ? void 0 : accountState.currentTokenPeriod,
    baseCurrency: global.settings.baseCurrency,
    historyPeriods: global.tokenPriceHistory.bySlug[ownProps.token.slug],
    tokenAddress,
    stakingStates,
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden
  };
})(TokenCard)));
;// ./src/components/main/sections/Card/Card.tsx





























function Card(_ref) {
  let {
    ref,
    tokens,
    currentTokenSlug,
    onTokenCardClose,
    onYieldClick,
    baseCurrency,
    stakingStates,
    isSensitiveDataHidden,
    isNftBuyingDisabled,
    cardNft,
    isViewMode
  } = _ref;
  const amountRef = teact_useRef();
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  const [customCardClassName, setCustomCardClassName] = useState(undefined);
  const [withTextGradient, setWithTextGradient] = useState(false);
  const {
    isPortrait
  } = useDeviceScreen();
  const {
    width: screenWidth
  } = useWindowSize();
  const isUpdating = useUpdateIndicator('balanceUpdateStartedAt');
  const {
    updateFontScale
  } = hooks_useFontScale(amountRef);
  // Screen width affects font size only in portrait orientation
  const screenWidthDep = isPortrait ? screenWidth : 0;
  const [currencyMenuAnchor, setCurrencyMenuAnchor] = useState();
  const currentToken = teact_useMemo(() => {
    return tokens ? tokens.find(token => token.slug === currentTokenSlug) : undefined;
  }, [currentTokenSlug, tokens]);
  const renderedToken = useCurrentOrPrev(currentToken, true);
  const {
    shouldRender: shouldRenderTokenCard,
    ref: tokenCardRef
  } = useShowTransition({
    isOpen: Boolean(currentTokenSlug),
    noMountTransition: true,
    withShouldRender: true
  });
  const sensitiveDataMaskSkin = getSensitiveDataMaskSkinFromCardNft(cardNft);
  const openCurrencyMenu = () => {
    const {
      left,
      width,
      bottom: y
    } = amountRef.current.getBoundingClientRect();
    setCurrencyMenuAnchor({
      x: left + width / 2,
      y
    });
  };
  const closeCurrencyMenu = useLastCallback(() => {
    setCurrencyMenuAnchor(undefined);
  });
  const handleCardChange = useLastCallback((hasGradient, className) => {
    setCustomCardClassName(className);
    setWithTextGradient(hasGradient);
  });
  const values = teact_useMemo(() => {
    return tokens ? calculateFullBalance(tokens, stakingStates) : undefined;
  }, [tokens, stakingStates]);
  useHistoryBack({
    isActive: Boolean(currentTokenSlug),
    onBack: onTokenCardClose
  });
  teact_useEffect(() => shouldRenderTokenCard ? captureEscKeyListener(onTokenCardClose) : undefined, [shouldRenderTokenCard, onTokenCardClose]);
  const {
    primaryValue,
    primaryWholePart,
    primaryFractionPart,
    changePrefix,
    changePercent,
    changeValue
  } = values || {};
  useLayoutEffect(() => {
    if (primaryValue !== undefined) {
      updateFontScale();
    }
  }, [primaryFractionPart, primaryValue, primaryWholePart, shortBaseSymbol, updateFontScale, screenWidthDep]);
  function renderLoader() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Card_module.isLoading)
    }, /*#__PURE__*/teact.createElement(ui_Spinner, {
      color: "white",
      className: Card_module.center
    }));
  }
  function renderBalance() {
    const iconCaretClassNames = buildClassName('icon', 'icon-caret-down', primaryFractionPart || shortBaseSymbol.length > 1 ? Card_module.iconCaretFraction : Card_module.iconCaret);
    const noAnimationCounter = !isUpdating || windowEnvironment/* IS_SAFARI */.Yw || windowEnvironment/* IS_IOS */.pz;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Transition, {
      ref: amountRef,
      activeKey: isUpdating && !isSensitiveDataHidden ? 1 : 0,
      name: "fade",
      shouldCleanup: true,
      className: Card_module.balanceTransition,
      slideClassName: Card_module.balanceSlide
    }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      maskSkin: sensitiveDataMaskSkin,
      rows: 4,
      cols: 14,
      cellSize: 13,
      align: "center",
      maskClassName: Card_module.blurred
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Card_module.primaryValue, 'rounded-font')
    }, /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Card_module.currencySwitcher, isUpdating && 'glare-text', !isUpdating && withTextGradient && 'gradientText'),
      role: "button",
      tabIndex: 0,
      onClick: !isSensitiveDataHidden ? openCurrencyMenu : undefined
    }, shortBaseSymbol.length === 1 && /*#__PURE__*/teact.createElement("span", {
      className: Card_module.currencySymbol
    }, shortBaseSymbol), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      isDisabled: noAnimationCounter,
      text: primaryWholePart ?? ''
    }), primaryFractionPart && /*#__PURE__*/teact.createElement("span", {
      className: Card_module.primaryFractionPart
    }, /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      isDisabled: noAnimationCounter,
      text: `.${primaryFractionPart}`
    })), shortBaseSymbol.length > 1 && /*#__PURE__*/teact.createElement("span", {
      className: Card_module.primaryFractionPart
    }, "\xA0", shortBaseSymbol), /*#__PURE__*/teact.createElement("i", {
      className: iconCaretClassNames,
      "aria-hidden": true
    }))))), /*#__PURE__*/teact.createElement(Card_CurrencySwitcherMenu, {
      isOpen: Boolean(currencyMenuAnchor),
      triggerRef: amountRef,
      anchor: currencyMenuAnchor,
      className: Card_module.currencySwitcherMenu,
      onClose: closeCurrencyMenu
    }), primaryValue !== '0' && /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      maskSkin: sensitiveDataMaskSkin,
      rows: 2,
      cols: 11,
      align: "center",
      cellSize: 14,
      className: Card_module.changeSpoiler,
      maskClassName: Card_module.blurred
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Card_module.change, 'rounded-font')
    }, !!changePrefix && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Card_module.changePrefix, changePrefix === 'up' ? 'icon-arrow-up' : 'icon-arrow-down'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: `${Math.abs(changePercent)}%`
    }), ' Â· '), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(Math.abs(changeValue), shortBaseSymbol)
    }))));
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: Card_module.containerWrapper
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: isUpdating ? 1 : 0,
    name: "fade",
    shouldCleanup: true,
    className: Card_module.loadingDotsContainer
  }, isUpdating ? /*#__PURE__*/teact.createElement(ui_LoadingDots, {
    isActive: true,
    isDoubled: true
  }) : undefined), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Card_module.container, currentTokenSlug && Card_module.backstage, customCardClassName)
  }, /*#__PURE__*/teact.createElement(Card_CustomCardManager, {
    nft: cardNft,
    onCardChange: handleCardChange
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Card_module.containerInner, customCardClassName)
  }, values ? renderBalance() : renderLoader(), /*#__PURE__*/teact.createElement(Card_CardAddress, {
    withTextGradient: withTextGradient
  }), !src_config/* IS_CORE_WALLET */.TI6 && !isNftBuyingDisabled && !isViewMode && /*#__PURE__*/teact.createElement(mintCard_MintCardButton, null))), shouldRenderTokenCard && /*#__PURE__*/teact.createElement(Card_TokenCard, {
    token: renderedToken,
    ref: tokenCardRef,
    isUpdating: isUpdating,
    onYieldClick: isViewMode ? undefined : onYieldClick,
    onClose: onTokenCardClose
  }));
}
/* harmony default export */ const Card_Card = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  const stakingStates = selectAccountStakingStates(global, global.currentAccountId);
  const {
    cardBackgroundNft: cardNft
  } = selectCurrentAccountSettings(global) || {};
  return {
    isViewMode: selectIsCurrentAccountViewMode(global),
    tokens: selectCurrentAccountTokens(global),
    currentTokenSlug: accountState === null || accountState === void 0 ? void 0 : accountState.currentTokenSlug,
    baseCurrency: global.settings.baseCurrency,
    stakingStates,
    cardNft,
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden,
    isNftBuyingDisabled: global.restrictions.isNftBuyingDisabled
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Card)));
;// ./src/components/main/sections/Card/index.ts

;// ./src/components/main/helpers/scrollableContainer.ts


/** Finds the appropriate scrollable container */
function getScrollableContainer(element, isPortrait) {
  // eslint-disable-next-line no-null/no-null
  if (!element) return null;
  const selector = getScrollableContainerSelector(isPortrait);
  if (isPortrait) {
    return element.closest(selector);
  } else {
    return element.matches(selector) ? element : element.querySelector(selector);
  }
}

// In portrait mode, find the parent `.app-slide-content` container, which contains the all app scrollable content
function getScrollableContainerSelector(isPortrait) {
  return isPortrait ? '.app-slide-content' : `.custom-scroll.${ACTIVE_SLIDE_CLASS_NAME}`;
}
function getScrollContainerClosestSelector(isActive, isPortrait) {
  return !isActive || !isPortrait ? undefined : '.app-slide-content';
}
;// ./src/components/main/modals/HideNftModal.tsx







function HideNftModal(_ref) {
  let {
    isOpen,
    selectedNftsToHide
  } = _ref;
  const {
    addNftsToBlacklist,
    closeNftCollection,
    closeHideNftModal
  } = getActions();
  const lang = hooks_useLang();
  const handleHide = useLastCallback(() => {
    addNftsToBlacklist({
      addresses: selectedNftsToHide.addresses
    });
    if (selectedNftsToHide !== null && selectedNftsToHide !== void 0 && selectedNftsToHide.isCollection) closeNftCollection();
    closeHideNftModal();
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    isCompact: true,
    onClose: closeHideNftModal,
    title: lang('Hide NFTs')
  }, /*#__PURE__*/teact.createElement("p", {
    className: Modal_module.text
  }, selectedNftsToHide !== null && selectedNftsToHide !== void 0 && selectedNftsToHide.isCollection ? lang('Are you sure you want to hide this NFT collection containing %number% NFTs?', {
    number: selectedNftsToHide === null || selectedNftsToHide === void 0 ? void 0 : selectedNftsToHide.addresses.length
  }) : lang('Are you sure you want to hide these %number% NFTs?', {
    number: selectedNftsToHide === null || selectedNftsToHide === void 0 ? void 0 : selectedNftsToHide.addresses.length
  })), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: closeHideNftModal,
    className: Modal_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    onClick: handleHide,
    className: Modal_module.button
  }, lang('Hide'))));
}
/* harmony default export */ const modals_HideNftModal = (memo(HideNftModal));
;// ./src/hooks/useInfiniteScroll.ts








const DEFAULT_LIST_SLICE = 30;
const useInfiniteScroll = function (loadMoreBackwards, listIds) {
  var _currentStateRef$curr;
  let isDisabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  let listSlice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_LIST_SLICE;
  let slug = arguments.length > 4 ? arguments[4] : undefined;
  let isActive = arguments.length > 5 ? arguments[5] : undefined;
  let withResetOnInactive = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
  const currentStateRef = teact_useRef();
  if (!currentStateRef.current && listIds && !isDisabled) {
    const {
      newViewportIds,
      newIsOnTop
    } = getViewportSlice(listIds, LoadMoreDirection.Forwards, listSlice, listIds[0]);
    currentStateRef.current = {
      viewportIds: newViewportIds,
      isOnTop: newIsOnTop
    };
  }
  const forceUpdate = hooks_useForceUpdate();
  const prevSlug = usePrevious2(slug);
  const resetScroll = useLastCallback(() => {
    if (!(listIds !== null && listIds !== void 0 && listIds.length)) return;
    const {
      newViewportIds,
      newIsOnTop
    } = getViewportSlice(listIds, LoadMoreDirection.Forwards, listSlice, listIds[0]);
    currentStateRef.current = {
      viewportIds: newViewportIds,
      isOnTop: newIsOnTop
    };
  });
  useSyncEffect(() => {
    if (slug !== prevSlug || withResetOnInactive && !isActive) {
      resetScroll();
    }
  }, [isActive, prevSlug, slug, withResetOnInactive]);
  const prevListIds = hooks_usePrevious(listIds);
  const prevIsDisabled = hooks_usePrevious(isDisabled);
  if (listIds && !isDisabled && (listIds !== prevListIds || isDisabled !== prevIsDisabled)) {
    const {
      viewportIds: oldViewportIds,
      isOnTop: oldIsOnTop
    } = currentStateRef.current ?? {};
    const {
      newViewportIds,
      newIsOnTop
    } = getViewportSliceAfterListChange(listIds, oldViewportIds, oldIsOnTop, listSlice);
    if (!oldViewportIds || !(0,iteratees/* areSortedArraysEqual */.k)(oldViewportIds, newViewportIds)) {
      currentStateRef.current = {
        viewportIds: newViewportIds,
        isOnTop: newIsOnTop
      };
    }
  } else if (!listIds) {
    currentStateRef.current = undefined;
  }
  const getMore = useLastCallback(_ref => {
    let {
      direction
    } = _ref;
    if (!isActive) return;
    const {
      viewportIds
    } = currentStateRef.current || {};
    const offsetId = viewportIds ? direction === LoadMoreDirection.Backwards ? viewportIds[viewportIds.length - 1] : viewportIds[0] : undefined;
    if (!listIds) {
      if (loadMoreBackwards) {
        loadMoreBackwards({
          offsetId
        });
      }
      return;
    }
    const {
      newViewportIds,
      areSomeLocal,
      areAllLocal,
      newIsOnTop
    } = getViewportSlice(listIds, direction, listSlice, offsetId);
    if (areSomeLocal && !(viewportIds && (0,iteratees/* areSortedArraysEqual */.k)(viewportIds, newViewportIds))) {
      currentStateRef.current = {
        viewportIds: newViewportIds,
        isOnTop: newIsOnTop
      };
      forceUpdate();
    }
    if (!areAllLocal && loadMoreBackwards) {
      loadMoreBackwards({
        offsetId
      });
    }
  });
  return isDisabled ? [listIds] : [(_currentStateRef$curr = currentStateRef.current) === null || _currentStateRef$curr === void 0 ? void 0 : _currentStateRef$curr.viewportIds, getMore, resetScroll];
};
function getViewportSlice(sourceIds, direction, listSlice, offsetId) {
  const {
    length
  } = sourceIds;
  const index = offsetId ? sourceIds.indexOf(offsetId) : 0;
  const isForwards = direction === LoadMoreDirection.Forwards;
  const indexForDirection = isForwards ? index : index + 1 || length;
  const from = Math.max(0, indexForDirection - listSlice);
  const to = indexForDirection + listSlice - 1;
  const newViewportIds = sourceIds.slice(Math.max(0, from), to + 1);
  let areSomeLocal;
  let areAllLocal;
  switch (direction) {
    case LoadMoreDirection.Forwards:
      areSomeLocal = indexForDirection >= 0;
      areAllLocal = from >= 0;
      break;
    case LoadMoreDirection.Backwards:
      areSomeLocal = indexForDirection < length;
      areAllLocal = to <= length - 1;
      break;
  }
  return {
    newViewportIds,
    areSomeLocal,
    areAllLocal,
    newIsOnTop: newViewportIds[0] === sourceIds[0]
  };
}
function getViewportSliceAfterListChange(newListIds, oldViewportIds, oldIsOnTop, sliceLength) {
  if (oldIsOnTop) {
    // When the offsetId is on the top, the viewport slice must include at least as many items as it already has.
    // Otherwise, the ids, that the user is seeing, can disappear (that causes the list to scroll higher instantly).
    // Subtracting 1 prevents getViewportSlice from expanding the viewport slice 1 item with each newListIds change.
    sliceLength = Math.max(sliceLength, ((oldViewportIds === null || oldViewportIds === void 0 ? void 0 : oldViewportIds.length) ?? 0) - 1);
    return getViewportSlice(newListIds, LoadMoreDirection.Backwards, sliceLength, newListIds[0]);
  }
  let offsetId = oldViewportIds === null || oldViewportIds === void 0 ? void 0 : oldViewportIds[Math.round(oldViewportIds.length / 2)];
  if (offsetId && !newListIds.includes(offsetId)) offsetId = newListIds[0];
  // The direction must be Forwards for getViewportSlice to keep the offsetId at the newViewportIds middle. Otherwise,
  // the viewport slice will "walk" 1 item backward with each newListIds change.
  return getViewportSlice(newListIds, LoadMoreDirection.Forwards, sliceLength, offsetId);
}
/* harmony default export */ const hooks_useInfiniteScroll = (useInfiniteScroll);
;// ./src/hooks/useLayoutEffectWithPrevDeps.ts

const useLayoutEffectWithPrevDeps_useLayoutEffectWithPrevDeps = (cb, dependencies, debugKey) => {
  const prevDepsRef = teact_useRef();
  return useLayoutEffect(() => {
    const prevDeps = prevDepsRef.current;
    prevDepsRef.current = dependencies;
    return cb(prevDeps || []);
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, dependencies, debugKey);
};
/* harmony default export */ const hooks_useLayoutEffectWithPrevDeps = (useLayoutEffectWithPrevDeps_useLayoutEffectWithPrevDeps);
;// ./src/util/resetScroll.ts

const resetScroll = (container, scrollTop) => {
  if (windowEnvironment/* IS_IOS */.pz) {
    container.style.overflow = 'hidden';
  }
  if (scrollTop !== undefined) {
    container.scrollTop = scrollTop;
  }
  if (windowEnvironment/* IS_IOS */.pz) {
    container.style.overflow = '';
  }
};
/* harmony default export */ const util_resetScroll = (resetScroll);
;// ./src/components/ui/InfiniteScroll.tsx










const DEFAULT_LIST_SELECTOR = '.ListItem';
const DEFAULT_PRELOAD_BACKWARDS = 20;
const DEFAULT_SENSITIVE_AREA = 800;
const InfiniteScroll = _ref => {
  let {
    ref,
    style,
    className,
    items,
    itemSelector = DEFAULT_LIST_SELECTOR,
    preloadBackwards = DEFAULT_PRELOAD_BACKWARDS,
    sensitiveArea = DEFAULT_SENSITIVE_AREA,
    withAbsolutePositioning,
    maxHeight,
    // Used to turn off restoring scroll position (e.g. for frequently re-ordered chat or user lists)
    noScrollRestore = false,
    noScrollRestoreOnTop = false,
    noFastList,
    // Used to re-query `listItemElements` if rendering is delayed by transition
    cacheBuster,
    beforeChildren,
    scrollContainerClosest,
    children,
    onLoadMore,
    onScroll,
    onWheel,
    onClick,
    onKeyDown,
    onDragOver,
    onDragLeave
  } = _ref;
  let containerRef = teact_useRef();
  if (ref) {
    containerRef = ref;
  }
  const stateRef = teact_useRef({});
  const [loadMoreBackwards, loadMoreForwards] = teact_useMemo(() => {
    if (!onLoadMore) {
      return [];
    }
    return [(0,schedulers/* debounce */.sg)(() => {
      onLoadMore({
        direction: LoadMoreDirection.Backwards
      });
    }, dateFormat/* SECOND */.Z2, true, false), (0,schedulers/* debounce */.sg)(() => {
      onLoadMore({
        direction: LoadMoreDirection.Forwards
      });
    }, dateFormat/* SECOND */.Z2, true, false)];
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, [onLoadMore, items]);

  // Initial preload
  teact_useEffect(() => {
    if (!loadMoreBackwards) {
      return;
    }
    if (preloadBackwards > 0 && (!items || items.length < preloadBackwards)) {
      loadMoreBackwards();
      return;
    }
    const scrollContainer = scrollContainerClosest ? containerRef.current.closest(scrollContainerClosest) : containerRef.current;
    const {
      scrollHeight,
      clientHeight
    } = scrollContainer;
    if (clientHeight && scrollHeight <= clientHeight) {
      loadMoreBackwards();
    }
  }, [items, loadMoreBackwards, preloadBackwards, scrollContainerClosest]);

  // Restore `scrollTop` after adding items
  hooks_useLayoutEffectWithPrevDeps(_ref2 => {
    let [prevItems] = _ref2;
    const scrollContainer = scrollContainerClosest ? containerRef.current.closest(scrollContainerClosest) : containerRef.current;
    const state = stateRef.current;
    const listItemElements = scrollContainer.querySelectorAll(itemSelector);
    state.listItemElements = listItemElements;
    if (!(prevItems !== null && prevItems !== void 0 && prevItems.length)) return;
    (0,fasterdom/* requestForcedReflow */.gm)(() => {
      let newScrollTop;
      if (state.currentAnchor && Array.from(listItemElements).includes(state.currentAnchor)) {
        const {
          scrollTop
        } = scrollContainer;
        const newAnchorTop = state.currentAnchor.getBoundingClientRect().top;
        newScrollTop = scrollTop + (newAnchorTop - state.currentAnchorTop);
      } else {
        const nextAnchor = listItemElements[0];
        if (nextAnchor) {
          state.currentAnchor = nextAnchor;
          state.currentAnchorTop = nextAnchor.getBoundingClientRect().top;
        }
      }
      if (withAbsolutePositioning || noScrollRestore) {
        return undefined;
      }
      const {
        scrollTop
      } = scrollContainer;
      if (noScrollRestoreOnTop && scrollTop === 0) {
        return undefined;
      }
      return () => {
        util_resetScroll(scrollContainer, newScrollTop);
        state.isScrollTopJustUpdated = true;
      };
    });
  }, [items, itemSelector, noScrollRestore, noScrollRestoreOnTop, cacheBuster, withAbsolutePositioning, scrollContainerClosest]);
  const handleScroll = useLastCallback(e => {
    if (loadMoreForwards && loadMoreBackwards) {
      const {
        isScrollTopJustUpdated,
        currentAnchor,
        currentAnchorTop
      } = stateRef.current;
      const listItemElements = stateRef.current.listItemElements;
      if (isScrollTopJustUpdated) {
        stateRef.current.isScrollTopJustUpdated = false;
        return;
      }
      const listLength = listItemElements.length;
      const scrollContainer = scrollContainerClosest ? containerRef.current.closest(scrollContainerClosest) : containerRef.current;
      const {
        scrollTop,
        scrollHeight,
        offsetHeight
      } = scrollContainer;
      const top = listLength ? listItemElements[0].offsetTop : 0;
      const isNearTop = scrollTop <= top + sensitiveArea;
      const bottom = listLength ? listItemElements[listLength - 1].offsetTop + listItemElements[listLength - 1].offsetHeight : scrollHeight;
      const isNearBottom = bottom - (scrollTop + offsetHeight) <= sensitiveArea;
      let isUpdated = false;
      if (isNearTop) {
        const nextAnchor = listItemElements[0];
        if (nextAnchor) {
          const nextAnchorTop = nextAnchor.getBoundingClientRect().top;
          const newAnchorTop = currentAnchor !== null && currentAnchor !== void 0 && currentAnchor.offsetParent && currentAnchor !== nextAnchor ? currentAnchor.getBoundingClientRect().top : nextAnchorTop;
          const isMovingUp = currentAnchor && currentAnchorTop !== undefined && newAnchorTop > currentAnchorTop;
          if (isMovingUp) {
            stateRef.current.currentAnchor = nextAnchor;
            stateRef.current.currentAnchorTop = nextAnchorTop;
            isUpdated = true;
            loadMoreForwards();
          }
        }
      }
      if (isNearBottom) {
        const nextAnchor = listItemElements[listLength - 1];
        if (nextAnchor) {
          const nextAnchorTop = nextAnchor.getBoundingClientRect().top;
          const newAnchorTop = currentAnchor !== null && currentAnchor !== void 0 && currentAnchor.offsetParent && currentAnchor !== nextAnchor ? currentAnchor.getBoundingClientRect().top : nextAnchorTop;
          const isMovingDown = currentAnchor && currentAnchorTop !== undefined && newAnchorTop < currentAnchorTop;
          if (isMovingDown) {
            stateRef.current.currentAnchor = nextAnchor;
            stateRef.current.currentAnchorTop = nextAnchorTop;
            isUpdated = true;
            loadMoreBackwards();
          }
        }
      }
      if (!isUpdated) {
        if (currentAnchor !== null && currentAnchor !== void 0 && currentAnchor.offsetParent) {
          stateRef.current.currentAnchorTop = currentAnchor.getBoundingClientRect().top;
        } else {
          const nextAnchor = listItemElements[0];
          if (nextAnchor) {
            stateRef.current.currentAnchor = nextAnchor;
            stateRef.current.currentAnchorTop = nextAnchor.getBoundingClientRect().top;
          }
        }
      }
    }
    if (onScroll) {
      onScroll(e);
    }
  });
  useLayoutEffect(() => {
    if (!scrollContainerClosest) return undefined;
    const closestScrollContainer = containerRef.current.closest(scrollContainerClosest);
    if (!closestScrollContainer) return undefined;
    const handleNativeScroll = e => handleScroll(e);
    closestScrollContainer.addEventListener('scroll', handleNativeScroll);
    return () => {
      closestScrollContainer.removeEventListener('scroll', handleNativeScroll);
    };
  }, [handleScroll, scrollContainerClosest]);
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    className: className,
    onScroll: handleScroll,
    onWheel: onWheel,
    teactFastList: !noFastList && !withAbsolutePositioning,
    onKeyDown: onKeyDown,
    onDragOver: onDragOver,
    onDragLeave: onDragLeave,
    onClick: onClick,
    style: style
  }, beforeChildren, withAbsolutePositioning && items !== null && items !== void 0 && items.length ? /*#__PURE__*/teact.createElement("div", {
    teactFastList: !noFastList,
    style: buildStyle('position: relative', windowEnvironment/* IS_ANDROID */.Ni && maxHeight !== undefined && `height: ${maxHeight}`)
  }, children) : children);
};
/* harmony default export */ const ui_InfiniteScroll = (InfiniteScroll);
;// ./src/components/main/sections/Content/Activities.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Activities_module = ({"emptyList":"Activities-module__emptyList","emptyListTitle":"Activities-module__emptyListTitle","emptyListLoading":"Activities-module__emptyListLoading","greeting":"Activities-module__greeting","sticker":"Activities-module__sticker","loaderThreshold":"Activities-module__loaderThreshold","itemLoading":"Activities-module__itemLoading","date":"Activities-module__date","date_withLoadingDots":"Activities-module__date_withLoadingDots","dateWithLoadingDots":"Activities-module__date_withLoadingDots","loadingDots":"Activities-module__loadingDots","dateContainer":"Activities-module__dateContainer","dateSlide":"Activities-module__dateSlide","listItem":"Activities-module__listItem","listGroup":"Activities-module__listGroup","animateOpacity":"Activities-module__animateOpacity","animateTransform":"Activities-module__animateTransform"});
;// ./src/components/main/sections/Content/hooks/useActivityListEntry.ts




const useActivityListEntry_ANIMATION_DURATION = 200;
const useActivityListEntry_ANIMATION_END_DELAY = 50;
function useActivityListEntry(withAnimation, topOffset // rem
) {
  const ref = teact_useRef();
  hooks_useLayoutEffectWithPrevDeps(_ref => {
    let [prevTopOffset] = _ref;
    const element = ref.current;
    if (!withAnimation || !element) {
      return;
    }
    if (prevTopOffset === undefined) {
      // A new activity
      animateOpacity(element);
      cleanupAnimation(element);
    } else if (topOffset !== prevTopOffset) {
      // An existing activity that has moved
      animateMove(element, topOffset - prevTopOffset);
      cleanupAnimation(element);
    }
  }, [topOffset, withAnimation]);
  return {
    ref
  };
}
function animateOpacity(element) {
  element.style.opacity = '0';
  (0,fasterdom/* requestMutation */.RK)(() => {
    element.classList.add(Activities_module.animateOpacity);
    element.style.opacity = '1';
  });
}
function animateMove(element, offsetY) {
  element.style.transform = `translate3d(0, ${-offsetY}rem, 0)`;
  (0,fasterdom/* requestMutation */.RK)(() => {
    element.classList.add(Activities_module.animateTransform);
    element.style.transform = '';
  });
}
function cleanupAnimation(element) {
  setTimeout(() => {
    (0,fasterdom/* requestMutation */.RK)(() => {
      element.classList.remove(Activities_module.animateOpacity, Activities_module.animateTransform);
      element.style.opacity = '';
      element.style.transform = '';
    });
  }, useActivityListEntry_ANIMATION_DURATION + useActivityListEntry_ANIMATION_END_DELAY);
}
;// ./src/components/main/sections/Content/ActivityListItem.tsx




function ActivityListItem(_ref) {
  let {
    topOffset,
    withAnimation,
    children
  } = _ref;
  const {
    ref: animationRef
  } = useActivityListEntry(withAnimation, topOffset);
  return /*#__PURE__*/teact.createElement("div", {
    ref: animationRef,
    style: `top: ${topOffset}rem`,
    className: buildClassName('ListItem', Activities_module.listItem)
  }, children);
}
/* harmony default export */ const Content_ActivityListItem = (ActivityListItem);
;// ./src/components/main/sections/Content/NewWalletGreeting.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const NewWalletGreeting_module = ({"container":"NewWalletGreeting-module__container","panel":"NewWalletGreeting-module__panel","emptyList":"NewWalletGreeting-module__emptyList","text":"NewWalletGreeting-module__text","header":"NewWalletGreeting-module__header","description":"NewWalletGreeting-module__description"});
;// ./src/components/main/sections/Content/NewWalletGreeting.tsx







function NewWalletGreeting(_ref) {
  let {
    isActive,
    isMutlichainAccount,
    mode
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(NewWalletGreeting_module.container, NewWalletGreeting_module[mode])
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.hello,
    previewUrl: ANIMATED_STICKERS_PATHS.helloPreview,
    nonInteractive: true,
    noLoop: false,
    size: mode === 'emptyList' ? src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk : src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp
  }), /*#__PURE__*/teact.createElement("div", {
    className: NewWalletGreeting_module.text
  }, /*#__PURE__*/teact.createElement("p", {
    className: NewWalletGreeting_module.header
  }, lang(isMutlichainAccount ? 'You have just created a new multichain wallet' : 'You have just created a new wallet')), /*#__PURE__*/teact.createElement("p", {
    className: NewWalletGreeting_module.description
  }, lang(isMutlichainAccount ? 'Now you can transfer tokens from your TON and TRON wallets.' : 'You can now transfer your tokens from another wallet or exchange.'))));
}
/* harmony default export */ const Content_NewWalletGreeting = (memo(NewWalletGreeting));
;// ./src/components/main/sections/Content/Activities.tsx



































const FURTHER_SLICE = 30;
const LIST_TOP_PADDING = 0.5; // rem
const DATE_HEADER_HEIGHT = 2.125; // rem

// After this threshold, the animations of adding new activities (controlled by `useActivityOrderDiff`) won't be visible
// to the user, so the animation is disabled to improve the performance. An important part that makes the additions
// invisible is the `usePreventScrolledListShift` hook.
const SCROLL_THRESHOLD = (LIST_TOP_PADDING + DATE_HEADER_HEIGHT) * windowEnvironment/* REM */.$;
const DATE_ID_PREFIX = 'date:';
const Activities_EMPTY_ARRAY = Object.freeze([]);
const EMPTY_DICTIONARY = Object.freeze({});
function Activities(_ref) {
  let {
    isActive,
    currentAccountId,
    isMultichainAccount,
    slug,
    byId,
    allActivityIds,
    tokensBySlug,
    swapTokensBySlug,
    areTinyTransfersHidden,
    currentActivityId,
    savedAddresses,
    isHistoryEndReached,
    alwaysShownSlugs,
    theme,
    baseCurrency,
    isSensitiveDataHidden,
    stakingStateBySlug,
    nftsByAddress,
    accounts,
    onScroll
  } = _ref;
  const {
    fetchPastActivities,
    showActivityInfo
  } = getActions();
  const lang = hooks_useLang();
  const {
    isLandscape,
    isPortrait
  } = useDeviceScreen();
  const containerRef = teact_useRef();
  const isUpdating = useUpdateIndicator('activitiesUpdateStartedAt');
  const appTheme = hooks_useAppTheme(theme);
  const hasUserScrolledRef = teact_useRef(false);

  // As with `allActivityIds`, `undefined` means "not loaded yet" and `[]` means "no activities"
  const listItemIds = teact_useMemo(() => {
    const activityIds = filterActivityIds(allActivityIds ?? Activities_EMPTY_ARRAY, byId ?? EMPTY_DICTIONARY, slug, tokensBySlug, areTinyTransfersHidden, alwaysShownSlugs);
    if (!activityIds.length && !isHistoryEndReached) {
      // When all the activities are hidden, the further activities are being loaded, so the spinner should be shown.
      return undefined;
    }
    return addDatesToActivityIds(activityIds, byId);
  }, [areTinyTransfersHidden, byId, alwaysShownSlugs, allActivityIds, slug, tokensBySlug, isHistoryEndReached]);
  const firstListItemId = listItemIds === null || listItemIds === void 0 ? void 0 : listItemIds[0];
  const loadMore = useLastCallback(() => {
    fetchPastActivities({
      slug,
      shouldLoadWithBudget: true
    });
  });
  const [viewportIds, getMore, resetScroll] = hooks_useInfiniteScroll(loadMore, listItemIds, undefined, FURTHER_SLICE, slug, isActive);
  const getListItemKey = useListItemKeys(viewportIds ?? Activities_EMPTY_ARRAY, byId ?? EMPTY_DICTIONARY);

  // The move animation should remain only for the case when new transactions appear in the feed.
  // At the same time, the smooth feed appearance animation should be kept when the loading is completed.
  const prevSlug = hooks_usePrevious(slug);
  const prevIsLoading = hooks_usePrevious(listItemIds === undefined);
  const shouldUseAnimations = Boolean(isActive && !hasUserScrolledRef.current && (prevIsLoading || prevSlug === slug));
  const itemPositionById = teact_useMemo(() => {
    const itemPositionById = {};
    let top = 0;
    listItemIds === null || listItemIds === void 0 || listItemIds.forEach((itemId, index) => {
      const height = itemId.startsWith(DATE_ID_PREFIX) ? DATE_HEADER_HEIGHT + (index === 0 ? LIST_TOP_PADDING : 0) : getActivityHeight(byId[itemId]);
      itemPositionById[itemId] = {
        top,
        height
      };
      top += height;
    });
    return itemPositionById;
  }, [byId, listItemIds]);
  const currentContainerHeight = teact_useMemo(() => {
    if (!(viewportIds !== null && viewportIds !== void 0 && viewportIds.length)) return 0;
    const lastViewportId = viewportIds[viewportIds.length - 1];
    const activityOffset = itemPositionById[lastViewportId];
    return activityOffset ? activityOffset.top + activityOffset.height : 0;
  }, [itemPositionById, viewportIds]);
  usePreventScrolledListShift(viewportIds ?? Activities_EMPTY_ARRAY, itemPositionById, isPortrait, containerRef, hasUserScrolledRef);
  useLayoutEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    setExtraStyles(container, {
      height: isLandscape ? '' : `${currentContainerHeight}rem`
    });
  }, [isLandscape, currentContainerHeight]);

  // Requests the history when the UI shows a spinner instead of the list.
  // Keeps requesting the history when all the currently loaded activities are hidden.
  teact_useEffect(() => {
    if (!(listItemIds !== null && listItemIds !== void 0 && listItemIds.length)) {
      loadMore();
    }
  }, [slug, allActivityIds, listItemIds, loadMore]);

  // Reset scroll and scroll tracking when the tab becomes inactive
  teact_useEffect(() => {
    if (!isActive && !isLandscape) {
      resetScroll === null || resetScroll === void 0 || resetScroll();
      hasUserScrolledRef.current = false;
    }
  }, [isActive, isLandscape, resetScroll]);
  const handleScroll = useLastCallback(e => {
    const scrollTop = e.target.scrollTop;
    hasUserScrolledRef.current = scrollTop >= SCROLL_THRESHOLD;
    onScroll === null || onScroll === void 0 || onScroll(e);
  });
  const handleActivityClick = useLastCallback(id => {
    showActivityInfo({
      id
    });
  });
  if (!currentAccountId) {
    return undefined;
  }
  function renderDate(dateValue, isFirst) {
    const formattedDate = (0,dateFormat/* formatHumanDay */.N5)(lang, dateValue);
    const date = /*#__PURE__*/teact.createElement("div", {
      className: Activities_module.date
    }, formattedDate);
    if (!isFirst) {
      return date;
    }
    const dateWithLoader = /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Activities_module.date, Activities_module.date_withLoadingDots)
    }, formattedDate, /*#__PURE__*/teact.createElement(ui_LoadingDots, {
      isActive: true,
      isDoubled: true,
      className: Activities_module.loadingDots
    }));
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "semiFade",
      activeKey: isUpdating ? 1 : 0,
      className: Activities_module.dateContainer,
      slideClassName: Activities_module.dateSlide
    }, isUpdating ? dateWithLoader : date);
  }
  function renderHistory() {
    if (!viewportIds) return undefined;
    return viewportIds.map((itemId, index) => {
      var _itemPositionById$ite;
      const topOffset = ((_itemPositionById$ite = itemPositionById[itemId]) === null || _itemPositionById$ite === void 0 ? void 0 : _itemPositionById$ite.top) ?? 0;
      let itemContent;
      if (itemId.startsWith(DATE_ID_PREFIX)) {
        itemContent = renderDate(Number(itemId.slice(DATE_ID_PREFIX.length)), itemId === firstListItemId);
      } else {
        const activity = byId === null || byId === void 0 ? void 0 : byId[itemId];
        if (!activity) return undefined;
        const isActivityActive = activity.id === currentActivityId;
        const isLastInDay = index === viewportIds.length - 1 || viewportIds[index + 1].startsWith(DATE_ID_PREFIX);
        itemContent = /*#__PURE__*/teact.createElement(Activity, {
          activity: activity,
          isLast: isLastInDay,
          isActive: isActivityActive,
          tokensBySlug: tokensBySlug,
          swapTokensBySlug: swapTokensBySlug,
          appTheme: appTheme,
          isSensitiveDataHidden: isSensitiveDataHidden,
          nftsByAddress: nftsByAddress,
          currentAccountId: currentAccountId,
          stakingStateBySlug: stakingStateBySlug,
          savedAddresses: savedAddresses,
          withChainIcon: isMultichainAccount,
          accounts: accounts,
          baseCurrency: baseCurrency,
          onClick: handleActivityClick
        });
      }
      return /*#__PURE__*/teact.createElement(Content_ActivityListItem, {
        key: getListItemKey(itemId),
        topOffset: topOffset,
        withAnimation: shouldUseAnimations
      }, itemContent);
    });
  }
  if (listItemIds === undefined) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Activities_module.emptyList, Activities_module.emptyListLoading)
    }, /*#__PURE__*/teact.createElement(ui_Spinner, null));
  }
  if (!listItemIds.length) {
    if (!slug) {
      return /*#__PURE__*/teact.createElement("div", {
        className: buildClassName(isLandscape && Activities_module.greeting)
      }, /*#__PURE__*/teact.createElement(Content_NewWalletGreeting, {
        isActive: isActive,
        isMutlichainAccount: isMultichainAccount,
        mode: isLandscape ? 'emptyList' : 'panel'
      }));
    } else {
      return /*#__PURE__*/teact.createElement("div", {
        className: Activities_module.emptyList
      }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
        play: isActive,
        tgsUrl: ANIMATED_STICKERS_PATHS.noData,
        previewUrl: ANIMATED_STICKERS_PATHS.noDataPreview,
        size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
        className: Activities_module.sticker,
        noLoop: false,
        nonInteractive: true
      }), /*#__PURE__*/teact.createElement("p", {
        className: Activities_module.emptyListTitle
      }, lang('No Activity')));
    }
  }
  return /*#__PURE__*/teact.createElement(ui_InfiniteScroll, {
    ref: containerRef,
    className: buildClassName('custom-scroll', Activities_module.listGroup),
    scrollContainerClosest: getScrollContainerClosestSelector(isActive, isPortrait),
    items: viewportIds,
    preloadBackwards: FURTHER_SLICE,
    withAbsolutePositioning: true,
    maxHeight: `${currentContainerHeight}rem`,
    onLoadMore: getMore,
    onScroll: handleScroll
  }, renderHistory());
}
/* harmony default export */ const Content_Activities = (memo(withGlobal(global => {
  var _global$swapTokenInfo;
  const accountId = global.currentAccountId;
  const accountState = selectCurrentAccountState(global);
  const accountSettings = selectCurrentAccountSettings(global);
  const slug = accountState === null || accountState === void 0 ? void 0 : accountState.currentTokenSlug;
  const stakingStateBySlug = selectAccountStakingStatesBySlug(global, accountId);
  const {
    byId
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.activities) ?? {};
  const {
    byAddress
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {};
  const accounts = selectAccounts(global);
  const isHistoryEndReached = selectIsHistoryEndReached(global, accountId, slug);
  const allActivityIds = selectActivityHistoryIds(global, accountId, slug);
  return {
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    currentAccountId: accountId,
    slug,
    byId,
    allActivityIds,
    tokensBySlug: global.tokenInfo.bySlug,
    swapTokensBySlug: (_global$swapTokenInfo = global.swapTokenInfo) === null || _global$swapTokenInfo === void 0 ? void 0 : _global$swapTokenInfo.bySlug,
    areTinyTransfersHidden: global.settings.areTinyTransfersHidden,
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    isHistoryEndReached,
    currentActivityId: accountState === null || accountState === void 0 ? void 0 : accountState.currentActivityId,
    alwaysShownSlugs: accountSettings === null || accountSettings === void 0 ? void 0 : accountSettings.alwaysShownSlugs,
    theme: global.settings.theme,
    baseCurrency: global.settings.baseCurrency,
    stakingStateBySlug,
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden,
    nftsByAddress: byAddress,
    accounts
  };
}, (global, _ref2, stickToFirst) => {
  let {
    totalTokensAmount
  } = _ref2;
  const accountState = selectCurrentAccountState(global);
  const shouldShowSeparateAssetsPanel = totalTokensAmount <= (getIsPortrait() ? src_config/* PORTRAIT_MIN_ASSETS_TAB_VIEW */.nj6 : src_config/* LANDSCAPE_MIN_ASSETS_TAB_VIEW */.hUs);
  return stickToFirst(((accountState === null || accountState === void 0 ? void 0 : accountState.activeContentTab) === ContentTab.Activity || (accountState === null || accountState === void 0 ? void 0 : accountState.activeContentTab) === ContentTab.Assets && shouldShowSeparateAssetsPanel) && global.currentAccountId);
})(Activities)));
function filterActivityIds(allActivityIds, byId, slug, tokensBySlug, areTinyTransfersHidden, alwaysShownSlugs) {
  return allActivityIds.filter(id => {
    const activity = byId === null || byId === void 0 ? void 0 : byId[id];
    if (!activity) return false;
    if (activity !== null && activity !== void 0 && activity.shouldHide) return false;
    if ((activity === null || activity === void 0 ? void 0 : activity.kind) === 'swap') {
      return !slug || activity.from === slug || activity.to === slug;
    } else {
      var _tokensBySlug$activit;
      return (activity === null || activity === void 0 ? void 0 : activity.slug) && (!slug || activity.slug === slug) && (!areTinyTransfersHidden || slug && ((_tokensBySlug$activit = tokensBySlug[activity.slug]) === null || _tokensBySlug$activit === void 0 ? void 0 : _tokensBySlug$activit.priceUsd) === 0 || !getIsTinyOrScamTransaction(activity, tokensBySlug[activity.slug]) || (alwaysShownSlugs === null || alwaysShownSlugs === void 0 ? void 0 : alwaysShownSlugs.includes(activity.slug))) && !getIsTransactionWithPoisoning(activity);
    }
  });
}
function addDatesToActivityIds(activityIds) {
  let byId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let lastActivityDayStart = Infinity;
  const listItemIds = [];

  // Mix-in the date headers to the list of activity ids
  for (const activityId of activityIds) {
    const activityDayStart = (0,dateFormat/* getDayStartAt */.CS)(byId[activityId].timestamp);

    // The clause is not `activityDayStart !== lastActivityDayStart`, because the days can go backwards, which will
    // cause duplicated date Teact keys. The days can go backwards because the pending activities are on the top
    // regardless of their timestamp.
    const isNewDay = activityDayStart < lastActivityDayStart;
    if (isNewDay) {
      lastActivityDayStart = activityDayStart;
      listItemIds.push(`${DATE_ID_PREFIX}${activityDayStart}`);
    }
    listItemIds.push(activityId);
  }
  return listItemIds;
}

/**
 * Pending activity ids may change. If the ids are used as the list keys, excessive blinking animations occur.
 * This hook creates stable keys for the list items, which prevents the excessive animations.
 */
function useListItemKeys(viewportIds, activityById) {
  const keyByIdRef = teact_useRef();
  keyByIdRef.current ??= {};
  useSyncEffectWithPrevDeps(_ref3 => {
    let [oldViewportIds = [], oldActivityById = {}] = _ref3;
    const keyById = keyByIdRef.current;
    const oldActivities = (0,iteratees/* compact */.oE)(oldViewportIds.map(id => oldActivityById[id]));
    const newActivities = (0,iteratees/* compact */.oE)(viewportIds.map(id => activityById[id]));

    // Transfer the keys from the old activities to the new activities. Besides the obvious goal, `swapKeysAndValues`
    // ensures that the `idReplacements` values are unique, which results into unique output keys.
    const idReplacements = (0,iteratees/* swapKeysAndValues */.V6)(getActivityIdReplacements(oldActivities, newActivities));
    for (const {
      id: newActivityId
    } of newActivities) {
      const oldActivityId = idReplacements[newActivityId];
      keyById[newActivityId] = (oldActivityId && keyById[oldActivityId]) ?? (0,generateUniqueId/* default */.A)();
    }

    // Clean the memory
    const newActivityIds = new Set(viewportIds);
    for (const itemId of Object.keys(keyById)) {
      if (!newActivityIds.has(itemId)) {
        delete keyById[itemId];
      }
    }
  }, [viewportIds, activityById]);
  return useLastCallback(itemId => {
    var _keyByIdRef$current;
    return ((_keyByIdRef$current = keyByIdRef.current) === null || _keyByIdRef$current === void 0 ? void 0 : _keyByIdRef$current[itemId]) ?? itemId;
  });
}

/**
 * In order to make the list look stationary after it has been scrolled, this hook compensates the scroll position when
 * new items are added and user scrolled content.
 */
function usePreventScrolledListShift(viewportIds, itemPositionById, isPortrait, containerRef, hasUserScrolledRef) {
  hooks_useLayoutEffectWithPrevDeps(_ref4 => {
    var _prevItemPositionById, _itemPositionById$anc;
    let [prevItemPositionById] = _ref4;
    const container = getScrollableContainer(containerRef.current, isPortrait);
    if (!hasUserScrolledRef.current || !container || !prevItemPositionById || !viewportIds.length) return;
    const anchorId = viewportIds[Math.floor(viewportIds.length / 2)];
    const prevTop = (_prevItemPositionById = prevItemPositionById[anchorId]) === null || _prevItemPositionById === void 0 ? void 0 : _prevItemPositionById.top;
    const nextTop = (_itemPositionById$anc = itemPositionById[anchorId]) === null || _itemPositionById$anc === void 0 ? void 0 : _itemPositionById$anc.top;
    if (prevTop === undefined || nextTop === undefined || prevTop === nextTop) return;
    (0,stricterdom/* forceMeasure */.Uj)(() => {
      container.scrollBy({
        top: (nextTop - prevTop) * windowEnvironment/* REM */.$,
        behavior: 'instant'
      });
    });
  }, [itemPositionById, viewportIds, containerRef, hasUserScrolledRef, isPortrait]);
}
;// ./src/hooks/useVesting.ts





function useVesting(_ref) {
  let {
    vesting,
    userMycoin,
    isDisabled
  } = _ref;
  const {
    loadMycoin,
    openVestingModal
  } = getActions();
  const hasVesting = !isDisabled && Boolean(vesting === null || vesting === void 0 ? void 0 : vesting.length);
  const isMycoinLoaded = Boolean(userMycoin);
  teact_useEffect(() => {
    if (isMycoinLoaded || !hasVesting) return;
    loadMycoin();
  }, [hasVesting, isMycoinLoaded]);
  const amount = teact_useMemo(() => {
    if (!hasVesting) return undefined;
    return calcVestingAmountByStatus(vesting, ['frozen', 'ready']);
  }, [hasVesting, vesting]);
  const unfreezeEndDate = teact_useMemo(() => {
    if (!hasVesting) return undefined;
    for (const {
      parts
    } of vesting) {
      for (const part of parts) {
        if (part.status === 'ready') {
          return new Date(part.timeEnd).getTime();
        }
      }
    }
    return undefined;
  }, [hasVesting, vesting]);
  const {
    shouldRender,
    ref
  } = useShowTransition({
    isOpen: Boolean(hasVesting && isMycoinLoaded && userMycoin && amount !== '0'),
    withShouldRender: true
  });
  const onVestingTokenClick = useLastCallback(() => {
    openVestingModal();
  });
  return {
    shouldRender,
    ref,
    amount,
    vestingStatus: unfreezeEndDate ? 'readyToUnfreeze' : 'frozen',
    unfreezeEndDate,
    onVestingTokenClick
  };
}
;// ./src/components/main/sections/Content/hooks/useTokenContextMenu.ts










function useTokenContextMenu(ref, options) {
  const {
    openReceiveModal,
    startTransfer,
    startSwap,
    startStaking,
    openSettingsWithState,
    toggleTokenVisibility,
    setLandscapeActionsActiveTabIndex,
    setReceiveActiveTab,
    startUnstaking,
    startStakingClaim
  } = getActions();
  const {
    token,
    isPortrait,
    withContextMenu,
    isStakingAvailable,
    isSwapDisabled,
    isViewMode,
    stakingState
  } = options;
  const {
    isContextMenuOpen,
    contextMenuAnchor,
    handleBeforeContextMenu,
    handleContextMenu,
    handleContextMenuClose,
    handleContextMenuHide
  } = hooks_useContextMenuHandlers({
    elementRef: ref,
    isMenuDisabled: !withContextMenu
  });
  const isServiceToken = getIsServiceToken(token);
  const stakingId = stakingState === null || stakingState === void 0 ? void 0 : stakingState.id;
  const isContextMenuShown = contextMenuAnchor !== undefined;
  const canBeClaimed = stakingState ? getStakingStateStatus(stakingState) === 'readyToClaim' : undefined;
  const hasUnclaimedRewards = (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'jetton' ? !!stakingState.unclaimedRewards : undefined;
  const items = teact_useMemo(() => {
    const mandatoryItems = [!stakingId && {
      name: 'Hide',
      fontIcon: 'eye-closed',
      value: 'hide'
    }, {
      name: 'Manage Tokens',
      fontIcon: 'menu-params',
      withDelimiter: !(isViewMode && stakingId),
      value: 'settings'
    }];
    if (isViewMode) {
      return (0,iteratees/* compact */.oE)(mandatoryItems);
    }
    const result = stakingId ? [((stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) !== 'ethena' || !canBeClaimed) && {
      name: (stakingState === null || stakingState === void 0 ? void 0 : stakingState.type) === 'ethena' ? 'Request Unstaking' : 'Unstake',
      fontIcon: 'menu-send',
      value: 'unstake'
    }, {
      name: 'Stake More',
      fontIcon: 'menu-receive',
      value: 'stakeMore'
    }, (canBeClaimed || hasUnclaimedRewards) && {
      name: 'Claim Rewards',
      fontIcon: 'menu-gem',
      value: 'claimRewards'
    }] : [!isServiceToken && {
      name: 'Add / Buy',
      fontIcon: 'menu-plus',
      value: 'add'
    }, {
      name: 'Send',
      fontIcon: 'menu-send',
      value: 'send'
    }, !isSwapDisabled && {
      name: 'Swap',
      fontIcon: 'menu-swap',
      value: 'swap'
    }, isStakingAvailable && {
      name: 'Stake',
      fontIcon: 'menu-percent',
      value: 'stake'
    }];
    return (0,iteratees/* compact */.oE)(result.concat(mandatoryItems));
  }, [canBeClaimed, hasUnclaimedRewards, isStakingAvailable, isSwapDisabled, isViewMode, stakingId, stakingState === null || stakingState === void 0 ? void 0 : stakingState.type, isServiceToken]);
  const handleMenuItemSelect = useLastCallback(value => {
    void vibrate();
    switch (value) {
      case 'add':
        if (isPortrait) {
          openReceiveModal({
            chain: token.chain
          });
        } else {
          setReceiveActiveTab({
            chain: token.chain
          });
          setLandscapeActionsActiveTabIndex({
            index: ActiveTab.Receive
          });
        }
        break;
      case 'send':
        startTransfer({
          isPortrait,
          tokenSlug: token.slug
        });
        break;
      case 'swap':
        startSwap({
          tokenInSlug: token.slug,
          tokenOutSlug: token.slug === src_config/* DEFAULT_SWAP_FIRST_TOKEN_SLUG */.JhS ? src_config/* DEFAULT_SWAP_SECOND_TOKEN_SLUG */.rKC : src_config/* DEFAULT_SWAP_FIRST_TOKEN_SLUG */.JhS
        });
        break;
      case 'stake':
      case 'stakeMore':
        startStaking({
          tokenSlug: token.slug
        });
        break;
      case 'settings':
        openSettingsWithState({
          state: SettingsState.Assets
        });
        break;
      case 'hide':
        toggleTokenVisibility({
          slug: token.slug,
          shouldShow: false
        });
        break;
      case 'unstake':
        startUnstaking({
          stakingId: stakingId
        });
        break;
      case 'claimRewards':
        startStakingClaim({
          stakingId: stakingId
        });
        break;
    }
    handleContextMenuClose();
  });
  return {
    isContextMenuOpen,
    isContextMenuShown,
    contextMenuAnchor,
    items,
    isBackdropRendered: isPortrait && isContextMenuOpen,
    handleBeforeContextMenu,
    handleContextMenu,
    handleContextMenuClose,
    handleContextMenuHide,
    handleMenuItemSelect
  };
}
/* harmony default export */ const hooks_useTokenContextMenu = (useTokenContextMenu);
;// ./src/components/main/sections/Content/Token.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Token_module = ({"container":"Token-module__container","button":"Token-module__button","vestingIcon":"Token-module__vestingIcon","percent":"Token-module__percent","readyToClaim":"Token-module__readyToClaim","active":"Token-module__active","iconArrow":"Token-module__iconArrow","iconChevron":"Token-module__iconChevron","primaryCell":"Token-module__primaryCell","secondaryCell":"Token-module__secondaryCell","subtitle":"Token-module__subtitle","amountChange":"Token-module__amountChange","name":"Token-module__name","name_text":"Token-module__name_text","nameText":"Token-module__name_text","secondaryValue":"Token-module__secondaryValue","secondaryValue_staked":"Token-module__secondaryValue_staked","secondaryValueStaked":"Token-module__secondaryValue_staked","change":"Token-module__change","change_up":"Token-module__change_up","changeUp":"Token-module__change_up","change_down":"Token-module__change_down","changeDown":"Token-module__change_down","dot":"Token-module__dot","label":"Token-module__label","apyLabel":"Token-module__apyLabel","apyLabel_staked":"Token-module__apyLabel_staked","apyLabelStaked":"Token-module__apyLabel_staked","chainLabel":"Token-module__chainLabel","tokenIcon":"Token-module__tokenIcon","secondaryValue_vesting":"Token-module__secondaryValue_vesting","secondaryValueVesting":"Token-module__secondaryValue_vesting","secondaryValue_vestingUnfreeze":"Token-module__secondaryValue_vestingUnfreeze","secondaryValueVestingUnfreeze":"Token-module__secondaryValue_vestingUnfreeze","wrapperVisible":"Token-module__wrapperVisible","menu":"Token-module__menu"});
;// ./src/components/main/sections/Content/Token.tsx
























const UNFREEZE_DANGER_DURATION = 7 * dateFormat/* DAY */.d_;
const CONTEXT_MENU_VERTICAL_SHIFT_PX = 4;
const OPEN_CONTEXT_MENU_CLASS_NAME = 'open-context-menu';
function Token_Token(_ref) {
  let {
    ref,
    token,
    amount,
    stakingStatus,
    stakingState,
    vestingStatus,
    unfreezeEndDate,
    annualYield,
    isInvestorView,
    classNames,
    style,
    appTheme,
    isActive,
    baseCurrency,
    withChainIcon,
    withContextMenu,
    isSensitiveDataHidden,
    isStakingAvailable,
    isSwapDisabled,
    isViewMode,
    yieldType,
    onClick
  } = _ref;
  const {
    symbol,
    slug,
    amount: tokenAmount,
    price,
    change24h: change,
    decimals
  } = token;
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  let buttonRef = teact_useRef();
  const menuRef = teact_useRef();
  const isVesting = Boolean(vestingStatus === null || vestingStatus === void 0 ? void 0 : vestingStatus.length);
  const renderedAmount = amount ?? (0,util_decimals/* toDecimal */.nI)(tokenAmount, decimals, true);
  const value = (0,big_js/* Big */.z)(renderedAmount).mul(price).toString();
  const changeClassName = change > 0 ? Token_module.change_up : change < 0 ? Token_module.change_down : undefined;
  const changeValue = Math.abs(round(calcChangeValue(Number(value), change), 4));
  const changePercent = Math.abs(round(change * 100, 2));
  const withYield = !src_config/* IS_CORE_WALLET */.TI6 && annualYield !== undefined;
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  const withLabel = Boolean(!isVesting && src_config/* TOKEN_WITH_LABEL */.OZB[slug]);
  const stakingId = stakingState === null || stakingState === void 0 ? void 0 : stakingState.id;
  const name = getTokenName(lang, token, !!stakingId);
  const amountCols = teact_useMemo(() => getPseudoRandomNumber(4, 12, name), [name]);
  const fiatAmountCols = 5 + amountCols % 6;
  if (ref) {
    buttonRef = ref;
  }
  const {
    shouldRender: shouldRenderYield,
    ref: yieldRef
  } = useShowTransition({
    isOpen: withYield,
    withShouldRender: true
  });
  const handleClick = useLastCallback(() => {
    onClick(stakingId ?? slug);
  });
  const getTriggerElement = useLastCallback(() => buttonRef.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true,
    doNotCoverTrigger: isPortrait,
    // The shift is needed to prevent the mouse cursor from highlighting the first menu item
    topShiftY: !isPortrait ? CONTEXT_MENU_VERTICAL_SHIFT_PX : undefined,
    preferredPositionX: 'left'
  }));
  const {
    isContextMenuOpen,
    isContextMenuShown,
    contextMenuAnchor,
    items,
    isBackdropRendered,
    handleBeforeContextMenu,
    handleContextMenu,
    handleContextMenuClose,
    handleContextMenuHide,
    handleMenuItemSelect
  } = hooks_useTokenContextMenu(buttonRef, {
    token,
    isPortrait,
    withContextMenu,
    isStakingAvailable,
    isSwapDisabled,
    isViewMode,
    stakingState
  });
  function renderYield() {
    const labelClassName = buildClassName(Token_module.label, Token_module.apyLabel, stakingStatus && Token_module.apyLabel_staked);
    return /*#__PURE__*/teact.createElement("span", {
      ref: yieldRef,
      className: labelClassName
    }, yieldType, " ", round(annualYield ?? 0, 2), "%");
  }
  function renderChangeIcon() {
    if (change === 0) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Token_module.iconArrow, change > 0 ? 'icon-arrow-up' : 'icon-arrow-down'),
      "aria-hidden": true
    });
  }
  function renderStakingIcon() {
    if (stakingStatus === 'active') {
      return /*#__PURE__*/teact.createElement("i", {
        className: buildClassName('icon-percent', Token_module.percent),
        "aria-hidden": true
      });
    }
    if (stakingStatus === 'readyToClaim') {
      return /*#__PURE__*/teact.createElement("i", {
        className: buildClassName('icon-check-alt', Token_module.readyToClaim),
        "aria-hidden": true
      });
    }
    return /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: true,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      className: Token_module.percent,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClockPurple,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClockPurple
    });
  }
  const fullClassName = buildClassName(Token_module.button, isActive && Token_module.active, isContextMenuOpen && OPEN_CONTEXT_MENU_CLASS_NAME);
  function renderInvestorView() {
    return /*#__PURE__*/teact.createElement(ui_Button, {
      ref: buttonRef,
      isSimple: true,
      className: fullClassName,
      onMouseDown: handleBeforeContextMenu,
      onContextMenu: handleContextMenu,
      onClick: handleClick
    }, /*#__PURE__*/teact.createElement(common_TokenIcon, {
      size: "large",
      token: token,
      withChainIcon: withChainIcon,
      className: Token_module.tokenIcon
    }, /*#__PURE__*/teact.createElement(teact.Fragment, null, stakingStatus && renderStakingIcon(), vestingStatus && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(vestingStatus === 'frozen' ? 'icon-snow' : 'icon-fire', Token_module.vestingIcon),
      "aria-hidden": true
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Token_module.primaryCell
    }, /*#__PURE__*/teact.createElement("div", {
      className: Token_module.name
    }, /*#__PURE__*/teact.createElement("span", {
      className: Token_module.nameText
    }, name), shouldRenderYield && renderYield(), withLabel && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Token_module.label, Token_module.chainLabel)
    }, src_config/* TOKEN_WITH_LABEL */.OZB[slug])), /*#__PURE__*/teact.createElement("div", {
      className: Token_module.subtitle
    }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: fiatAmountCols,
      rows: 2,
      cellSize: 8
    }, /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(renderedAmount, symbol)
    })), /*#__PURE__*/teact.createElement("i", {
      className: Token_module.dot,
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(price, shortBaseSymbol, undefined, true)
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Token_module.secondaryCell
    }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: amountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      className: buildClassName(Token_module.secondaryValue, stakingStatus && Token_module.secondaryValue_staked, isVesting && Token_module.secondaryValue_vesting, isVesting && vestingStatus === 'readyToUnfreeze' && Token_module.secondaryValue_vestingUnfreeze)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(value, shortBaseSymbol)
    })), unfreezeEndDate ? /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Token_module.change, unfreezeEndDate - Date.now() < UNFREEZE_DANGER_DURATION && Token_module.change_down)
    }, lang('Unfreeze'), ' ', lang('until %date%', {
      date: `${(0,dateFormat/* formatFullDay */.TK)(lang.code, unfreezeEndDate)}`
    })) : /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: fiatAmountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      className: buildClassName(Token_module.change, changeClassName)
    }, renderChangeIcon(), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: String(changePercent)
    }), "%", /*#__PURE__*/teact.createElement("i", {
      className: Token_module.dot,
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(changeValue, shortBaseSymbol, undefined, true)
    }))));
  }
  function renderDefaultView() {
    const totalAmount = (0,big_js/* Big */.z)(renderedAmount).mul(price);
    const canRenderYield = annualYield !== undefined;
    return /*#__PURE__*/teact.createElement(ui_Button, {
      ref: buttonRef,
      isSimple: true,
      className: fullClassName,
      onMouseDown: handleBeforeContextMenu,
      onContextMenu: handleContextMenu,
      onClick: handleClick
    }, /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: token,
      size: "large",
      withChainIcon: withChainIcon,
      className: Token_module.tokenIcon
    }, /*#__PURE__*/teact.createElement(teact.Fragment, null, stakingStatus && renderStakingIcon(), vestingStatus && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(vestingStatus === 'frozen' ? 'icon-snow' : 'icon-fire', Token_module.vestingIcon),
      "aria-hidden": true
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Token_module.primaryCell
    }, /*#__PURE__*/teact.createElement("div", {
      className: Token_module.name
    }, /*#__PURE__*/teact.createElement("span", {
      className: Token_module.nameText
    }, name), canRenderYield && renderYield(), withLabel && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Token_module.label, Token_module.chainLabel)
    }, src_config/* TOKEN_WITH_LABEL */.OZB[slug])), /*#__PURE__*/teact.createElement("div", {
      className: Token_module.subtitle
    }, /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(price, shortBaseSymbol, undefined, true)
    }), !stakingStatus && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("i", {
      className: Token_module.dot,
      "aria-hidden": true
    }), unfreezeEndDate ? /*#__PURE__*/teact.createElement("span", {
      className: unfreezeEndDate - Date.now() < UNFREEZE_DANGER_DURATION && Token_module.change_down
    }, lang('Unfreeze'), ' ', lang('until %date%', {
      date: `${(0,dateFormat/* formatFullDay */.TK)(lang.code, unfreezeEndDate)}`
    })) : /*#__PURE__*/teact.createElement("span", {
      className: changeClassName
    }, renderChangeIcon(), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: String(changePercent)
    }), "%")))), /*#__PURE__*/teact.createElement("div", {
      className: Token_module.secondaryCell
    }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: amountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      className: buildClassName(Token_module.secondaryValue, stakingStatus && Token_module.secondaryValue_staked, isVesting && Token_module.secondaryValue_vesting, isVesting && vestingStatus === 'readyToUnfreeze' && Token_module.secondaryValue_vestingUnfreeze)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(renderedAmount, symbol)
    })), /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: fiatAmountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      className: Token_module.subtitle
    }, totalAmount.gt(0) ? 'â‰ˆ' : '', "\u2009", /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency(totalAmount, shortBaseSymbol, undefined, true)
    }))));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Token_module.container, classNames),
    style: style
  }, /*#__PURE__*/teact.createElement(ui_MenuBackdrop, {
    isMenuOpen: isBackdropRendered,
    contentRef: buttonRef,
    contentClassName: Token_module.wrapperVisible
  }), isInvestorView ? renderInvestorView() : renderDefaultView(), withContextMenu && isContextMenuShown && /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    ref: menuRef,
    withPortal: true,
    shouldTranslateOptions: true,
    isOpen: isContextMenuOpen,
    items: items,
    menuAnchor: contextMenuAnchor,
    bubbleClassName: Token_module.menu,
    fontIconClassName: Token_module.menuIcon,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    onSelect: handleMenuItemSelect,
    onClose: handleContextMenuClose,
    onCloseAnimationEnd: handleContextMenuHide
  }));
}
function getTokenName(lang, token, isStaking) {
  if (!isStaking) {
    return token.name;
  }
  switch (token.slug) {
    case src_config/* TON_USDE */.wpN.slug:
      return lang('%token% Staking', {
        token: 'Ethena'
      })[0];
    default:
      return lang('%token% Staking', {
        token: token.name
      })[0];
  }
}
/* harmony default export */ const Content_Token = (memo(Token_Token));
;// ./src/components/main/sections/Content/Assets.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Assets_module = ({"wrapper":"Assets-module__wrapper","wrapperLoading":"Assets-module__wrapperLoading","emptyList":"Assets-module__emptyList","emptyListSeparate":"Assets-module__emptyListSeparate","noTokens":"Assets-module__noTokens","noTokens_text":"Assets-module__noTokens_text","noTokensText":"Assets-module__noTokens_text","noTokens_header":"Assets-module__noTokens_header","noTokensHeader":"Assets-module__noTokens_header","noTokens_description":"Assets-module__noTokens_description","noTokensDescription":"Assets-module__noTokens_description","openSettingsButton":"Assets-module__openSettingsButton"});
;// ./src/components/main/sections/Content/Assets.tsx


























const LIST_SLICE = 30;
const TOKEN_HEIGHT_REM = 4;
function Assets(_ref) {
  let {
    isActive,
    tokens,
    swapTokens,
    vesting,
    isInvestorViewEnabled,
    isSeparatePanel,
    currentTokenSlug,
    onTokenClick,
    onStakedTokenClick,
    baseCurrency,
    mycoin,
    isMultichainAccount,
    isSensitiveDataHidden,
    theme,
    states,
    isViewMode,
    isSwapDisabled,
    isStakingDisabled,
    onScroll
  } = _ref;
  const lang = hooks_useLang();
  const {
    openSettingsWithState
  } = getActions();
  const containerRef = teact_useRef();
  const renderedTokens = useCurrentOrPrev(tokens, true);
  const renderedMycoin = useCurrentOrPrev(mycoin, true);
  const userMycoin = teact_useMemo(() => {
    if (!renderedTokens || !renderedMycoin) return undefined;
    return renderedTokens.find(_ref2 => {
      let {
        slug
      } = _ref2;
      return slug === renderedMycoin.slug;
    });
  }, [renderedMycoin, renderedTokens]);
  const {
    isLandscape,
    isPortrait
  } = useDeviceScreen();
  const appTheme = hooks_useAppTheme(theme);
  const activeStates = teact_useMemo(() => {
    if (src_config/* IS_CORE_WALLET */.TI6) return [];
    return (states === null || states === void 0 ? void 0 : states.filter(getIsActiveStakingState)) ?? [];
  }, [states]);
  const stakedTokens = teact_useMemo(() => {
    return activeStates.reduce((prevValue, state) => {
      const token = tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref3 => {
        let {
          slug
        } = _ref3;
        return slug === state.tokenSlug;
      });
      if (token) {
        prevValue[state.tokenSlug] = {
          token,
          state
        };
      }
      return prevValue;
    }, {});
  }, [tokens, activeStates]);
  const swapTokensBySlug = teact_useMemo(() => {
    return (0,iteratees/* buildCollectionByKey */.dU)(swapTokens ?? [], 'slug');
  }, [swapTokens]);
  const {
    shouldRender: shouldRenderStakedTokens
  } = useShowTransition({
    isOpen: Boolean(Object.keys(stakedTokens).length),
    withShouldRender: true
  });
  const {
    ref: vestingTokenRef,
    shouldRender: shouldRenderVestingToken,
    amount: vestingAmount,
    vestingStatus,
    unfreezeEndDate,
    onVestingTokenClick
  } = useVesting({
    vesting,
    userMycoin,
    isDisabled: src_config/* IS_CORE_WALLET */.TI6
  });
  const tokenSlugs = teact_useMemo(() => renderedTokens === null || renderedTokens === void 0 ? void 0 : renderedTokens.filter(_ref4 => {
    let {
      isDisabled
    } = _ref4;
    return !isDisabled;
  }).map(_ref5 => {
    let {
      slug
    } = _ref5;
    return slug;
  }), [renderedTokens]);
  const [viewportSlugs, getMore] = hooks_useInfiniteScroll(undefined, tokenSlugs, undefined, undefined, undefined, isActive, isPortrait);
  const viewportIndex = teact_useMemo(() => {
    if (!viewportSlugs) return -1;
    let index = tokenSlugs.indexOf(viewportSlugs[0]);
    if (shouldRenderStakedTokens) {
      index += Object.keys(stakedTokens).length;
    }
    if (shouldRenderVestingToken) {
      index++;
    }
    return index;
  }, [shouldRenderStakedTokens, shouldRenderVestingToken, tokenSlugs, viewportSlugs, stakedTokens]);
  const tokensBySlug = teact_useMemo(() => renderedTokens ? (0,iteratees/* buildCollectionByKey */.dU)(renderedTokens, 'slug') : undefined, [renderedTokens]);
  const withAbsolutePositioning = tokenSlugs && tokenSlugs.length > LIST_SLICE;
  const currentContainerHeight = teact_useMemo(() => {
    if (!withAbsolutePositioning || !(viewportSlugs !== null && viewportSlugs !== void 0 && viewportSlugs.length) || viewportIndex < 0) return undefined;
    return (viewportIndex + viewportSlugs.length) * TOKEN_HEIGHT_REM;
  }, [viewportIndex, viewportSlugs === null || viewportSlugs === void 0 ? void 0 : viewportSlugs.length, withAbsolutePositioning]);
  useLayoutEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    setExtraStyles(container, {
      height: currentContainerHeight && !isLandscape ? `${currentContainerHeight}rem` : ''
    });
  }, [isLandscape, currentContainerHeight]);
  const handleOpenTokenSettings = useLastCallback(() => {
    openSettingsWithState({
      state: SettingsState.Assets
    });
  });
  const stateByTokenSlug = (0,iteratees/* buildCollectionByKey */.dU)(states ?? [], 'tokenSlug');
  function renderVestingToken() {
    return /*#__PURE__*/teact.createElement(Content_Token, {
      ref: vestingTokenRef,
      key: "vesting",
      token: userMycoin,
      vestingStatus: vestingStatus,
      unfreezeEndDate: unfreezeEndDate,
      amount: vestingAmount,
      isInvestorView: isInvestorViewEnabled,
      baseCurrency: baseCurrency,
      appTheme: appTheme,
      isSensitiveDataHidden: isSensitiveDataHidden,
      onClick: onVestingTokenClick
    });
  }
  function renderStakedTokens() {
    return Object.values(stakedTokens).map(_ref6 => {
      let {
        state,
        token
      } = _ref6;
      const {
        id,
        annualYield,
        yieldType
      } = state;
      const stakingStatus = getStakingStateStatus(state);
      const stakingBalance = getFullStakingBalance(state);
      return /*#__PURE__*/teact.createElement(Content_Token, {
        key: `staking-${id}`,
        token: token,
        stakingStatus: stakingStatus,
        annualYield: annualYield,
        yieldType: yieldType,
        amount: (0,util_decimals/* toDecimal */.nI)(stakingBalance, token.decimals),
        isInvestorView: isInvestorViewEnabled,
        baseCurrency: baseCurrency,
        appTheme: appTheme,
        isSensitiveDataHidden: isSensitiveDataHidden,
        withContextMenu: true,
        isViewMode: isViewMode,
        isSwapDisabled: isSwapDisabled,
        stakingState: state,
        onClick: onStakedTokenClick
      });
    });
  }
  function renderToken(token, indexInViewport) {
    const style = withAbsolutePositioning ? `position: absolute; top: ${(viewportIndex + indexInViewport) * TOKEN_HEIGHT_REM}rem` : undefined;
    const {
      annualYield,
      yieldType
    } = !(token.slug in stakedTokens) && stateByTokenSlug[token.slug] || {};
    const isStakingAvailable = Boolean(!isStakingDisabled && stateByTokenSlug[token.slug]);
    const isSwapAvailable = Boolean(swapTokensBySlug[token.slug]);
    return /*#__PURE__*/teact.createElement(Content_Token, {
      classNames: "token-list-item",
      style: style,
      key: token.slug,
      token: token,
      annualYield: annualYield,
      yieldType: yieldType,
      isInvestorView: isInvestorViewEnabled,
      isActive: token.slug === currentTokenSlug,
      baseCurrency: baseCurrency,
      withChainIcon: isMultichainAccount,
      appTheme: appTheme,
      isSensitiveDataHidden: isSensitiveDataHidden,
      withContextMenu: true,
      isViewMode: isViewMode,
      isStakingAvailable: isStakingAvailable,
      isSwapDisabled: isSwapDisabled || !isSwapAvailable,
      onClick: onTokenClick
    });
  }
  const isEmpty = !shouldRenderVestingToken && !shouldRenderStakedTokens && !(tokenSlugs !== null && tokenSlugs !== void 0 && tokenSlugs.length);
  if (isEmpty) {
    return /*#__PURE__*/teact.createElement("div", {
      className: Assets_module.noTokens
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      tgsUrl: ANIMATED_STICKERS_PATHS.noData,
      previewUrl: ANIMATED_STICKERS_PATHS.noDataPreview,
      size: src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp,
      nonInteractive: true,
      noLoop: false,
      className: Assets_module.sticker
    }), /*#__PURE__*/teact.createElement("div", {
      className: Assets_module.noTokensText
    }, /*#__PURE__*/teact.createElement("span", {
      className: Assets_module.noTokensHeader
    }, lang('No tokens yet')), /*#__PURE__*/teact.createElement("span", {
      className: Assets_module.noTokensDescription
    }, lang('$no_tokens_description')), /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleOpenTokenSettings,
      isPrimary: true,
      isSmall: true,
      className: Assets_module.openSettingsButton
    }, lang('Add Tokens'))));
  }
  return /*#__PURE__*/teact.createElement(ui_InfiniteScroll, {
    ref: containerRef,
    className: buildClassName(Assets_module.wrapper, isSeparatePanel && !renderedTokens && Assets_module.wrapperLoading),
    scrollContainerClosest: getScrollContainerClosestSelector(isActive, isPortrait),
    items: viewportSlugs,
    itemSelector: ".token-list-item",
    withAbsolutePositioning: withAbsolutePositioning,
    maxHeight: currentContainerHeight === undefined ? undefined : `${currentContainerHeight}rem`,
    onLoadMore: getMore,
    onScroll: onScroll
  }, !renderedTokens && /*#__PURE__*/teact.createElement("div", {
    key: "loading",
    className: isSeparatePanel ? Assets_module.emptyListSeparate : Assets_module.emptyList
  }, /*#__PURE__*/teact.createElement(ui_Spinner, null)), shouldRenderVestingToken && renderVestingToken(), shouldRenderStakedTokens && renderStakedTokens(), viewportSlugs === null || viewportSlugs === void 0 ? void 0 : viewportSlugs.map((tokenSlug, i) => renderToken(tokensBySlug[tokenSlug], i)));
}
/* harmony default export */ const Content_Assets = (memo(withGlobal(global => {
  var _accountState$vesting;
  const accountId = global.currentAccountId;
  const tokens = selectCurrentAccountTokens(global);
  const swapTokens = selectSwapTokens(global);
  const accountState = selectCurrentAccountState(global);
  const {
    isInvestorViewEnabled
  } = global.settings;
  const states = selectAccountStakingStates(global, accountId);
  const isViewMode = selectIsCurrentAccountViewMode(global);
  return {
    tokens,
    swapTokens,
    vesting: accountState === null || accountState === void 0 || (_accountState$vesting = accountState.vesting) === null || _accountState$vesting === void 0 ? void 0 : _accountState$vesting.info,
    isInvestorViewEnabled,
    currentTokenSlug: accountState === null || accountState === void 0 ? void 0 : accountState.currentTokenSlug,
    baseCurrency: global.settings.baseCurrency,
    mycoin: selectMycoin(global),
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden,
    theme: global.settings.theme,
    states,
    isViewMode,
    isSwapDisabled: selectIsSwapDisabled(global),
    isStakingDisabled: selectIsStakingDisabled(global)
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Assets)));
;// ./src/components/main/sections/Content/NftCollectionHeader.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const NftCollectionHeader_module = ({"root":"NftCollectionHeader-module__root","backButton":"NftCollectionHeader-module__backButton","backIcon":"NftCollectionHeader-module__backIcon","content":"NftCollectionHeader-module__content","title":"NftCollectionHeader-module__title","amount":"NftCollectionHeader-module__amount","menuButton":"NftCollectionHeader-module__menuButton","menu":"NftCollectionHeader-module__menu","menuItem":"NftCollectionHeader-module__menuItem","menuItemDescription":"NftCollectionHeader-module__menuItemDescription","sendAllButton":"NftCollectionHeader-module__sendAllButton","burnAllButton":"NftCollectionHeader-module__burnAllButton","buttonIcon":"NftCollectionHeader-module__buttonIcon"});
;// ./src/components/main/sections/Content/NftCollectionHeader.tsx


















function NftCollectionHeader(_ref) {
  let {
    currentCollectionAddress,
    nfts,
    isTestnet,
    isViewMode,
    collectionTabs,
    dnsExpiration
  } = _ref;
  const {
    closeNftCollection,
    selectNfts,
    startTransfer,
    burnNfts,
    openHideNftModal,
    addCollectionTab,
    removeCollectionTab,
    openDomainRenewalModal
  } = getActions();
  const lang = hooks_useLang();
  const [menuAnchor, setMenuAnchor] = useState();
  const isMenuOpen = Boolean(menuAnchor);
  const ref = teact_useRef();
  const menuRef = teact_useRef();
  const isTelegramGifts = currentCollectionAddress === src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R;
  const collectionNfts = teact_useMemo(() => {
    if (!currentCollectionAddress || !nfts) {
      return [];
    }
    return Object.values(nfts).filter(nft => {
      return isTelegramGifts && nft.isTelegramGift || nft.collectionAddress === currentCollectionAddress;
    });
  }, [currentCollectionAddress, isTelegramGifts, nfts]);
  const dnsExpireInDays = teact_useMemo(() => {
    if (currentCollectionAddress !== src_config/* TON_DNS_COLLECTION */.nQN) return undefined;
    const date = getDomainsExpirationDate(collectionNfts, undefined, dnsExpiration);
    return date ? (0,dateFormat/* getCountDaysToDate */.GS)(date) : undefined;
  }, [collectionNfts, currentCollectionAddress, dnsExpiration]);
  const collectionName = isTelegramGifts ? lang('Telegram Gifts') : collectionNfts[0].collectionName ?? lang('Unnamed Collection');
  const menuItems = teact_useMemo(() => {
    const isInTabs = collectionTabs === null || collectionTabs === void 0 ? void 0 : collectionTabs.includes(currentCollectionAddress);
    return (0,iteratees/* compact */.oE)([!isViewMode && {
      name: 'Send All',
      value: 'sendAll'
    }, collectionNfts[0].isOnFragment && {
      name: 'Fragment',
      value: 'fragment',
      fontIcon: 'external'
    }, {
      name: 'Getgems',
      value: 'getgems',
      fontIcon: 'external'
    }, !isTelegramGifts && {
      name: getExplorerName('ton'),
      value: 'tonExplorer',
      fontIcon: 'external'
    }, !isViewMode && currentCollectionAddress === src_config/* TON_DNS_COLLECTION */.nQN && {
      name: collectionNfts.length > 1 ? 'Renew All' : 'Renew',
      value: 'renew',
      description: dnsExpireInDays && dnsExpireInDays < 0 ? collectionNfts.length > 1 ? '$expired_many' : 'Expired' : lang('$expires_in %days%', {
        days: lang('$in_days', dnsExpireInDays)
      }, undefined, collectionNfts.length)
    }, !src_config/* IS_CORE_WALLET */.TI6 && {
      name: 'Hide All',
      value: 'hideAll'
    }, !isViewMode && {
      name: 'Burn All',
      value: 'burnAll',
      isDangerous: true
    }, {
      name: 'Select All',
      value: 'selectAll',
      withDelimiter: true
    }, {
      name: isInTabs ? lang('Remove Tab') : lang('Add Tab'),
      value: isInTabs ? 'removeTab' : 'addTab'
    }]);
  }, [collectionNfts, collectionTabs, currentCollectionAddress, dnsExpireInDays, isTelegramGifts, isViewMode, lang]);
  useHistoryBack({
    isActive: true,
    onBack: closeNftCollection
  });
  teact_useEffect(() => captureEscKeyListener(closeNftCollection), []);
  const getTriggerElement = useLastCallback(() => ref.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true
  }));
  const handleMenuItemClick = useLastCallback(value => {
    switch (value) {
      case 'sendAll':
        {
          startTransfer({
            nfts: collectionNfts.filter(_ref2 => {
              let {
                isOnSale
              } = _ref2;
              return !isOnSale;
            }),
            isPortrait: getIsPortrait()
          });
          break;
        }
      case 'getgems':
        {
          const getgemsBaseUrl = isTestnet ? src_config/* GETGEMS_BASE_TESTNET_URL */.PKm : src_config/* GETGEMS_BASE_MAINNET_URL */.wln;
          void openUrl(isTelegramGifts ? `${getgemsBaseUrl}top-gifts` : `${getgemsBaseUrl}collection/${currentCollectionAddress}`);
          break;
        }
      case 'tonExplorer':
        {
          const url = getExplorerNftCollectionUrl(currentCollectionAddress, isTestnet);
          if (url) {
            void openUrl(url);
          }
          break;
        }
      case 'fragment':
        {
          if (isTelegramGifts) {
            void openUrl('https://fragment.com/gifts');
          } else if (currentCollectionAddress === src_config/* NFT_FRAGMENT_COLLECTIONS */.q5n[0]) {
            void openUrl('https://fragment.com/numbers');
          } else if (currentCollectionAddress === src_config/* NFT_FRAGMENT_COLLECTIONS */.q5n[1]) {
            void openUrl('https://fragment.com');
          } else {
            const collectionSlug = collectionName.toLowerCase().replace(/\W/g, '').replace(/s$/, '');
            void openUrl(`https://fragment.com/gifts/${collectionSlug}`);
          }
          break;
        }
      case 'selectAll':
        {
          selectNfts({
            addresses: collectionNfts.filter(_ref3 => {
              let {
                isOnSale
              } = _ref3;
              return !isOnSale;
            }).map(_ref4 => {
              let {
                address
              } = _ref4;
              return address;
            })
          });
          break;
        }
      case 'burnAll':
        {
          burnNfts({
            nfts: collectionNfts.filter(_ref5 => {
              let {
                isOnSale
              } = _ref5;
              return !isOnSale;
            })
          });
          break;
        }
      case 'hideAll':
        {
          openHideNftModal({
            addresses: collectionNfts.map(nft => nft.address),
            isCollection: true
          });
          break;
        }
      case 'addTab':
        {
          addCollectionTab({
            collectionAddress: currentCollectionAddress
          });
          break;
        }
      case 'removeTab':
        {
          closeNftCollection();
          removeCollectionTab({
            collectionAddress: currentCollectionAddress
          });
          break;
        }
      case 'renew':
        {
          openDomainRenewalModal({
            addresses: collectionNfts.map(nft => nft.address)
          });
          break;
        }
    }
  });
  const handleMenuOpen = useLastCallback(() => {
    const {
      right: x,
      bottom: y
    } = ref.current.getBoundingClientRect();
    setMenuAnchor({
      x,
      y
    });
  });
  const handleMenuClose = useLastCallback(() => {
    setMenuAnchor(undefined);
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.root
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    ariaLabel: lang('Back'),
    className: NftCollectionHeader_module.backButton,
    onClick: closeNftCollection
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(NftCollectionHeader_module.backIcon, 'icon-chevron-left'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.content
  }, /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.title
  }, collectionName), /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.amount
  }, collectionNfts.length > 1 ? lang('%amount% NFTs', {
    amount: collectionNfts.length
  }) : lang('1 NFT'))), /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    ref: ref,
    className: NftCollectionHeader_module.menuButton,
    onClick: handleMenuOpen,
    ariaLabel: lang('Open Menu')
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-menu-dots",
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isMenuOpen,
    ref: menuRef,
    withPortal: true,
    shouldTranslateOptions: true,
    menuPositionX: "right",
    menuAnchor: menuAnchor,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    buttonClassName: NftCollectionHeader_module.menuItem,
    bubbleClassName: NftCollectionHeader_module.menu,
    itemDescriptionClassName: NftCollectionHeader_module.menuItemDescription,
    items: menuItems,
    onSelect: handleMenuItemClick,
    onClose: handleMenuClose
  }));
}
/* harmony default export */ const Content_NftCollectionHeader = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  const {
    byAddress: nfts,
    currentCollectionAddress,
    collectionTabs,
    dnsExpiration
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  return {
    currentCollectionAddress,
    nfts,
    isTestnet: global.settings.isTestnet,
    isViewMode: selectIsCurrentAccountViewMode(global),
    collectionTabs,
    dnsExpiration
  };
}, (global, ownProps, stickToFirst) => {
  var _selectCurrentAccount2;
  const {
    currentCollectionAddress
  } = ((_selectCurrentAccount2 = selectCurrentAccountState(global)) === null || _selectCurrentAccount2 === void 0 ? void 0 : _selectCurrentAccount2.nfts) || {};
  return stickToFirst(currentCollectionAddress);
})(NftCollectionHeader)));
;// ./src/components/ui/Radio.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Radio_module = ({"root":"Radio-module__root","checked":"Radio-module__checked"});
;// ./src/components/ui/Radio.tsx



function Radio(_ref) {
  let {
    id,
    name,
    value,
    isChecked,
    className,
    onChange
  } = _ref;
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Radio_module.root, className, isChecked && Radio_module.checked)
  }, /*#__PURE__*/teact.createElement("input", {
    id: id,
    type: "radio",
    name: name,
    className: "visually-hidden",
    value: value,
    checked: isChecked,
    onChange: onChange
  }));
}
/* harmony default export */ const ui_Radio = (memo(Radio));
;// ./src/components/mediaViewer/hooks/useNftMenu.ts










const ON_SALE_ITEM = {
  name: 'Cannot be sent',
  value: 'send',
  description: 'NFT is for sale',
  isDisabled: true
};
const TON_DNS_ITEM = {
  name: 'Configure DNS',
  value: 'tondns',
  fontIcon: 'external'
};
const SEND_ITEM = {
  name: 'Send',
  value: 'send'
};
const FRAGMENT_ITEM = {
  name: 'Fragment',
  value: 'fragment',
  fontIcon: 'external'
};
const GETGEMS_ITEM = {
  name: 'Getgems',
  value: 'getgems',
  fontIcon: 'external'
};
const TON_EXPLORER_ITEM = {
  name: getExplorerName('ton'),
  value: 'tonExplorer',
  fontIcon: 'external'
};
const COLLECTION_ITEM = {
  name: 'Collection',
  value: 'collection'
};
const HIDE_ITEM = {
  name: 'Hide',
  value: 'hide'
};
const RENEW_ITEM = {
  name: 'Renew',
  value: 'renew'
};
const NOT_SCAM = {
  name: 'Not Scam',
  value: 'not_scam'
};
const UNHIDE = {
  name: 'Unhide',
  value: 'unhide'
};
const BURN_ITEM = {
  name: 'Burn',
  value: 'burn',
  isDangerous: true
};
const SELECT_ITEM = {
  name: 'Select',
  value: 'select',
  withDelimiter: true
};
const INSTALL_CARD = {
  name: 'Install Card',
  value: 'installCard'
};
const RESET_CARD = {
  name: 'Reset Card',
  value: 'resetCard'
};
const INSTALL_ACCENT_COLOR = {
  name: 'Apply Palette',
  value: 'installAccentColor'
};
const RESET_ACCENT_COLOR = {
  name: 'Reset Palette',
  value: 'resetAccentColor'
};
const LINK_TO_ADDRESS = {
  name: 'Link to Wallet',
  value: 'linkDomain'
};
const CHANGE_LINKED_ADDRESS = {
  name: 'Change Wallet',
  value: 'linkDomain'
};
function useNftMenu(_ref) {
  let {
    nft,
    isViewMode,
    dnsExpireInDays,
    linkedAddress,
    isNftBlacklisted,
    isNftWhitelisted,
    isNftInstalled,
    isNftAccentColorInstalled
  } = _ref;
  const {
    startTransfer,
    selectNfts,
    openNftCollection,
    burnNfts,
    addNftsToBlacklist,
    addNftsToWhitelist,
    closeMediaViewer,
    closeNftAttributesModal,
    openUnhideNftModal,
    setCardBackgroundNft,
    clearCardBackgroundNft,
    installAccentColorFromNft,
    clearAccentColorFromNft,
    openDomainRenewalModal,
    openDomainLinkingModal
  } = getActions();
  const lang = hooks_useLang();
  function closeOverlays() {
    closeMediaViewer();
    closeNftAttributesModal();
  }
  const handleMenuItemSelect = useLastCallback((value, e) => {
    const {
      isTestnet
    } = getGlobal().settings;
    const isExternal = (e === null || e === void 0 ? void 0 : e.shiftKey) || (e === null || e === void 0 ? void 0 : e.ctrlKey) || (e === null || e === void 0 ? void 0 : e.metaKey);
    switch (value) {
      case 'send':
        {
          startTransfer({
            isPortrait: getIsPortrait(),
            nfts: [nft]
          });
          closeOverlays();
          break;
        }
      case 'tonExplorer':
        {
          const url = getExplorerNftUrl(nft.address, isTestnet);
          void openUrl(url, {
            isExternal
          });
          break;
        }
      case 'getgems':
        {
          const getgemsBaseUrl = isTestnet ? src_config/* GETGEMS_BASE_TESTNET_URL */.PKm : src_config/* GETGEMS_BASE_MAINNET_URL */.wln;
          const getgemsUrl = nft.collectionAddress ? `${getgemsBaseUrl}collection/${nft.collectionAddress}/${nft.address}` : `${getgemsBaseUrl}nft/${nft.address}`;
          void openUrl(getgemsUrl, {
            isExternal
          });
          break;
        }
      case 'tondns':
        {
          const url = `https://dns.ton.org/#${(nft.name || '').replace(/\.ton$/i, '')}`;
          void openUrl(url, {
            isExternal
          });
          break;
        }
      case 'installCard':
        {
          setCardBackgroundNft({
            nft: nft
          });
          installAccentColorFromNft({
            nft: nft
          });
          break;
        }
      case 'resetCard':
        {
          clearCardBackgroundNft();
          clearAccentColorFromNft();
          break;
        }
      case 'installAccentColor':
        {
          installAccentColorFromNft({
            nft: nft
          });
          break;
        }
      case 'resetAccentColor':
        {
          clearAccentColorFromNft();
          break;
        }
      case 'fragment':
        {
          let url;
          const {
            collectionName,
            name,
            metadata: {
              fragmentUrl
            }
          } = nft;
          if (fragmentUrl) {
            url = fragmentUrl;
          } else if (collectionName !== null && collectionName !== void 0 && collectionName.toLowerCase().includes('numbers')) {
            url = `https://fragment.com/number/${name === null || name === void 0 ? void 0 : name.replace(/[^0-9]/g, '')}`;
          } else {
            url = `https://fragment.com/username/${encodeURIComponent((name === null || name === void 0 ? void 0 : name.substring(1)) || '')}`;
          }
          void openUrl(url, {
            isExternal
          });
          break;
        }
      case 'collection':
        {
          openNftCollection({
            address: nft.collectionAddress
          }, {
            forceOnHeavyAnimation: true
          });
          closeOverlays();
          break;
        }
      case 'hide':
        {
          addNftsToBlacklist({
            addresses: [nft.address]
          });
          closeOverlays();
          break;
        }
      case 'not_scam':
        {
          openUnhideNftModal({
            address: nft.address,
            name: nft.name
          });
          break;
        }
      case 'unhide':
        {
          addNftsToWhitelist({
            addresses: [nft.address]
          });
          closeOverlays();
          break;
        }
      case 'burn':
        {
          burnNfts({
            nfts: [nft]
          });
          closeOverlays();
          break;
        }
      case 'select':
        {
          selectNfts({
            addresses: [nft.address]
          });
          break;
        }
      case 'renew':
        {
          openDomainRenewalModal({
            addresses: [nft.address]
          });
          break;
        }
      case 'linkDomain':
        {
          openDomainLinkingModal({
            address: nft.address
          });
          break;
        }
    }
  });
  const menuItems = teact_useMemo(() => {
    if (!nft) return [];
    const {
      collectionAddress,
      isOnSale,
      isOnFragment,
      isScam
    } = nft;
    const isTonDns = isTonDnsNft(nft);
    const isCard = !src_config/* IS_CORE_WALLET */.TI6 && nft.collectionAddress === src_config/* MTW_CARDS_COLLECTION */.qL;
    return (0,iteratees/* compact */.oE)([!isViewMode && (isOnSale ? ON_SALE_ITEM : SEND_ITEM), !isViewMode && isTonDns && !isOnSale && dnsExpireInDays !== undefined && {
      ...RENEW_ITEM,
      description: dnsExpireInDays < 0 ? 'Expired' : lang('$expires_in %days%', {
        days: lang('$in_days', dnsExpireInDays)
      }, undefined, 1)
    }, !isViewMode && isTonDns && !isOnSale && (linkedAddress ? CHANGE_LINKED_ADDRESS : LINK_TO_ADDRESS), !src_config/* IS_CORE_WALLET */.TI6 && (!isScam && !isNftBlacklisted || isNftWhitelisted) && HIDE_ITEM, !src_config/* IS_CORE_WALLET */.TI6 && isScam && !isNftWhitelisted && NOT_SCAM, !src_config/* IS_CORE_WALLET */.TI6 && !isScam && isNftBlacklisted && UNHIDE, ...(!isOnSale && !isViewMode ? [BURN_ITEM, SELECT_ITEM] : []), collectionAddress && COLLECTION_ITEM, isTonDns && !isViewMode && TON_DNS_ITEM, ...(isCard ? [!isNftInstalled ? INSTALL_CARD : RESET_CARD] : []), ...(isCard ? [!isNftAccentColorInstalled ? INSTALL_ACCENT_COLOR : RESET_ACCENT_COLOR] : []), isOnFragment && FRAGMENT_ITEM, GETGEMS_ITEM, TON_EXPLORER_ITEM]);
  }, [nft, isViewMode, dnsExpireInDays, lang, linkedAddress, isNftBlacklisted, isNftWhitelisted, isNftInstalled, isNftAccentColorInstalled]);
  return {
    menuItems,
    handleMenuItemSelect
  };
}
;// ./src/components/main/sections/Content/NftMenu.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const NftMenu_module = ({"button":"NftMenu-module__button","icon":"NftMenu-module__icon","menu":"NftMenu-module__menu","contextMenu":"NftMenu-module__contextMenu","menuBubble":"NftMenu-module__menuBubble","item":"NftMenu-module__item","menuItemDescription":"NftMenu-module__menuItemDescription"});
;// ./src/components/main/sections/Content/NftMenu.tsx













const NftMenu_CONTEXT_MENU_VERTICAL_SHIFT_PX = 4;
function NftMenu(_ref) {
  let {
    isViewMode,
    isContextMenuMode,
    nft,
    ref,
    dnsExpireInDays,
    linkedAddress,
    menuAnchor,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    cardBackgroundNft,
    accentColorNft,
    className,
    onOpen,
    onClose,
    onCloseAnimationEnd
  } = _ref;
  const isNftBlacklisted = teact_useMemo(() => {
    return blacklistedNftAddresses === null || blacklistedNftAddresses === void 0 ? void 0 : blacklistedNftAddresses.includes(nft.address);
  }, [nft, blacklistedNftAddresses]);
  const isNftWhitelisted = teact_useMemo(() => {
    return whitelistedNftAddresses === null || whitelistedNftAddresses === void 0 ? void 0 : whitelistedNftAddresses.includes(nft.address);
  }, [nft, whitelistedNftAddresses]);
  const isNftInstalled = usePrevDuringAnimationSimple(nft && nft.address === (cardBackgroundNft === null || cardBackgroundNft === void 0 ? void 0 : cardBackgroundNft.address), ANIMATION_DURATION);
  const isNftAccentColorInstalled = usePrevDuringAnimationSimple(nft && nft.address === (accentColorNft === null || accentColorNft === void 0 ? void 0 : accentColorNft.address), ANIMATION_DURATION);
  const {
    menuItems,
    handleMenuItemSelect
  } = useNftMenu({
    nft,
    isViewMode,
    dnsExpireInDays,
    linkedAddress,
    isNftBlacklisted,
    isNftWhitelisted,
    isNftInstalled,
    isNftAccentColorInstalled
  });
  let buttonRef = teact_useRef();
  const menuRef = teact_useRef();
  const isOpen = Boolean(menuAnchor);
  if (ref) {
    buttonRef = ref;
  }
  const getTriggerElement = useLastCallback(() => buttonRef.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true,
    topShiftY: isContextMenuMode ? NftMenu_CONTEXT_MENU_VERTICAL_SHIFT_PX : 0,
    preferredPositionX: isContextMenuMode ? 'left' : 'right'
  }));
  const lang = hooks_useLang();
  const handleButtonClick = e => {
    stopEvent(e);
    if (isOpen) {
      onClose();
    } else {
      void vibrate();
      onOpen();
    }
  };
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("button", {
    ref: buttonRef,
    type: "button",
    className: buildClassName(NftMenu_module.button, className),
    "aria-label": lang('NFT Menu'),
    onClick: handleButtonClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(NftMenu_module.icon, 'icon-menu-dots'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isOpen,
    ref: menuRef,
    withPortal: true,
    menuAnchor: menuAnchor,
    menuPositionX: "right",
    getTriggerElement: !isContextMenuMode ? getTriggerElement : undefined,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    items: menuItems,
    shouldTranslateOptions: true,
    className: isContextMenuMode ? NftMenu_module.contextMenu : NftMenu_module.menu,
    bubbleClassName: NftMenu_module.menuBubble,
    buttonClassName: NftMenu_module.item,
    itemDescriptionClassName: NftMenu_module.menuItemDescription,
    shouldCleanup: true,
    onClose: onClose,
    onCloseAnimationEnd: onCloseAnimationEnd,
    onSelect: handleMenuItemSelect
  }));
}
/* harmony default export */ const Content_NftMenu = (memo(withGlobal((global, _ref2) => {
  let {
    nft
  } = _ref2;
  const {
    blacklistedNftAddresses,
    whitelistedNftAddresses
  } = selectCurrentAccountState(global) || {};
  const {
    cardBackgroundNft,
    accentColorNft
  } = selectCurrentAccountSettings(global) || {};
  const linkedAddress = selectTonDnsLinkedAddress(global, nft);
  return {
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    cardBackgroundNft,
    accentColorNft,
    isViewMode: selectIsCurrentAccountViewMode(global),
    linkedAddress
  };
})(NftMenu)));
;// ./src/components/main/sections/Content/Nft.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Nft_module = ({"emptyList":"Nft-module__emptyList","emptyListContent":"Nft-module__emptyListContent","emptyListTitle":"Nft-module__emptyListTitle","emptyListText":"Nft-module__emptyListText","emptyListLoading":"Nft-module__emptyListLoading","emptyListButton":"Nft-module__emptyListButton","sticker":"Nft-module__sticker","list":"Nft-module__list","landscapeList":"Nft-module__landscapeList","item":"Nft-module__item","image":"Nft-module__image","item_onSale":"Nft-module__item_onSale","itemOnSale":"Nft-module__item_onSale","nonInteractive":"Nft-module__nonInteractive","itemWithMenu":"Nft-module__itemWithMenu","imageWrapper":"Nft-module__imageWrapper","warning":"Nft-module__warning","imageSelected":"Nft-module__imageSelected","fullImage":"Nft-module__fullImage","warningBlock":"Nft-module__warningBlock","infoWrapper":"Nft-module__infoWrapper","title":"Nft-module__title","collection":"Nft-module__collection","radio":"Nft-module__radio","notcoinVoucherButton":"Nft-module__notcoinVoucherButton","notcoinVoucherIcon":"Nft-module__notcoinVoucherIcon"});
;// ./src/components/main/sections/Content/Nft.tsx





















function Nft(_ref) {
  let {
    nft,
    selectedAddresses,
    tonDnsExpiration,
    observeIntersection,
    isViewAccount
  } = _ref;
  const {
    selectNfts,
    clearNftSelection,
    openDomainRenewalModal,
    openNftAttributesModal
  } = getActions();
  const lang = hooks_useLang();
  const ref = teact_useRef();
  const {
    isLottie,
    shouldPlay,
    noLoop,
    markHover,
    unmarkHover
  } = useLottie(nft, ref, observeIntersection);
  const [menuAnchor, setMenuAnchor] = useState();
  const isSelectionEnabled = !!selectedAddresses && selectedAddresses.length > 0;
  const isSelected = teact_useMemo(() => selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.includes(nft.address), [selectedAddresses, nft.address]);
  const isMenuOpen = Boolean(menuAnchor);
  const dnsExpireInDays = tonDnsExpiration ? (0,dateFormat/* getCountDaysToDate */.GS)(tonDnsExpiration) : undefined;
  const isDnsExpireSoon = dnsExpireInDays !== undefined ? dnsExpireInDays <= src_config/* TON_DNS_RENEWAL_NFT_WARNING_DAYS */.tI4 : false;
  const {
    shouldRender: shouldRenderWarning,
    ref: warningRef
  } = useShowTransition({
    isOpen: isSelectionEnabled && nft.isOnSale,
    withShouldRender: true
  });
  const {
    isContextMenuOpen,
    contextMenuAnchor,
    handleBeforeContextMenu,
    handleContextMenu,
    handleContextMenuHide,
    handleContextMenuClose
  } = hooks_useContextMenuHandlers({
    elementRef: ref
  });
  const fullClassName = buildClassName(Nft_module.item, !isSelectionEnabled && nft.isOnSale && Nft_module.item_onSale, isMenuOpen && Nft_module.itemWithMenu, isSelectionEnabled && nft.isOnSale && Nft_module.nonInteractive);
  function handleClick() {
    if (isSelectionEnabled) {
      if (isSelected) {
        clearNftSelection({
          address: nft.address
        });
      } else {
        selectNfts({
          addresses: [nft.address]
        });
      }
      return;
    }
    void vibrate();
    openNftAttributesModal({
      nft
    });
  }
  function handleRenewDomainClick(e) {
    stopEvent(e);
    openDomainRenewalModal({
      addresses: [nft.address]
    });
  }
  const handleOpenContextMenu = useLastCallback(() => {
    setMenuAnchor(contextMenuAnchor);
  });
  const handleOpenMenu = useLastCallback(() => {
    const {
      right: x,
      y
    } = ref.current.getBoundingClientRect();
    setMenuAnchor({
      x,
      y
    });
  });
  const handleCloseMenu = useLastCallback(() => {
    setMenuAnchor(undefined);
    handleContextMenuClose();
  });
  useSyncEffect(() => {
    if (isContextMenuOpen) {
      handleOpenContextMenu();
    } else {
      handleCloseMenu();
    }
  }, [isContextMenuOpen]);
  function renderDnsExpireWarning() {
    return /*#__PURE__*/teact.createElement("button", {
      type: "button",
      className: buildClassName(Nft_module.warningBlock, isViewAccount && Nft_module.nonInteractive),
      onClick: !isViewAccount ? handleRenewDomainClick : undefined
    }, dnsExpireInDays < 0 ? 'Expired' : lang('$expires_in %days%', {
      days: lang('$in_days', dnsExpireInDays)
    }, undefined, 1));
  }
  return /*#__PURE__*/teact.createElement("div", {
    key: nft.address,
    ref: ref,
    className: fullClassName,
    onMouseEnter: markHover,
    onMouseLeave: unmarkHover,
    onClick: !isSelectionEnabled || !nft.isOnSale ? handleClick : undefined,
    onMouseDown: handleBeforeContextMenu,
    onContextMenu: handleContextMenu
  }, isSelectionEnabled && !nft.isOnSale && /*#__PURE__*/teact.createElement(ui_Radio, {
    isChecked: isSelected,
    name: "nft",
    value: nft.address,
    className: Nft_module.radio
  }), !isSelectionEnabled && /*#__PURE__*/teact.createElement(Content_NftMenu, {
    nft: nft,
    isContextMenuMode: Boolean(contextMenuAnchor),
    dnsExpireInDays: dnsExpireInDays,
    menuAnchor: menuAnchor,
    onOpen: handleOpenMenu,
    onClose: handleCloseMenu,
    onCloseAnimationEnd: handleContextMenuHide
  }), isLottie ? /*#__PURE__*/teact.createElement("div", {
    className: Nft_module.imageWrapper
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    shouldStretch: true,
    play: shouldPlay,
    noLoop: noLoop,
    tgsUrl: nft.metadata.lottie,
    previewUrl: nft.thumbnail,
    noPreviewTransition: true,
    className: buildClassName(Nft_module.image, isSelected && Nft_module.imageSelected)
  }), isDnsExpireSoon && renderDnsExpireWarning()) : /*#__PURE__*/teact.createElement(ui_Image, {
    url: nft.thumbnail,
    className: Nft_module.imageWrapper,
    imageClassName: buildClassName(Nft_module.image, isSelected && Nft_module.imageSelected)
  }, isDnsExpireSoon && renderDnsExpireWarning()), shouldRenderWarning && /*#__PURE__*/teact.createElement("div", {
    ref: warningRef,
    className: Nft_module.warning
  }, lang('For sale. Cannot be sent and burned')), /*#__PURE__*/teact.createElement("div", {
    className: Nft_module.infoWrapper
  }, /*#__PURE__*/teact.createElement("b", {
    className: Nft_module.title
  }, nft.name || (0,shortenAddress/* shortenAddress */.W)(nft.address, 4))), /*#__PURE__*/teact.createElement("div", {
    className: Nft_module.collection
  }, nft.collectionName));
}
/* harmony default export */ const Content_Nft = (memo(Nft));
function useLottie(nft, ref, observeIntersection) {
  var _nft$metadata;
  const isLottie = Boolean((_nft$metadata = nft.metadata) === null || _nft$metadata === void 0 ? void 0 : _nft$metadata.lottie);
  const isIntersecting = useIsIntersecting(ref, isLottie ? observeIntersection : undefined);
  const [isHover, markHover, unmarkHover] = hooks_useFlag();
  if (!isLottie) {
    return {
      isLottie
    };
  }
  const shouldPlay = isIntersecting || isHover;
  const noLoop = !isHover;
  return {
    isLottie,
    shouldPlay,
    noLoop,
    ...(!(windowEnvironment/* IS_IOS */.pz || windowEnvironment/* IS_ANDROID */.Ni) && {
      markHover,
      unmarkHover
    })
  };
}
;// ./src/components/main/sections/Content/Nfts.tsx





















const INTERSECTION_THROTTLE = 200;
const INITIAL_SLICE_LENGTH = 50;
const Nfts_SCROLL_THRESHOLD = 800;
function Nfts(_ref) {
  let {
    isActive,
    orderedAddresses,
    selectedAddresses,
    byAddress,
    currentCollectionAddress,
    dnsExpiration,
    isNftBuyingDisabled,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    isViewAccount
  } = _ref;
  const {
    fetchNftsFromCollection,
    clearNftsSelection
  } = getActions();
  const lang = hooks_useLang();
  const containerRef = teact_useRef();
  const {
    isPortrait,
    isLandscape
  } = useDeviceScreen();
  const hasSelection = Boolean(selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length);
  const [isScrolled, setIsScrolled] = useState(false);
  const scrollContainerClosest = getScrollContainerClosestSelector(true, isPortrait) || '.nfts-container';
  teact_useEffect(() => {
    if (currentCollectionAddress) {
      fetchNftsFromCollection({
        collectionAddress: currentCollectionAddress
      });
    }
  }, [currentCollectionAddress]);
  teact_useEffect(clearNftsSelection, [clearNftsSelection, isActive, currentCollectionAddress]);
  teact_useEffect(() => hasSelection ? captureEscKeyListener(clearNftsSelection) : undefined, [hasSelection]);
  const nfts = teact_useMemo(() => {
    if (!orderedAddresses || !byAddress) {
      return undefined;
    }
    const blacklistedNftAddressesSet = new Set(blacklistedNftAddresses);
    const whitelistedNftAddressesSet = new Set(whitelistedNftAddresses);
    const result = orderedAddresses.reduce((acc, address) => {
      const nft = byAddress[address];
      if (nft && (!currentCollectionAddress || nft.collectionAddress === currentCollectionAddress || currentCollectionAddress === src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R && nft.isTelegramGift) && (!nft.isHidden || whitelistedNftAddressesSet.has(nft.address)) && !blacklistedNftAddressesSet.has(nft.address)) {
        acc.push(nft);
      }
      return acc;
    }, []);
    return isScrolled ? result : result.slice(0, INITIAL_SLICE_LENGTH);
  }, [byAddress, currentCollectionAddress, orderedAddresses, blacklistedNftAddresses, whitelistedNftAddresses, isScrolled]);
  const handleNativeScroll = useLastCallback(() => {
    var _containerRef$current;
    const closestScrollContainer = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.closest(scrollContainerClosest);
    if (!closestScrollContainer || isScrolled) {
      return;
    }
    const {
      scrollTop,
      scrollHeight,
      clientHeight
    } = closestScrollContainer;
    const distanceToBottom = scrollHeight - scrollTop - clientHeight;
    if (distanceToBottom <= Nfts_SCROLL_THRESHOLD) {
      setIsScrolled(true);
    }
  });
  useLayoutEffect(() => {
    var _containerRef$current2;
    if (!scrollContainerClosest || !(nfts !== null && nfts !== void 0 && nfts.length)) return undefined;
    const closestScrollContainer = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.closest(scrollContainerClosest);
    if (!closestScrollContainer) return undefined;
    closestScrollContainer.addEventListener('scroll', handleNativeScroll);
    return () => {
      closestScrollContainer.removeEventListener('scroll', handleNativeScroll);
    };
  }, [nfts === null || nfts === void 0 ? void 0 : nfts.length, scrollContainerClosest]);
  const {
    observe: observeIntersection
  } = useIntersectionObserver({
    throttleMs: INTERSECTION_THROTTLE,
    isDisabled: !(nfts !== null && nfts !== void 0 && nfts.length)
  });
  function handleNftMarketplaceClick(e) {
    stopEvent(e);
    void openUrl(src_config/* NFT_MARKETPLACE_URL */.FgL, {
      title: src_config/* NFT_MARKETPLACE_TITLE */.Ia6,
      subtitle: getHostnameFromUrl(src_config/* NFT_MARKETPLACE_URL */.FgL)
    });
  }
  if (nfts === undefined) {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Nft_module.emptyList, Nft_module.emptyListLoading)
    }, /*#__PURE__*/teact.createElement(ui_Spinner, null));
  }
  if (nfts.length === 0) {
    return /*#__PURE__*/teact.createElement("div", {
      className: Nft_module.emptyList
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      tgsUrl: ANIMATED_STICKERS_PATHS.happy,
      previewUrl: ANIMATED_STICKERS_PATHS.happyPreview,
      size: isPortrait ? src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp : src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
      className: Nft_module.sticker,
      noLoop: false,
      nonInteractive: true
    }), /*#__PURE__*/teact.createElement("div", {
      className: Nft_module.emptyListContent
    }, /*#__PURE__*/teact.createElement("p", {
      className: Nft_module.emptyListTitle
    }, lang('No NFTs yet')), !isNftBuyingDisabled && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Nft_module.emptyListText
    }, renderText(lang('$nft_explore_offer'), isPortrait ? ['simple_markdown'] : undefined)), /*#__PURE__*/teact.createElement("button", {
      type: "button",
      className: Nft_module.emptyListButton,
      onClick: handleNftMarketplaceClick
    }, lang('Open %nft_marketplace%', {
      nft_marketplace: src_config/* NFT_MARKETPLACE_TITLE */.Ia6
    })))));
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    className: buildClassName(Nft_module.list, isLandscape && Nft_module.landscapeList)
  }, nfts.map(nft => /*#__PURE__*/teact.createElement(Content_Nft, {
    key: nft.address,
    nft: nft,
    selectedAddresses: selectedAddresses,
    tonDnsExpiration: getTonDnsExpirationDate(nft, dnsExpiration),
    isViewAccount: isViewAccount,
    observeIntersection: observeIntersection
  })));
}
/* harmony default export */ const Content_Nfts = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  const {
    orderedAddresses,
    byAddress,
    currentCollectionAddress,
    selectedAddresses,
    dnsExpiration
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  const {
    isNftBuyingDisabled
  } = global.restrictions;
  const {
    blacklistedNftAddresses,
    whitelistedNftAddresses
  } = selectCurrentAccountState(global) || {};
  return {
    orderedAddresses,
    selectedAddresses,
    byAddress,
    currentCollectionAddress,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    isNftBuyingDisabled,
    dnsExpiration,
    isViewAccount: selectIsCurrentAccountViewMode(global)
  };
}, (global, _, stickToFirst) => {
  var _selectCurrentAccount2;
  const {
    currentCollectionAddress
  } = ((_selectCurrentAccount2 = selectCurrentAccountState(global)) === null || _selectCurrentAccount2 === void 0 ? void 0 : _selectCurrentAccount2.nfts) || {};
  return stickToFirst(`${global.currentAccountId}_${currentCollectionAddress || 'all'}`);
})(Nfts)));
;// ./src/components/main/sections/Content/NftSelectionHeader.tsx
















function NftSelectionHeader(_ref) {
  let {
    isViewMode,
    selectedAddresses,
    byAddress,
    dnsExpiration,
    currentCollectionAddress
  } = _ref;
  const {
    selectAllNfts,
    clearNftsSelection,
    startTransfer,
    burnNfts,
    openHideNftModal,
    openDomainRenewalModal
  } = getActions();
  const lang = hooks_useLang();
  const amount = (selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length) ?? 1;
  const isActive = Boolean(selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length);
  const allSelectedIsTonDnsNft = teact_useMemo(() => {
    return selectedAddresses !== null && selectedAddresses !== void 0 && selectedAddresses.length ? selectedAddresses.every(address => isTonDnsNft(byAddress === null || byAddress === void 0 ? void 0 : byAddress[address])) : false;
  }, [byAddress, selectedAddresses]);
  const dnsExpireInDays = teact_useMemo(() => {
    if (!allSelectedIsTonDnsNft) return undefined;
    const date = getDomainsExpirationDate(selectedAddresses ?? [], byAddress, dnsExpiration);
    return date ? (0,dateFormat/* getCountDaysToDate */.GS)(date) : undefined;
  }, [allSelectedIsTonDnsNft, dnsExpiration, selectedAddresses, byAddress]);
  const tonDnsMultiSelected = ((selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length) ?? 0) > 1;
  useHistoryBack({
    isActive,
    onBack: clearNftsSelection
  });
  teact_useEffect(() => isActive ? captureEscKeyListener(clearNftsSelection) : undefined, [isActive]);
  const menuItems = teact_useMemo(() => {
    return (0,iteratees/* compact */.oE)([!isViewMode && {
      name: 'Send',
      value: 'send'
    }, !isViewMode && allSelectedIsTonDnsNft && {
      name: tonDnsMultiSelected ? 'Renew All' : 'Renew',
      value: 'renew',
      description: dnsExpireInDays && dnsExpireInDays < 0 ? tonDnsMultiSelected ? '$expired_many' : 'Expired' : lang('$expires_in %days%', {
        days: lang('$in_days', dnsExpireInDays)
      }, undefined, (selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length) ?? 1)
    }, !src_config/* IS_CORE_WALLET */.TI6 && {
      name: 'Hide',
      value: 'hide'
    }, !isViewMode && {
      name: 'Burn',
      value: 'burn',
      isDangerous: true
    }, {
      name: 'Select All',
      value: 'select-all',
      withDelimiter: true
    }]);
  }, [allSelectedIsTonDnsNft, dnsExpireInDays, isViewMode, lang, selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length, tonDnsMultiSelected]);
  const handleSendClick = useLastCallback(() => {
    const nfts = selectedAddresses.map(address => byAddress[address]) ?? [];
    clearNftsSelection();
    startTransfer({
      isPortrait: getIsPortrait(),
      nfts
    });
  });
  const handleBurnClick = useLastCallback(() => {
    const nfts = selectedAddresses.map(address => byAddress[address]) ?? [];
    clearNftsSelection();
    burnNfts({
      nfts
    });
  });
  const handleHideClick = useLastCallback(() => {
    clearNftsSelection();
    openHideNftModal({
      addresses: selectedAddresses,
      isCollection: false
    });
  });
  const [menuAnchor, setMenuAnchor] = useState();
  const isMenuOpen = Boolean(menuAnchor);
  const ref = teact_useRef();
  const menuRef = teact_useRef();
  const handleMenuOpen = useLastCallback(() => {
    const {
      right: x,
      bottom: y
    } = ref.current.getBoundingClientRect();
    setMenuAnchor({
      x,
      y
    });
  });
  const handleMenuClose = useLastCallback(() => {
    setMenuAnchor(undefined);
  });
  const getTriggerElement = useLastCallback(() => ref.current);
  const getRootElement = useLastCallback(() => document.body);
  const getMenuElement = useLastCallback(() => menuRef.current);
  const getLayout = useLastCallback(() => ({
    withPortal: true
  }));
  const handleMenuItemClick = useLastCallback(value => {
    switch (value) {
      case 'send':
        {
          handleSendClick();
          break;
        }
      case 'hide':
        {
          handleHideClick();
          break;
        }
      case 'burn':
        {
          handleBurnClick();
          break;
        }
      case 'select-all':
        {
          selectAllNfts({
            collectionAddress: currentCollectionAddress
          });
          break;
        }
      case 'renew':
        {
          openDomainRenewalModal({
            addresses: selectedAddresses
          });
          break;
        }
    }
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.root
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    ariaLabel: lang('Back'),
    className: NftCollectionHeader_module.backButton,
    onClick: clearNftsSelection
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(NftCollectionHeader_module.backIcon, 'icon-chevron-left'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.content
  }, /*#__PURE__*/teact.createElement("div", {
    className: NftCollectionHeader_module.title
  }, amount > 1 ? lang('%amount% NFTs Selected', {
    amount
  }) : lang('1 NFT Selected'))), /*#__PURE__*/teact.createElement("div", null, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    ref: ref,
    className: NftCollectionHeader_module.menuButton,
    onClick: handleMenuOpen,
    ariaLabel: lang('Open Menu')
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-menu-dots",
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isMenuOpen,
    ref: menuRef,
    withPortal: true,
    shouldTranslateOptions: true,
    menuPositionX: "right",
    menuAnchor: menuAnchor,
    getTriggerElement: getTriggerElement,
    getRootElement: getRootElement,
    getMenuElement: getMenuElement,
    getLayout: getLayout,
    buttonClassName: NftCollectionHeader_module.menuItem,
    bubbleClassName: NftCollectionHeader_module.menu,
    itemDescriptionClassName: NftCollectionHeader_module.menuItemDescription,
    items: menuItems,
    onSelect: handleMenuItemClick,
    onClose: handleMenuClose
  })));
}
/* harmony default export */ const Content_NftSelectionHeader = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  const {
    selectedAddresses,
    byAddress,
    currentCollectionAddress,
    dnsExpiration
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  return {
    selectedAddresses,
    byAddress,
    currentCollectionAddress,
    dnsExpiration,
    isViewMode: selectIsCurrentAccountViewMode(global)
  };
})(NftSelectionHeader)));
;// ./src/components/main/sections/Content/Content.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Content_module = ({"contentPanel":"Content-module__contentPanel","landscapeContentPanel":"Content-module__landscapeContentPanel","container":"Content-module__container","landscapeContainer":"Content-module__landscapeContainer","assetsPanel":"Content-module__assetsPanel","tabsContainer":"Content-module__tabsContainer","tabsSlide":"Content-module__tabsSlide","tab":"Content-module__tab","slides":"Content-module__slides","slide":"Content-module__slide","portraitContainer":"Content-module__portraitContainer","tabsContent":"Content-module__tabsContent","tabs":"Content-module__tabs","tabsOverlay":"Content-module__tabsOverlay"});
;// ./src/components/main/sections/Content/Content.tsx


































const MAIN_CONTENT_TABS_LENGTH = Object.values(ContentTab).length / 2;
const INTERSECTION_APPROXIMATION_VALUE_PX = 3 * windowEnvironment/* REM */.$;
let activeNftKey = 0;
function Content_Content(_ref) {
  let {
    isActive,
    activeContentTab,
    tokensCount,
    nfts,
    currentCollectionAddress,
    selectedAddresses,
    onStakedTokenClick,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    selectedNftsToHide,
    states,
    hasVesting,
    currentSiteCategoryId,
    doesSupportNft,
    collectionTabs,
    onTabsStuck
  } = _ref;
  const {
    selectToken,
    showTokenActivity,
    setActiveContentTab,
    openNftCollection,
    closeNftCollection,
    openSettingsWithState
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait,
    isLandscape
  } = useDeviceScreen();
  const tabsRef = teact_useRef();
  const hasNftSelection = Boolean(selectedAddresses === null || selectedAddresses === void 0 ? void 0 : selectedAddresses.length);
  const numberOfStaking = teact_useMemo(() => {
    return (states === null || states === void 0 ? void 0 : states.filter(getIsActiveStakingState).length) ?? 0;
  }, [states]);
  useSyncEffect(() => {
    if (currentCollectionAddress) {
      activeNftKey += 1;
    } else {
      activeNftKey = 0;
    }
  }, [currentCollectionAddress]);
  const handleNftsMenuButtonClick = useLastCallback(value => {
    if (value === 'hidden_nfts') {
      openSettingsWithState({
        state: SettingsState.HiddenNfts
      });
    } else {
      openNftCollection({
        address: value
      }, {
        forceOnHeavyAnimation: true
      });
    }
  });
  const nftCollections = teact_useMemo(() => {
    const blacklistedNftAddressesSet = new Set(blacklistedNftAddresses);
    const whitelistedNftAddressesSet = new Set(whitelistedNftAddresses);
    let hasTelegramGifts = false;
    const itemsByAddress = Object.values(nfts ?? {}).reduce((acc, nft) => {
      if (nft.collectionAddress && (!nft.isHidden || whitelistedNftAddressesSet.has(nft.address)) && !blacklistedNftAddressesSet.has(nft.address)) {
        if (!acc[nft.collectionAddress]) {
          acc[nft.collectionAddress] = {
            value: nft.collectionAddress,
            name: nft.collectionName || lang('Unnamed collection')
          };
        }
        if (!hasTelegramGifts && nft.isTelegramGift) {
          hasTelegramGifts = true;
        }
      }
      return acc;
    }, {});
    const items = Object.values(itemsByAddress);
    items.sort((a, b) => a.name.localeCompare(b.name));
    if (hasTelegramGifts) {
      items.unshift({
        value: src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R,
        name: lang('Telegram Gifts'),
        fontIcon: 'gift',
        withDelimiterAfter: true
      });
    }
    return items;
  }, [lang, nfts, blacklistedNftAddresses, whitelistedNftAddresses]);
  const shouldRenderHiddenNftsSection = teact_useMemo(() => {
    if (src_config/* IS_CORE_WALLET */.TI6) return false;
    const blacklistedAddressesSet = new Set(blacklistedNftAddresses);
    return Object.values(nfts ?? {}).some(nft => blacklistedAddressesSet.has(nft.address) || nft.isHidden);
  }, [blacklistedNftAddresses, nfts]);
  const transitionRef = teact_useRef();
  const totalTokensAmount = tokensCount + (hasVesting ? 1 : 0) + numberOfStaking;
  const shouldShowSeparateAssetsPanel = totalTokensAmount <= (isPortrait ? src_config/* PORTRAIT_MIN_ASSETS_TAB_VIEW */.nj6 : src_config/* LANDSCAPE_MIN_ASSETS_TAB_VIEW */.hUs);
  const [mainContentTabsCount, tabs] = teact_useMemo(() => {
    const mainContentTabs = (0,iteratees/* compact */.oE)([!shouldShowSeparateAssetsPanel && {
      id: ContentTab.Assets,
      title: lang('Assets'),
      className: Content_module.tab
    }, {
      id: ContentTab.Activity,
      title: lang('Activity'),
      className: Content_module.tab
    }, !isPortrait && !src_config/* IS_CORE_WALLET */.TI6 && {
      id: ContentTab.Explore,
      title: lang('Explore'),
      className: Content_module.tab
    }, doesSupportNft && {
      id: ContentTab.Nft,
      title: lang('Collectibles'),
      className: Content_module.tab,
      menuItems: shouldRenderHiddenNftsSection ? [...nftCollections, {
        name: lang('Hidden NFTs'),
        value: 'hidden_nfts',
        withDelimiter: true
      }] : nftCollections,
      onMenuItemClick: handleNftsMenuButtonClick
    }]);
    return [mainContentTabs.length, mainContentTabs.concat((collectionTabs === null || collectionTabs === void 0 ? void 0 : collectionTabs.map((collectionAddress, index) => {
      const collection = nftCollections.find(nc => nc.value === collectionAddress);
      if (!collection) return undefined;
      return {
        id: MAIN_CONTENT_TABS_LENGTH + index,
        title: collection.name,
        className: Content_module.tab,
        collectionAddress,
        icon: collectionAddress === src_config/* TELEGRAM_GIFTS_SUPER_COLLECTION */.X6R ? 'icon-gift' : undefined
      };
    }).filter(Boolean)) ?? [])];
  }, [collectionTabs, doesSupportNft, isPortrait, lang, nftCollections, shouldRenderHiddenNftsSection, shouldShowSeparateAssetsPanel]);
  const activeTabIndex = teact_useMemo(() => {
    const tabIndex = tabs.findIndex(tab => tab.id === activeContentTab);
    if (tabIndex === -1) {
      return ContentTab.Assets;
    }
    return tabIndex;
  }, [tabs, activeContentTab]);
  const contentTransitionKey = teact_useMemo(() => {
    if (!currentCollectionAddress || tabs[activeTabIndex].id === ContentTab.Nft) return activeTabIndex;
    const nftCollectionIndex = (collectionTabs === null || collectionTabs === void 0 ? void 0 : collectionTabs.indexOf(currentCollectionAddress)) ?? -1;
    return nftCollectionIndex === -1 ? activeTabIndex : mainContentTabsCount + nftCollectionIndex;
  }, [activeTabIndex, collectionTabs, currentCollectionAddress, mainContentTabsCount, tabs]);
  hooks_useEffectOnce(() => {
    if (activeContentTab === undefined) {
      setActiveContentTab({
        tab: ContentTab.Assets
      });
    }
  });
  const handleSwitchTab = useLastCallback(tab => {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    const tabIndex = tabs.findIndex(_ref2 => {
      let {
        id
      } = _ref2;
      return id === tab;
    });
    if (tabIndex >= mainContentTabsCount) {
      const collectionAddress = collectionTabs[tabIndex - mainContentTabsCount];
      openNftCollection({
        address: collectionAddress
      }, {
        forceOnHeavyAnimation: true
      });
      return;
    }
    selectToken({
      slug: undefined
    }, {
      forceOnHeavyAnimation: true
    });
    setActiveContentTab({
      tab
    });
  });
  const handleScrollToTop = useLastCallback(() => {
    const scrollContainer = getScrollableContainer(transitionRef.current, isPortrait);
    scrollContainer === null || scrollContainer === void 0 || scrollContainer.scrollTo(0, 0);
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled,
    update: updateScrolledState
  } = useScrolledState();
  useHistoryBack({
    isActive: activeTabIndex !== 0,
    onBack: () => handleSwitchTab(ContentTab.Assets)
  });
  const safeAreaTop = calcSafeAreaTop();
  const intersectionRootMarginTop = windowEnvironment/* STICKY_CARD_INTERSECTION_THRESHOLD */.XS - safeAreaTop - 1;
  const handleTabIntersection = useLastCallback(e => {
    const {
      intersectionRect: {
        bottom
      },
      intersectionRatio
    } = e;
    const isStuck = intersectionRatio < 1
    // During fast scrolling with rubber effect, the values in `intersectionRect` are `0`
    && bottom > 0
    // Due to the overscroll effect in iOS, it is necessary to check the bottom position of the element.
    // If the `bottom` value and `height` of the screen are approximately equal, this is overscroll, not sticking.
    && Math.abs(bottom - windowSize.get().height) > INTERSECTION_APPROXIMATION_VALUE_PX;
    onTabsStuck === null || onTabsStuck === void 0 || onTabsStuck(isStuck);
    (0,fasterdom/* requestMutation */.RK)(() => {
      e.target.classList.toggle(Content_module.tabsContainerStuck, isStuck);
    });
  });
  useElementVisibility({
    isDisabled: !isPortrait,
    targetRef: tabsRef,
    rootMargin: `${intersectionRootMarginTop}px 0px 0px 0px`,
    threshold: [1],
    cb: handleTabIntersection
  });
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF) {
      return undefined;
    }
    return captureEvents(transitionRef.current, {
      includedClosestSelector: '.swipe-container',
      excludedClosestSelector: '.dapps-feed',
      onSwipe: (e, direction) => {
        var _e$target;
        if (direction === SwipeDirection.Up || direction === SwipeDirection.Down
        // For preventing swipe in one interaction with a long press event handler
        || (_e$target = e.target) !== null && _e$target !== void 0 && _e$target.closest(`.${OPEN_CONTEXT_MENU_CLASS_NAME}`)) {
          return false;
        }
        if (direction === SwipeDirection.Left) {
          const tab = tabs[Math.min(tabs.length - 1, activeTabIndex + 1)];
          handleSwitchTab(tab.id);
          return true;
        } else if (direction === SwipeDirection.Right) {
          if (currentSiteCategoryId) return false;
          if (currentCollectionAddress) {
            closeNftCollection();
          } else {
            const tab = tabs[Math.max(0, activeTabIndex - 1)];
            handleSwitchTab(tab.id);
          }
          return true;
        }
        return false;
      },
      selectorToPreventScroll: '.custom-scroll'
    });
  }, [tabs, handleSwitchTab, activeTabIndex, currentCollectionAddress, currentSiteCategoryId]);
  const handleClickAsset = useLastCallback(slug => {
    showTokenActivity({
      slug
    });
  });

  // `isScrolled` state should be updated after tab is switched
  const handleContentTransitionStop = useLastCallback(() => {
    if (isPortrait) return;
    (0,fasterdom/* requestMeasure */.YS)(() => {
      const scrollContainer = getScrollableContainer(transitionRef.current, isPortrait);
      if (scrollContainer) {
        updateScrolledState(scrollContainer);
      }
    });
  });
  const containerClassName = buildClassName(Content_module.container, windowEnvironment/* IS_TOUCH_ENV */.TF && 'swipe-container', isPortrait ? Content_module.portraitContainer : Content_module.landscapeContainer);
  function renderTabsPanel() {
    if (hasNftSelection) {
      return /*#__PURE__*/teact.createElement(Content_NftSelectionHeader, null);
    }
    if (!isPortrait && currentSiteCategoryId) {
      return /*#__PURE__*/teact.createElement(explore_CategoryHeader, {
        id: currentSiteCategoryId
      });
    }
    return currentCollectionAddress ? /*#__PURE__*/teact.createElement(Content_NftCollectionHeader, {
      key: "collection"
    }) : /*#__PURE__*/teact.createElement(ui_TabList, {
      isActive: isActive,
      tabs: tabs,
      activeTab: activeTabIndex,
      onSwitchTab: handleSwitchTab,
      onActiveTabClick: handleScrollToTop,
      className: buildClassName(Content_module.tabs, 'content-tabslist'),
      overlayClassName: Content_module.tabsOverlay
    });
  }
  function renderCurrentTab(isActive) {
    // When assets are shown separately, there is effectively no tab with index 0,
    // so we fall back to next tab to not break parent's component logic.
    if (activeTabIndex === 0 && shouldShowSeparateAssetsPanel && !currentCollectionAddress) {
      return /*#__PURE__*/teact.createElement(Content_Activities, {
        isActive: isActive,
        totalTokensAmount: totalTokensAmount,
        onScroll: isLandscape ? handleContentScroll : undefined
      });
    }
    if (currentCollectionAddress && tabs[activeTabIndex].id !== ContentTab.Nft) {
      return /*#__PURE__*/teact.createElement("div", {
        className: "nfts-container",
        onScroll: isLandscape ? handleContentScroll : undefined
      }, /*#__PURE__*/teact.createElement(Content_Nfts, {
        key: `custom:${currentCollectionAddress}`,
        isActive: isActive
      }));
    }
    switch (tabs[activeTabIndex].id) {
      case ContentTab.Assets:
        return /*#__PURE__*/teact.createElement(Content_Assets, {
          isActive: isActive,
          onTokenClick: handleClickAsset,
          onStakedTokenClick: onStakedTokenClick,
          onScroll: isLandscape ? handleContentScroll : undefined
        });
      case ContentTab.Activity:
        return /*#__PURE__*/teact.createElement(Content_Activities, {
          isActive: isActive,
          totalTokensAmount: totalTokensAmount,
          onScroll: isLandscape ? handleContentScroll : undefined
        });
      case ContentTab.Explore:
        return /*#__PURE__*/teact.createElement(explore_Explore, {
          isActive: isActive,
          onScroll: isLandscape ? handleContentScroll : undefined
        });
      case ContentTab.Nft:
        return /*#__PURE__*/teact.createElement(ui_Transition, {
          activeKey: activeNftKey,
          name: isPortrait ? 'slide' : 'slideFade',
          className: "nfts-container",
          onScroll: isLandscape ? handleContentScroll : undefined
        }, /*#__PURE__*/teact.createElement(Content_Nfts, {
          key: currentCollectionAddress || 'all',
          isActive: isActive
        }));
      default:
        return undefined;
    }
  }
  function renderContent() {
    const headerTransitionKey = hasNftSelection || !isPortrait && currentSiteCategoryId ? 2 : currentCollectionAddress ? 1 : 0;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      ref: tabsRef,
      className: buildClassName(Content_module.tabsContainer, currentCollectionAddress && Content_module.tabsContainerForNftCollection, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
    }, /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "slideFade",
      className: Content_module.tabsContent,
      activeKey: headerTransitionKey,
      slideClassName: Content_module.tabsSlide,
      shouldCleanup: true,
      cleanupExceptionKey: 0
    }, renderTabsPanel())), /*#__PURE__*/teact.createElement(ui_Transition, {
      ref: transitionRef,
      name: isPortrait ? 'slide' : 'slideFade',
      activeKey: contentTransitionKey,
      renderCount: mainContentTabsCount + ((collectionTabs === null || collectionTabs === void 0 ? void 0 : collectionTabs.length) ?? 0),
      className: buildClassName(Content_module.slides, 'content-transition'),
      slideClassName: buildClassName(Content_module.slide, 'custom-scroll'),
      onStop: handleContentTransitionStop,
      onScroll: isLandscape ? handleContentScroll : undefined
    }, renderCurrentTab));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: containerClassName
  }, shouldShowSeparateAssetsPanel && /*#__PURE__*/teact.createElement("div", {
    className: Content_module.assetsPanel
  }, /*#__PURE__*/teact.createElement(Content_Assets, {
    isActive: true,
    isSeparatePanel: true,
    onStakedTokenClick: onStakedTokenClick,
    onTokenClick: handleClickAsset
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(isPortrait ? Content_module.contentPanel : Content_module.landscapeContentPanel)
  }, renderContent()), /*#__PURE__*/teact.createElement(modals_HideNftModal, {
    isOpen: Boolean(selectedNftsToHide === null || selectedNftsToHide === void 0 ? void 0 : selectedNftsToHide.addresses.length),
    selectedNftsToHide: selectedNftsToHide
  }));
}
/* harmony default export */ const sections_Content_Content = (memo(withGlobal(global => {
  var _vesting$info;
  const accountId = global.currentAccountId;
  const {
    activeContentTab,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    selectedNftsToHide,
    vesting,
    nfts: {
      byAddress: nfts,
      currentCollectionAddress,
      selectedAddresses,
      collectionTabs
    } = {},
    currentSiteCategoryId
  } = selectCurrentAccountState(global) ?? {};
  const tokens = selectCurrentAccountTokens(global);
  const tokensCount = selectEnabledTokensCountMemoizedFor(global.currentAccountId)(tokens);
  const hasVesting = Boolean(vesting === null || vesting === void 0 || (_vesting$info = vesting.info) === null || _vesting$info === void 0 ? void 0 : _vesting$info.length);
  const states = accountId ? selectAccountStakingStates(global, accountId) : undefined;
  const doesSupportNft = selectDoesAccountSupportNft(global);
  return {
    nfts,
    currentCollectionAddress,
    selectedAddresses,
    tokensCount,
    activeContentTab,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    selectedNftsToHide,
    states,
    hasVesting,
    currentSiteCategoryId,
    doesSupportNft,
    collectionTabs
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Content_Content)));
;// ./src/components/main/sections/Content/index.ts

;// ./src/components/main/sections/Header/AccountRenameModal.tsx










const ACCOUNT_NAME_MAX_LENGTH = 255;
function AccountRenameModal(_ref) {
  let {
    isOpen,
    name,
    currentAccountId,
    onClose
  } = _ref;
  const {
    renameAccount
  } = getActions();
  const lang = hooks_useLang();
  const inputRef = teact_useRef();
  const [newName, setNewName] = useState(name);
  teact_useEffect(() => {
    if (isOpen) {
      setNewName(name);
    }
  }, [isOpen, name]);
  useFocusAfterAnimation(inputRef, !isOpen);
  const handleSubmit = useLastCallback(e => {
    stopEvent(e);
    if (newName.trim().length === 0) return;
    renameAccount({
      accountId: currentAccountId,
      title: newName.trim()
    });
    onClose();
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isCompact: true,
    isOpen: isOpen,
    title: lang('Rename Wallet'),
    onClose: onClose
  }, /*#__PURE__*/teact.createElement("form", {
    action: "#",
    onSubmit: handleSubmit
  }, /*#__PURE__*/teact.createElement("p", null, lang('You can rename this wallet for easier identification.')), /*#__PURE__*/teact.createElement(ui_Input, {
    ref: inputRef,
    placeholder: lang('Name'),
    onInput: setNewName,
    value: newName,
    maxLength: ACCOUNT_NAME_MAX_LENGTH,
    enterKeyHint: "done"
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    className: Modal_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isSubmit: true,
    isDisabled: newName.trim().length === 0,
    className: Modal_module.button
  }, lang('Save')))));
}
/* harmony default export */ const Header_AccountRenameModal = (memo(AccountRenameModal));
;// ./src/components/main/sections/Header/AccountSelector.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AccountSelector_module = ({"root":"AccountSelector-module__root","slide":"AccountSelector-module__slide","accountTitle":"AccountSelector-module__accountTitle","withBalance":"AccountSelector-module__withBalance","accountTitleInteractive":"AccountSelector-module__accountTitleInteractive","accountTitleInner":"AccountSelector-module__accountTitleInner","arrowIcon":"AccountSelector-module__arrowIcon","balance":"AccountSelector-module__balance","balanceFractionPart":"AccountSelector-module__balanceFractionPart","balanceCurrency":"AccountSelector-module__balanceCurrency","balanceCurrencyPrefix":"AccountSelector-module__balanceCurrencyPrefix","container":"AccountSelector-module__container","dialog":"AccountSelector-module__dialog","backdrop":"AccountSelector-module__backdrop","dialog_compact":"AccountSelector-module__dialog_compact","dialogCompact":"AccountSelector-module__dialog_compact","createAccountButton":"AccountSelector-module__createAccountButton","createAccountIcon":"AccountSelector-module__createAccountIcon"});
;// ./src/components/main/sections/Header/AccountSelector.tsx
























const ACCOUNTS_AMOUNT_FOR_COMPACT_DIALOG = 2;
function AccountSelector(_ref) {
  let {
    currentAccountId,
    currentAccount,
    forceClose,
    accountClassName,
    accountSelectorClassName,
    withAccountSelector,
    withBalance,
    tokens,
    baseCurrency,
    stakingStates,
    isSensitiveDataHidden,
    accounts,
    currentWalletVersion,
    settingsByAccountId
  } = _ref;
  const {
    switchAccount,
    openAddAccountModal,
    openSettingsWithState
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const [isOpen, openAccountSelector, closeAccountSelector] = hooks_useFlag(false);
  const [isEdit, openEdit, closeEdit] = hooks_useFlag(false);
  const {
    shouldRender: shouldRenderDialog,
    ref: dialogContainerRef
  } = useShowTransition({
    isOpen,
    className: 'slow',
    withShouldRender: true
  });

  // The API doesn't check the TON wallet version for BIP39 and Tron-only accounts,
  // therefore `currentWalletVersion !== 'W5'` can be incorrectly true in that cases.
  const isBip39Account = (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.type) === 'mnemonic' && Boolean(currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.addressByChain.tron);
  const hasTonWallet = Boolean(currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.addressByChain.ton);
  const withAddW5Button = currentWalletVersion !== 'W5' && (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.type) !== 'hardware' && hasTonWallet && !isBip39Account;
  const accountsAmount = teact_useMemo(() => Object.keys(accounts || {}).length, [accounts]);
  const balanceValues = teact_useMemo(() => {
    return tokens ? calculateFullBalance(tokens, stakingStates) : undefined;
  }, [tokens, stakingStates]);
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  const {
    primaryWholePart,
    primaryFractionPart
  } = balanceValues || {};
  teact_useEffect(() => {
    if (isOpen && forceClose) closeAccountSelector();
  }, [forceClose, isOpen]);
  teact_useEffect(() => shouldRenderDialog ? captureEscKeyListener(closeAccountSelector) : undefined, [closeAccountSelector, isOpen, shouldRenderDialog]);
  teact_useEffect(() => shouldRenderDialog && dialogContainerRef.current ? trapFocus(dialogContainerRef.current) : undefined, [dialogContainerRef, shouldRenderDialog]);
  const handleOpenAccountSelector = () => {
    openAccountSelector();
  };
  const handleSwitchAccount = useLastCallback(accountId => {
    void vibrate();
    closeAccountSelector();
    switchAccount({
      accountId
    });
  });
  const handleAddWalletClick = useLastCallback(() => {
    void vibrate();
    closeAccountSelector();
    openAddAccountModal();
  });
  const handleAddV5WalletClick = useLastCallback(() => {
    void vibrate();
    closeAccountSelector();
    openSettingsWithState({
      state: SettingsState.WalletVersion
    });
  });
  function renderButton(accountId, addressByChain, accountType, title) {
    const {
      cardBackgroundNft
    } = (settingsByAccountId === null || settingsByAccountId === void 0 ? void 0 : settingsByAccountId[accountId]) || {};
    const isActive = accountId === currentAccountId;
    return /*#__PURE__*/teact.createElement(Header_AccountButton, {
      key: accountId,
      accountId: accountId,
      addressByChain: addressByChain,
      accountType: accountType,
      isActive: isActive,
      title: title,
      cardBackgroundNft: cardBackgroundNft,
      canEditAccount: !src_config/* IS_CORE_WALLET */.TI6,
      onClick: handleSwitchAccount,
      onEdit: openEdit
    });
  }
  const fullClassName = buildClassName(AccountSelector_module.container, accountSelectorClassName);
  const accountTitleClassName = buildClassName(AccountSelector_module.accountTitle, withAccountSelector && !withBalance && AccountSelector_module.accountTitleInteractive, withBalance && AccountSelector_module.withBalance, accountClassName);
  function renderCurrentAccount() {
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "slideVerticalFade",
      activeKey: withBalance ? 1 : 0,
      className: AccountSelector_module.root,
      slideClassName: AccountSelector_module.slide
    }, withBalance && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(AccountSelector_module.balance, 'rounded-font')
    }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      shouldHoldSize: true,
      align: "center",
      cols: 10,
      rows: 2,
      cellSize: 8.5
    }, /*#__PURE__*/teact.createElement("span", {
      className: AccountSelector_module.currencySwitcher
    }, shortBaseSymbol.length === 1 && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(AccountSelector_module.balanceCurrency, AccountSelector_module.balanceCurrencyPrefix)
    }, shortBaseSymbol), primaryWholePart, primaryFractionPart && /*#__PURE__*/teact.createElement("span", {
      className: AccountSelector_module.balanceFractionPart
    }, ".", primaryFractionPart), shortBaseSymbol.length > 1 && /*#__PURE__*/teact.createElement("span", {
      className: AccountSelector_module.balanceCurrency
    }, "\xA0", shortBaseSymbol)))), /*#__PURE__*/teact.createElement("div", {
      className: accountTitleClassName,
      onClick: withAccountSelector ? handleOpenAccountSelector : undefined
    }, /*#__PURE__*/teact.createElement("span", {
      className: AccountSelector_module.accountTitleInner
    }, (currentAccount && (0,util_account/* getAccountTitle */.S)(currentAccount)) ?? ''), withAccountSelector && !withBalance && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName('icon icon-caret-down', AccountSelector_module.arrowIcon),
      "aria-hidden": true
    })));
  }
  function renderAccountsSelector() {
    const dialogFullClassName = buildClassName(AccountSelector_module.dialog, accountsAmount <= ACCOUNTS_AMOUNT_FOR_COMPACT_DIALOG && AccountSelector_module.dialog_compact);
    return /*#__PURE__*/teact.createElement("div", {
      ref: dialogContainerRef,
      className: fullClassName,
      tabIndex: -1,
      role: "dialog"
    }, /*#__PURE__*/teact.createElement("div", {
      className: AccountSelector_module.backdrop,
      onClick: () => closeAccountSelector()
    }), /*#__PURE__*/teact.createElement("div", {
      className: dialogFullClassName
    }, accounts && Object.entries(accounts).map(_ref2 => {
      let [accountId, {
        title,
        addressByChain,
        type
      }] = _ref2;
      return renderButton(accountId, addressByChain, type, title);
    }), withAddW5Button && /*#__PURE__*/teact.createElement(ui_Button, {
      className: AccountSelector_module.createAccountButton,
      onClick: handleAddV5WalletClick
    }, lang('Switch to W5'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(AccountSelector_module.createAccountIcon, 'icon-versions'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement(ui_Button, {
      className: AccountSelector_module.createAccountButton,
      onClick: handleAddWalletClick
    }, lang('Add Wallet'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(AccountSelector_module.createAccountIcon, 'icon-plus'),
      "aria-hidden": true
    }))));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderCurrentAccount(), shouldRenderDialog && (isPortrait ? /*#__PURE__*/teact.createElement(ui_Portal, null, renderAccountsSelector()) : renderAccountsSelector()), /*#__PURE__*/teact.createElement(Header_AccountRenameModal, {
    isOpen: isEdit,
    currentAccountId: currentAccountId,
    name: (currentAccount === null || currentAccount === void 0 ? void 0 : currentAccount.title) ?? '',
    onClose: closeEdit
  }));
}
/* harmony default export */ const Header_AccountSelector = (memo(withGlobal(global => {
  const {
    walletVersions,
    settings: {
      byAccountId: settingsByAccountId,
      baseCurrency,
      isSensitiveDataHidden
    }
  } = global;
  const accounts = selectNetworkAccounts(global);
  const currentAccountId = global.currentAccountId;
  const currentAccount = accounts === null || accounts === void 0 ? void 0 : accounts[currentAccountId];
  const stakingStates = selectAccountStakingStates(global, currentAccountId);
  return {
    currentAccountId,
    currentAccount,
    accounts,
    currentWalletVersion: walletVersions === null || walletVersions === void 0 ? void 0 : walletVersions.currentVersion,
    settingsByAccountId,
    tokens: selectCurrentAccountTokens(global),
    baseCurrency,
    stakingStates,
    isSensitiveDataHidden
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(AccountSelector)));
;// ./src/components/main/sections/Header/actionButtons/Buttons.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Buttons_module = ({"button":"Buttons-module__button","qrScannerButton":"Buttons-module__qrScannerButton"});
;// ./src/components/main/sections/Header/actionButtons/AppLockButton.tsx







function AppLockButton() {
  const {
    setIsManualLockActive
  } = getActions();
  const lang = hooks_useLang();
  const handleManualLock = useLastCallback(() => {
    setIsManualLockActive({
      isActive: true,
      shouldHideBiometrics: true
    });
    void vibrate();
  });
  return /*#__PURE__*/teact.createElement(ui_Button, {
    className: Buttons_module.button,
    isText: true,
    isSimple: true,
    kind: "transparent",
    ariaLabel: lang('App Lock'),
    onClick: handleManualLock
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-manual-lock",
    "aria-hidden": true
  }));
}
/* harmony default export */ const actionButtons_AppLockButton = (memo(AppLockButton));
;// ./src/components/main/sections/Header/actionButtons/QrScannerButton.tsx









function QrScannerButton(_ref) {
  let {
    isViewMode
  } = _ref;
  const {
    requestOpenQrScanner
  } = getActions();
  const lang = hooks_useLang();
  const isQrScannerSupported = useQrScannerSupport() && !isViewMode;
  const handleQrScanClick = useLastCallback(() => {
    if (windowEnvironment/* IS_IOS */.pz && (0,windowEnvironment/* getIsMobileTelegramApp */.v3)()) {
      alert('Scanning is temporarily not available');
      return;
    }
    requestOpenQrScanner();
  });
  if (!isQrScannerSupported) return undefined;
  return /*#__PURE__*/teact.createElement(ui_Button, {
    className: buildClassName(Buttons_module.button, Buttons_module.qrScannerButton),
    isText: true,
    isSimple: true,
    kind: "transparent",
    ariaLabel: lang('Scan QR Code'),
    onClick: handleQrScanClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-qr-scanner",
    "aria-hidden": true
  }));
}
/* harmony default export */ const actionButtons_QrScannerButton = (memo(QrScannerButton));
;// ./src/components/main/sections/Header/actionButtons/SettingsButton.tsx





function SettingsButton() {
  const {
    openSettings
  } = getActions();
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(ui_Button, {
    className: Buttons_module.button,
    isText: true,
    isSimple: true,
    kind: "transparent",
    ariaLabel: lang('Main menu'),
    onClick: openSettings
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-cog",
    "aria-hidden": true
  }));
}
/* harmony default export */ const actionButtons_SettingsButton = (memo(SettingsButton));
;// ./src/components/main/sections/Header/actionButtons/ToggleFullscreenButton.tsx






function ToggleFullscreenButton(_ref) {
  let {
    isFullscreen
  } = _ref;
  const lang = hooks_useLang();
  const handleFullscreenToggle = useLastCallback(() => {
    if (isFullscreen) {
      var _getTelegramApp;
      (_getTelegramApp = telegram_getTelegramApp()) === null || _getTelegramApp === void 0 || _getTelegramApp.exitFullscreen();
    } else {
      var _getTelegramApp2;
      (_getTelegramApp2 = telegram_getTelegramApp()) === null || _getTelegramApp2 === void 0 || _getTelegramApp2.requestFullscreen();
    }
  });
  return /*#__PURE__*/teact.createElement(ui_Button, {
    className: Buttons_module.button,
    isText: true,
    isSimple: true,
    kind: "transparent",
    ariaLabel: lang('Toggle fullscreen'),
    onClick: handleFullscreenToggle
  }, /*#__PURE__*/teact.createElement("i", {
    className: isFullscreen ? 'icon-fullscreen-exit' : 'icon-fullscreen',
    "aria-hidden": true
  }));
}
/* harmony default export */ const actionButtons_ToggleFullscreenButton = (memo(ToggleFullscreenButton));
;// ./src/components/main/sections/Header/actionButtons/ToggleLayoutButton.tsx







function ToggleLayoutButton() {
  const {
    setAppLayout
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const handleAppLayoutToggle = useLastCallback(() => {
    setAppLayout({
      layout: isPortrait ? 'landscape' : 'portrait'
    });
  });
  return /*#__PURE__*/teact.createElement(ui_Button, {
    className: Buttons_module.button,
    isText: true,
    isSimple: true,
    kind: "transparent",
    ariaLabel: lang(isPortrait ? 'Toggle to landscape layout' : 'Toggle to portrait layout'),
    onClick: handleAppLayoutToggle
  }, /*#__PURE__*/teact.createElement("i", {
    className: isPortrait ? 'icon-view-landscape' : 'icon-view-portrait',
    "aria-hidden": true
  }));
}
/* harmony default export */ const actionButtons_ToggleLayoutButton = (memo(ToggleLayoutButton));
;// ./src/components/main/sections/Header/actionButtons/ToggleSensitiveDataButton.tsx






function ToggleSensitiveDataButton(_ref) {
  let {
    isSensitiveDataHidden
  } = _ref;
  const {
    setIsSensitiveDataHidden
  } = getActions();
  const lang = hooks_useLang();
  const handleSensitiveDataToggle = useLastCallback(() => {
    setIsSensitiveDataHidden({
      isHidden: !isSensitiveDataHidden
    });
  });
  return /*#__PURE__*/teact.createElement(ui_Button, {
    className: Buttons_module.button,
    isText: true,
    isSimple: true,
    kind: "transparent",
    ariaLabel: lang(isSensitiveDataHidden ? 'Show Sensitive Data' : 'Hide Sensitive Data'),
    onClick: handleSensitiveDataToggle
  }, /*#__PURE__*/teact.createElement("i", {
    className: isSensitiveDataHidden ? 'icon-eye' : 'icon-eye-closed',
    "aria-hidden": true
  }));
}
/* harmony default export */ const actionButtons_ToggleSensitiveDataButton = (memo(ToggleSensitiveDataButton));
;// ./src/components/main/sections/Header/Header.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Header_module = ({"header":"Header-module__header","isScrolled":"Header-module__isScrolled","areTabsStuck":"Header-module__areTabsStuck","headerInner":"Header-module__headerInner","landscapeActions":"Header-module__landscapeActions","portraitActions":"Header-module__portraitActions"});
;// ./src/components/main/sections/Header/Header.tsx















const HEADER_HEIGHT_REM = 3;
function Header(_ref) {
  let {
    isViewMode,
    withBalance,
    areTabsStuck,
    isScrolled,
    isAppLockEnabled,
    isSensitiveDataHidden,
    isFullscreen
  } = _ref;
  const {
    isPortrait
  } = useDeviceScreen();
  const canToggleAppLayout = src_config/* IS_EXTENSION */.hL1 || windowEnvironment/* IS_ELECTRON */.cp;
  if (isPortrait) {
    const fullClassName = buildClassName(Header_module.header, areTabsStuck && Header_module.areTabsStuck, isScrolled && Header_module.isScrolled);
    const iconsAmount = 1 + (isAppLockEnabled ? 1 : 0) + (src_config/* IS_TELEGRAM_APP */.tKX ? 1 : 0) + (canToggleAppLayout ? 1 : 0);
    return /*#__PURE__*/teact.createElement("div", {
      className: fullClassName
    }, /*#__PURE__*/teact.createElement("div", {
      className: Header_module.headerInner,
      style: `--icons-amount: ${iconsAmount}`
    }, /*#__PURE__*/teact.createElement(actionButtons_QrScannerButton, {
      isViewMode: isViewMode
    }), /*#__PURE__*/teact.createElement(Header_AccountSelector, {
      withBalance: withBalance,
      withAccountSelector: !src_config/* IS_CORE_WALLET */.TI6
    }), /*#__PURE__*/teact.createElement("div", {
      className: Header_module.portraitActions
    }, isAppLockEnabled && /*#__PURE__*/teact.createElement(actionButtons_AppLockButton, null), /*#__PURE__*/teact.createElement(actionButtons_ToggleSensitiveDataButton, {
      isSensitiveDataHidden: isSensitiveDataHidden
    }), src_config/* IS_TELEGRAM_APP */.tKX && /*#__PURE__*/teact.createElement(actionButtons_ToggleFullscreenButton, {
      isFullscreen: isFullscreen
    }), canToggleAppLayout && /*#__PURE__*/teact.createElement(actionButtons_ToggleLayoutButton, null))));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Header_module.header
  }, /*#__PURE__*/teact.createElement("div", {
    className: Header_module.headerInner
  }, /*#__PURE__*/teact.createElement("div", {
    className: Header_module.landscapeActions
  }, /*#__PURE__*/teact.createElement(actionButtons_ToggleSensitiveDataButton, {
    isSensitiveDataHidden: isSensitiveDataHidden
  }), /*#__PURE__*/teact.createElement(actionButtons_QrScannerButton, {
    isViewMode: isViewMode
  }), isAppLockEnabled && /*#__PURE__*/teact.createElement(actionButtons_AppLockButton, null)), /*#__PURE__*/teact.createElement(Header_AccountSelector, {
    withBalance: withBalance,
    withAccountSelector: !src_config/* IS_CORE_WALLET */.TI6
  }), /*#__PURE__*/teact.createElement("div", {
    className: Header_module.landscapeActions
  }, src_config/* IS_TELEGRAM_APP */.tKX && /*#__PURE__*/teact.createElement(actionButtons_ToggleFullscreenButton, {
    isFullscreen: isFullscreen
  }), canToggleAppLayout && /*#__PURE__*/teact.createElement(actionButtons_ToggleLayoutButton, null), /*#__PURE__*/teact.createElement(actionButtons_SettingsButton, null))));
}
/* harmony default export */ const Header_Header = (memo(withGlobal(global => {
  const {
    isFullscreen,
    settings: {
      isAppLockEnabled,
      isSensitiveDataHidden
    }
  } = global;
  const isPasswordPresent = selectIsPasswordPresent(global);
  const isViewMode = selectIsCurrentAccountViewMode(global);
  return {
    isViewMode,
    isAppLockEnabled: isAppLockEnabled && isPasswordPresent,
    isFullscreen: Boolean(isFullscreen),
    isSensitiveDataHidden: Boolean(isSensitiveDataHidden)
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Header)));
;// ./src/hooks/useBrowserUiColor.ts

function useBrowserUiColor(_ref) {
  let {
    isActive,
    currentTheme,
    lightColor,
    darkColor
  } = _ref;
  teact_useEffect(() => {
    const metaElementLight = getThemeColorMetaElement(true);
    const metaElementDark = getThemeColorMetaElement();
    const lightContent = currentTheme === 'dark' ? darkColor : lightColor;
    const darkContent = currentTheme === 'light' ? lightColor : darkColor;
    if (isActive) {
      metaElementLight.setAttribute('content', lightContent);
      metaElementDark.setAttribute('content', darkContent);
    }
    return () => {
      metaElementLight.remove();
      metaElementDark.remove();
    };
  }, [lightColor, isActive, darkColor, currentTheme]);
}
function getThemeColorMetaElement(isLight) {
  let metaThemeColor = document.querySelector(`meta[name="theme-color"][media="(prefers-color-scheme: ${isLight ? 'light' : 'dark'})"]`);
  if (!metaThemeColor) {
    metaThemeColor = document.createElement('meta');
    metaThemeColor.setAttribute('name', 'theme-color');
    metaThemeColor.setAttribute('media', `(prefers-color-scheme: ${isLight ? 'light' : 'dark'})`);
    document.getElementsByTagName('head')[0].appendChild(metaThemeColor);
  }
  return metaThemeColor;
}
;// ./src/components/main/sections/Warnings/Warnings.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Warnings_module = ({"portraitContainer":"Warnings-module__portraitContainer","container":"Warnings-module__container","testnetWarning":"Warnings-module__testnetWarning","wrapper":"Warnings-module__wrapper","wrapper_landscape":"Warnings-module__wrapper_landscape","wrapperLandscape":"Warnings-module__wrapper_landscape","wrapperFlex":"Warnings-module__wrapperFlex","icon":"Warnings-module__icon","text":"Warnings-module__text","light":"Warnings-module__light","closeButton":"Warnings-module__closeButton","domainPreviewWrapper":"Warnings-module__domainPreviewWrapper","domainPreview":"Warnings-module__domainPreview","domainPreview_1":"Warnings-module__domainPreview_1","domainPreview1":"Warnings-module__domainPreview_1","domainPreview_2":"Warnings-module__domainPreview_2","domainPreview2":"Warnings-module__domainPreview_2","domainPreview_3":"Warnings-module__domainPreview_3","domainPreview3":"Warnings-module__domainPreview_3","linkContainer":"Warnings-module__linkContainer","link":"Warnings-module__link"});
;// ./src/components/main/sections/Warnings/BackupWarning.tsx








const UI_BG_RED_LIGHT = '#F36A6B';
const UI_BG_RED_DARK = '#C44646';
function BackupWarning(_ref) {
  let {
    isRequired,
    theme,
    onOpenBackupWallet
  } = _ref;
  const {
    shouldRender,
    ref
  } = useShowTransition({
    isOpen: isRequired,
    noMountTransition: true,
    withShouldRender: true
  });
  const {
    isLandscape
  } = useDeviceScreen();
  const lang = hooks_useLang();
  useBrowserUiColor({
    isActive: isRequired,
    currentTheme: theme,
    lightColor: UI_BG_RED_LIGHT,
    darkColor: UI_BG_RED_DARK
  });
  const handleClick = () => {
    onOpenBackupWallet();
  };
  if (!shouldRender) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: buildClassName(Warnings_module.wrapper, isLandscape && Warnings_module.wrapper_landscape),
    onClick: handleClick
  }, lang('Wallet is not backed up'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Warnings_module.icon, 'icon-chevron-right'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("p", {
    className: Warnings_module.text
  }, lang('Back up wallet to have full access to it')));
}
/* harmony default export */ const Warnings_BackupWarning = (memo(withGlobal(global => {
  return {
    theme: global.settings.theme
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(BackupWarning)));
;// ./src/components/ui/Collapsible.tsx





const Collapsible_CLASSES = {
  collapsible: 'collapsible',
  shown: 'shown',
  open: 'open',
  content: 'content'
};
const DELAY = 200;
function Collapsible(_ref) {
  let {
    children,
    isShown
  } = _ref;
  const containerRef = teact_useRef();
  const isOpenRef = teact_useRef(isShown);
  const [shouldRender, setShouldRender] = useState(isShown);
  const prevIsShown = hooks_usePrevious(isShown);
  const hideTimeoutRef = teact_useRef();
  function toggleOpen() {
    if (!containerRef.current) return;
    containerRef.current.classList.toggle(Collapsible_CLASSES.open);
    isOpenRef.current = !isOpenRef.current;
  }
  if (prevIsShown !== undefined && prevIsShown !== isShown) {
    if (isShown && !isOpenRef.current) {
      setShouldRender(true);
      if (hideTimeoutRef.current) window.clearTimeout(hideTimeoutRef.current);
      setTimeout(() => (0,fasterdom/* requestMutation */.RK)(toggleOpen), DELAY);
    } else {
      (0,fasterdom/* requestMutation */.RK)(toggleOpen);
      hideTimeoutRef.current = window.setTimeout(() => {
        setShouldRender(false);
      }, DELAY);
    }
  }
  const render = /*#__PURE__*/teact.createElement("div", {
    className: Collapsible_CLASSES.content
  }, children);
  return /*#__PURE__*/teact.createElement("div", {
    ref: containerRef,
    className: buildClassName(Collapsible_CLASSES.collapsible, isShown && Collapsible_CLASSES.shown, isOpenRef.current && Collapsible_CLASSES.open)
  }, shouldRender ? render : undefined);
}
/* harmony default export */ const ui_Collapsible = (memo(Collapsible));
;// ./src/components/main/sections/Warnings/RenewDomainWarning.tsx













// Store the addresses that the user ignores for the current session
let ignoredAddressForRenewal = [];
function RenewDomainWarning(_ref) {
  let {
    orderedAddresses,
    byAddress,
    dnsExpiration
  } = _ref;
  const {
    openDomainRenewalModal
  } = getActions();
  const lang = hooks_useLang();
  const {
    isLandscape
  } = useDeviceScreen();
  const forceUpdate = hooks_useForceUpdate();
  const nftForRenewal = teact_useMemo(() => {
    return filterExpiringDomains(orderedAddresses ?? [], byAddress, dnsExpiration).filter(_ref2 => {
      let {
        address
      } = _ref2;
      return !ignoredAddressForRenewal.includes(address);
    });
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps
  }, [byAddress, ignoredAddressForRenewal, orderedAddresses]);
  const isShown = nftForRenewal.length > 0;
  const renderedNftForRenewal = useCurrentOrPrev(isShown ? nftForRenewal : undefined, true);
  const expireInDays = teact_useMemo(() => {
    const date = getDomainsExpirationDate(renderedNftForRenewal ?? [], undefined, dnsExpiration);
    return date ? (0,dateFormat/* getCountDaysToDate */.GS)(date) : undefined;
  }, [renderedNftForRenewal, dnsExpiration]);
  const expiredDomains = teact_useMemo(() => {
    if (!expireInDays || expireInDays >= 0 || !renderedNftForRenewal) return [];
    const now = Date.now();
    return renderedNftForRenewal.filter(nft => {
      const date = getTonDnsExpirationDate(nft, dnsExpiration);
      return date && date < now;
    });
  }, [dnsExpiration, expireInDays, renderedNftForRenewal]);
  function handleClick() {
    const addresses = (renderedNftForRenewal ?? []).map(_ref3 => {
      let {
        address
      } = _ref3;
      return address;
    });
    openDomainRenewalModal({
      addresses
    });
  }
  function handleClose(e) {
    stopEvent(e);
    ignoredAddressForRenewal = [...ignoredAddressForRenewal, ...nftForRenewal.map(_ref4 => {
      let {
        address
      } = _ref4;
      return address;
    })];
    forceUpdate();
  }
  function renderPreview() {
    const previewNfts = (renderedNftForRenewal ?? []).slice(0, 3);
    return /*#__PURE__*/teact.createElement("div", {
      className: Warnings_module.domainPreviewWrapper
    }, previewNfts.map((nft, index) => {
      return /*#__PURE__*/teact.createElement("img", {
        key: nft.address,
        src: nft.thumbnail,
        alt: nft.name,
        style: `--index: ${index}`,
        className: buildClassName(Warnings_module.domainPreview, Warnings_module[`domainPreview_${previewNfts.length}`])
      });
    }));
  }
  function renderWarningMessage() {
    if (expireInDays === undefined) return undefined;
    if (nftForRenewal.length === 1) {
      return expireInDays < 0 ? lang('$domain_was_expired', {
        domain: nftForRenewal[0].name
      }) : lang('$domain_expire', {
        domain: nftForRenewal[0].name,
        days: lang('$in_days', expireInDays, 'i')
      });
    }
    return expireInDays < 0 ? lang('$domains_was_expired', {
      domain: expiredDomains.length
    }, undefined, expiredDomains.length) : lang('$domains_expire', {
      domain: nftForRenewal.length,
      days: lang('$in_days', expireInDays, 'i')
    }, undefined, nftForRenewal.length);
  }
  return /*#__PURE__*/teact.createElement(ui_Collapsible, {
    isShown: isShown
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Warnings_module.wrapper, Warnings_module.wrapperFlex, isLandscape && Warnings_module.wrapper_landscape),
    onClick: handleClick
  }, renderPreview(), /*#__PURE__*/teact.createElement("div", null, (renderedNftForRenewal ?? []).length === 1 ? lang('Renew Domain') : lang('Renew Domains'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Warnings_module.icon, 'icon-chevron-right'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(Warnings_module.text, Warnings_module.light)
  }, renderWarningMessage())), /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: Warnings_module.closeButton,
    "aria-label": lang('Close'),
    onClick: handleClose
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-close",
    "aria-hidden": true
  }))));
}
/* harmony default export */ const Warnings_RenewDomainWarning = (memo(withGlobal(global => {
  const {
    nfts
  } = selectCurrentAccountState(global) || {};
  return {
    orderedAddresses: nfts === null || nfts === void 0 ? void 0 : nfts.orderedAddresses,
    byAddress: nfts === null || nfts === void 0 ? void 0 : nfts.byAddress,
    dnsExpiration: nfts === null || nfts === void 0 ? void 0 : nfts.dnsExpiration
  };
})(RenewDomainWarning)));
;// ./src/components/main/sections/Warnings/SecurityWarning.tsx










function SecurityWarning(_ref) {
  let {
    isSecurityWarningHidden
  } = _ref;
  const {
    closeSecurityWarning
  } = getActions();
  const {
    shouldRender,
    ref
  } = useShowTransition({
    isOpen: !isSecurityWarningHidden,
    noMountTransition: true,
    withShouldRender: true
  });
  const {
    isLandscape
  } = useDeviceScreen();
  const lang = hooks_useLang();
  function handleClick() {
    void openUrl(src_config/* MYTONWALLET_PROMO_URL */.tpB);
  }
  const handleClose = useLastCallback(e => {
    e.stopPropagation();
    closeSecurityWarning();
  });
  if (!shouldRender) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: buildClassName(Warnings_module.wrapper, isLandscape && Warnings_module.wrapper_landscape),
    onClick: handleClick
  }, lang('Consider More Secure Version'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Warnings_module.icon, 'icon-chevron-right'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("p", {
    className: Warnings_module.text
  }, lang('Install our native app or browser extension.')), /*#__PURE__*/teact.createElement("button", {
    type: "button",
    className: Warnings_module.closeButton,
    "aria-label": lang('Close'),
    onClick: handleClose
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-close",
    "aria-hidden": true
  })));
}
/* harmony default export */ const Warnings_SecurityWarning = (memo(withGlobal(global => {
  return {
    isSecurityWarningHidden: global.settings.isSecurityWarningHidden
  };
})(SecurityWarning)));
;// ./src/components/main/sections/Warnings/TronScamWarning.tsx









function TronScamWarning(_ref) {
  let {
    isMultisig,
    isViewMode
  } = _ref;
  const {
    isLandscape
  } = useDeviceScreen();
  const lang = hooks_useLang();
  const isShown = !!isMultisig && !isViewMode;
  const helpCenterLink = getHelpCenterUrl(lang.code, 'seedScam');
  return /*#__PURE__*/teact.createElement(ui_Collapsible, {
    isShown: isShown
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Warnings_module.wrapper, isLandscape && Warnings_module.wrapper_landscape)
  }, lang('Multisig Wallet Detected'), /*#__PURE__*/teact.createElement("p", {
    className: Warnings_module.text
  }, lang('$multisig_warning_text', {
    multisig_warning_link: /*#__PURE__*/teact.createElement("span", {
      className: Warnings_module.linkContainer
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Warnings_module.link, 'icon-chevron-right'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("a", {
      href: helpCenterLink,
      className: Warnings_module.link,
      target: "_blank",
      rel: "noreferrer"
    }, lang('$multisig_warning_link')))
  }))));
}
/* harmony default export */ const Warnings_TronScamWarning = (memo(withGlobal(global => {
  var _account$isMultisigBy;
  const account = selectCurrentAccount(global);
  return {
    isMultisig: account === null || account === void 0 || (_account$isMultisigBy = account.isMultisigByChain) === null || _account$isMultisigBy === void 0 ? void 0 : _account$isMultisigBy.tron,
    isViewMode: (account === null || account === void 0 ? void 0 : account.type) === 'view'
  };
})(TronScamWarning)));
;// ./src/components/main/sections/Warnings/Warnings.tsx












const IS_UNSAFE_WEB = !src_config/* IS_CORE_WALLET */.TI6 && !windowEnvironment/* IS_ELECTRON */.cp && !src_config/* IS_EXTENSION */.hL1 && !windowEnvironment/* IS_IOS */.pz && !windowEnvironment/* IS_ANDROID */.Ni && !src_config/* IS_TELEGRAM_APP */.tKX;
function Warnings(_ref) {
  let {
    isBackupRequired,
    isTestnet,
    isViewMode,
    onOpenBackupWallet
  } = _ref;
  const {
    isPortrait
  } = useDeviceScreen();
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, isTestnet && /*#__PURE__*/teact.createElement("div", {
    className: isPortrait ? Warnings_module.portraitContainer : Warnings_module.container
  }, /*#__PURE__*/teact.createElement("div", {
    className: Warnings_module.testnetWarning
  }, lang('Testnet Version'))), !isViewMode && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(Warnings_BackupWarning, {
    isRequired: isBackupRequired,
    onOpenBackupWallet: onOpenBackupWallet
  }), /*#__PURE__*/teact.createElement(Warnings_RenewDomainWarning, null), /*#__PURE__*/teact.createElement(Warnings_TronScamWarning, null)), IS_UNSAFE_WEB && /*#__PURE__*/teact.createElement(Warnings_SecurityWarning, null));
}
/* harmony default export */ const Warnings_Warnings = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  return {
    isBackupRequired: Boolean((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.isBackupRequired),
    isTestnet: global.settings.isTestnet,
    isViewMode: selectIsCurrentAccountViewMode(global)
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Warnings)));
;// ./src/components/main/sections/Warnings/index.ts

;// ./src/components/main/Main.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Main_module = ({"portraitContainer":"Main-module__portraitContainer","head":"Main-module__head","landscapeContainer":"Main-module__landscapeContainer","sidebar":"Main-module__sidebar","main":"Main-module__main"});
;// ./src/components/main/Main.tsx






































const UPDATE_SWAPS_INTERVAL_NOT_FOCUSED = 15000; // 15 sec
const UPDATE_SWAPS_INTERVAL = 3000; // 3 sec

function Main(_ref) {
  let {
    isActive,
    currentTokenSlug,
    stakingState,
    isTestnet,
    isViewMode,
    isLedger,
    isStakingInfoModalOpen,
    isSwapDisabled,
    isStakingDisabled,
    isOnRampDisabled,
    isMediaViewerOpen,
    theme,
    accentColorIndex
  } = _ref;
  const {
    selectToken,
    openBackupWalletModal,
    setActiveContentTab,
    closeStakingInfo,
    openStakingInfoOrStart,
    changeCurrentStaking,
    setLandscapeActionsActiveTabIndex,
    loadExploreSites,
    openReceiveModal,
    updatePendingSwaps
  } = getActions();
  const cardRef = teact_useRef();
  const portraitContainerRef = teact_useRef();
  const landscapeContainerRef = teact_useRef();
  const safeAreaTop = calcSafeAreaTop();
  const [isFocused, markIsFocused, unmarkIsFocused] = hooks_useFlag(!isBackgroundModeActive());
  const [areTabsStuck, setAreTabsStuck] = useState(false);
  const intersectionRootMarginTop = HEADER_HEIGHT_REM * windowEnvironment/* REM */.$ + safeAreaTop;
  const stakingStatus = stakingState ? getStakingStateStatus(stakingState) : 'inactive';
  useBackgroundMode(unmarkIsFocused, markIsFocused);
  useOpenFromMainBottomSheet('receive', openReceiveModal);
  usePreventPinchZoomGesture(isMediaViewerOpen);
  const {
    isPortrait,
    isLandscape
  } = useDeviceScreen();
  hooks_useEffectOnce(() => {
    if (src_config/* IS_CORE_WALLET */.TI6) return;
    loadExploreSites({
      isLandscape
    });
  });
  hooks_useInterval(updatePendingSwaps, isFocused ? UPDATE_SWAPS_INTERVAL : UPDATE_SWAPS_INTERVAL_NOT_FOCUSED);

  // Use scroll detection for portrait mode
  const {
    isVisible: isPageAtTop
  } = useElementVisibility({
    isDisabled: !isPortrait || !isActive,
    targetRef: cardRef,
    rootMargin: `-${intersectionRootMarginTop}px 0px 0px 0px`,
    threshold: [1]
  });
  const {
    isVisible: shouldHideBalanceInHeader
  } = useElementVisibility({
    isDisabled: !isPortrait || !isActive,
    targetRef: cardRef,
    rootMargin: `-${intersectionRootMarginTop}px 0px 0px 0px`
  });
  const handleTokenCardClose = useLastCallback(() => {
    selectToken({
      slug: undefined
    });
    setActiveContentTab({
      tab: ContentTab.Assets
    });
  });
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF || !isPortrait || !portraitContainerRef.current || !currentTokenSlug) {
      return undefined;
    }
    return captureEvents(portraitContainerRef.current, {
      excludedClosestSelector: '.token-card',
      onSwipe: (e, direction) => {
        if (direction === SwipeDirection.Right) {
          handleTokenCardClose();
          return true;
        }
        return false;
      }
    });
  }, [currentTokenSlug, handleTokenCardClose, isPortrait]);
  const appTheme = hooks_useAppTheme(theme);
  useAccentColor(isPortrait ? portraitContainerRef : landscapeContainerRef, appTheme, accentColorIndex);
  const handleEarnClick = useLastCallback(stakingId => {
    if (stakingId) changeCurrentStaking({
      stakingId
    });
    if (isPortrait || isViewMode) {
      openStakingInfoOrStart();
    } else {
      setLandscapeActionsActiveTabIndex({
        index: ActiveTab.Stake
      });
    }
  });
  function renderPortraitLayout() {
    return /*#__PURE__*/teact.createElement("div", {
      ref: portraitContainerRef,
      className: Main_module.portraitContainer
    }, /*#__PURE__*/teact.createElement("div", {
      className: Main_module.head
    }, /*#__PURE__*/teact.createElement(Warnings_Warnings, {
      onOpenBackupWallet: openBackupWalletModal
    }), /*#__PURE__*/teact.createElement(Header_Header, {
      withBalance: !shouldHideBalanceInHeader,
      areTabsStuck: areTabsStuck,
      isScrolled: !isPageAtTop
    }), /*#__PURE__*/teact.createElement(Card_Card, {
      ref: cardRef,
      onTokenCardClose: handleTokenCardClose,
      onYieldClick: handleEarnClick
    }), !isViewMode && /*#__PURE__*/teact.createElement(Actions_PortraitActions, {
      containerRef: portraitContainerRef,
      isTestnet: isTestnet,
      stakingStatus: stakingStatus,
      isStakingDisabled: isStakingDisabled,
      isSwapDisabled: isSwapDisabled,
      isOnRampDisabled: isOnRampDisabled,
      onEarnClick: handleEarnClick
    })), /*#__PURE__*/teact.createElement(sections_Content_Content, {
      isActive: isActive,
      onStakedTokenClick: handleEarnClick,
      onTabsStuck: setAreTabsStuck
    }));
  }
  function renderLandscapeLayout() {
    return /*#__PURE__*/teact.createElement("div", {
      ref: landscapeContainerRef,
      className: Main_module.landscapeContainer
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Main_module.sidebar, 'custom-scroll')
    }, /*#__PURE__*/teact.createElement(Warnings_Warnings, {
      onOpenBackupWallet: openBackupWalletModal
    }), /*#__PURE__*/teact.createElement(Header_Header, null), /*#__PURE__*/teact.createElement(Card_Card, {
      onTokenCardClose: handleTokenCardClose,
      onYieldClick: handleEarnClick
    }), !isViewMode && /*#__PURE__*/teact.createElement(Actions_LandscapeActions, {
      containerRef: landscapeContainerRef,
      stakingStatus: stakingStatus,
      isLedger: isLedger,
      theme: theme
    })), /*#__PURE__*/teact.createElement("div", {
      className: Main_module.main
    }, /*#__PURE__*/teact.createElement(sections_Content_Content, {
      onStakedTokenClick: handleEarnClick
    })));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, !windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && (isPortrait ? renderPortraitLayout() : renderLandscapeLayout()), /*#__PURE__*/teact.createElement(staking_StakeModal, null), /*#__PURE__*/teact.createElement(staking_StakingInfoModal, {
    isOpen: isStakingInfoModalOpen,
    onClose: closeStakingInfo
  }), /*#__PURE__*/teact.createElement(receive_ReceiveModal, null), /*#__PURE__*/teact.createElement(receive_InvoiceModal, null), /*#__PURE__*/teact.createElement(staking_UnstakeModal, null), /*#__PURE__*/teact.createElement(staking_StakingClaimModal, null), /*#__PURE__*/teact.createElement(vesting_VestingModal, null), /*#__PURE__*/teact.createElement(vesting_VestingPasswordModal, null), /*#__PURE__*/teact.createElement(domain_RenewDomainModal, null), /*#__PURE__*/teact.createElement(domain_LinkingDomainModal, null), !windowEnvironment/* IS_ELECTRON */.cp && !windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && /*#__PURE__*/teact.createElement(ui_UpdateAvailable, null));
}
/* harmony default export */ const main_Main = (memo(withGlobal(global => {
  var _global$mediaViewer, _selectCurrentAccount;
  const {
    ledger
  } = selectCurrentAccount(global) || {};
  const accountState = selectCurrentAccountState(global);
  const {
    currentTokenSlug
  } = accountState ?? {};
  const {
    isOnRampDisabled
  } = global.restrictions;
  const stakingState = global.currentAccountId ? selectAccountStakingState(global, global.currentAccountId) : undefined;
  return {
    stakingState,
    currentTokenSlug,
    isTestnet: global.settings.isTestnet,
    isLedger: Boolean(ledger),
    isViewMode: selectIsCurrentAccountViewMode(global),
    isStakingInfoModalOpen: global.isStakingInfoModalOpen,
    isMediaViewerOpen: Boolean((_global$mediaViewer = global.mediaViewer) === null || _global$mediaViewer === void 0 ? void 0 : _global$mediaViewer.mediaId),
    isSwapDisabled: selectIsSwapDisabled(global),
    isStakingDisabled: selectIsStakingDisabled(global),
    isOnRampDisabled,
    theme: global.settings.theme,
    accentColorIndex: (_selectCurrentAccount = selectCurrentAccountSettings(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.accentColorIndex
  };
}, (global, _, stickToFirst) => stickToFirst(global.currentAccountId))(Main)));
;// ./src/components/main/modals/AddAccountPasswordModal.tsx







function AddAccountPasswordModal(_ref) {
  let {
    isActive,
    isLoading,
    error,
    onClearError,
    onSubmit,
    onBack,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Enter Password'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
    isActive: isActive,
    isLoading: isLoading,
    error: error,
    operationType: "passcode",
    withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
    submitLabel: lang('Send'),
    cancelLabel: lang('Back'),
    onSubmit: onSubmit,
    onCancel: onBack,
    onUpdate: onClearError
  }));
}
/* harmony default export */ const modals_AddAccountPasswordModal = (memo(AddAccountPasswordModal));
;// ./src/components/main/modals/AddAccountModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AddAccountModal_module = ({"modalDialog":"AddAccountModal-module__modalDialog","modalContent":"AddAccountModal-module__modalContent","actionsSection":"AddAccountModal-module__actionsSection","actionsSectionShift":"AddAccountModal-module__actionsSectionShift","importText":"AddAccountModal-module__importText","walletVersionBlock":"AddAccountModal-module__walletVersionBlock","walletVersionText":"AddAccountModal-module__walletVersionText"});
;// ./src/components/main/modals/AddAccountModal.tsx





















var RenderingState = /*#__PURE__*/function (RenderingState) {
  RenderingState[RenderingState["Initial"] = 0] = "Initial";
  RenderingState[RenderingState["Password"] = 1] = "Password";
  RenderingState[RenderingState["ConnectHardware"] = 2] = "ConnectHardware";
  RenderingState[RenderingState["SelectAccountsHardware"] = 3] = "SelectAccountsHardware";
  RenderingState[RenderingState["ViewMode"] = 4] = "ViewMode";
  return RenderingState;
}(RenderingState || {});
function AddAccountModal(_ref) {
  let {
    isOpen,
    isLoading,
    error,
    hardwareWallets,
    isPasswordPresent,
    accounts,
    withOtherWalletVersions,
    forceAddingTonOnlyAccount
  } = _ref;
  const {
    addAccount,
    clearAccountError,
    closeAddAccountModal,
    afterSelectHardwareWallets,
    openSettingsWithState,
    resetHardwareWalletConnect,
    clearAccountLoading
  } = getActions();
  const lang = hooks_useLang();
  const [renderingKey, setRenderingKey] = useState(RenderingState.Initial);
  const [isNewAccountImporting, setIsNewAccountImporting] = useState(false);
  const handleBackClick = useLastCallback(() => {
    setRenderingKey(RenderingState.Initial);
    clearAccountError();
  });
  const handleModalClose = useLastCallback(() => {
    setRenderingKey(RenderingState.Initial);
    setIsNewAccountImporting(false);
    clearAccountLoading();
  });
  const handleNewAccountClick = useLastCallback(() => {
    if (!isPasswordPresent) {
      addAccount({
        method: 'createAccount',
        password: ''
      });
      return;
    }
    if (getHasInMemoryPassword()) {
      void getInMemoryPassword().then(password => addAccount({
        method: 'createAccount',
        password: password
      }));
    } else {
      setRenderingKey(RenderingState.Password);
      setIsNewAccountImporting(false);
    }
  });
  teact_useEffect(() => {
    if (forceAddingTonOnlyAccount) {
      handleNewAccountClick();
    }
  }, [forceAddingTonOnlyAccount]);
  const handleImportAccountClick = useLastCallback(() => {
    if (!isPasswordPresent) {
      addAccount({
        method: 'importMnemonic',
        password: ''
      });
      return;
    }
    setIsNewAccountImporting(true);
    if (getHasInMemoryPassword()) {
      void getInMemoryPassword().then(password => addAccount({
        method: 'importMnemonic',
        password: password
      }));
    } else {
      setRenderingKey(RenderingState.Password);
    }
  });
  const handleViewModeWalletClick = useLastCallback(() => {
    setRenderingKey(RenderingState.ViewMode);
  });
  const handleImportHardwareWalletClick = useLastCallback(() => {
    resetHardwareWalletConnect();
    setRenderingKey(RenderingState.ConnectHardware);
  });
  const handleAddLedgerWallet = useLastCallback(() => {
    afterSelectHardwareWallets({
      hardwareSelectedIndices: [hardwareWallets[0].index]
    });
    closeAddAccountModal();
  });
  const handleHardwareWalletConnected = useLastCallback(isSingleWallet => {
    if (isSingleWallet) {
      handleAddLedgerWallet();
      return;
    }
    setRenderingKey(RenderingState.SelectAccountsHardware);
  });
  const handleSubmit = useLastCallback(password => {
    addAccount({
      method: isNewAccountImporting ? 'importMnemonic' : 'createAccount',
      password
    });
  });
  const handleOpenSettingWalletVersion = useLastCallback(() => {
    closeAddAccountModal();
    openSettingsWithState({
      state: SettingsState.WalletVersion
    });
  });
  function renderSelector() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Add Wallet'),
      onClose: closeAddAccountModal
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(AddAccountModal_module.actionsSection, AddAccountModal_module.actionsSectionShift)
    }, /*#__PURE__*/teact.createElement(ui_ListItem, {
      icon: "wallet-add",
      label: lang('Create New Wallet'),
      onClick: handleNewAccountClick,
      isLoading: !isNewAccountImporting && isLoading
    })), /*#__PURE__*/teact.createElement("span", {
      className: AddAccountModal_module.importText
    }, lang('or import from')), /*#__PURE__*/teact.createElement("div", {
      className: AddAccountModal_module.actionsSection
    }, /*#__PURE__*/teact.createElement(ui_ListItem, {
      icon: "key",
      label: lang(src_config/* IS_CORE_WALLET */.TI6 ? '24 Secret Words' : '12/24 Secret Words'),
      onClick: handleImportAccountClick,
      isLoading: isNewAccountImporting && isLoading
    }), windowEnvironment/* IS_LEDGER_SUPPORTED */.sC && /*#__PURE__*/teact.createElement(ui_ListItem, {
      icon: "ledger-alt",
      label: lang('Ledger'),
      onClick: handleImportHardwareWalletClick
    })), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("div", {
      className: AddAccountModal_module.actionsSection
    }, /*#__PURE__*/teact.createElement(ui_ListItem, {
      icon: "wallet-view",
      label: lang('View Any Address'),
      onClick: handleViewModeWalletClick
    })), withOtherWalletVersions && /*#__PURE__*/teact.createElement("div", {
      className: AddAccountModal_module.walletVersionBlock
    }, /*#__PURE__*/teact.createElement("span", null, lang('$wallet_switch_version_1', {
      action: /*#__PURE__*/teact.createElement("div", {
        role: "button",
        tabIndex: 0,
        onClick: handleOpenSettingWalletVersion,
        className: AddAccountModal_module.walletVersionText
      }, lang('$wallet_switch_version_2'))
    }))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case RenderingState.Initial:
        return renderSelector();
      case RenderingState.Password:
        return /*#__PURE__*/teact.createElement(modals_AddAccountPasswordModal, {
          isActive: isActive,
          isLoading: isLoading,
          error: error,
          onClearError: clearAccountError,
          onSubmit: handleSubmit,
          onBack: handleBackClick,
          onClose: closeAddAccountModal
        });
      case RenderingState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleHardwareWalletConnected,
          onCancel: handleBackClick,
          onClose: closeAddAccountModal
        });
      case RenderingState.SelectAccountsHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerSelectWallets, {
          accounts: accounts,
          hardwareWallets: hardwareWallets,
          onCancel: handleBackClick,
          onClose: closeAddAccountModal
        });
      case RenderingState.ViewMode:
        return /*#__PURE__*/teact.createElement(auth_AuthImportViewAccount, {
          isActive: isActive,
          isLoading: isLoading,
          onCancel: handleBackClick,
          onClose: closeAddAccountModal
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen,
    noBackdropClose: true,
    dialogClassName: AddAccountModal_module.modalDialog,
    contentClassName: AddAccountModal_module.modalContent,
    nativeBottomSheetKey: "add-account",
    forceFullNative: renderingKey === RenderingState.Password,
    onCloseAnimationEnd: handleModalClose,
    onClose: closeAddAccountModal
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: renderingKey === RenderingState.Initial && !getHasInMemoryPassword() ? RenderingState.Password : undefined
  }, renderContent));
}
/* harmony default export */ const modals_AddAccountModal = (memo(withGlobal(global => {
  var _global$accounts, _global$accounts2;
  const accounts = selectNetworkAccounts(global);
  const isPasswordPresent = selectIsPasswordPresent(global);
  const {
    byId: versionById
  } = global.walletVersions ?? {};
  const versions = versionById === null || versionById === void 0 ? void 0 : versionById[global.currentAccountId];
  const withOtherWalletVersions = !!(versions !== null && versions !== void 0 && versions.length);
  const {
    auth: {
      forceAddingTonOnlyAccount
    },
    hardware: {
      hardwareWallets
    }
  } = global;
  return {
    isOpen: global.isAddAccountModalOpen,
    isLoading: (_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.isLoading,
    error: (_global$accounts2 = global.accounts) === null || _global$accounts2 === void 0 ? void 0 : _global$accounts2.error,
    accounts,
    isPasswordPresent,
    hardwareWallets,
    withOtherWalletVersions,
    forceAddingTonOnlyAccount
  };
})(AddAccountModal)));
;// ./src/components/auth/MnemonicCheck.tsx









function MnemonicCheck(_ref) {
  let {
    isActive,
    isInModal,
    mnemonic,
    checkIndexes,
    buttonLabel,
    onCancel,
    onSubmit,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onCancel
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContentWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Let\'s Check!'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.transitionContent, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(Auth_module.info, Auth_module.small)
  }, lang('Letâ€™s make sure your secrets words are recorded correctly.')), /*#__PURE__*/teact.createElement(backup_CheckWordsForm, {
    descriptionClassName: buildClassName(Auth_module.info, Auth_module.small),
    isActive: isActive,
    mnemonic: mnemonic,
    checkIndexes: checkIndexes,
    isInModal: isInModal,
    errorClassName: buildClassName(Auth_module.error, Auth_module.small),
    onSubmit: onSubmit
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onCancel,
    className: Modal_module.button
  }, lang('Back')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    forFormId: "check_mnemonic_form",
    className: Modal_module.button
  }, buttonLabel))));
}
/* harmony default export */ const auth_MnemonicCheck = (memo(MnemonicCheck));
;// ./src/components/auth/MnemonicList.tsx









function MnemonicList(_ref) {
  let {
    isActive,
    mnemonic,
    onNext,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const wordsCount = (mnemonic === null || mnemonic === void 0 ? void 0 : mnemonic.length) || 0;
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContentWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('%1$d Secret Words', wordsCount),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.mnemonicContainer, Modal_module.transitionContent, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(backup_SecretWordsList, {
    mnemonic: mnemonic
  }), onNext && /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    onClick: onNext
  }, lang('Let\'s Check')))));
}
/* harmony default export */ const auth_MnemonicList = (memo(MnemonicList));
;// ./src/components/auth/MnemonicPrivateKey.tsx









function MnemonicPrivateKey_MnemonicList(_ref) {
  let {
    isActive,
    privateKeyHex,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContentWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Private Key'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Auth_module.mnemonicContainer, Modal_module.transitionContent, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(Auth_module.info, Auth_module.small)
  }, /*#__PURE__*/teact.createElement(ui_Emoji, {
    from: "\u26A0\uFE0F"
  }), ' ', renderText(lang('$mnemonic_warning'))), /*#__PURE__*/teact.createElement("p", {
    className: Auth_module.privateKey
  }, privateKeyHex)));
}
/* harmony default export */ const MnemonicPrivateKey = (memo(MnemonicPrivateKey_MnemonicList));
;// ./src/components/auth/SafetyRules.tsx








function SafetyRules(_ref) {
  let {
    isActive,
    onSubmit,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const [writedownAccepted, setWritedownAccepted] = useState(false);
  const [openWalletAccepted, setOpenWalletAccepted] = useState(false);
  const [canBeStolenAccepted, setCanBeStolenAccepted] = useState(false);
  const canSubmit = writedownAccepted && openWalletAccepted && canBeStolenAccepted;
  const handleSubmit = useLastCallback(() => {
    if (!canSubmit) {
      return;
    }
    onSubmit();
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContentWrapper
  }, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Safety Rules'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.transitionContent, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(backup_SafetyRulesContent, {
    customStickerClassName: Auth_module.modalSticker,
    customButtonWrapperClassName: Modal_module.buttons,
    isFullSizeButton: false,
    isActive: isActive,
    isFirstCheckboxSelected: writedownAccepted,
    isSecondCheckboxSelected: openWalletAccepted,
    isThirdCheckboxSelected: canBeStolenAccepted,
    textFirst: lang('$safety_rules_one'),
    textSecond: lang('$safety_rules_two'),
    textThird: lang('$safety_rules_three'),
    onFirstCheckboxClick: setWritedownAccepted,
    onSecondCheckboxClick: setOpenWalletAccepted,
    onThirdCheckboxClick: setCanBeStolenAccepted,
    onSubmit: handleSubmit
  })));
}
/* harmony default export */ const auth_SafetyRules = (memo(SafetyRules));
;// ./src/components/main/modals/BackupModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const BackupModal_module = ({"modalDialog":"BackupModal-module__modalDialog"});
;// ./src/components/main/modals/BackupModal.tsx























var BackupModal_SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["confirm"] = 0] = "confirm";
  SLIDES[SLIDES["password"] = 1] = "password";
  SLIDES[SLIDES["mnemonic"] = 2] = "mnemonic";
  SLIDES[SLIDES["check"] = 3] = "check";
  return SLIDES;
}(BackupModal_SLIDES || {});
function BackupModal(_ref) {
  let {
    isOpen,
    currentAccountId,
    onClose,
    isBackupRequired
  } = _ref;
  const {
    setIsBackupRequired,
    setIsPinAccepted,
    clearIsPinAccepted
  } = getActions();
  const lang = hooks_useLang();
  const [currentSlide, setCurrentSlide] = useState(BackupModal_SLIDES.confirm);
  const [nextKey, setNextKey] = useState(BackupModal_SLIDES.password);
  const [checkIndexes, setCheckIndexes] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState();
  const mnemonicRef = teact_useRef(undefined);
  const noResetFullNativeOnBlur = currentSlide === BackupModal_SLIDES.confirm || currentSlide === BackupModal_SLIDES.password;
  teact_useEffect(() => {
    mnemonicRef.current = undefined;
  }, [isOpen]);
  const handleSafetyConfirm = useLastCallback(() => {
    setCurrentSlide(BackupModal_SLIDES.password);
    setNextKey(BackupModal_SLIDES.mnemonic);
  });
  const handlePasswordSubmit = useLastCallback(async password => {
    setIsLoading(true);
    mnemonicRef.current = await (0,api/* callApi */.p)('fetchMnemonic', currentAccountId, password);
    if (!mnemonicRef.current) {
      setError('Wrong password, please try again.');
      setIsLoading(false);
      void vibrateOnError();
      return;
    }
    if (getDoesUsePinPad()) {
      setIsPinAccepted();
      await vibrateOnSuccess(true);
      clearIsPinAccepted();
    }
    setIsLoading(false);
    setNextKey(BackupModal_SLIDES.check);
    setCurrentSlide(BackupModal_SLIDES.mnemonic);
  });
  const handleBackupErrorUpdate = useLastCallback(() => {
    setError(undefined);
  });
  const handleCheckMnemonic = useLastCallback(() => {
    var _mnemonicRef$current;
    setCheckIndexes(selectMnemonicForCheck(((_mnemonicRef$current = mnemonicRef.current) === null || _mnemonicRef$current === void 0 ? void 0 : _mnemonicRef$current.length) || src_config/* MNEMONIC_COUNT */.xA_));
    setCurrentSlide(BackupModal_SLIDES.check);
    setNextKey(undefined);
  });
  const handleRestartCheckMnemonic = useLastCallback(() => {
    setCurrentSlide(BackupModal_SLIDES.mnemonic);
    setNextKey(BackupModal_SLIDES.check);
  });
  const handleModalClose = useLastCallback(() => {
    setIsLoading(false);
    setError(undefined);
    setCurrentSlide(BackupModal_SLIDES.confirm);
    setNextKey(BackupModal_SLIDES.password);
  });
  const handleCheckMnemonicSubmit = useLastCallback(() => {
    setIsBackupRequired({
      isMnemonicChecked: true
    });
    onClose();
  });
  function renderContent(isActive, isFrom, currentKey) {
    const mnemonic = mnemonicRef.current;
    switch (currentKey) {
      case BackupModal_SLIDES.confirm:
        return /*#__PURE__*/teact.createElement(auth_SafetyRules, {
          isActive: isActive,
          onSubmit: handleSafetyConfirm,
          onClose: onClose
        });
      case BackupModal_SLIDES.password:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Enter Password'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
          isActive: isActive,
          isLoading: isLoading,
          error: error,
          withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
          submitLabel: lang('$back_up_auth'),
          cancelLabel: lang('Cancel'),
          onSubmit: handlePasswordSubmit,
          onCancel: onClose,
          onUpdate: handleBackupErrorUpdate
        }));
      case BackupModal_SLIDES.mnemonic:
        return mnemonic && isMnemonicPrivateKey(mnemonic) ? /*#__PURE__*/teact.createElement(MnemonicPrivateKey, {
          privateKeyHex: mnemonic[0],
          onClose: onClose
        }) : /*#__PURE__*/teact.createElement(auth_MnemonicList, {
          isActive: isActive,
          mnemonic: mnemonic,
          onNext: isBackupRequired ? handleCheckMnemonic : undefined,
          onClose: onClose
        });
      case BackupModal_SLIDES.check:
        return /*#__PURE__*/teact.createElement(auth_MnemonicCheck, {
          isActive: isActive,
          isInModal: true,
          mnemonic: mnemonicRef.current,
          checkIndexes: checkIndexes,
          buttonLabel: lang('Done'),
          onSubmit: handleCheckMnemonicSubmit,
          onCancel: handleRestartCheckMnemonic,
          onClose: onClose
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    hasCloseButton: true,
    dialogClassName: BackupModal_module.modalDialog,
    nativeBottomSheetKey: "backup",
    forceFullNative: currentSlide === BackupModal_SLIDES.password,
    noResetFullNativeOnBlur: noResetFullNativeOnBlur,
    onClose: onClose,
    onCloseAnimationEnd: handleModalClose
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: currentSlide,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const modals_BackupModal = (memo(withGlobal(global => {
  const {
    isBackupRequired
  } = selectCurrentAccountState(global) || {};
  return {
    currentAccountId: global.currentAccountId,
    isBackupRequired
  };
})(BackupModal)));
;// ./src/components/main/modals/NftAttributesModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const NftAttributesModal_module = ({"modal":"NftAttributesModal-module__modal","dialog":"NftAttributesModal-module__dialog","container":"NftAttributesModal-module__container","menuButton":"NftAttributesModal-module__menuButton","closeButton":"NftAttributesModal-module__closeButton","icon":"NftAttributesModal-module__icon","nftInfo":"NftAttributesModal-module__nftInfo","fullImage":"NftAttributesModal-module__fullImage","thumbnail":"NftAttributesModal-module__thumbnail","info":"NftAttributesModal-module__info","nftName":"NftAttributesModal-module__nftName","collectionName":"NftAttributesModal-module__collectionName","content":"NftAttributesModal-module__content","noData":"NftAttributesModal-module__noData","label":"NftAttributesModal-module__label","description":"NftAttributesModal-module__description","attributesList":"NftAttributesModal-module__attributesList","attributeName":"NftAttributesModal-module__attributeName","attributeValue":"NftAttributesModal-module__attributeValue","first":"NftAttributesModal-module__first","last":"NftAttributesModal-module__last","expandButton":"NftAttributesModal-module__expandButton","collectionNameIcon":"NftAttributesModal-module__collectionNameIcon","expandButtonIcon":"NftAttributesModal-module__expandButtonIcon"});
;// ./src/components/main/modals/NftAttributesModal.tsx



















const FOLD_LIMIT = 5;
const ANIMATED_ICON_SIZE = 250; // Preview size (500px) / 2

function NftAttributesModal(_ref) {
  let {
    nft,
    dnsExpiration
  } = _ref;
  const {
    closeNftAttributesModal,
    openMediaViewer,
    openNftCollection
  } = getActions();
  const lang = hooks_useLang();
  const menuButtonRef = teact_useRef();
  const [menuAnchor, setMenuAnchor] = useState();
  const {
    isPortrait
  } = useDeviceScreen();
  const isOpen = !!nft;
  const renderedNft = useCurrentOrPrev(nft, true);
  const {
    metadata: {
      lottie,
      attributes
    }
  } = renderedNft || {
    metadata: {}
  };
  const attributesCount = (attributes === null || attributes === void 0 ? void 0 : attributes.length) || 0;
  const [isFolded, setIsFolded] = useState(attributesCount > FOLD_LIMIT);
  const tonDnsExpiration = getTonDnsExpirationDate(renderedNft, dnsExpiration);
  const dnsExpireInDays = tonDnsExpiration ? (0,dateFormat/* getCountDaysToDate */.GS)(tonDnsExpiration) : undefined;
  const list = (attributes === null || attributes === void 0 ? void 0 : attributes.slice(0, isFolded ? FOLD_LIMIT : undefined)) || [];
  const isNoData = !(renderedNft !== null && renderedNft !== void 0 && renderedNft.description) && list.length === 0;
  useSyncEffect(() => {
    setIsFolded(attributesCount > FOLD_LIMIT + 1);
  }, [attributesCount, nft]);
  teact_useEffect(() => {
    if (!isOpen) return undefined;
    disableSwipeToClose();
    return enableSwipeToClose;
  }, [isOpen]);
  const handleOpenMenu = useLastCallback(() => {
    const {
      right: x,
      y
    } = menuButtonRef.current.getBoundingClientRect();
    setMenuAnchor({
      x,
      y
    });
  });
  const handleCloseMenu = useLastCallback(() => {
    setMenuAnchor(undefined);
  });
  const handleExpand = useLastCallback(e => {
    stopEvent(e);
    setIsFolded(false);
  });
  const handleNftClick = useLastCallback(() => {
    openMediaViewer({
      mediaId: renderedNft.address,
      mediaType: MediaType.Nft
    });
  });
  const handleCollectionClick = useLastCallback(e => {
    stopEvent(e);
    closeNftAttributesModal(undefined, {
      forceOnHeavyAnimation: true
    });
    openNftCollection({
      address: renderedNft.collectionAddress
    }, {
      forceOnHeavyAnimation: true
    });
  });
  const renderAttributeRow = (attribute, index) => {
    const isFirst = index === 0;
    const isLast = index === list.length - 1;
    return /*#__PURE__*/teact.createElement("tr", {
      key: index
    }, /*#__PURE__*/teact.createElement("th", {
      className: buildClassName(NftAttributesModal_module.attributeName, isFirst && NftAttributesModal_module.first, isLast && NftAttributesModal_module.last)
    }, attribute.trait_type), /*#__PURE__*/teact.createElement("td", {
      className: buildClassName(NftAttributesModal_module.attributeValue, isFirst && NftAttributesModal_module.first, isLast && NftAttributesModal_module.last)
    }, attribute.value));
  };
  if (!renderedNft) return undefined;
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    className: NftAttributesModal_module.modal,
    dialogClassName: NftAttributesModal_module.dialog,
    contentClassName: NftAttributesModal_module.container,
    onClose: closeNftAttributesModal
  }, /*#__PURE__*/teact.createElement("button", {
    type: "button",
    "aria-label": lang('Close'),
    className: NftAttributesModal_module.closeButton,
    onClick: () => closeNftAttributesModal()
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(NftAttributesModal_module.icon, NftAttributesModal_module.actionIcon, isPortrait && !(windowEnvironment/* IS_ELECTRON */.cp && windowEnvironment/* IS_MAC_OS */.MP) ? 'icon-chevron-left' : 'icon-close'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(Content_NftMenu, {
    nft: renderedNft,
    ref: menuButtonRef,
    dnsExpireInDays: dnsExpireInDays,
    menuAnchor: menuAnchor,
    className: NftAttributesModal_module.menuButton,
    onOpen: handleOpenMenu,
    onClose: handleCloseMenu
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(NftAttributesModal_module.nftInfo, 'nft-container'),
    "data-nft-address": renderedNft.address
  }, lottie ? /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    size: ANIMATED_ICON_SIZE,
    shouldStretch: true,
    play: isOpen,
    noLoop: false,
    tgsUrl: lottie,
    previewUrl: renderedNft.thumbnail,
    className: NftAttributesModal_module.thumbnail,
    noPreviewTransition: true,
    onClick: handleNftClick
  }) : /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("img", {
    src: renderedNft.thumbnail,
    alt: lang('Preview'),
    role: "button",
    tabIndex: 0,
    className: NftAttributesModal_module.thumbnail,
    onClick: handleNftClick
  }), Boolean(renderedNft.image) && /*#__PURE__*/teact.createElement("img", {
    src: renderedNft.image,
    alt: renderedNft.name,
    role: "button",
    tabIndex: 0,
    className: NftAttributesModal_module.fullImage,
    onClick: handleNftClick
  })), /*#__PURE__*/teact.createElement("div", {
    className: NftAttributesModal_module.info
  }, /*#__PURE__*/teact.createElement("div", {
    className: NftAttributesModal_module.nftName
  }, renderedNft.name), renderedNft.collectionName && /*#__PURE__*/teact.createElement("div", {
    className: NftAttributesModal_module.collectionName,
    onClick: handleCollectionClick,
    tabIndex: 0,
    role: "button"
  }, renderedNft.collectionName, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(NftAttributesModal_module.collectionNameIcon, 'icon-chevron-right'),
    "aria-hidden": true
  })))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(NftAttributesModal_module.content, isNoData && NftAttributesModal_module.noData)
  }, isNoData && lang('No additional data.'), renderedNft.description && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("h3", {
    className: NftAttributesModal_module.label
  }, lang('Description')), /*#__PURE__*/teact.createElement("div", {
    className: NftAttributesModal_module.description
  }, renderedNft.description)), list.length > 0 && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("h3", {
    className: NftAttributesModal_module.label
  }, lang('Attributes')), /*#__PURE__*/teact.createElement("table", {
    className: NftAttributesModal_module.attributesList
  }, /*#__PURE__*/teact.createElement("tbody", null, list.map(renderAttributeRow))), isFolded && /*#__PURE__*/teact.createElement("a", {
    href: "#",
    className: NftAttributesModal_module.expandButton,
    onClick: handleExpand
  }, lang('Show All'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(NftAttributesModal_module.expandButtonIcon, 'icon-chevron-down'),
    "aria-hidden": true
  })))));
}
/* harmony default export */ const modals_NftAttributesModal = (memo(withGlobal(global => {
  const {
    currentNftForAttributes,
    nfts
  } = selectCurrentAccountState(global) || {};
  const {
    dnsExpiration
  } = nfts || {};
  return {
    nft: currentNftForAttributes,
    dnsExpiration
  };
})(NftAttributesModal)));
;// ./src/components/main/modals/OnRampWidgetModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const OnRampWidgetModal_module = ({"modalDialog":"OnRampWidgetModal-module__modalDialog","content":"OnRampWidgetModal-module__content","iframe":"OnRampWidgetModal-module__iframe","loaderContainer":"OnRampWidgetModal-module__loaderContainer","fadeOut":"OnRampWidgetModal-module__fadeOut","fade-out-opacity":"OnRampWidgetModal-module__fade-out-opacity","fadeOutOpacity":"OnRampWidgetModal-module__fade-out-opacity","fadeIn":"OnRampWidgetModal-module__fadeIn","fade-in-opacity":"OnRampWidgetModal-module__fade-in-opacity","fadeInOpacity":"OnRampWidgetModal-module__fade-in-opacity","inactive":"OnRampWidgetModal-module__inactive"});
;// ./src/components/main/modals/OnRampWidgetModal.tsx










const ANIMATION_TIMEOUT = 200;
function OnRampWidgetModal(_ref) {
  let {
    chain,
    address,
    countryCode,
    theme
  } = _ref;
  const {
    closeOnRampWidgetModal,
    showError
  } = getActions();
  const isOpen = Boolean(chain) && Boolean(address);
  const lang = hooks_useLang();
  const animationTimeoutRef = teact_useRef();
  const [isAnimationInProgress, setIsAnimationInProgress] = useState(true);
  const [isLoading, setIsLoading] = useState(true);
  const [iframeSrc, setIframeSrc] = useState('');
  const appTheme = hooks_useAppTheme(theme);
  teact_useEffect(() => {
    if (!isOpen) {
      setIsAnimationInProgress(true);
      setIsLoading(true);
      setIframeSrc('');
    }
    return () => window.clearTimeout(animationTimeoutRef.current);
  }, [isOpen]);
  teact_useEffect(() => {
    if (!isOpen) return;
    if (countryCode === 'RU') {
      setIframeSrc(`https://dreamwalkers.io/ru/mytonwallet/?wallet=${address}&give=CARDRUB&take=TON&type=buy`);
      return;
    }
    void (async () => {
      const response = await (0,api/* callApi */.p)('getMoonpayOnrampUrl', chain, address, appTheme);
      if (response && 'error' in response) {
        showError({
          error: response.error
        });
      } else {
        setIframeSrc((response === null || response === void 0 ? void 0 : response.url) || '');
      }
    })();
  }, [address, appTheme, chain, countryCode, isOpen]);
  const onIframeLoaded = () => {
    setIsLoading(false);
    animationTimeoutRef.current = window.setTimeout(() => {
      setIsAnimationInProgress(false);
    }, ANIMATION_TIMEOUT);
  };
  function renderContent() {
    if (!iframeSrc) return undefined;
    return /*#__PURE__*/teact.createElement("iframe", {
      title: "On Ramp Widget",
      onLoad: onIframeLoaded,
      className: buildClassName(OnRampWidgetModal_module.iframe, !isLoading && OnRampWidgetModal_module.fadeIn),
      width: "100%",
      height: "100%",
      frameBorder: "none",
      allow: "autoplay; camera; microphone; payment",
      src: iframeSrc
    }, lang('Cannot load widget'));
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen,
    title: lang('Buy with Card'),
    dialogClassName: OnRampWidgetModal_module.modalDialog,
    forceFullNative: true,
    nativeBottomSheetKey: "onramp-widget",
    onClose: closeOnRampWidgetModal
  }, /*#__PURE__*/teact.createElement("div", {
    className: OnRampWidgetModal_module.content
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(OnRampWidgetModal_module.loaderContainer, !isLoading && OnRampWidgetModal_module.fadeOut, !isAnimationInProgress && OnRampWidgetModal_module.inactive)
  }, /*#__PURE__*/teact.createElement(ui_Spinner, null)), renderContent()));
}
/* harmony default export */ const modals_OnRampWidgetModal = (memo(withGlobal(global => {
  const {
    addressByChain
  } = selectAccount(global, global.currentAccountId) || {};
  const {
    countryCode
  } = global.restrictions;
  const {
    chainForOnRampWidgetModal: chain
  } = global;
  return {
    chain,
    address: chain && (addressByChain === null || addressByChain === void 0 ? void 0 : addressByChain[chain]),
    countryCode,
    theme: global.settings.theme
  };
})(OnRampWidgetModal)));
;// ./src/components/main/modals/QrScannerModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const QrScannerModal_module = ({"title":"QrScannerModal-module__title","square":"QrScannerModal-module__square","squareInner":"QrScannerModal-module__squareInner","closeButton":"QrScannerModal-module__closeButton","flashLightButton":"QrScannerModal-module__flashLightButton","flashLightButtonEnabled":"QrScannerModal-module__flashLightButtonEnabled","documentRoot":"QrScannerModal-module__documentRoot","scanner":"QrScannerModal-module__scanner","scannerStarted":"QrScannerModal-module__scannerStarted"});
;// ./src/components/main/modals/QrScannerModal.tsx















const START_SCAN_DELAY_MS = windowEnvironment/* IS_IOS */.pz ? 160 : 360;
const MODAL_ANIMATION_DURATION_MS = windowEnvironment/* IS_IOS */.pz ? 650 : 500;
const DESTROY_SCANNER_DELAY_MS = windowEnvironment/* IS_IOS */.pz ? 250 : 500;
function QrScannerModal(_ref) {
  let {
    isOpen,
    onClose
  } = _ref;
  const {
    handleQrCode
  } = getActions();
  const [isFlashlightAvailable, setIsFlashlightAvailable] = useState(false);
  const [isFlashlightEnabled, setIsFlashlightEnabled] = useState(false);
  const [isScannerStarted, setIsScannerStarted] = useState(false);
  const {
    ref: flashlightRef,
    shouldRender: flashlightShouldRender
  } = useShowTransition({
    isOpen: isFlashlightAvailable,
    withShouldRender: true
  });
  const lang = hooks_useLang();
  const scanSquareRef = teact_useRef();
  const onCloseAnimationEnd = useLastCallback(async () => {
    removeExtraClass(document.documentElement, QrScannerModal_module.documentRoot);
    await BarcodeScanner.stopScan();
  });
  const handleClose = useLastCallback(() => {
    setIsScannerStarted(false);
    setIsFlashlightEnabled(false);
    onClose();
  });
  const startScan = useLastCallback(async () => {
    const options = {
      formats: [esm_definitions/* BarcodeFormat */.Gi.QrCode]
    };
    const scanAreaCoordinates = getDomNodeDimensions(scanSquareRef.current);
    await BarcodeScanner.removeAllListeners();
    const listener = await BarcodeScanner.addListener('barcodesScanned', async _ref2 => {
      let {
        barcodes: [barcode]
      } = _ref2;
      let qrCodeCoordinates = barcode.cornerPoints;
      qrCodeCoordinates = qrCodeCoordinates ? sortCoordinatesClockwise(qrCodeCoordinates) : undefined;
      if (!scanAreaCoordinates || !qrCodeCoordinates || isQrCodeOutsideScanArea(scanAreaCoordinates, qrCodeCoordinates)) {
        return;
      }
      await listener.remove();
      await vibrateOnSuccess();
      handleQrCode({
        data: barcode.rawValue
      });
      handleClose();
      await (0,schedulers/* pause */.v7)(DESTROY_SCANNER_DELAY_MS);
      if (windowEnvironment/* IS_IOS */.pz) {
        removeExtraClass(document.documentElement, QrScannerModal_module.documentRoot);
      }
    });
    setIsScannerStarted(true);
    await BarcodeScanner.startScan(options);

    // Wait until the scanner is started, after that we can determine if flashlight is available
    if (!isFlashlightAvailable) {
      void BarcodeScanner.isTorchAvailable().then(result => {
        setIsFlashlightAvailable(result.available);
      });
    }
    void BarcodeScanner.isTorchEnabled().then(result => {
      setIsFlashlightEnabled(result.enabled);
    });
  });
  hooks_useEffectWithPrevDeps(_ref3 => {
    let [prevIsOpen] = _ref3;
    if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) return undefined;
    let startScanTimeoutId;
    let documentClassModifyTimeoutId;
    if (isOpen) {
      startScanTimeoutId = window.setTimeout(startScan, START_SCAN_DELAY_MS);
      documentClassModifyTimeoutId = window.setTimeout(() => {
        addExtraClass(document.documentElement, QrScannerModal_module.documentRoot);
      }, MODAL_ANIMATION_DURATION_MS);
    } else if (prevIsOpen) {
      handleClose();
    }
    return () => {
      if (startScanTimeoutId) window.clearTimeout(startScanTimeoutId);
      if (documentClassModifyTimeoutId) window.clearTimeout(documentClassModifyTimeoutId);
    };
  }, [isOpen, handleClose, startScan]);
  const handleFlashlightClick = useLastCallback(async () => {
    if (isFlashlightEnabled) {
      await BarcodeScanner.disableTorch();
    } else {
      await BarcodeScanner.enableTorch();
    }
    setIsFlashlightEnabled(!isFlashlightEnabled);
  });
  const flashlightButtonClassName = buildClassName(QrScannerModal_module.flashLightButton, isFlashlightEnabled && QrScannerModal_module.flashLightButtonEnabled);
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    onClose: handleClose,
    nativeBottomSheetKey: "qr-scanner",
    forceFullNative: true,
    onCloseAnimationEnd: onCloseAnimationEnd
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(QrScannerModal_module.scanner, isScannerStarted && QrScannerModal_module.scannerStarted)
  }, /*#__PURE__*/teact.createElement("div", {
    className: QrScannerModal_module.closeButton,
    "aria-label": lang('Close'),
    role: "button",
    tabIndex: 0,
    onClick: handleClose
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Modal_module.closeIcon, 'icon-close'),
    "aria-hidden": true
  })), flashlightShouldRender && /*#__PURE__*/teact.createElement("div", {
    ref: flashlightRef,
    className: flashlightButtonClassName,
    onClick: handleFlashlightClick,
    "aria-label": lang('Toggle Flashlight'),
    role: "button",
    tabIndex: 0
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon-flashlight",
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("div", {
    className: QrScannerModal_module.title
  }, lang('Scan QR Code')), /*#__PURE__*/teact.createElement("div", {
    className: QrScannerModal_module.square,
    ref: scanSquareRef
  }, /*#__PURE__*/teact.createElement("div", {
    className: QrScannerModal_module.squareInner
  }))));
}
/* harmony default export */ const modals_QrScannerModal = (memo(QrScannerModal));
function sortCoordinatesClockwise(coordinates) {
  coordinates.sort((a, b) => a[1] - b[1]);
  const topHalf = coordinates.slice(0, 2);
  const bottomHalf = coordinates.slice(2);
  topHalf.sort((a, b) => b[0] - a[0]);
  bottomHalf.sort((a, b) => a[0] - b[0]);
  return [...topHalf, ...bottomHalf];
}
function getDomNodeDimensions(node) {
  if (!node) {
    return undefined;
  }
  const scanSquareRect = node.getBoundingClientRect();
  const scaledRect = {
    left: scanSquareRect.left * windowEnvironment/* DPR */.Lv,
    right: scanSquareRect.right * windowEnvironment/* DPR */.Lv,
    top: scanSquareRect.top * windowEnvironment/* DPR */.Lv,
    bottom: scanSquareRect.bottom * windowEnvironment/* DPR */.Lv,
    width: scanSquareRect.width * windowEnvironment/* DPR */.Lv,
    height: scanSquareRect.height * windowEnvironment/* DPR */.Lv
  };
  return [[scaledRect.left, scaledRect.top], [scaledRect.left + scaledRect.width, scaledRect.top], [scaledRect.left + scaledRect.width, scaledRect.top + scaledRect.height], [scaledRect.left, scaledRect.top + scaledRect.height]];
}
function isQrCodeOutsideScanArea(scanArea, qrCodeCoordinates) {
  return scanArea[0][0] > qrCodeCoordinates[0][0] || scanArea[0][1] > qrCodeCoordinates[0][1] || scanArea[1][0] < qrCodeCoordinates[1][0] || scanArea[1][1] > qrCodeCoordinates[1][1] || scanArea[2][0] < qrCodeCoordinates[2][0] || scanArea[2][1] < qrCodeCoordinates[2][1] || scanArea[3][0] > qrCodeCoordinates[3][0] || scanArea[3][1] < qrCodeCoordinates[3][1];
}
;// ./src/components/main/modals/SignatureModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SignatureModal_module = ({"modalDialog":"SignatureModal-module__modalDialog","error":"SignatureModal-module__error","sticker":"SignatureModal-module__sticker","description":"SignatureModal-module__description"});
;// ./src/components/main/modals/SignatureModal.tsx



















var SignatureModal_SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["confirm"] = 0] = "confirm";
  SLIDES[SLIDES["password"] = 1] = "password";
  SLIDES[SLIDES["complete"] = 2] = "complete";
  return SLIDES;
}(SignatureModal_SLIDES || {});
function SignatureModal(_ref) {
  let {
    dataHex,
    error,
    isSigned
  } = _ref;
  const {
    submitSignature,
    clearSignatureError,
    cancelSignature
  } = getActions();
  const lang = hooks_useLang();
  const [isModalOpen, openModal, closeModal] = hooks_useFlag(false);
  const [currentSlide, setCurrentSlide] = useState(SignatureModal_SLIDES.confirm);
  const [nextKey, setNextKey] = useState(SignatureModal_SLIDES.password);
  useLayoutEffect(() => {
    if (dataHex) {
      setCurrentSlide(SignatureModal_SLIDES.confirm);
      setNextKey(SignatureModal_SLIDES.password);
      openModal();
    }
  }, [dataHex, openModal]);
  useLayoutEffect(() => {
    if (isSigned) {
      setCurrentSlide(SignatureModal_SLIDES.complete);
      setNextKey(undefined);
    }
  }, [isSigned]);
  teact_useEffect(() => currentSlide === SignatureModal_SLIDES.complete ? captureKeyboardListeners({
    onEnter: closeModal
  }) : undefined, [closeModal, currentSlide]);
  const handleConfirm = useLastCallback(() => {
    setCurrentSlide(SignatureModal_SLIDES.password);
    setNextKey(SignatureModal_SLIDES.complete);
  });
  const handlePasswordSubmit = useLastCallback(password => {
    submitSignature({
      password
    });
  });
  function renderConfirm() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Confirmation'),
      onClose: closeModal
    }), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, lang('Signing Data')), /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.inputReadOnly
    }, dataHex), /*#__PURE__*/teact.createElement("div", {
      className: SignatureModal_module.error
    }, renderText(lang('$signature_warning'))), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Modal_module.button,
      onClick: closeModal
    }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      className: Modal_module.button,
      onClick: handleConfirm
    }, lang('Sign')))));
  }
  function renderPasswordForm(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Enter Password'),
      onClose: closeModal
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      error: error,
      submitLabel: lang('Sign'),
      cancelLabel: lang('Cancel'),
      onSubmit: handlePasswordSubmit,
      onCancel: closeModal,
      onUpdate: clearSignatureError
    }));
  }
  function renderComplete(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Done!'),
      onClose: closeModal
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.transitionContent, Modal_module.transitionContent_simple)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      noLoop: false,
      nonInteractive: true,
      className: SignatureModal_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
      previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
    }), /*#__PURE__*/teact.createElement("div", {
      className: SignatureModal_module.description
    }, lang('Signing was confirmed!')), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      onClick: closeModal
    }, lang('Close')))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case SignatureModal_SLIDES.confirm:
        return renderConfirm();
      case SignatureModal_SLIDES.password:
        return renderPasswordForm(isActive);
      case SignatureModal_SLIDES.complete:
        return renderComplete(isActive);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isModalOpen,
    dialogClassName: SignatureModal_module.modalDialog,
    onClose: closeModal,
    onCloseAnimationEnd: cancelSignature
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: currentSlide,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const modals_SignatureModal = (memo(withGlobal(global => {
  const {
    dataHex,
    error,
    isSigned
  } = global.currentSignature || {};
  return {
    dataHex,
    error,
    isSigned
  };
})(SignatureModal)));
;// ./src/hooks/usePrevDuringAnimation.ts




function usePrevDuringAnimation(current, duration) {
  const prev = hooks_usePrevious(current, true);
  const timeoutRef = teact_useRef();
  const forceUpdate = hooks_useForceUpdate();
  // eslint-disable-next-line no-null/no-null
  const isCurrentPresent = current !== undefined && current !== null;
  // eslint-disable-next-line no-null/no-null
  const isPrevPresent = prev !== undefined && prev !== null;
  if (isCurrentPresent && timeoutRef.current) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = undefined;
  }
  useSyncEffect(() => {
    // When `current` becomes empty
    if (duration && !isCurrentPresent && isPrevPresent && !timeoutRef.current) {
      timeoutRef.current = window.setTimeout(() => {
        timeoutRef.current = undefined;
        forceUpdate();
      }, duration);
    }
  }, [duration, forceUpdate, isCurrentPresent, isPrevPresent]);
  return !timeoutRef.current || !duration || isCurrentPresent ? current : prev;
}
;// ./src/components/common/Countdown.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Countdown_module = ({"time":"Countdown-module__time","timeWarning":"Countdown-module__timeWarning"});
;// ./src/components/common/Countdown.tsx






const WARNING_TIME = 5 * 60; // 5 minutes in seconds;

function Countdown(_ref) {
  let {
    timestamp,
    deadline,
    onCompleted
  } = _ref;
  const lang = hooks_useLang();
  const initialSeconds = Math.floor((timestamp + deadline - Date.now()) / dateFormat/* SECOND */.Z2);
  const [secondsLeft, setSecondsLeft] = useState(Math.max(initialSeconds, 0));
  const shouldShowWarning = secondsLeft <= WARNING_TIME;
  teact_useEffect(() => {
    const clearTimer = (0,schedulers/* setCancellableTimeout */.Gf)(dateFormat/* SECOND */.Z2, () => {
      if (secondsLeft <= 0) return;
      setSecondsLeft(Math.floor((timestamp + deadline - Date.now()) / dateFormat/* SECOND */.Z2));
    });
    if (secondsLeft <= 0) {
      onCompleted === null || onCompleted === void 0 || onCompleted();
    }
    return clearTimer;
  }, [secondsLeft, onCompleted, timestamp, deadline]);
  return /*#__PURE__*/teact.createElement("span", {
    className: buildClassName(Countdown_module.time, shouldShowWarning && Countdown_module.timeWarning)
  }, formatTime(lang, secondsLeft));
}
function formatTime(lang, seconds) {
  const pad = num => num.toString().padStart(2, '0');
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor(seconds % 3600 / 60);
  const remainingSeconds = seconds % 60;
  let formattedTime = hours > 0 ? `${hours}:` : '';
  formattedTime += `${hours > 0 ? pad(minutes) : minutes}:`;
  formattedTime += pad(remainingSeconds);
  return formattedTime;
}
/* harmony default export */ const common_Countdown = (memo(Countdown));
;// ./src/components/common/SwapTokensInfo.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SwapTokensInfo_module = ({"infoBlock":"SwapTokensInfo-module__infoBlock","infoRow":"SwapTokensInfo-module__infoRow","noIcon":"SwapTokensInfo-module__noIcon","noCurrency":"SwapTokensInfo-module__noCurrency","infoRowIcon":"SwapTokensInfo-module__infoRowIcon","infoRowToken":"SwapTokensInfo-module__infoRowToken","label":"SwapTokensInfo-module__label","infoRowChain":"SwapTokensInfo-module__infoRowChain","infoRowAmount":"SwapTokensInfo-module__infoRowAmount","infoRowAmountGreen":"SwapTokensInfo-module__infoRowAmountGreen","infoRowAmountError":"SwapTokensInfo-module__infoRowAmountError","infoRowCurrency":"SwapTokensInfo-module__infoRowCurrency","infoRowCurrencyValue":"SwapTokensInfo-module__infoRowCurrencyValue","infoSeparator":"SwapTokensInfo-module__infoSeparator","infoSeparatorIcon":"SwapTokensInfo-module__infoSeparatorIcon","infoSeparatorIconError":"SwapTokensInfo-module__infoSeparatorIconError"});
;// ./src/components/common/SwapTokensInfo.tsx










function SwapTokensInfo(_ref) {
  let {
    isSensitiveDataHidden,
    tokenIn,
    amountIn,
    tokenOut,
    amountOut,
    isError = false
  } = _ref;
  const amountInCols = teact_useMemo(() => getPseudoRandomNumber(5, 13, amountIn ?? ''), [amountIn]);
  const amountOutCols = teact_useMemo(() => getPseudoRandomNumber(5, 13, amountOut ?? ''), [amountOut]);
  function renderTokenInfo(amountCols, token) {
    let amount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';
    let isReceived = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const amountWithSign = isReceived ? amount : `-${amount}`;
    const withLabel = Boolean(token && src_config/* TOKEN_WITH_LABEL */.OZB[token.slug]);
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(SwapTokensInfo_module.infoRow, !token && SwapTokensInfo_module.noIcon, isReceived && SwapTokensInfo_module.noCurrency)
    }, Boolean(token) && /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: token,
      withChainIcon: true,
      className: SwapTokensInfo_module.infoRowIcon
    }), /*#__PURE__*/teact.createElement("span", {
      className: SwapTokensInfo_module.infoRowToken
    }, token === null || token === void 0 ? void 0 : token.name, withLabel && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(SwapTokensInfo_module.label, SwapTokensInfo_module.chainLabel)
    }, src_config/* TOKEN_WITH_LABEL */.OZB[token.slug])), /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: amountCols,
      rows: 2,
      cellSize: 8,
      align: "right",
      className: buildClassName(SwapTokensInfo_module.infoRowAmount, isReceived && SwapTokensInfo_module.infoRowAmountGreen, isError && SwapTokensInfo_module.infoRowAmountError)
    }, formatCurrencyExtended(amountWithSign, (token === null || token === void 0 ? void 0 : token.symbol) ?? '')), /*#__PURE__*/teact.createElement("span", {
      className: SwapTokensInfo_module.infoRowChain
    }, getChainNetworkName(token === null || token === void 0 ? void 0 : token.chain)), !isReceived && renderCurrency(amountIn, amountOut, tokenIn, tokenOut));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: SwapTokensInfo_module.infoBlock
  }, renderTokenInfo(amountInCols, tokenIn, amountIn), /*#__PURE__*/teact.createElement("div", {
    className: SwapTokensInfo_module.infoSeparator
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(SwapTokensInfo_module.infoSeparatorIcon, isError && SwapTokensInfo_module.infoSeparatorIconError, isError ? 'icon-close' : 'icon-arrow-down'),
    "aria-hidden": true
  })), renderTokenInfo(amountOutCols, tokenOut, amountOut, true));
}
/* harmony default export */ const common_SwapTokensInfo = (memo(SwapTokensInfo));
function renderCurrency(amountIn, amountOut, fromToken, toToken) {
  const rate = getSwapRate(amountIn, amountOut, fromToken, toToken);
  if (!rate) return undefined;
  return /*#__PURE__*/teact.createElement("span", {
    className: SwapTokensInfo_module.infoRowCurrency
  }, rate.firstCurrencySymbol, " \u2248", /*#__PURE__*/teact.createElement("span", {
    className: SwapTokensInfo_module.infoRowCurrencyValue
  }, rate.price, ' ', rate.secondCurrencySymbol));
}
;// ./src/components/common/TransactionFee.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TransactionFee_module = ({"label":"TransactionFee-module__label","field":"TransactionFee-module__field","field_transition":"TransactionFee-module__field_transition","fieldTransition":"TransactionFee-module__field_transition","field_loading":"TransactionFee-module__field_loading","fieldLoading":"TransactionFee-module__field_loading"});
;// ./src/components/common/TransactionFee.tsx






function TransactionFee(_ref) {
  let {
    terms,
    token,
    precision,
    isLoading,
    className
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement("div", {
    className: className
  }, /*#__PURE__*/teact.createElement("div", {
    className: TransactionFee_module.label
  }, lang('Fee')), /*#__PURE__*/teact.createElement("div", {
    className: TransactionFee_module.field
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: isLoading ? 1 : 0,
    name: "fade",
    className: TransactionFee_module.field_transition
  }, isLoading ? /*#__PURE__*/teact.createElement(ui_LoadingDots, {
    isActive: true,
    className: TransactionFee_module.field_loading
  }) : /*#__PURE__*/teact.createElement(ui_Fee, {
    terms: terms,
    token: token,
    precision: precision
  }))));
}
;// ./src/components/main/modals/TransactionModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TransactionModal_module = ({"modalDialog":"TransactionModal-module__modalDialog","unstakeModal":"TransactionModal-module__unstakeModal","passwordFormContent":"TransactionModal-module__passwordFormContent","passwordFormContentInModal":"TransactionModal-module__passwordFormContentInModal","sticker":"TransactionModal-module__sticker","footer":"TransactionModal-module__footer","copyButtonWrapper":"TransactionModal-module__copyButtonWrapper","feeField":"TransactionModal-module__feeField","comment":"TransactionModal-module__comment","button":"TransactionModal-module__button","buttonWide":"TransactionModal-module__buttonWide","unstakeTime":"TransactionModal-module__unstakeTime","unstakeTimeIcon":"TransactionModal-module__unstakeTimeIcon","scamImage":"TransactionModal-module__scamImage","scamAddress":"TransactionModal-module__scamAddress","modalTitle":"TransactionModal-module__modalTitle","transactionHeader":"TransactionModal-module__transactionHeader","headerTitle":"TransactionModal-module__headerTitle","headerTitle__badge":"TransactionModal-module__headerTitle__badge","headerTitleBadge":"TransactionModal-module__headerTitle__badge","warning":"TransactionModal-module__warning","headerDate":"TransactionModal-module__headerDate","infoBlock":"TransactionModal-module__infoBlock","textFieldWrapper":"TransactionModal-module__textFieldWrapper","swapSupportBlock":"TransactionModal-module__swapSupportBlock","textFieldLabel":"TransactionModal-module__textFieldLabel","advancedTooltip":"TransactionModal-module__advancedTooltip","advancedTooltipContainer":"TransactionModal-module__advancedTooltipContainer","errorCexBlock":"TransactionModal-module__errorCexBlock","errorCexMessage":"TransactionModal-module__errorCexMessage","errorCexEmail":"TransactionModal-module__errorCexEmail","changellyInfoBlock":"TransactionModal-module__changellyInfoBlock","changellyDescription":"TransactionModal-module__changellyDescription","changellyDescriptionBold":"TransactionModal-module__changellyDescriptionBold","qrCode":"TransactionModal-module__qrCode","qrCodeHidden":"TransactionModal-module__qrCodeHidden","scamWarning":"TransactionModal-module__scamWarning"});
;// ./src/components/main/modals/SwapActivityModal.tsx




























const CHANGELLY_EXPIRE_CHECK_STATUSES = new Set(['new', 'waiting']);
const SwapActivityModal_CHANGELLY_PENDING_STATUSES = new Set(['new', 'waiting', 'confirming', 'exchanging', 'sending']);
const CHANGELLY_ERROR_STATUSES = new Set(['failed', 'expired', 'refunded', 'overdue']);
const SwapActivityModal_ONCHAIN_ERROR_STATUSES = new Set(['failed', 'expired']);
function SwapActivityModal(_ref) {
  let {
    activity,
    tokensBySlug,
    theme,
    addressByChain,
    isSwapDisabled,
    isSensitiveDataHidden
  } = _ref;
  const {
    fetchActivityDetails,
    startSwap,
    closeActivityInfo
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const isOpen = Boolean(activity);
  const animationLevel = getGlobal().settings.animationLevel;
  const animationDuration = animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp ? 0 : (isPortrait ? CLOSE_DURATION_PORTRAIT : Modal_CLOSE_DURATION) + src_config/* ANIMATION_END_DELAY */.xB5;
  const renderedActivity = usePrevDuringAnimation(activity, animationDuration);
  const appTheme = hooks_useAppTheme(theme);
  const {
    id,
    hashes,
    timestamp,
    networkFee = '0',
    ourFee = '0',
    shouldLoadDetails
  } = renderedActivity ?? {};
  const {
    payinAddress,
    payoutAddress,
    payinExtraId
  } = (renderedActivity === null || renderedActivity === void 0 ? void 0 : renderedActivity.cex) || {};
  let fromAmount = '0';
  let toAmount = '0';
  let isPending = true;
  let isError = false;
  let shouldRenderCexInfo = false;
  let isCex = false;
  let isCexError = false;
  let isCexHold = false;
  let isCexWaiting = false;
  let isCexPending = false;
  let isExpired = false;
  let cexTransactionId = '';
  let title = '';
  let titleBadge;
  let isTitleBadgeWarning = false;
  let cexErrorMessage = '';
  let isFromToncoin = true;
  let isCountdownFinished = false;
  const fromToken = teact_useMemo(() => {
    if (!(renderedActivity !== null && renderedActivity !== void 0 && renderedActivity.from) || !tokensBySlug) return undefined;
    return resolveSwapAsset(tokensBySlug, renderedActivity.from);
  }, [renderedActivity === null || renderedActivity === void 0 ? void 0 : renderedActivity.from, tokensBySlug]);
  const toToken = teact_useMemo(() => {
    if (!(renderedActivity !== null && renderedActivity !== void 0 && renderedActivity.to) || !tokensBySlug) return undefined;
    return resolveSwapAsset(tokensBySlug, renderedActivity.to);
  }, [renderedActivity === null || renderedActivity === void 0 ? void 0 : renderedActivity.to, tokensBySlug]);
  const isInternalSwap = getIsInternalSwap({
    from: fromToken,
    to: toToken,
    toAddress: payoutAddress,
    addressByChain
  });
  if (renderedActivity) {
    const {
      status,
      from,
      cex
    } = renderedActivity;
    fromAmount = renderedActivity.fromAmount;
    toAmount = renderedActivity.toAmount;
    isFromToncoin = from === src_config/* TONCOIN */.Tu9.slug;
    isCex = Boolean(cex);
    if (cex) {
      isCountdownFinished = timestamp ? timestamp + src_config/* CHANGELLY_WAITING_DEADLINE */.JWy - Date.now() < 0 : false;
      isExpired = CHANGELLY_EXPIRE_CHECK_STATUSES.has(cex.status) && isCountdownFinished;
      shouldRenderCexInfo = cex.status !== 'finished';
      isPending = !isExpired && SwapActivityModal_CHANGELLY_PENDING_STATUSES.has(cex.status);
      isCexPending = isPending;
      isCexError = isExpired || CHANGELLY_ERROR_STATUSES.has(cex.status);
      isCexHold = cex.status === 'hold';
      // Skip the 'waiting' status for transactions from Toncoin to other chains
      // or from TRON to TON inside a multichain wallet for delayed status updates from Ð¡hangelly
      isCexWaiting = cex.status === 'waiting' && !isExpired && !isInternalSwap && !isFromToncoin;
      cexTransactionId = cex.transactionId;
    } else {
      isPending = status === 'pending';
      isError = SwapActivityModal_ONCHAIN_ERROR_STATUSES.has(status);
    }
    if (isPending) {
      title = lang('Swapping');
    } else if (isCexHold) {
      title = lang('$swap_action');
      titleBadge = lang('On Hold');
      isTitleBadgeWarning = true;
    } else if (isCexError) {
      const {
        status: cexStatus
      } = renderedActivity.cex ?? {};
      if (cexStatus === 'expired' || cexStatus === 'overdue') {
        title = lang('$swap_action');
        titleBadge = lang('Expired');
        cexErrorMessage = lang('You have not sent the coins to the specified address.');
      } else if (cexStatus === 'refunded') {
        title = lang('$swap_action');
        titleBadge = lang('Refunded');
        cexErrorMessage = lang('Exchange failed and coins were refunded to your wallet.');
      } else {
        title = lang('$swap_action');
        titleBadge = lang('Failed');
      }
    } else if (isError) {
      title = lang('$swap_action');
      titleBadge = lang('Failed');
    } else {
      title = lang('Swapped');
    }
  }
  const transactionHash = id ? isCex ? hashes === null || hashes === void 0 ? void 0 : hashes[0] : parseTxId(id).hash : undefined;
  const transactionUrl = getExplorerTransactionUrl('ton', transactionHash);
  const shouldShowQrCode = !payinExtraId && (toToken === null || toToken === void 0 ? void 0 : toToken.chain) === 'ton' && !isInternalSwap;
  const {
    qrCodeRef,
    isInitialized
  } = useQrCode({
    address: payinAddress,
    isActive: Boolean(payinAddress),
    hiddenClassName: TransactionModal_module.qrCodeHidden,
    hideLogo: true
  });
  const handleClose = useLastCallback(() => {
    closeActivityInfo({
      id: id
    });
  });
  const handleSwapClick = useLastCallback(() => {
    closeActivityInfo({
      id: id
    });
    startSwap({
      tokenInSlug: fromToken.slug,
      tokenOutSlug: toToken.slug,
      amountIn: fromAmount
    });
  });
  teact_useEffect(() => {
    if (id && shouldLoadDetails) fetchActivityDetails({
      id
    });
  }, [id, shouldLoadDetails]);
  function renderHeader() {
    return /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.transactionHeader
    }, /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.headerTitle
    }, title, isPending && /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isOpen,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClock,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClock
    }), !!titleBadge && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(TransactionModal_module.headerTitle__badge, isTitleBadgeWarning && TransactionModal_module.warning)
    }, titleBadge)), !!timestamp && /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.headerDate
    }, (0,dateFormat/* formatFullDay */.TK)(lang.code, timestamp), ", ", (0,dateFormat/* formatTime */.fU)(timestamp)));
  }
  function renderFooterButton() {
    let isButtonVisible = true;
    let buttonText = 'Swap Again';
    if (isCexWaiting) {
      return /*#__PURE__*/teact.createElement(ui_Button, {
        onClick: handleClose,
        className: TransactionModal_module.button
      }, lang('Close'));
    }
    if (isCexHold) {
      isButtonVisible = false;
    } else if (isCexError) {
      const {
        status: cexStatus
      } = (renderedActivity === null || renderedActivity === void 0 ? void 0 : renderedActivity.cex) ?? {};
      if (cexStatus === 'expired' || cexStatus === 'refunded' || cexStatus === 'overdue') {
        buttonText = 'Try Again';
      }
    }
    if (!isButtonVisible) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleSwapClick,
      className: TransactionModal_module.button
    }, lang(buttonText));
  }
  function renderCexInformation() {
    if (isCexHold) {
      return /*#__PURE__*/teact.createElement("div", {
        className: TransactionModal_module.textFieldWrapper
      }, /*#__PURE__*/teact.createElement("span", {
        className: TransactionModal_module.changellyDescription
      }, lang('$swap_changelly_kyc_security', {
        email: /*#__PURE__*/teact.createElement("span", {
          className: TransactionModal_module.changellyDescriptionBold
        }, src_config/* CHANGELLY_SECURITY_EMAIL */.gpw)
      })), cexTransactionId && /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
        text: cexTransactionId,
        copyNotification: lang('Transaction ID was copied!'),
        noSavedAddress: true,
        noExplorer: true
      }));
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(TransactionModal_module.textFieldWrapper, TransactionModal_module.swapSupportBlock)
    }, cexErrorMessage && /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.errorCexMessage
    }, cexErrorMessage), isCexPending && /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(TransactionModal_module.changellyDescription)
    }, lang('Please note that it may take up to a few hours for tokens to appear in your wallet.')), isCountdownFinished && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.changellyDescription
    }, lang('$swap_changelly_support', {
      livechat: /*#__PURE__*/teact.createElement("a", {
        href: src_config/* CHANGELLY_LIVE_CHAT_URL */.o$d,
        target: "_blank",
        rel: "noreferrer",
        className: TransactionModal_module.changellyDescriptionBold
      }, lang('Changelly Live Chat')),
      email: /*#__PURE__*/teact.createElement("span", {
        className: TransactionModal_module.changellyDescriptionBold
      }, src_config/* CHANGELLY_SUPPORT_EMAIL */.HWN)
    })), cexTransactionId && /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      text: cexTransactionId,
      copyNotification: lang('Transaction ID was copied!'),
      noSavedAddress: true,
      noExplorer: true
    })));
  }
  function renderMemo() {
    if (!payinExtraId) return undefined;
    return /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.textFieldWrapper
    }, /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.textFieldLabel
    }, lang('Memo')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      address: payinExtraId,
      copyNotification: lang('Memo was copied!'),
      noSavedAddress: true,
      noExplorer: true
    }));
  }
  function renderTransactionId() {
    return /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.textFieldWrapper
    }, /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.textFieldLabel
    }, lang('Transaction ID')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      noSavedAddress: true,
      chain: "ton",
      address: transactionHash,
      addressUrl: transactionUrl,
      isTransaction: true,
      copyNotification: lang('Transaction ID was copied!')
    }));
  }
  function renderFee() {
    if (!(Number(networkFee) || shouldLoadDetails) || !fromToken) {
      return undefined;
    }
    const terms = isFromToncoin ? {
      native: (0,big_js/* Big */.z)(networkFee).add(ourFee).toString()
    } : {
      native: networkFee,
      token: ourFee
    };
    return /*#__PURE__*/teact.createElement(TransactionFee, {
      terms: terms,
      token: fromToken,
      precision: (activity === null || activity === void 0 ? void 0 : activity.status) === 'pending' ? 'approximate' : 'exact',
      isLoading: shouldLoadDetails
    });
  }
  function renderAddress() {
    if (!payinAddress) return undefined;
    const token = isFromToncoin ? toToken : fromToken;
    const chain = getIsSupportedChain(token === null || token === void 0 ? void 0 : token.chain) ? token.chain : undefined;
    return /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.textFieldWrapper
    }, /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.textFieldLabel
    }, isFromToncoin ? lang('Your %blockchain% Address', {
      blockchain: toToken === null || toToken === void 0 ? void 0 : toToken.name
    }) : lang('Address for %blockchain% transfer', {
      blockchain: fromToken === null || fromToken === void 0 ? void 0 : fromToken.name
    })), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      chain: chain,
      address: isFromToncoin ? payoutAddress : payinAddress,
      copyNotification: lang('Address was copied!'),
      noSavedAddress: true,
      noExplorer: true,
      noDimming: true
    }));
  }
  function renderSwapInfo() {
    if (isCexWaiting) {
      if (isInternalSwap) return undefined;
      const chain = getIsSupportedChain(fromToken === null || fromToken === void 0 ? void 0 : fromToken.chain) ? fromToken.chain : undefined;
      return /*#__PURE__*/teact.createElement("div", {
        className: TransactionModal_module.changellyInfoBlock
      }, renderFee(), /*#__PURE__*/teact.createElement("span", {
        className: TransactionModal_module.changellyDescription
      }, lang('$swap_changelly_to_ton_description1', {
        value: /*#__PURE__*/teact.createElement("span", {
          className: TransactionModal_module.changellyDescriptionBold
        }, formatCurrencyExtended(Number(fromAmount), (fromToken === null || fromToken === void 0 ? void 0 : fromToken.symbol) ?? '', true)),
        blockchain: /*#__PURE__*/teact.createElement("span", {
          className: TransactionModal_module.changellyDescriptionBold
        }, getChainNetworkName(fromToken === null || fromToken === void 0 ? void 0 : fromToken.chain)),
        time: /*#__PURE__*/teact.createElement(common_Countdown, {
          timestamp: timestamp ?? 0,
          deadline: src_config/* CHANGELLY_WAITING_DEADLINE */.JWy
        })
      })), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
        chain: chain,
        address: payinAddress,
        copyNotification: lang('Address was copied!'),
        noSavedAddress: true,
        noExplorer: true,
        noDimming: true
      }), renderMemo(), shouldShowQrCode && /*#__PURE__*/teact.createElement("div", {
        className: buildClassName(TransactionModal_module.qrCode, !isInitialized && TransactionModal_module.qrCodeHidden),
        ref: qrCodeRef
      }));
    }
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderFee(), !isInternalSwap && renderAddress(), !isInternalSwap && renderMemo());
  }
  function renderContent() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, /*#__PURE__*/teact.createElement(common_SwapTokensInfo, {
      isSensitiveDataHidden: isSensitiveDataHidden,
      tokenIn: fromToken,
      amountIn: fromAmount,
      tokenOut: toToken,
      amountOut: toAmount,
      isError: isError || isCexError
    }), /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.infoBlock
    }, renderSwapInfo(), shouldRenderCexInfo && renderCexInformation(), transactionUrl && renderTransactionId()), !isSwapDisabled && /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.footer
    }, renderFooterButton()));
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    title: renderHeader(),
    titleClassName: TransactionModal_module.modalTitle,
    isOpen: isOpen,
    nativeBottomSheetKey: "swap-activity",
    onClose: handleClose
  }, renderContent());
}
/* harmony default export */ const modals_SwapActivityModal = (memo(withGlobal(global => {
  var _accountState$activit, _global$swapTokenInfo;
  const accountState = selectCurrentAccountState(global);
  const account = selectCurrentAccount(global);
  const {
    isSwapDisabled
  } = global.restrictions;
  const {
    theme,
    isSensitiveDataHidden
  } = global.settings;
  const id = accountState === null || accountState === void 0 ? void 0 : accountState.currentActivityId;
  const activity = id ? accountState === null || accountState === void 0 || (_accountState$activit = accountState.activities) === null || _accountState$activit === void 0 ? void 0 : _accountState$activit.byId[id] : undefined;
  return {
    activity: (activity === null || activity === void 0 ? void 0 : activity.kind) === 'swap' ? activity : undefined,
    tokensBySlug: (_global$swapTokenInfo = global.swapTokenInfo) === null || _global$swapTokenInfo === void 0 ? void 0 : _global$swapTokenInfo.bySlug,
    theme,
    addressByChain: account === null || account === void 0 ? void 0 : account.addressByChain,
    isSwapDisabled: isSwapDisabled || global.settings.isTestnet || selectIsCurrentAccountViewMode(global),
    isSensitiveDataHidden
  };
})(SwapActivityModal)));
;// ./src/components/common/TransactionAmount.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const TransactionAmount_module = ({"amountSensitiveData":"TransactionAmount-module__amountSensitiveData","baseCurrencyAmountSensitiveData":"TransactionAmount-module__baseCurrencyAmountSensitiveData","withStatus":"TransactionAmount-module__withStatus","amount":"TransactionAmount-module__amount","baseCurrencyAmount":"TransactionAmount-module__baseCurrencyAmount","status":"TransactionAmount-module__status","amountSymbol":"TransactionAmount-module__amountSymbol","amountFraction":"TransactionAmount-module__amountFraction","operationPositive":"TransactionAmount-module__operationPositive","operationNegative":"TransactionAmount-module__operationNegative"});
;// ./src/components/common/TransactionAmount.tsx








function TransactionAmount(_ref) {
  let {
    isIncoming,
    isScam,
    isFailed,
    amount,
    token,
    status,
    noSign = false,
    isSensitiveDataHidden,
    baseCurrency
  } = _ref;
  const typeClass = isFailed || isScam ? TransactionAmount_module.operationNegative : isIncoming ? TransactionAmount_module.operationPositive : undefined;
  function renderAmount() {
    const {
      decimals,
      symbol
    } = token ?? src_config/* UNKNOWN_TOKEN */.Bx3;
    const amountString = (0,util_decimals/* toDecimal */.nI)(noSign ? (0,bigint/* bigintAbs */.wg)(amount) : amount, decimals);
    const [wholePart, fractionPart] = formatCurrencyExtended(amountString, '', noSign, decimals, !isIncoming).split('.');
    const withStatus = Boolean(status);
    return /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: 12,
      rows: withStatus ? 7 : 4,
      align: "center",
      cellSize: withStatus ? 17 : 18,
      className: buildClassName(TransactionAmount_module.amountSensitiveData, status && TransactionAmount_module.withStatus)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(TransactionAmount_module.amount, status && TransactionAmount_module.withStatus, typeClass, 'rounded-font')
    }, wholePart.trim().replace('\u202F', ''), fractionPart && /*#__PURE__*/teact.createElement("span", {
      className: TransactionAmount_module.amountFraction
    }, ".", fractionPart.trim()), /*#__PURE__*/teact.createElement("span", {
      className: TransactionAmount_module.amountSymbol
    }, symbol)), withStatus && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(TransactionAmount_module.status, typeClass)
    }, status));
  }
  function renderBaseCurrencyAmount() {
    if (!token) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: 10,
      rows: 3,
      align: "center",
      cellSize: 12,
      className: TransactionAmount_module.baseCurrencyAmountSensitiveData,
      contentClassName: buildClassName(TransactionAmount_module.baseCurrencyAmount, 'rounded-font', typeClass)
    }, formatBaseCurrencyAmount(amount, baseCurrency, token));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderAmount(), renderBaseCurrencyAmount());
}
/* harmony default export */ const common_TransactionAmount = (memo(TransactionAmount));
;// ./src/components/main/modals/TransactionModal.tsx











































var TransactionModal_SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["initial"] = 0] = "initial";
  SLIDES[SLIDES["password"] = 1] = "password";
  return SLIDES;
}(TransactionModal_SLIDES || {});
function TransactionModal(_ref) {
  var _transaction$metadata;
  let {
    transaction,
    tokensBySlug,
    savedAddresses,
    isTestnet,
    isHardwareAccount,
    isViewMode,
    stakingStates,
    isLongUnstakeRequested,
    isMediaViewerOpen,
    theme,
    isSensitiveDataHidden,
    nftsByAddress,
    accounts,
    currentAccountId,
    baseCurrency
  } = _ref;
  const {
    fetchActivityDetails,
    startTransfer,
    startStaking,
    startUnstaking,
    closeActivityInfo,
    setIsPinAccepted,
    clearIsPinAccepted,
    setLandscapeActionsActiveTabIndex
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const [currentSlide, setCurrentSlide] = useState(TransactionModal_SLIDES.initial);
  const [nextKey, setNextKey] = useState(TransactionModal_SLIDES.password);
  const animationLevel = getGlobal().settings.animationLevel;
  const animationDuration = animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp ? 0 : (isPortrait ? CLOSE_DURATION_PORTRAIT : Modal_CLOSE_DURATION) + src_config/* ANIMATION_END_DELAY */.xB5;
  const renderedTransaction = usePrevDuringAnimation(transaction, animationDuration);
  const [unstakeDate, setUnstakeDate] = useState(Date.now() + src_config/* VALIDATION_PERIOD_MS */.NFS);
  const appTheme = hooks_useAppTheme(theme);
  const {
    fromAddress,
    toAddress,
    amount,
    comment,
    encryptedComment,
    fee,
    id,
    isIncoming,
    slug,
    timestamp,
    nft,
    shouldLoadDetails,
    status
  } = renderedTransaction || {};
  const isActivityWithHash = Boolean(renderedTransaction && getIsActivityWithHash(renderedTransaction));
  const isOurStaking = renderedTransaction && isOurStakingTransaction(renderedTransaction);
  const isOurUnstaking = isOurStaking && (renderedTransaction === null || renderedTransaction === void 0 ? void 0 : renderedTransaction.type) === 'unstake';
  const isNftTransfer = Boolean(renderedTransaction === null || renderedTransaction === void 0 ? void 0 : renderedTransaction.nft);
  const token = slug ? tokensBySlug === null || tokensBySlug === void 0 ? void 0 : tokensBySlug[slug] : undefined;
  const chain = token === null || token === void 0 ? void 0 : token.chain;
  const nativeToken = token ? getNativeToken(token.chain) : undefined;
  const address = isIncoming ? fromAddress : toAddress;
  const isAnyPending = status === 'pending' || status === 'pendingTrusted';
  const iconClock = status === 'pendingTrusted' ? 'iconClockGreen' : 'iconClock';
  const localAddressName = teact_useMemo(() => {
    if (!chain) return undefined;
    return getLocalAddressName({
      address,
      chain,
      currentAccountId,
      accounts: accounts,
      savedAddresses
    });
  }, [accounts, address, chain, currentAccountId, savedAddresses]);
  const addressName = localAddressName || (transaction === null || transaction === void 0 || (_transaction$metadata = transaction.metadata) === null || _transaction$metadata === void 0 ? void 0 : _transaction$metadata.name);
  const isTransactionWithPoisoning = isIncoming && getIsTransactionWithPoisoning(renderedTransaction);
  const isScam = Boolean(transaction) && isScamTransaction(transaction);
  const isModalOpen = Boolean(transaction) && !isMediaViewerOpen;
  const transactionHash = chain && id ? parseTxId(id).hash : undefined;
  const doesNftExist = Boolean(nft && (nftsByAddress === null || nftsByAddress === void 0 ? void 0 : nftsByAddress[nft.address]));
  const canDecryptComment = !isViewMode && !isHardwareAccount;
  const [decryptedComment, setDecryptedComment] = useState();
  const [passwordError, setPasswordError] = useState();
  const transactionUrl = chain ? getExplorerTransactionUrl(chain, transactionHash, isTestnet) : undefined;
  const {
    shouldRender: shouldRenderTransactionId,
    ref: transactionIdRef
  } = useShowTransition({
    isOpen: Boolean(isActivityWithHash && transactionUrl),
    withShouldRender: true
  });
  const stakingState = teact_useMemo(() => {
    return stakingStates === null || stakingStates === void 0 ? void 0 : stakingStates.find(staking => {
      return staking.tokenSlug === src_config/* TONCOIN */.Tu9.slug && staking.balance > 0n;
    });
  }, [stakingStates]);
  const stakingStatus = stakingState && getStakingStateStatus(stakingState);
  const startOfStakingCycle = stakingState === null || stakingState === void 0 ? void 0 : stakingState.start;
  const endOfStakingCycle = stakingState === null || stakingState === void 0 ? void 0 : stakingState.end;
  const {
    shouldRender: shouldRenderUnstakeTimer,
    ref: unstakeTimerRef
  } = useShowTransition({
    isOpen: (transaction === null || transaction === void 0 ? void 0 : transaction.type) === 'unstakeRequest' && startOfStakingCycle !== undefined && (stakingStatus === 'unstakeRequested' || isLongUnstakeRequested) && transaction.timestamp >= startOfStakingCycle,
    withShouldRender: true
  });
  useSyncEffect(() => {
    if (renderedTransaction) {
      setDecryptedComment(undefined);
    }
  }, [renderedTransaction]);
  useSyncEffect(() => {
    if (endOfStakingCycle) {
      setUnstakeDate(endOfStakingCycle);
    }
  }, [endOfStakingCycle]);
  teact_useEffect(() => {
    if (id && shouldLoadDetails) fetchActivityDetails({
      id
    });
  }, [id, shouldLoadDetails]);
  const clearPasswordError = useLastCallback(() => {
    setPasswordError(undefined);
  });
  const openPasswordSlide = useLastCallback(() => {
    setCurrentSlide(TransactionModal_SLIDES.password);
    setNextKey(undefined);
  });
  const closePasswordSlide = useLastCallback(() => {
    setCurrentSlide(TransactionModal_SLIDES.initial);
    setNextKey(TransactionModal_SLIDES.password);
    clearPasswordError();
  });
  const handleSendClick = useLastCallback(() => {
    closeActivityInfo({
      id: id
    });
    startTransfer({
      isPortrait,
      tokenSlug: slug || src_config/* TONCOIN */.Tu9.slug,
      toAddress: address,
      amount: (0,bigint/* bigintAbs */.wg)(amount),
      comment: !isIncoming ? comment : undefined
    });
  });
  const handleStartStakingClick = useLastCallback(() => {
    closeActivityInfo({
      id: id
    });
    if (!isPortrait) {
      setLandscapeActionsActiveTabIndex({
        index: ActiveTab.Stake
      });
      return;
    }
    startStaking();
  });
  const handleUnstakeMoreClick = useLastCallback(() => {
    closeActivityInfo({
      id: id
    });
    if (!isPortrait) {
      setLandscapeActionsActiveTabIndex({
        index: ActiveTab.Stake
      });
    }
    startUnstaking();
  });
  const handlePasswordSubmit = useLastCallback(async password => {
    const result = await (0,api/* callApi */.p)('decryptComment', getGlobal().currentAccountId, encryptedComment, fromAddress, password);
    if (isErrorTransferResult(result)) {
      setPasswordError(errorCodeToMessage(result === null || result === void 0 ? void 0 : result.error));
      return;
    }
    if (getDoesUsePinPad()) {
      setIsPinAccepted();
      await vibrateOnSuccess(true);
    }
    closePasswordSlide();
    setDecryptedComment(result);
  });
  const openHiddenComment = useLastCallback(async () => {
    if (!encryptedComment) {
      return;
    }
    if (getHasInMemoryPassword()) {
      const password = await getInMemoryPassword();
      if (password) {
        void handlePasswordSubmit(password);
        return;
      }
    }
    openPasswordSlide();
  });
  const handleClose = useLastCallback(() => {
    closeActivityInfo({
      id: id
    });
    if (getDoesUsePinPad()) {
      clearIsPinAccepted();
    }
  });
  function renderHeader() {
    const titleTense = isAnyPending ? 'present' : status === 'failed' ? 'future' : 'past';
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.header, Modal_module.header_wideContent)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.title, TransactionModal_module.modalTitle)
    }, /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.headerTitle
    }, transaction && getTransactionTitle(transaction, titleTense, lang), isAnyPending && /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isModalOpen,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme][iconClock],
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview[iconClock]
    }), status === 'failed' && /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.headerTitle__badge
    }, lang('Failed')), isScam && isIncoming && /*#__PURE__*/teact.createElement("img", {
      src: scam_namespaceObject,
      alt: lang('Scam'),
      className: TransactionModal_module.scamImage
    })), !!timestamp && /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.headerDate
    }, (0,dateFormat/* formatFullDay */.TK)(lang.code, timestamp), ", ", (0,dateFormat/* formatTime */.fU)(timestamp))), /*#__PURE__*/teact.createElement(ui_Button, {
      isRound: true,
      className: Modal_module.closeButton,
      ariaLabel: lang('Close'),
      onClick: handleClose
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Modal_module.closeIcon, 'icon-close'),
      "aria-hidden": true
    })));
  }
  function renderTransactionWithPoisoningWarning() {
    return /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.scamWarning
    }, lang('This address mimics another address that you previously interacted with.'));
  }
  function renderFee() {
    if (!(fee || shouldLoadDetails) || !nativeToken) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement(TransactionFee, {
      terms: {
        native: fee
      },
      token: nativeToken,
      precision: isAnyPending ? 'approximate' : 'exact',
      isLoading: shouldLoadDetails,
      className: TransactionModal_module.feeField
    });
  }
  function renderComment() {
    if (!comment && !encryptedComment) {
      return undefined;
    }
    const spoiler = encryptedComment ? lang('Message is encrypted.') : isScam ? lang('Scam comment is hidden.') : undefined;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, lang('Comment')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      text: encryptedComment ? decryptedComment : comment,
      spoiler: spoiler,
      spoilerRevealText: encryptedComment ? canDecryptComment ? lang('Decrypt') : undefined : lang('Display'),
      spoilerCallback: canDecryptComment ? openHiddenComment : undefined,
      copyNotification: lang('Comment was copied!'),
      className: TransactionModal_module.copyButtonWrapper,
      textClassName: TransactionModal_module.comment
    }));
  }
  function renderTransactionId() {
    return /*#__PURE__*/teact.createElement("div", {
      ref: transactionIdRef,
      className: TransactionModal_module.textFieldWrapper
    }, /*#__PURE__*/teact.createElement("span", {
      className: TransactionModal_module.textFieldLabel
    }, lang('Transaction ID')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      noSavedAddress: true,
      chain: chain,
      address: transactionHash,
      addressUrl: transactionUrl,
      isTransaction: true,
      copyNotification: lang('Transaction ID was copied!'),
      className: TransactionModal_module.changellyTextField
    }));
  }
  function renderUnstakeTimer() {
    return /*#__PURE__*/teact.createElement("div", {
      ref: unstakeTimerRef,
      className: TransactionModal_module.unstakeTime
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isModalOpen,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      className: TransactionModal_module.unstakeTimeIcon,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClockGray,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClockGray
    }), /*#__PURE__*/teact.createElement("div", null, lang('$unstaking_when_receive', {
      time: /*#__PURE__*/teact.createElement("strong", null, (0,dateFormat/* formatRelativeHumanDateTime */.YG)(lang.code, unstakeDate))
    })));
  }
  function renderFooter() {
    const canUnstake = isOurStaking && (isOurUnstaking || (transaction === null || transaction === void 0 ? void 0 : transaction.type) === 'unstakeRequest') && stakingStatus === 'active';
    const buttons = [];
    if (!isOurStaking && !isIncoming && !isNftTransfer) {
      buttons.push(/*#__PURE__*/teact.createElement(ui_Button, {
        onClick: handleSendClick,
        className: TransactionModal_module.button
      }, lang('Repeat')));
    }
    if (!src_config/* IS_CORE_WALLET */.TI6 && isOurStaking) {
      buttons.push(/*#__PURE__*/teact.createElement(ui_Button, {
        onClick: handleStartStakingClick,
        className: buildClassName(TransactionModal_module.button, canUnstake && TransactionModal_module.buttonWide)
      }, lang('Stake Again')));
    }
    if (canUnstake) {
      buttons.push(/*#__PURE__*/teact.createElement(ui_Button, {
        onClick: handleUnstakeMoreClick,
        className: buildClassName(TransactionModal_module.button, TransactionModal_module.buttonWide)
      }, lang('Unstake More')));
    }
    return buttons.length ? /*#__PURE__*/teact.createElement("div", {
      className: TransactionModal_module.footer
    }, buttons) : undefined;
  }
  function renderTransactionContent() {
    const amountDisplayMode = transaction && getTransactionAmountDisplayMode(transaction);
    return /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.transitionContent
    }, amountDisplayMode !== 'hide' && /*#__PURE__*/teact.createElement(common_TransactionAmount, {
      isSensitiveDataHidden: isSensitiveDataHidden,
      isIncoming: isIncoming,
      isScam: isScam,
      isFailed: status === 'failed',
      amount: amount ?? 0n,
      token: token,
      status: isOurUnstaking && !shouldRenderUnstakeTimer ? lang('Successfully') : undefined,
      noSign: amountDisplayMode === 'noSign',
      baseCurrency: baseCurrency
    }), nft && /*#__PURE__*/teact.createElement(transfer_NftInfo, {
      nft: nft,
      withMediaViewer: doesNftExist,
      withTonExplorer: true
    }), isTransactionWithPoisoning && renderTransactionWithPoisoningWarning(), transaction && shouldShowTransactionAddress(transaction).includes('modal') && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, lang(isIncoming ? 'Sender' : 'Recipient')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      chain: chain,
      addressName: addressName,
      address: address,
      isScam: isScam && !isIncoming,
      copyNotification: lang('Address was copied!'),
      className: TransactionModal_module.copyButtonWrapper,
      textClassName: isScam && isIncoming ? TransactionModal_module.scamAddress : undefined
    })), renderFee(), renderComment(), shouldRenderTransactionId && renderTransactionId(), shouldRenderUnstakeTimer && renderUnstakeTimer(), !isViewMode && renderFooter());
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case TransactionModal_SLIDES.initial:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderHeader(), renderTransactionContent());
      case TransactionModal_SLIDES.password:
        if (!encryptedComment) return undefined;
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Enter Password'),
          onClose: handleClose
        }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
          isActive: isActive,
          error: passwordError,
          withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
          containerClassName: src_config/* IS_CAPACITOR */.UMQ ? TransactionModal_module.passwordFormContent : TransactionModal_module.passwordFormContentInModal,
          submitLabel: lang('Send'),
          onSubmit: handlePasswordSubmit,
          onCancel: closePasswordSlide,
          onUpdate: clearPasswordError
        }));
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isModalOpen,
    hasCloseButton: true,
    nativeBottomSheetKey: "transaction-info",
    forceFullNative: currentSlide === TransactionModal_SLIDES.password,
    dialogClassName: buildClassName(TransactionModal_module.modalDialog, isOurUnstaking && TransactionModal_module.unstakeModal),
    onClose: handleClose,
    onCloseAnimationEnd: closePasswordSlide
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: currentSlide,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const modals_TransactionModal = (memo(withGlobal(global => {
  var _accountState$activit, _global$tokenInfo;
  const accountId = global.currentAccountId;
  const accountState = selectCurrentAccountState(global);
  const txId = accountState === null || accountState === void 0 ? void 0 : accountState.currentActivityId;
  const activity = txId ? accountState === null || accountState === void 0 || (_accountState$activit = accountState.activities) === null || _accountState$activit === void 0 ? void 0 : _accountState$activit.byId[txId] : undefined;
  const savedAddresses = accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses;
  const {
    byAddress
  } = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {};
  const stakingStates = selectAccountStakingStates(global, accountId);
  const {
    isTestnet,
    theme,
    isSensitiveDataHidden
  } = global.settings;
  const accounts = selectAccounts(global);
  const isHardwareAccount = selectIsHardwareAccount(global);
  return {
    transaction: (activity === null || activity === void 0 ? void 0 : activity.kind) === 'transaction' ? activity : undefined,
    tokensBySlug: (_global$tokenInfo = global.tokenInfo) === null || _global$tokenInfo === void 0 ? void 0 : _global$tokenInfo.bySlug,
    savedAddresses,
    isHardwareAccount,
    isTestnet,
    isViewMode: selectIsCurrentAccountViewMode(global),
    isLongUnstakeRequested: accountState === null || accountState === void 0 ? void 0 : accountState.isLongUnstakeRequested,
    isMediaViewerOpen: Boolean(global.mediaViewer.mediaId),
    theme,
    stakingStates,
    isSensitiveDataHidden,
    nftsByAddress: byAddress,
    accounts,
    currentAccountId: accountId,
    baseCurrency: global.settings.baseCurrency
  };
})(TransactionModal)));
;// ./src/components/main/modals/UnhideNftModal.tsx








function UnhideNftModal(_ref) {
  let {
    isOpen,
    nftAddress,
    nftName
  } = _ref;
  const {
    addNftsToWhitelist,
    closeUnhideNftModal
  } = getActions();
  const lang = hooks_useLang();
  const handleUnhide = useLastCallback(() => {
    addNftsToWhitelist({
      addresses: [nftAddress]
    });
    closeUnhideNftModal();
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    isCompact: true,
    onClose: closeUnhideNftModal,
    title: lang('Unhide NFT')
  }, /*#__PURE__*/teact.createElement("p", {
    className: Modal_module.text
  }, lang('$unhide_nft_warning', {
    name: /*#__PURE__*/teact.createElement("b", null, nftName)
  })), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: closeUnhideNftModal,
    className: Modal_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    onClick: handleUnhide,
    className: Modal_module.button
  }, lang('Unhide'))));
}
/* harmony default export */ const modals_UnhideNftModal = (memo(withGlobal(global => {
  const {
    isUnhideNftModalOpen,
    selectedNftToUnhide
  } = selectCurrentAccountState(global) ?? {};
  return {
    isOpen: isUnhideNftModalOpen,
    nftAddress: selectedNftToUnhide === null || selectedNftToUnhide === void 0 ? void 0 : selectedNftToUnhide.address,
    nftName: selectedNftToUnhide === null || selectedNftToUnhide === void 0 ? void 0 : selectedNftToUnhide.name
  };
})(UnhideNftModal)));
;// ./src/components/ui/Notification.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Notification_module = ({"container":"Notification-module__container","container_electron":"Notification-module__container_electron","containerElectron":"Notification-module__container_electron","notification":"Notification-module__notification","content":"Notification-module__content","icon":"Notification-module__icon"});
;// ./src/components/ui/Notification.tsx








const DURATION_MS = 5000;
const Notification_ANIMATION_DURATION = 250;
const Notification = _ref => {
  let {
    icon,
    message,
    containerId,
    onDismiss
  } = _ref;
  const [isOpen, setIsOpen] = useState(true);
  const timerRef = teact_useRef();
  const {
    ref
  } = useShowTransition({
    isOpen
  });
  const closeAndDismiss = useLastCallback(() => {
    setIsOpen(false);
    setTimeout(onDismiss, Notification_ANIMATION_DURATION);
  });
  teact_useEffect(() => isOpen ? captureEscKeyListener(closeAndDismiss) : undefined, [isOpen, closeAndDismiss]);
  teact_useEffect(() => {
    timerRef.current = window.setTimeout(closeAndDismiss, DURATION_MS);
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = undefined;
      }
    };
  }, [closeAndDismiss]);
  const handleMouseEnter = useLastCallback(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
      timerRef.current = undefined;
    }
  });
  const handleMouseLeave = useLastCallback(() => {
    timerRef.current = window.setTimeout(closeAndDismiss, DURATION_MS);
  });
  return /*#__PURE__*/teact.createElement(ui_Portal, {
    className: buildClassName(Notification_module.container, windowEnvironment/* IS_ELECTRON */.cp && Notification_module.container_electron),
    containerId: containerId
  }, /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: Notification_module.notification,
    onClick: closeAndDismiss,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave
  }, /*#__PURE__*/teact.createElement("div", {
    className: Notification_module.content
  }, icon && /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Notification_module.icon, icon),
    "aria-hidden": true
  }), message)));
};
/* harmony default export */ const ui_Notification = (Notification);
;// ./src/components/main/Notifications.tsx




function Notifications(_ref) {
  let {
    notifications
  } = _ref;
  const {
    dismissNotification
  } = getActions();
  if (!notifications.length) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    id: "Notifications"
  }, notifications.map(_ref2 => {
    let {
      message,
      icon
    } = _ref2;
    return /*#__PURE__*/teact.createElement(ui_Notification, {
      key: message,
      icon: icon,
      message: message,
      onDismiss: dismissNotification
    });
  }));
}
/* harmony default export */ const main_Notifications = (memo(withGlobal(global => (0,iteratees/* pick */.Up)(global, ['notifications']))(Notifications)));
;// ./src/hooks/useHideBottomBar.ts


let bottomBarHideCounter = 0;
const bottomBarListeners = createCallbackManager();
function getIsBottomBarHidden() {
  return bottomBarHideCounter > 0;
}
function subscribeToBottomBarVisibility(callback) {
  return bottomBarListeners.addCallback(callback);
}
function notifyBottomBarListeners() {
  bottomBarListeners.runCallbacks();
}
function hideBottomBar() {
  const wasHidden = getIsBottomBarHidden();
  bottomBarHideCounter += 1;
  if (!wasHidden && getIsBottomBarHidden()) {
    notifyBottomBarListeners();
  }
}
function showBottomBar() {
  const wasHidden = getIsBottomBarHidden();
  bottomBarHideCounter = Math.max(0, bottomBarHideCounter - 1);
  if (wasHidden && !getIsBottomBarHidden()) {
    notifyBottomBarListeners();
  }
}

// Use this hook when you need to temporarily hide the bottom bar on a screen, for example,
// when assumes the use of the entire screen height - `PasswordForm` with biometrics
function useHideBottomBar(isHidden) {
  teact_useEffect(() => {
    if (!isHidden) return undefined;
    hideBottomBar();
    return showBottomBar;
  }, [isHidden]);
}
;// ./src/components/main/sections/Actions/BottomBar.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const BottomBar_module = ({"root":"BottomBar-module__root","hidden":"BottomBar-module__hidden","button":"BottomBar-module__button","active":"BottomBar-module__active","icon":"BottomBar-module__icon","label":"BottomBar-module__label"});
;// ./src/components/main/sections/Actions/BottomBar.tsx












function BottomBar(_ref) {
  let {
    areSettingsOpen,
    areAssetsActive,
    isExploreOpen
  } = _ref;
  const {
    switchToWallet,
    switchToExplore,
    switchToSettings
  } = getActions();
  const lang = hooks_useLang();
  const [isHidden, setIsHidden] = useState(getIsBottomBarHidden());
  const isWalletTabActive = !isExploreOpen && !areSettingsOpen;
  hooks_useEffectOnce(() => {
    return subscribeToBottomBarVisibility(() => {
      setIsHidden(getIsBottomBarHidden());
    });
  });
  useHistoryBack({
    isActive: isExploreOpen,
    onBack: switchToWallet
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(BottomBar_module.root, isHidden && BottomBar_module.hidden)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    className: buildClassName(BottomBar_module.button, isWalletTabActive && BottomBar_module.active),
    onClick: switchToWallet
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(BottomBar_module.icon, 'icon-wallet')
  }), /*#__PURE__*/teact.createElement("span", {
    className: BottomBar_module.label
  }, lang('Wallet'))), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    className: buildClassName(BottomBar_module.button, isExploreOpen && BottomBar_module.active),
    onClick: switchToExplore
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(BottomBar_module.icon, 'icon-explore')
  }), /*#__PURE__*/teact.createElement("span", {
    className: BottomBar_module.label
  }, lang('Explore'))), /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    className: buildClassName(BottomBar_module.button, areSettingsOpen && BottomBar_module.active),
    onClick: switchToSettings
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(BottomBar_module.icon, 'icon-settings')
  }), /*#__PURE__*/teact.createElement("span", {
    className: BottomBar_module.label
  }, lang('Settings'))));
}
/* harmony default export */ const Actions_BottomBar = (memo(withGlobal(global => {
  const {
    areSettingsOpen,
    isExploreOpen
  } = global;
  const {
    activeContentTab
  } = selectCurrentAccountState(global) ?? {};
  return {
    areSettingsOpen,
    areAssetsActive: activeContentTab === ContentTab.Assets,
    isExploreOpen
  };
})(BottomBar)));
;// ./src/util/isElementInViewport.ts

function isElementInViewport(el) {
  if (el.style.display === 'none') {
    return false;
  }
  const rect = el.getBoundingClientRect();
  const {
    height: windowHeight
  } = windowSize.get();
  return rect.top <= windowHeight && rect.top + rect.height >= 0;
}
;// ./src/components/mediaViewer/MediaViewer.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const MediaViewer_module = ({"root":"MediaViewer-module__root","header":"MediaViewer-module__header","headerTransition":"MediaViewer-module__headerTransition","actions":"MediaViewer-module__actions","actionButton":"MediaViewer-module__actionButton","actionIcon":"MediaViewer-module__actionIcon","menuButton":"MediaViewer-module__menuButton","menuButton_active":"MediaViewer-module__menuButton_active","menuButtonActive":"MediaViewer-module__menuButton_active","menuItem":"MediaViewer-module__menuItem","slides":"MediaViewer-module__slides","slide":"MediaViewer-module__slide","slide_active":"MediaViewer-module__slide_active","slideActive":"MediaViewer-module__slide_active","slide_moving":"MediaViewer-module__slide_moving","slideMoving":"MediaViewer-module__slide_moving","content":"MediaViewer-module__content","image":"MediaViewer-module__image","contentDescription":"MediaViewer-module__contentDescription","contentTextWrapper":"MediaViewer-module__contentTextWrapper","contentText":"MediaViewer-module__contentText","navigation":"MediaViewer-module__navigation","portraitContainer":"MediaViewer-module__portraitContainer","navigation_prev":"MediaViewer-module__navigation_prev","navigationPrev":"MediaViewer-module__navigation_prev","navigation_next":"MediaViewer-module__navigation_next","navigationNext":"MediaViewer-module__navigation_next","mediaInfo":"MediaViewer-module__mediaInfo","mediaInfoTitle":"MediaViewer-module__mediaInfoTitle","mediaInfoDescription":"MediaViewer-module__mediaInfoDescription","descriptionText":"MediaViewer-module__descriptionText","tooltip":"MediaViewer-module__tooltip","ghost":"MediaViewer-module__ghost","ghost_roundedOpening":"MediaViewer-module__ghost_roundedOpening","ghostRoundedOpening":"MediaViewer-module__ghost_roundedOpening","ghost_roundedClosing":"MediaViewer-module__ghost_roundedClosing","ghostRoundedClosing":"MediaViewer-module__ghost_roundedClosing","ghostImage":"MediaViewer-module__ghostImage","scamImage":"MediaViewer-module__scamImage"});
;// ./src/components/mediaViewer/helpers/ghostAnimation.ts









const ghostAnimation_ANIMATION_DURATION = 200;

// Header height + bottom padding, keep in sync with styles.image max-height
const OCCUPIED_HEIGHT = 14 * windowEnvironment/* REM */.$;
function animateOpening(type, mediaId, mediaUrl, txId, hiddenNfts) {
  const {
    image: fromImage
  } = getNode(type, mediaId, txId, hiddenNfts);
  if (!fromImage || !mediaUrl) {
    return;
  }
  (0,fasterdom/* requestMutation */.RK)(async () => {
    document.body.classList.add('ghost-animating');
    const {
      width: windowWidth,
      height: windowHeight
    } = windowSize.get();
    const {
      width: mediaWidth,
      height: mediaHeight
    } = await getImageDimension(mediaUrl);
    const availableHeight = windowHeight - OCCUPIED_HEIGHT;
    const offsetTop = (windowWidth <= src_config/* MOBILE_SCREEN_MAX_WIDTH */.c2m ? 8 : 7) * windowEnvironment/* REM */.$;
    const {
      width: toWidth,
      height: toHeight
    } = calculateDimensions(windowWidth, availableHeight, mediaWidth, mediaHeight);
    const toLeft = (windowWidth - toWidth) / 2;
    const toTop = offsetTop + (availableHeight - toHeight) / 2;
    const {
      top: fromTop,
      left: fromLeft,
      width: fromWidth,
      height: fromHeight
    } = fromImage.getBoundingClientRect();
    const fromTranslateX = fromLeft + fromWidth / 2 - (toLeft + toWidth / 2);
    const fromTranslateY = fromTop + fromHeight / 2 - (toTop + toHeight / 2);
    const fromScaleX = fromWidth / toWidth;
    const fromScaleY = fromHeight / toHeight;
    (0,fasterdom/* requestMutation */.RK)(() => {
      const ghost = createGhost(fromImage);
      applyShape(ghost, type, true);
      (0,animation/* applyStyles */.ZM)(ghost, {
        top: `${toTop}px`,
        left: `${toLeft}px`,
        width: `${toWidth}px`,
        height: `${toHeight}px`,
        transform: `translate3d(${fromTranslateX}px, ${fromTranslateY}px, 0) scale(${fromScaleX}, ${fromScaleY})`
      });
      document.body.appendChild(ghost);
      (0,fasterdom/* requestMutation */.RK)(() => {
        ghost.style.transform = '';
        clearShape(ghost, type, true);
        setTimeout(() => {
          (0,fasterdom/* requestMutation */.RK)(() => {
            if (document.body.contains(ghost)) {
              document.body.removeChild(ghost);
            }
            document.body.classList.remove('ghost-animating');
          });
        }, ghostAnimation_ANIMATION_DURATION + src_config/* ANIMATION_END_DELAY */.xB5);
      });
    });
  });
}
function animateClosing(type, mediaId, txId, hiddenNfts) {
  const {
    container,
    image: toImage
  } = getNode(type, mediaId, txId, hiddenNfts);
  const fromImage = document.querySelector(`.${MediaViewer_module.slide_active} img, .${MediaViewer_module.slide_active} canvas`);
  if (!fromImage || !toImage) {
    return;
  }
  const {
    top: fromTop,
    left: fromLeft,
    width: fromWidth,
    height: fromHeight
  } = fromImage.getBoundingClientRect();
  const {
    top: targetTop,
    left: toLeft,
    width: toWidth,
    height: toHeight
  } = toImage.getBoundingClientRect();
  let toTop = targetTop;
  if (!isElementInViewport(toImage)) {
    const {
      height: windowHeight
    } = windowSize.get();
    toTop = targetTop < fromTop ? -toHeight : windowHeight;
  }
  const fromTranslateX = fromLeft + fromWidth / 2 - (toLeft + toWidth / 2);
  const fromTranslateY = fromTop + fromHeight / 2 - (toTop + toHeight / 2);
  const fromScaleX = fromWidth / toWidth;
  const fromScaleY = fromHeight / toHeight;
  const existingGhost = document.querySelector(`.${MediaViewer_module.ghost}`);
  const ghost = existingGhost || createGhost(fromImage);
  let ghostStyles;
  if (existingGhost) {
    const {
      top,
      left,
      width,
      height
    } = existingGhost.getBoundingClientRect();
    const scaleX = width / toWidth;
    const scaleY = height / toHeight;
    ghostStyles = {
      transition: 'none',
      top: `${toTop}px`,
      left: `${toLeft}px`,
      transformOrigin: 'top left',
      transform: `translate3d(${left - toLeft}px, ${top - toTop}px, 0) scale(${scaleX}, ${scaleY})`,
      width: `${toWidth}px`,
      height: `${toHeight}px`
    };
  } else {
    ghostStyles = {
      top: `${toTop}px`,
      left: `${toLeft}px`,
      width: `${toWidth}px`,
      height: `${toHeight}px`,
      transform: `translate3d(${fromTranslateX}px, ${fromTranslateY}px, 0) scale(${fromScaleX}, ${fromScaleY})`
    };
  }
  (0,fasterdom/* requestMutation */.RK)(() => {
    applyShape(ghost, type);
    (0,animation/* applyStyles */.ZM)(ghost, ghostStyles);
    if (!existingGhost) document.body.appendChild(ghost);
    document.body.classList.add('ghost-animating');
    if (container) {
      container.classList.add('ghost-target');
    }
    (0,fasterdom/* requestMutation */.RK)(() => {
      if (existingGhost) {
        existingGhost.style.transition = '';
      }
      ghost.style.transform = '';
      setTimeout(() => {
        (0,fasterdom/* requestMutation */.RK)(() => {
          if (document.body.contains(ghost)) {
            document.body.removeChild(ghost);
          }
          document.body.classList.remove('ghost-animating');
          if (container) {
            container.classList.remove('ghost-target');
          }
        });
      }, ghostAnimation_ANIMATION_DURATION + src_config/* ANIMATION_END_DELAY */.xB5);
    });
  });
}
function getNode(type, mediaId, txId, hiddenNfts) {
  let image;
  let container;
  if (type === MediaType.Nft) {
    var _container;
    container = document.querySelector(txId ? `.transaction-nft[data-tx-id="${txId}"][data-nft-address="${mediaId}"]` : hiddenNfts ? `.hidden-nfts-${hiddenNfts} [data-nft-address="${mediaId}"]` : `.nft-container[data-nft-address="${mediaId}"]`);
    image = (_container = container) === null || _container === void 0 ? void 0 : _container.querySelector('img, canvas');
  }
  return {
    container,
    image
  };
}
function createGhost(source) {
  var _source$parentElement;
  const ghost = document.createElement('div');
  ghost.classList.add(MediaViewer_module.ghost);
  const img = new Image();
  img.classList.add(MediaViewer_module.ghostImage);
  img.draggable = false;
  img.oncontextmenu = stopEvent;
  img.src = source instanceof HTMLImageElement ? source.src : ((_source$parentElement = source.parentElement) === null || _source$parentElement === void 0 || (_source$parentElement = _source$parentElement.parentElement) === null || _source$parentElement === void 0 ? void 0 : _source$parentElement.dataset.previewUrl) || '';
  ghost.appendChild(img);
  return ghost;
}
function calculateDimensions(availableWidth, availableHeight, mediaWidth, mediaHeight) {
  const aspectRatio = mediaHeight / mediaWidth;
  const calculatedWidth = Math.min(mediaWidth, availableWidth);
  const calculatedHeight = Math.round(calculatedWidth * aspectRatio);
  if (calculatedHeight > availableHeight) {
    return {
      width: Math.round(availableHeight / aspectRatio),
      height: availableHeight
    };
  }
  return {
    width: calculatedWidth,
    height: Math.round(calculatedWidth * aspectRatio)
  };
}
function applyShape(ghost, type) {
  let isOpening = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (type === MediaType.Nft) {
    ghost.classList.add(isOpening ? MediaViewer_module.ghost_roundedOpening : MediaViewer_module.ghost_roundedClosing);
  }
}
function clearShape(ghost, type) {
  let isOpening = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (type === MediaType.Nft) {
    ghost.classList.remove(isOpening ? MediaViewer_module.ghost_roundedOpening : MediaViewer_module.ghost_roundedClosing);
  }
}
async function getImageDimension(url) {
  const img = new Image();
  img.src = url;
  await new Promise(resolve => {
    img.onload = resolve;
  });
  return {
    width: img.width,
    height: img.height
  };
}
;// ./src/components/ui/ShowTransition.tsx



const ShowTransition = _ref => {
  let {
    isOpen,
    isHidden,
    isCustom,
    id,
    className,
    onClick,
    children,
    noCloseTransition,
    shouldAnimateFirstRender,
    style,
    ref: externalRef
  } = _ref;
  const prevIsOpen = hooks_usePrevious(isOpen);
  const prevChildren = hooks_usePrevious(children);
  const fromChildrenRef = teact_useRef();
  const isFirstRender = prevIsOpen === undefined;
  const {
    ref,
    shouldRender
  } = useShowTransition({
    isOpen: isOpen && !isHidden,
    ref: externalRef,
    noMountTransition: isFirstRender && !shouldAnimateFirstRender,
    className: isCustom ? false : undefined,
    noCloseTransition,
    withShouldRender: true
  });
  if (prevIsOpen && !isOpen) {
    fromChildrenRef.current = prevChildren;
  }
  return (shouldRender || isHidden) && /*#__PURE__*/teact.createElement("div", {
    id: id,
    ref: ref,
    className: className,
    onClick: onClick,
    style: style
  }, isOpen ? children : fromChildrenRef.current);
};
/* harmony default export */ const ui_ShowTransition = (ShowTransition);
;// ./src/components/mediaViewer/Actions.tsx















const SHOULD_CLOSE_VIEWER_HANDLERS = ['send', 'renew', 'burn', 'collection', 'select', 'linkDomain'];
function Actions(_ref) {
  let {
    nft,
    tonDnsExpiration,
    linkedAddress,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    cardBackgroundNft,
    accentColorNft,
    isViewMode,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const [isMenuOpen, openMenu, closeMenu] = hooks_useFlag();
  const dnsExpireInDays = tonDnsExpiration ? (0,dateFormat/* getCountDaysToDate */.GS)(tonDnsExpiration) : undefined;
  const isNftBlacklisted = teact_useMemo(() => {
    return blacklistedNftAddresses === null || blacklistedNftAddresses === void 0 ? void 0 : blacklistedNftAddresses.includes(nft.address);
  }, [nft, blacklistedNftAddresses]);
  const isNftWhitelisted = teact_useMemo(() => {
    return whitelistedNftAddresses === null || whitelistedNftAddresses === void 0 ? void 0 : whitelistedNftAddresses.includes(nft.address);
  }, [nft, whitelistedNftAddresses]);
  const isNftInstalled = usePrevDuringAnimationSimple(nft && nft.address === (cardBackgroundNft === null || cardBackgroundNft === void 0 ? void 0 : cardBackgroundNft.address), ANIMATION_DURATION);
  const isNftAccentColorInstalled = usePrevDuringAnimationSimple(nft && nft.address === (accentColorNft === null || accentColorNft === void 0 ? void 0 : accentColorNft.address), ANIMATION_DURATION);
  const {
    menuItems,
    handleMenuItemSelect
  } = useNftMenu({
    nft,
    isViewMode,
    dnsExpireInDays,
    linkedAddress,
    isNftBlacklisted,
    isNftWhitelisted,
    isNftInstalled,
    isNftAccentColorInstalled
  });
  const handleSelect = useLastCallback(value => {
    if (SHOULD_CLOSE_VIEWER_HANDLERS.includes(value)) {
      onClose();
    }
    handleMenuItemSelect(value);
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.actions
  }, /*#__PURE__*/teact.createElement("button", {
    type: "button",
    "aria-label": lang('More actions'),
    className: buildClassName(MediaViewer_module.actionButton, MediaViewer_module.menuButton, isMenuOpen && MediaViewer_module.menuButton_active),
    onClick: openMenu
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon icon-more",
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement(ui_DropdownMenu, {
    isOpen: isMenuOpen,
    items: menuItems,
    menuPositionY: "top",
    menuPositionX: "right",
    shouldTranslateOptions: true,
    onClose: closeMenu,
    className: "component-theme-dark",
    buttonClassName: MediaViewer_module.menuItem,
    onSelect: handleSelect
  }), /*#__PURE__*/teact.createElement("button", {
    type: "button",
    "aria-label": lang('Close'),
    className: MediaViewer_module.actionButton,
    onClick: onClose
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-windows-close', MediaViewer_module.actionIcon),
    "aria-hidden": true
  })));
}
/* harmony default export */ const mediaViewer_Actions = (memo(withGlobal((global, _ref2) => {
  var _selectCurrentAccount;
  let {
    mediaId
  } = _ref2;
  const {
    mediaType = MediaType.Nft
  } = global.mediaViewer || {};
  const isViewMode = selectIsCurrentAccountViewMode(global);
  if (!mediaId || mediaType !== MediaType.Nft) return {
    isViewMode
  };
  const {
    byAddress,
    dnsExpiration
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  const nft = byAddress === null || byAddress === void 0 ? void 0 : byAddress[mediaId];
  if (!nft) return {
    isViewMode
  };
  const {
    blacklistedNftAddresses,
    whitelistedNftAddresses
  } = selectCurrentAccountState(global) || {};
  const {
    cardBackgroundNft,
    accentColorNft
  } = selectCurrentAccountSettings(global) || {};
  const tonDnsExpiration = getTonDnsExpirationDate(nft, dnsExpiration);
  const linkedAddress = selectTonDnsLinkedAddress(global, nft);
  return {
    nft,
    tonDnsExpiration,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    cardBackgroundNft,
    accentColorNft,
    isViewMode,
    linkedAddress
  };
})(Actions)));
;// ./src/components/mediaViewer/MediaInfo.tsx










function MediaInfo(_ref) {
  let {
    title,
    description,
    descriptionUrl
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.mediaInfo
  }, /*#__PURE__*/teact.createElement("span", {
    className: MediaViewer_module.mediaInfoTitle
  }, title), /*#__PURE__*/teact.createElement("a", {
    href: descriptionUrl,
    target: "_blank",
    "aria-label": lang('Open NFT Collection'),
    className: MediaViewer_module.mediaInfoDescription,
    rel: "noreferrer",
    onClick: handleUrlClick
  }, /*#__PURE__*/teact.createElement("span", {
    className: MediaViewer_module.descriptionText
  }, description), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName('icon-tooltip', MediaViewer_module.tooltip),
    "aria-hidden": true
  })));
}
/* harmony default export */ const mediaViewer_MediaInfo = (memo(withGlobal((global, _ref2) => {
  var _selectCurrentAccount;
  let {
    mediaId
  } = _ref2;
  const {
    mediaType = MediaType.Nft
  } = global.mediaViewer || {};
  if (!mediaId || mediaType !== MediaType.Nft) return {};
  const isTestnet = global.settings.isTestnet;
  const getgemsBaseUrl = isTestnet ? src_config/* GETGEMS_BASE_TESTNET_URL */.PKm : src_config/* GETGEMS_BASE_MAINNET_URL */.wln;
  const {
    byAddress
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  const nft = byAddress === null || byAddress === void 0 ? void 0 : byAddress[mediaId];
  if (!nft) return {};
  return {
    title: nft.name || (0,shortenAddress/* shortenAddress */.W)(nft.address, 4),
    description: nft.collectionName,
    descriptionUrl: `${getgemsBaseUrl}collection/${nft.collectionAddress}`
  };
})(MediaInfo)));
;// ./src/hooks/useSignalRef.ts



// Allows to use signal value as "silent" dependency in hooks (not causing updates)
function useSignalRef(getValue) {
  const ref = teact_useRef(getValue());
  hooks_useEffectOnce(() => {
    return getValue.subscribe(() => {
      ref.current = getValue();
    });
  });
  return ref;
}
;// ./src/components/mediaViewer/hooks/useZoomChangeSignal.ts


const [getZoomChange, setZoomChange] = createSignal(1);
function useZoomChange() {
  teact_useEffect(() => {
    return () => {
      setZoomChange(1);
    };
  }, []);
  return [getZoomChange, setZoomChange];
}
;// ./src/components/mediaViewer/Media.tsx











const Media_ANIMATED_ICON_SIZE = 250; // Preview size (500px) / 2

function Media(_ref) {
  let {
    mediaId,
    alt,
    thumbnail,
    image,
    lottie,
    description,
    isScam,
    whitelistedMediaIds
  } = _ref;
  const lang = hooks_useLang();
  const src = image || thumbnail;
  const ref = teact_useRef();
  const {
    isPortrait
  } = useDeviceScreen();
  teact_useEffect(() => {
    const element = ref.current;
    const {
      height
    } = element.getBoundingClientRect();
    (0,fasterdom/* requestMutation */.RK)(() => {
      // Inner scroll requires max-height to be set
      element.style.setProperty('--max-height', `${height}px`);
    });
  }, [isPortrait]);
  const isNftWhiteListed = teact_useMemo(() => {
    return whitelistedMediaIds === null || whitelistedMediaIds === void 0 ? void 0 : whitelistedMediaIds.includes(mediaId);
  }, [mediaId, whitelistedMediaIds]);
  return /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.content
  }, lottie ? /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    size: Media_ANIMATED_ICON_SIZE,
    shouldStretch: true,
    play: true,
    noLoop: false,
    tgsUrl: lottie,
    previewUrl: src,
    className: MediaViewer_module.image,
    noPreviewTransition: true
  }) : /*#__PURE__*/teact.createElement("img", {
    src: src,
    alt: alt,
    className: MediaViewer_module.image
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MediaViewer_module.contentDescription, 'custom-scroll'),
    ref: ref
  }, description && /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.contentTextWrapper
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MediaViewer_module.contentText, 'custom-scroll'),
    dir: "auto"
  }, isScam && !isNftWhiteListed && /*#__PURE__*/teact.createElement("img", {
    src: scam_namespaceObject,
    alt: lang('Scam'),
    className: MediaViewer_module.scamImage
  }), description))));
}
/* harmony default export */ const mediaViewer_Media = (memo(withGlobal((global, _ref2) => {
  var _selectCurrentAccount, _nft$metadata;
  let {
    mediaId
  } = _ref2;
  const {
    mediaType = MediaType.Nft
  } = global.mediaViewer || {};
  if (mediaType !== MediaType.Nft) return {};
  const {
    byAddress
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  const nft = byAddress === null || byAddress === void 0 ? void 0 : byAddress[mediaId];
  if (!nft) return {};
  const {
    whitelistedNftAddresses
  } = selectCurrentAccountState(global) || {};
  return {
    alt: nft.name,
    thumbnail: nft.thumbnail,
    image: nft.image,
    lottie: (_nft$metadata = nft.metadata) === null || _nft$metadata === void 0 ? void 0 : _nft$metadata.lottie,
    description: nft.description,
    isScam: nft.isScam,
    whitelistedMediaIds: whitelistedNftAddresses
  };
})(Media)));
;// ./src/components/mediaViewer/Slides.tsx


















var Slides_SwipeDirection = /*#__PURE__*/function (SwipeDirection) {
  SwipeDirection[SwipeDirection["Horizontal"] = 0] = "Horizontal";
  SwipeDirection[SwipeDirection["Vertical"] = 1] = "Vertical";
  return SwipeDirection;
}(Slides_SwipeDirection || {});
const SWIPE_X_THRESHOLD = 50; // px
const SWIPE_Y_THRESHOLD = 50; // px
const SLIDES_GAP = windowEnvironment/* IS_TOUCH_ENV */.TF ? 40 : 0; // px
const Slides_ANIMATION_DURATION = 350; // ms
const DEBOUNCE_SELECT_MEDIA = 350; // ms
const DEBOUNCE_SWIPE = 500; // ms
const DOUBLE_TAP_ZOOM = 3;
const CLICK_Y_THRESHOLD = 80; // px
const MAX_ZOOM = 4;
const MIN_ZOOM = 1;
const {
  easeOutCubic,
  easeOutQuart
} = animation/* timingFunctions */.qM;
let cancelAnimation;
let cancelZoomAnimation;
function Slides(_ref) {
  let {
    isOpen,
    mediaId,
    selectMedia,
    getMediaId,
    withAnimation,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const containerRef = teact_useRef();
  const activeSlideRef = teact_useRef();
  const leftSlideRef = teact_useRef();
  const rightSlideRef = teact_useRef();
  const lastTransformRef = teact_useRef({
    x: 0,
    y: 0,
    scale: 1
  });
  const swipeDirectionRef = teact_useRef(undefined);
  const initialContentRectRef = teact_useRef(undefined);
  const isReleasedRef = teact_useRef(false);
  const [getZoomChange] = useZoomChange();
  const prevZoomChangeRef = teact_useRef(getZoomChange());
  const [isMouseDown, setIsMouseDown] = useState(false);
  const [getTransform, setTransform] = useSignal_useSignal({
    x: 0,
    y: 0,
    scale: 1
  });
  const transformRef = useSignalRef(getTransform);
  const [getActiveMediaId, setActiveMediaId] = useSignal_useSignal(mediaId);
  const activeMediaIdRef = useSignalRef(getActiveMediaId);
  const isScaled = hooks_useDerivedState(() => getTransform().scale !== 1, [getTransform]);
  const activeMediaId = hooks_useDerivedState(getActiveMediaId);
  const {
    height: windowHeight,
    width: windowWidth,
    isResizing
  } = useWindowSize();
  useHistoryBack({
    isActive: isOpen,
    onBack: onClose,
    shouldBeReplaced: true
  });
  const selectMediaDebounced = useDebouncedCallback_useDebouncedCallback(selectMedia, [selectMedia], DEBOUNCE_SELECT_MEDIA, true);
  const clearSwipeDirectionDebounced = useDebouncedCallback_useDebouncedCallback(() => {
    swipeDirectionRef.current = undefined;
  }, [], DEBOUNCE_SWIPE, true);
  const clickXThreshold = windowEnvironment/* IS_TOUCH_ENV */.TF ? 40 : windowWidth / 10;
  teact_useEffect(() => {
    const {
      scale,
      x,
      y
    } = transformRef.current;
    // Only update active media if slide is in default position
    if (x === 0 && y === 0 && scale === 1) {
      setActiveMediaId(mediaId);
    }
  }, [mediaId, setActiveMediaId, transformRef]);
  useLayoutEffect(() => {
    const {
      x,
      y,
      scale
    } = getTransform();
    if (leftSlideRef.current) {
      leftSlideRef.current.style.transform = getTransformStyle(-windowWidth + x - SLIDES_GAP);
    }
    if (activeSlideRef.current) {
      activeSlideRef.current.style.transform = getTransformStyle(x, y, scale);
    }
    if (rightSlideRef.current) {
      rightSlideRef.current.style.transform = getTransformStyle(windowWidth + x + SLIDES_GAP);
    }
  }, [getTransform, windowWidth]);
  const changeSlide = useLastCallback(function (direction) {
    let dryRun = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let lastTransform = lastTransformRef.current;
    const mId = getMediaId(activeMediaIdRef.current, direction);
    if (dryRun) return mId !== undefined;
    if (mId === undefined) return false;
    const offset = (windowWidth + SLIDES_GAP) * direction;
    const transform = transformRef.current;
    const x = transform.x + offset;
    setActiveMediaId(mId);
    selectMediaDebounced(mId);
    lastTransform = {
      x: 0,
      y: 0,
      scale: 1
    };
    if (!withAnimation) {
      setTransform(lastTransform);
      return true;
    }
    cancelAnimation = (0,animation/* animateNumber */.Hd)({
      from: x,
      to: 0,
      duration: Slides_ANIMATION_DURATION,
      timing: easeOutCubic,
      onUpdate: value => setTransform({
        y: 0,
        x: value,
        scale: 1
      })
    });
    return true;
  });
  const handleNextSlide = useLastCallback(() => changeSlide(1));
  const handlePrevSlide = useLastCallback(() => changeSlide(-1));
  teact_useEffect(() => {
    if (!containerRef.current || activeMediaIdRef.current === undefined) {
      return undefined;
    }
    let lastTransform = lastTransformRef.current;
    const lastDragOffset = {
      x: 0,
      y: 0
    };
    const lastZoomCenter = {
      x: 0,
      y: 0
    };
    const panDelta = {
      x: 0,
      y: 0
    };
    let lastGestureTime = Date.now();
    let content;
    const setLastGestureTime = (0,schedulers/* debounce */.sg)(() => {
      lastGestureTime = Date.now();
    }, 500, false, true);
    const changeSlideOnClick = e => {
      const {
        scale
      } = transformRef.current;
      if (scale !== 1) return [false, false];
      let direction = 0;
      if (windowHeight - e.pageY < CLICK_Y_THRESHOLD) {
        return [false, false];
      }
      if (e.pageX < clickXThreshold) {
        direction = -1;
      } else if (e.pageX > windowWidth - clickXThreshold) {
        direction = 1;
      }
      const hasNextSlide = changeSlide(direction, !windowEnvironment/* IS_TOUCH_ENV */.TF);
      const isInThreshold = direction !== 0;
      return [isInThreshold, hasNextSlide];
    };
    const handleKeyDown = e => {
      const {
        scale
      } = transformRef.current;
      if (scale !== 1) return;
      switch (e.key) {
        case 'Left': // IE/Edge specific value
        case 'ArrowLeft':
          changeSlide(-1);
          break;
        case 'Right': // IE/Edge specific value
        case 'ArrowRight':
          changeSlide(1);
          break;
      }
    };
    const calculateOffsetBoundaries = function (_ref2) {
      let {
        x,
        y,
        scale
      } = _ref2;
      let offsetTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const initialContentRect = initialContentRectRef.current;
      if (!initialContentRect) return [{
        x,
        y,
        scale
      }, true, true];
      // Get current content boundaries
      let inBoundsX = true;
      let inBoundsY = true;
      const centerX = (windowWidth - windowWidth * scale) / 2;
      const centerY = (windowHeight - windowHeight * scale) / 2;

      // If content is outside window we calculate offset boundaries
      // based on initial content rect and current scale
      const minOffsetX = Math.max(-initialContentRect.left * scale, centerX);
      const maxOffsetX = windowWidth - initialContentRect.right * scale;
      inBoundsX = isBetween(x, maxOffsetX, minOffsetX);
      x = clamp(x, maxOffsetX, minOffsetX);
      const minOffsetY = Math.max(-initialContentRect.top * scale + offsetTop, centerY);
      const maxOffsetY = windowHeight - initialContentRect.bottom * scale;
      inBoundsY = isBetween(y, maxOffsetY, minOffsetY);
      y = clamp(y, maxOffsetY, minOffsetY);
      return [{
        x,
        y,
        scale
      }, inBoundsX, inBoundsY];
    };
    const onRelease = e => {
      // This allows to prevent onRelease triggered by debounced wheel event
      // after onRelease was triggered manually in onDrag
      if (isReleasedRef.current) {
        isReleasedRef.current = false;
        return;
      }
      if (e.type === 'mouseup') {
        setIsMouseDown(false);
      }
      const transform = transformRef.current;
      const {
        y,
        scale
      } = transform;
      let x = transform.x;
      const absX = Math.abs(x);
      const absY = Math.abs(y);
      clearSwipeDirectionDebounced();

      // If scale is less than 1 we need to bounce back
      if (scale < 1) {
        lastTransform = {
          x: 0,
          y: 0,
          scale: 1
        };
        cancelAnimation = (0,animation/* animateNumber */.Hd)({
          from: [x, y, scale],
          to: [0, 0, 1],
          duration: Slides_ANIMATION_DURATION,
          timing: easeOutCubic,
          onUpdate: value => setTransform({
            x: value[0],
            y: value[1],
            scale: value[2]
          })
        });
        return;
      }
      if (scale > 1) {
        // Get current content boundaries
        const s1 = Math.min(scale, MAX_ZOOM);
        const scaleFactor = s1 / scale;

        // Calculate new position based on the last zoom center to keep the zoom center
        // at the same position when bouncing back from max zoom
        let x1 = x * scaleFactor + (lastZoomCenter.x - scaleFactor * lastZoomCenter.x);
        let y1 = y * scaleFactor + (lastZoomCenter.y - scaleFactor * lastZoomCenter.y);

        // Arbitrary pan velocity coefficient
        const k = 0.15;

        // If scale didn't change, we need to add inertia to pan gesture
        if (e.type !== 'wheel' && lastTransform.scale === scale) {
          // Calculate user gesture velocity
          const Vx = Math.abs(lastDragOffset.x) / (Date.now() - lastGestureTime);
          const Vy = Math.abs(lastDragOffset.y) / (Date.now() - lastGestureTime);

          // Add extra distance based on gesture velocity and last pan delta
          x1 -= Math.abs(lastDragOffset.x) * Vx * k * panDelta.x;
          y1 -= Math.abs(lastDragOffset.y) * Vy * k * panDelta.y;
        }
        [lastTransform] = calculateOffsetBoundaries({
          x: x1,
          y: y1,
          scale: s1
        });
        cancelAnimation = (0,animation/* animateNumber */.Hd)({
          from: [x, y, scale],
          to: [lastTransform.x, lastTransform.y, lastTransform.scale],
          duration: Slides_ANIMATION_DURATION,
          timing: easeOutCubic,
          onUpdate: value => setTransform({
            x: value[0],
            y: value[1],
            scale: value[2]
          })
        });
        return;
      }
      lastTransform = {
        x,
        y,
        scale
      };
      if (absY >= SWIPE_Y_THRESHOLD) {
        onClose();
        return;
      }
      // Bounce back if vertical swipe is below threshold
      if (absY > 0) {
        cancelAnimation = (0,animation/* animateNumber */.Hd)({
          from: y,
          to: 0,
          duration: Slides_ANIMATION_DURATION,
          timing: easeOutCubic,
          onUpdate: value => setTransform({
            x: 0,
            y: value,
            scale
          })
        });
        return;
      }
      // Get horizontal swipe direction
      const direction = x < 0 ? 1 : -1;
      const mId = getMediaId(activeMediaIdRef.current, x < 0 ? 1 : -1);
      // Get the direction of the last pan gesture.
      // Could be different from the total horizontal swipe direction
      // if user starts a swipe in one direction and then changes the direction
      // we need to cancel slide transition
      const dirX = panDelta.x < 0 ? -1 : 1;
      if (mId !== undefined && absX >= SWIPE_X_THRESHOLD && direction === dirX) {
        const offset = (windowWidth + SLIDES_GAP) * direction;
        // If image is shifted by more than SWIPE_X_THRESHOLD,
        // We shift everything by one screen width and then set new active message id
        x += offset;
        setActiveMediaId(mId);
        selectMediaDebounced(mId);
      }
      // Then we always return to the original position
      cancelAnimation = (0,animation/* animateNumber */.Hd)({
        from: x,
        to: 0,
        duration: Slides_ANIMATION_DURATION,
        timing: easeOutCubic,
        onUpdate: value => setTransform({
          y: 0,
          x: value,
          scale: scale ?? 1
        })
      });
    };
    const cleanup = captureEvents(containerRef.current, {
      isNotPassive: true,
      withNativeDrag: true,
      excludedClosestSelector: `${MediaViewer_module.header}, .${MediaViewer_module.contentDescription}`,
      minZoom: MIN_ZOOM,
      maxZoom: MAX_ZOOM,
      doubleTapZoom: DOUBLE_TAP_ZOOM,
      withWheelDrag: true,
      onCapture: e => {
        const {
          x,
          y,
          scale
        } = transformRef.current;
        if (e.type === 'mousedown') {
          setIsMouseDown(true);
          if (scale !== 1) {
            e.preventDefault();
            return;
          }
        }
        lastGestureTime = Date.now();
        if (x === 0 && y === 0 && scale === 1) {
          if (!activeSlideRef.current) return;
          content = activeSlideRef.current.querySelector('img, video');
          if (!content) return;
          // Store initial content rect, without transformations
          initialContentRectRef.current = content.getBoundingClientRect();
        }
      },
      onDrag: (event, captureEvent, _ref3, cancelDrag) => {
        let {
          dragOffsetX,
          dragOffsetY
        } = _ref3;
        if (isReleasedRef.current) return;
        // Avoid conflicts with swipe-to-back gestures
        if (windowEnvironment/* IS_IOS */.pz && captureEvent.type === 'touchstart') {
          const {
            pageX
          } = captureEvent.touches[0];
          if (pageX <= IOS_SCREEN_EDGE_THRESHOLD || pageX >= windowWidth - IOS_SCREEN_EDGE_THRESHOLD) {
            return;
          }
        }
        if (cancelAnimation) {
          cancelAnimation();
          cancelAnimation = undefined;
        }
        panDelta.x = lastDragOffset.x - dragOffsetX;
        panDelta.y = lastDragOffset.y - dragOffsetY;
        lastDragOffset.x = dragOffsetX;
        lastDragOffset.y = dragOffsetY;
        const absOffsetX = Math.abs(dragOffsetX);
        const absOffsetY = Math.abs(dragOffsetY);
        const {
          x,
          y,
          scale
        } = transformRef.current;

        // If user is inactive but is still touching the screen
        // we reset last gesture time
        setLastGestureTime();

        // If image is scaled we just need to pan it
        if (scale !== 1) {
          const x1 = lastTransform.x + dragOffsetX;
          const y1 = lastTransform.y + dragOffsetY;
          if (['wheel', 'mousemove'].includes(event.type)) {
            const [transform, inBoundsX, inBoundsY] = calculateOffsetBoundaries({
              x: x1,
              y: y1,
              scale
            });
            if (cancelDrag) cancelDrag(!inBoundsX, !inBoundsY);
            setTransform(transform);
            return;
          }
          if ('touches' in event && event.touches.length === 1) {
            setTransform({
              x: x1,
              y: y1,
              scale
            });
          }
          return;
        }
        if (event.type === 'mousemove') return;
        if (swipeDirectionRef.current !== Slides_SwipeDirection.Vertical) {
          // If user is swiping horizontally or horizontal shift is dominant
          // we change only horizontal position
          if (swipeDirectionRef.current === Slides_SwipeDirection.Horizontal || Math.abs(x) > SWIPE_DIRECTION_THRESHOLD || absOffsetX / absOffsetY > SWIPE_DIRECTION_TOLERANCE) {
            swipeDirectionRef.current = Slides_SwipeDirection.Horizontal;
            const limit = windowWidth + SLIDES_GAP;
            const x1 = clamp(dragOffsetX, -limit, limit);
            setTransform({
              x: x1,
              y: 0,
              scale
            });
            // We know that at this point onRelease will trigger slide change,
            // We can trigger onRelease directly instead of waiting for the debounced callback
            // to avoid a delay
            if (event.type === 'wheel' && Math.abs(x1) > SWIPE_X_THRESHOLD * 2) {
              onRelease(event);
              isReleasedRef.current = true;
            }
            return;
          }
        }
        // If vertical shift is dominant we change only vertical position
        if (swipeDirectionRef.current === Slides_SwipeDirection.Vertical || Math.abs(y) > SWIPE_DIRECTION_THRESHOLD || absOffsetY / absOffsetX > SWIPE_DIRECTION_TOLERANCE) {
          swipeDirectionRef.current = Slides_SwipeDirection.Vertical;
          const limit = windowHeight;
          const y1 = clamp(dragOffsetY, -limit, limit);
          setTransform({
            x: 0,
            y: y1,
            scale
          });
          if (event.type === 'wheel' && Math.abs(y1) > SWIPE_Y_THRESHOLD * 2) {
            onRelease(event);
            isReleasedRef.current = true;
          }
        }
      },
      onZoom: (e, _ref4) => {
        let {
          zoom,
          zoomFactor,
          initialCenterX,
          initialCenterY,
          dragOffsetX,
          dragOffsetY,
          currentCenterX,
          currentCenterY
        } = _ref4;
        if (cancelAnimation) cancelAnimation();
        initialCenterX = initialCenterX || windowWidth / 2;
        initialCenterY = initialCenterY || windowHeight / 2;
        currentCenterX = currentCenterX || windowWidth / 2;
        currentCenterY = currentCenterY || windowHeight / 2;

        // Calculate current scale based on zoom factor and limits, add zoom margin for bounce back effect
        const scale = zoom ?? clamp(lastTransform.scale * zoomFactor, MIN_ZOOM * 0.5, MAX_ZOOM * 3);
        const scaleFactor = scale / lastTransform.scale;
        const offsetX = Math.abs(Math.min(lastTransform.x, 0));
        const offsetY = Math.abs(Math.min(lastTransform.y, 0));

        // Save last zoom center for bounce back effect
        lastZoomCenter.x = currentCenterX;
        lastZoomCenter.y = currentCenterY;

        // Calculate new center relative to the shifted image
        const scaledCenterX = offsetX + initialCenterX;
        const scaledCenterY = offsetY + initialCenterY;

        // Calculate how much we need to shift the image to keep the zoom center at the same position
        const scaleOffsetX = scaledCenterX - scaleFactor * scaledCenterX;
        const scaleOffsetY = scaledCenterY - scaleFactor * scaledCenterY;
        const [transform] = calculateOffsetBoundaries({
          x: lastTransform.x + scaleOffsetX + dragOffsetX,
          y: lastTransform.y + scaleOffsetY + dragOffsetY,
          scale
        });
        setTransform(transform);
      },
      onClick(e) {
        setIsMouseDown(false);
        const [isInThreshold, hasNextSlide] = changeSlideOnClick(e);
        if (isInThreshold) {
          e.preventDefault();
          e.stopPropagation();
          if (windowEnvironment/* IS_TOUCH_ENV */.TF) return;
          if (!hasNextSlide) onClose();
          return;
        }
        if (lastTransform.scale !== 1 || windowEnvironment/* IS_TOUCH_ENV */.TF) return;
        onClose();
      },
      onDoubleClick(e, _ref5) {
        let {
          centerX,
          centerY
        } = _ref5;
        const [isInThreshold] = changeSlideOnClick(e);
        if (isInThreshold) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (!windowEnvironment/* IS_TOUCH_ENV */.TF && e.type !== 'wheel') return;
        const {
          x,
          y,
          scale
        } = transformRef.current;
        // Calculate how much we need to shift the image to keep the zoom center at the same position
        const scaleOffsetX = centerX - DOUBLE_TAP_ZOOM * centerX;
        const scaleOffsetY = centerY - DOUBLE_TAP_ZOOM * centerY;
        if (scale === 1) {
          if (x !== 0 || y !== 0) return;
          lastTransform = calculateOffsetBoundaries({
            x: scaleOffsetX,
            y: scaleOffsetY,
            scale: DOUBLE_TAP_ZOOM
          })[0];
        } else {
          lastTransform = {
            x: 0,
            y: 0,
            scale: 1
          };
        }
        cancelAnimation = (0,animation/* animateNumber */.Hd)({
          from: [x, y, scale],
          to: [lastTransform.x, lastTransform.y, lastTransform.scale],
          duration: Slides_ANIMATION_DURATION,
          timing: easeOutCubic,
          onUpdate: value => {
            const transform = {
              x: value[0],
              y: value[1],
              scale: value[2]
            };
            setTransform(transform);
          }
        });
      },
      onRelease
    });
    document.addEventListener('keydown', handleKeyDown, false);
    return () => {
      cleanup();
      document.removeEventListener('keydown', handleKeyDown, false);
    };
  }, [onClose, setTransform, getMediaId, windowWidth, windowHeight, clickXThreshold, selectMediaDebounced, clearSwipeDirectionDebounced, withAnimation, setIsMouseDown, transformRef, setActiveMediaId, activeMediaIdRef, changeSlide]);
  teact_useEffect(() => {
    const zoomChange = getZoomChange();
    const hasZoomChanged = prevZoomChangeRef.current !== undefined && prevZoomChangeRef.current !== zoomChange;
    if (!containerRef.current || !hasZoomChanged) return;
    prevZoomChangeRef.current = zoomChange;
    const {
      scale
    } = transformRef.current;
    const dir = zoomChange > 0 ? -1 : +1;
    const minZoom = MIN_ZOOM * 0.6;
    const maxZoom = MAX_ZOOM * 3;
    let steps = 100;
    let prevValue = 0;
    if (scale <= minZoom && dir > 0) return;
    if (scale >= maxZoom && dir < 0) return;
    if (scale === 1 && dir > 0) steps = 20;
    if (cancelZoomAnimation) cancelZoomAnimation();
    cancelZoomAnimation = (0,animation/* animateNumber */.Hd)({
      from: dir,
      to: dir * steps,
      duration: Slides_ANIMATION_DURATION,
      timing: easeOutQuart,
      onUpdate: value => {
        if (!containerRef.current) return;
        const delta = math_round(value - prevValue, 2);
        prevValue = value;
        // To reuse existing logic we trigger wheel event for zoom buttons
        const wheelEvent = new WheelEvent('wheel', {
          deltaY: delta,
          ctrlKey: true
        });
        containerRef.current.dispatchEvent(wheelEvent);
      }
    });
  }, [getZoomChange, transformRef]);

  // eslint-disable-next-line no-null/no-null
  if (activeMediaId === undefined) return null;
  const nextMediaId = getMediaId(activeMediaId, 1);
  const prevMediaId = getMediaId(activeMediaId, -1);
  const hasPrev = prevMediaId !== undefined;
  const hasNext = nextMediaId !== undefined;
  const isMoving = isMouseDown && isScaled;
  return /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.slides,
    ref: containerRef
  }, /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.slide,
    ref: leftSlideRef
  }, hasPrev && !isScaled && !isResizing && /*#__PURE__*/teact.createElement(mediaViewer_Media, {
    mediaId: prevMediaId
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MediaViewer_module.slide, MediaViewer_module.slide_active, isMoving && MediaViewer_module.slide_moving),
    ref: activeSlideRef
  }, /*#__PURE__*/teact.createElement(mediaViewer_Media, {
    mediaId: activeMediaId
  })), /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.slide,
    ref: rightSlideRef
  }, hasNext && !isScaled && !isResizing && /*#__PURE__*/teact.createElement(mediaViewer_Media, {
    mediaId: nextMediaId
  })), hasPrev && !isScaled && !windowEnvironment/* IS_TOUCH_ENV */.TF && /*#__PURE__*/teact.createElement("button", {
    type: "button",
    onClick: handlePrevSlide,
    className: buildClassName(MediaViewer_module.navigation, MediaViewer_module.navigation_prev),
    "aria-label": lang('Previous'),
    dir: lang.isRtl ? 'rtl' : undefined
  }), hasNext && !isScaled && !windowEnvironment/* IS_TOUCH_ENV */.TF && /*#__PURE__*/teact.createElement("button", {
    type: "button",
    onClick: handleNextSlide,
    className: buildClassName(MediaViewer_module.navigation, MediaViewer_module.navigation_next),
    "aria-label": lang('Next'),
    dir: lang.isRtl ? 'rtl' : undefined
  }));
}
/* harmony default export */ const mediaViewer_Slides = (memo(Slides));
function getTransformStyle() {
  let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return `translate3d(${x.toFixed(3)}px, ${y.toFixed(3)}px, 0px) scale(${scale.toFixed(3)})`;
}
;// ./src/components/mediaViewer/MediaViewer.tsx



















function MediaViewer(_ref) {
  let {
    mediaId,
    mediaIds,
    mediaType,
    mediaUrl,
    withAnimation,
    mediaByIds,
    blacklistedIds,
    txId,
    hiddenNfts,
    noGhostAnimation
  } = _ref;
  const {
    closeMediaViewer,
    openMediaViewer
  } = getActions();
  const isOpen = Boolean(mediaId);
  const lang = hooks_useLang();
  const prevMediaId = hooks_usePrevious(mediaId);
  const prevTxId = hooks_usePrevious(txId);
  const prevHiddenNfts = hooks_usePrevious(hiddenNfts);
  const prevNoGhostAnimation = hooks_usePrevious(noGhostAnimation);
  const headerAnimation = withAnimation ? 'slideFade' : 'none';
  const shouldAnimateOpening = withAnimation && isOpen && !prevMediaId && !noGhostAnimation;
  const shouldAnimateClosing = withAnimation && !isOpen && !!prevMediaId && !prevNoGhostAnimation;
  const handleClose = useLastCallback(() => closeMediaViewer());
  const renderedMediaIds = teact_useMemo(() => {
    return mediaIds.filter(id => {
      const media = mediaByIds === null || mediaByIds === void 0 ? void 0 : mediaByIds[id];
      return media && !media.isHidden && !blacklistedIds.includes(id);
    });
  }, [blacklistedIds, mediaByIds, mediaIds]);
  const selectedMediaIndex = renderedMediaIds.indexOf(mediaId);
  const getMediaId = useLastCallback((fromId, direction) => {
    if (fromId === undefined) return undefined;
    const index = renderedMediaIds.indexOf(fromId);
    if (direction === -1 && index > 0 || direction === 1 && index < renderedMediaIds.length - 1) {
      return renderedMediaIds[index + direction];
    }
    return undefined;
  });
  const selectMedia = useLastCallback(id => {
    openMediaViewer({
      mediaType,
      mediaId: id
    });
  });
  useToggleClass({
    className: 'is-media-viewer-open',
    isActive: isOpen,
    element: document.body
  });
  teact_useEffect(() => isOpen ? captureEscKeyListener(handleClose) : undefined, [handleClose, isOpen]);
  teact_useEffect(() => {
    if (shouldAnimateOpening) {
      beginHeavyAnimation(ghostAnimation_ANIMATION_DURATION + src_config/* ANIMATION_END_DELAY */.xB5);
      animateOpening(mediaType, mediaId, mediaUrl, txId, hiddenNfts);
    }
    if (shouldAnimateClosing) {
      beginHeavyAnimation(ghostAnimation_ANIMATION_DURATION + src_config/* ANIMATION_END_DELAY */.xB5);
      animateClosing(mediaType, prevMediaId, prevTxId, prevHiddenNfts);
    }
  }, [shouldAnimateOpening, shouldAnimateClosing, mediaId, mediaType, mediaUrl, prevMediaId, txId, prevTxId, hiddenNfts, prevHiddenNfts]);
  return /*#__PURE__*/teact.createElement(ui_ShowTransition, {
    className: buildClassName(MediaViewer_module.root, 'opacity-transition', 'slow'),
    isOpen: isOpen,
    shouldAnimateFirstRender: true,
    isCustom: true
  }, /*#__PURE__*/teact.createElement("div", {
    className: MediaViewer_module.header,
    dir: lang.isRtl ? 'rtl' : undefined
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: selectedMediaIndex,
    name: headerAnimation,
    className: MediaViewer_module.headerTransition
  }, /*#__PURE__*/teact.createElement(mediaViewer_MediaInfo, {
    mediaId: mediaId
  })), /*#__PURE__*/teact.createElement(mediaViewer_Actions, {
    mediaId: mediaId,
    onClose: handleClose
  })), /*#__PURE__*/teact.createElement(mediaViewer_Slides, {
    isOpen: isOpen,
    mediaId: mediaId,
    getMediaId: getMediaId,
    selectMedia: selectMedia,
    withAnimation: withAnimation,
    onClose: handleClose
  }));
}
/* harmony default export */ const mediaViewer_MediaViewer = (memo(withGlobal(global => {
  var _global$settings;
  const {
    mediaId,
    mediaType = MediaType.Nft,
    txId,
    hiddenNfts,
    noGhostAnimation
  } = global.mediaViewer || {};
  const animationLevel = (_global$settings = global.settings) === null || _global$settings === void 0 ? void 0 : _global$settings.animationLevel;
  const accountState = selectCurrentAccountState(global);
  let mediaIds = MEMO_EMPTY_ARRAY;
  let mediaUrl;
  let mediaByIds;
  let blacklistedIds = MEMO_EMPTY_ARRAY;
  if (mediaType === MediaType.Nft) {
    var _nft$metadata;
    const {
      orderedAddresses,
      byAddress
    } = (accountState === null || accountState === void 0 ? void 0 : accountState.nfts) || {};
    const {
      blacklistedNftAddresses
    } = accountState || {};
    const nft = byAddress === null || byAddress === void 0 ? void 0 : byAddress[mediaId];
    mediaUrl = !(nft !== null && nft !== void 0 && (_nft$metadata = nft.metadata) !== null && _nft$metadata !== void 0 && _nft$metadata.lottie) && (nft === null || nft === void 0 ? void 0 : nft.image) || (nft === null || nft === void 0 ? void 0 : nft.thumbnail);
    mediaIds = orderedAddresses || MEMO_EMPTY_ARRAY;
    mediaByIds = byAddress;
    if (blacklistedNftAddresses !== null && blacklistedNftAddresses !== void 0 && blacklistedNftAddresses.length) {
      blacklistedIds = blacklistedNftAddresses;
    }
  }
  return {
    mediaId,
    txId,
    hiddenNfts,
    noGhostAnimation,
    mediaIds,
    mediaType,
    mediaUrl,
    mediaByIds,
    blacklistedIds,
    withAnimation: animationLevel > 0
  };
})(MediaViewer)));
;// ./src/components/mintCard/CardPros.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const CardPros_module = ({"root":"CardPros-module__root","standard":"CardPros-module__standard","silver":"CardPros-module__silver","gold":"CardPros-module__gold","platinum":"CardPros-module__platinum","black":"CardPros-module__black","list":"CardPros-module__list","term":"CardPros-module__term","icon":"CardPros-module__icon","data":"CardPros-module__data","button":"CardPros-module__button","currencyIcon":"CardPros-module__currencyIcon"});
;// ./src/components/mintCard/CardPros.tsx









function CardPros(_ref) {
  let {
    type,
    price,
    balance,
    isAvailable
  } = _ref;
  const {
    startCardMinting,
    showDialog
  } = getActions();
  const lang = hooks_useLang();
  const isEnoughBalance = price && balance ? (0,util_decimals/* fromDecimal */.UH)(price, src_config/* TONCOIN */.Tu9.decimals) + src_config/* DEFAULT_FEE */.dqR < balance : false;
  const handleSubmit = useLastCallback(() => {
    if (!isEnoughBalance) {
      showDialog({
        title: lang('Insufficient Balance'),
        message: lang('Please top up your TON balance.')
      });
      return;
    }
    startCardMinting({
      type
    });
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(CardPros_module.root, CardPros_module[type])
  }, /*#__PURE__*/teact.createElement("dl", {
    className: CardPros_module.list
  }, /*#__PURE__*/teact.createElement("dt", {
    className: CardPros_module.term
  }, lang('Unique'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(CardPros_module.icon, 'icon-diamond'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("dd", {
    className: CardPros_module.data
  }, lang('Get a card with unique background and personalized palette for wallet interface.')), /*#__PURE__*/teact.createElement("dt", {
    className: CardPros_module.term
  }, lang('Transferable'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(CardPros_module.icon, 'icon-swap'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("dd", {
    className: CardPros_module.data
  }, lang('Easily send your upgraded card to any of your friends.')), /*#__PURE__*/teact.createElement("dt", {
    className: CardPros_module.term
  }, lang('Tradable'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(CardPros_module.icon, 'icon-auction'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("dd", {
    className: CardPros_module.data
  }, lang('Sell or auction your card on third-party NFT marketplaces.'))), !!price && /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDisabled: !isAvailable,
    className: CardPros_module.button,
    onClick: handleSubmit
  }, lang('Upgrade for %currency% %amount%', {
    amount: price,
    currency: /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(CardPros_module.currencyIcon, 'icon-ton'),
      "aria-label": "TON"
    })
  })));
}
/* harmony default export */ const mintCard_CardPros = (memo(CardPros));
;// ./src/components/mintCard/MintCardModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const MintCardModal_module = ({"dialog":"MintCardModal-module__dialog","transition":"MintCardModal-module__transition","transitionSlide":"MintCardModal-module__transitionSlide","content":"MintCardModal-module__content","slide":"MintCardModal-module__slide","standard":"MintCardModal-module__standard","black":"MintCardModal-module__black","slideInner":"MintCardModal-module__slideInner","video":"MintCardModal-module__video","cardType":"MintCardModal-module__cardType","close":"MintCardModal-module__close","navigation":"MintCardModal-module__navigation","navigationLeft":"MintCardModal-module__navigationLeft","navigationRight":"MintCardModal-module__navigationRight","navigationIcon":"MintCardModal-module__navigationIcon","avaliability":"MintCardModal-module__avaliability","progress":"MintCardModal-module__progress","soldOut":"MintCardModal-module__soldOut","amount":"MintCardModal-module__amount","amountInner":"MintCardModal-module__amountInner","amountLeft":"MintCardModal-module__amountLeft","amountSold":"MintCardModal-module__amountSold","dots":"MintCardModal-module__dots","dot":"MintCardModal-module__dot","dotActive":"MintCardModal-module__dotActive","sticker":"MintCardModal-module__sticker","resultWithTime":"MintCardModal-module__resultWithTime","resultTimeIcon":"MintCardModal-module__resultTimeIcon","mintCardBanner":"MintCardModal-module__mintCardBanner"});
;// ./src/components/mintCard/CardRoster.tsx
















const MAP_CARD_TYPE_TO_NAME = {
  standard: 'Standard Card',
  silver: 'Silver Card',
  gold: 'Gold Card',
  platinum: 'Platinum Card',
  black: 'Black Card'
};
var CardSlides = /*#__PURE__*/function (CardSlides) {
  CardSlides[CardSlides["Standard"] = 0] = "Standard";
  CardSlides[CardSlides["Silver"] = 1] = "Silver";
  CardSlides[CardSlides["Gold"] = 2] = "Gold";
  CardSlides[CardSlides["Platinum"] = 3] = "Platinum";
  CardSlides[CardSlides["Black"] = 4] = "Black";
  return CardSlides;
}(CardSlides || {});
const TOTAL_SLIDES = Object.values(CardSlides).length / 2;
function CardRoster(_ref) {
  let {
    cardsInfo,
    tonBalance
  } = _ref;
  const {
    closeMintCardModal
  } = getActions();
  const lang = hooks_useLang();
  const transitionRef = teact_useRef();
  const [currentSlide, setCurrentSlide] = useState(CardSlides.Standard);
  const [nextKey, setNextKey] = useState(CardSlides.Silver);
  const showNextSlide = useLastCallback(() => {
    setCurrentSlide(current => current === CardSlides.Black ? CardSlides.Standard : current + 1);
    setNextKey(current => current === CardSlides.Black ? CardSlides.Standard : current + 1);
  });
  const showPrevSlide = useLastCallback(() => {
    setCurrentSlide(current => current === CardSlides.Standard ? CardSlides.Black : current - 1);
    setNextKey(current => current === CardSlides.Standard ? CardSlides.Black : current - 1);
  });
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF) {
      return undefined;
    }
    return captureEvents(transitionRef.current, {
      onSwipe: (e, direction) => {
        if (direction === SwipeDirection.Left) {
          showNextSlide();
          return true;
        } else if (direction === SwipeDirection.Right) {
          showPrevSlide();
          return true;
        }
        return false;
      },
      selectorToPreventScroll: '.custom-scroll'
    });
  }, []);
  function renderControls() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Button, {
      isRound: true,
      className: buildClassName(MintCardModal_module.close, Modal_module.closeButton),
      ariaLabel: lang('Close'),
      onClick: closeMintCardModal
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Modal_module.closeIcon, 'icon-close'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("button", {
      className: buildClassName(MintCardModal_module.navigation, MintCardModal_module.navigationLeft),
      type: "button",
      "aria-label": lang('Prev'),
      onClick: () => showPrevSlide()
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(MintCardModal_module.navigationIcon, 'icon-chevron-left'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("button", {
      className: buildClassName(MintCardModal_module.navigation, MintCardModal_module.navigationRight),
      type: "button",
      onClick: () => showNextSlide(),
      "aria-label": lang('Next')
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(MintCardModal_module.navigationIcon, 'icon-chevron-right'),
      "aria-hidden": true
    })));
  }
  function renderContent(isActive, isFrom, currentKey) {
    const defaultProps = {
      lang,
      tonBalance,
      currentKey
    };
    switch (currentKey) {
      case CardSlides.Standard:
        return renderMediaCard({
          ...defaultProps,
          title: MAP_CARD_TYPE_TO_NAME.standard,
          type: 'standard',
          cardInfo: cardsInfo === null || cardsInfo === void 0 ? void 0 : cardsInfo.standard
        });
      case CardSlides.Silver:
        return renderMediaCard({
          ...defaultProps,
          title: MAP_CARD_TYPE_TO_NAME.silver,
          type: 'silver',
          cardInfo: cardsInfo === null || cardsInfo === void 0 ? void 0 : cardsInfo.silver
        });
      case CardSlides.Gold:
        return renderMediaCard({
          ...defaultProps,
          title: MAP_CARD_TYPE_TO_NAME.gold,
          type: 'gold',
          cardInfo: cardsInfo === null || cardsInfo === void 0 ? void 0 : cardsInfo.gold
        });
      case CardSlides.Platinum:
        return renderMediaCard({
          ...defaultProps,
          title: MAP_CARD_TYPE_TO_NAME.platinum,
          type: 'platinum',
          cardInfo: cardsInfo === null || cardsInfo === void 0 ? void 0 : cardsInfo.platinum
        });
      case CardSlides.Black:
        return renderMediaCard({
          ...defaultProps,
          title: MAP_CARD_TYPE_TO_NAME.black,
          type: 'black',
          cardInfo: cardsInfo === null || cardsInfo === void 0 ? void 0 : cardsInfo.black
        });
    }
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderControls(), /*#__PURE__*/teact.createElement(ui_Transition, {
    ref: transitionRef,
    name: "semiFade",
    className: buildClassName(MintCardModal_module.transition, 'custom-scroll'),
    activeKey: currentSlide,
    nextKey: nextKey
  }, renderContent));
}
/* harmony default export */ const mintCard_CardRoster = (memo(withGlobal(global => {
  return {
    tonBalance: selectCurrentToncoinBalance(global)
  };
})(CardRoster)));
function renderMediaCard(_ref2) {
  let {
    lang,
    title,
    type,
    cardInfo,
    tonBalance,
    currentKey
  } = _ref2;
  return /*#__PURE__*/teact.createElement("div", {
    className: MintCardModal_module.content
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MintCardModal_module.slide, MintCardModal_module[type])
  }, /*#__PURE__*/teact.createElement("video", {
    autoPlay: true,
    muted: true,
    loop: true,
    playsInline: true,
    poster: `${src_config/* MTW_CARDS_MINT_BASE_URL */.eec}mtw_card_${type}.avif`,
    className: MintCardModal_module.video
  }, /*#__PURE__*/teact.createElement("source", {
    src: `${src_config/* MTW_CARDS_MINT_BASE_URL */.eec}mtw_card_${type}.h264.mp4`,
    type: "video/mp4; codecs=avc1.4D401E,mp4a.40.2"
  })), /*#__PURE__*/teact.createElement("div", {
    className: MintCardModal_module.slideInner
  }, renderDots(currentKey), /*#__PURE__*/teact.createElement("div", {
    className: MintCardModal_module.cardType
  }, title), renderAvailability(lang, cardInfo))), /*#__PURE__*/teact.createElement(mintCard_CardPros, {
    type: type,
    price: cardInfo === null || cardInfo === void 0 ? void 0 : cardInfo.price,
    balance: tonBalance,
    isAvailable: Boolean(cardInfo === null || cardInfo === void 0 ? void 0 : cardInfo.notMinted)
  }));
}
function renderDots(currentKey) {
  return /*#__PURE__*/teact.createElement("div", {
    className: MintCardModal_module.dots
  }, Array.from({
    length: TOTAL_SLIDES
  }).map((_, index) => {
    return /*#__PURE__*/teact.createElement("div", {
      key: index,
      className: buildClassName(MintCardModal_module.dot, index === currentKey && MintCardModal_module.dotActive)
    });
  }));
}
function renderAvailability(lang, cardInfo) {
  const {
    all,
    notMinted
  } = cardInfo || {};
  if (!all || !notMinted) {
    return /*#__PURE__*/teact.createElement("div", {
      className: MintCardModal_module.avaliability
    }, /*#__PURE__*/teact.createElement("div", {
      className: MintCardModal_module.soldOut
    }, lang('This card has been sold out')));
  }
  const sold = all - notMinted;
  const leftAmount = lang('%amount% left', {
    amount: formatNumber(notMinted)
  });
  const soldAmount = lang('%amount% sold', {
    amount: formatNumber(sold)
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: MintCardModal_module.avaliability
  }, /*#__PURE__*/teact.createElement("div", {
    className: MintCardModal_module.progress,
    style: `--progress: ${round(notMinted / all, 2)};}`
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MintCardModal_module.amount, MintCardModal_module.amountInner, MintCardModal_module.amountLeft)
  }, leftAmount), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MintCardModal_module.amount, MintCardModal_module.amountInner, MintCardModal_module.amountSold)
  }, soldAmount)), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MintCardModal_module.amount, MintCardModal_module.amountLeft)
  }, leftAmount), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(MintCardModal_module.amount, MintCardModal_module.amountSold)
  }, soldAmount));
}
;// ./src/components/mintCard/MintCardModal.tsx


























function MintCardModal(_ref) {
  let {
    isOpen,
    cardsInfo,
    isLoading,
    state,
    error,
    theme,
    selectedCardType
  } = _ref;
  const {
    closeMintCardModal,
    clearMintCardError,
    submitMintCard
  } = getActions();
  const lang = hooks_useLang();
  const appTheme = hooks_useAppTheme(theme);
  const {
    renderingKey,
    nextKey
  } = useModalTransitionKeys(state ?? 0, isOpen);
  const selectedCardName = selectedCardType ? MAP_CARD_TYPE_TO_NAME[selectedCardType] : '';
  const handlePasswordSubmit = useLastCallback(password => {
    submitMintCard({
      password
    });
  });
  const handleHardwareSubmit = useLastCallback(() => {
    submitMintCard();
  });
  function renderPasswordForm(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: !getDoesUsePinPad() ? lang('Confirm Upgrading') : undefined,
      onClose: getDoesUsePinPad() ? closeMintCardModal : undefined,
      onBackButtonClick: !getDoesUsePinPad() ? closeMintCardModal : undefined
    }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
      isActive: isActive,
      error: error,
      isLoading: isLoading,
      submitLabel: lang('Confirm'),
      cancelLabel: lang('Cancel'),
      onSubmit: handlePasswordSubmit,
      onCancel: closeMintCardModal,
      onUpdate: clearMintCardError,
      operationType: "mintCard",
      skipAuthScreen: true
    }, /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      className: MintCardModal_module.mintCardBanner,
      secondText: selectedCardName
    })));
  }
  function renderComplete(isActive) {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Card has been upgraded!'),
      onClose: closeMintCardModal
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Modal_module.transitionContent, Modal_module.transitionContent_simple)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      noLoop: false,
      nonInteractive: true,
      className: MintCardModal_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
      previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
    }), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(MintCardModal_module.resultWithTime)
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isActive,
      size: src_config/* ANIMATED_STICKER_TINY_ICON_PX */.wg4,
      className: MintCardModal_module.resultTimeIcon,
      nonInteractive: true,
      noLoop: false,
      tgsUrl: ANIMATED_STICKERS_PATHS[appTheme].iconClockGray,
      previewUrl: ANIMATED_STICKERS_PATHS[appTheme].preview.iconClockGray
    }), /*#__PURE__*/teact.createElement("div", null, renderText(lang('$mint_card_result')))), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isPrimary: true,
      className: Modal_module.buttonFullWidth,
      onClick: closeMintCardModal
    }, lang('Done')))));
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case MintCardState.Initial:
        return /*#__PURE__*/teact.createElement(mintCard_CardRoster, {
          cardsInfo: cardsInfo
        });
      case MintCardState.Password:
        return renderPasswordForm(isActive);
      case MintCardState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleHardwareSubmit,
          onClose: closeMintCardModal
        });
      case MintCardState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onClose: closeMintCardModal,
          onTryAgain: handleHardwareSubmit
        });
      case MintCardState.Done:
        return renderComplete(isActive);
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    forceFullNative: true,
    nativeBottomSheetKey: "mint-card",
    dialogClassName: MintCardModal_module.dialog,
    onClose: closeMintCardModal
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: renderingKey,
    nextKey: nextKey,
    name: resolveSlideTransitionName(),
    className: buildClassName(MintCardModal_module.transition, 'custom-scroll'),
    slideClassName: MintCardModal_module.transitionSlide
  }, renderContent));
}
/* harmony default export */ const mintCard_MintCardModal = (memo(withGlobal(global => {
  const {
    currentMintCard
  } = global;
  const {
    config
  } = selectCurrentAccountState(global) || {};
  const {
    cardsInfo
  } = config || {};
  return {
    isOpen: (currentMintCard === null || currentMintCard === void 0 ? void 0 : currentMintCard.state) !== undefined,
    cardsInfo,
    isLoading: currentMintCard === null || currentMintCard === void 0 ? void 0 : currentMintCard.isLoading,
    state: currentMintCard === null || currentMintCard === void 0 ? void 0 : currentMintCard.state,
    error: currentMintCard === null || currentMintCard === void 0 ? void 0 : currentMintCard.error,
    theme: global.settings.theme,
    selectedCardType: currentMintCard === null || currentMintCard === void 0 ? void 0 : currentMintCard.type
  };
})(MintCardModal)));
;// ./src/components/ui/Switcher.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Switcher_module = ({"container":"Switcher-module__container","input":"Switcher-module__input","widget":"Switcher-module__widget"});
;// ./src/components/ui/Switcher.tsx



function Switcher(_ref) {
  let {
    id,
    name,
    value,
    label,
    checked = false,
    className,
    onChange,
    onCheck,
    shouldStopPropagation
  } = _ref;
  function handleChange(e) {
    onChange === null || onChange === void 0 || onChange(e);
    onCheck === null || onCheck === void 0 || onCheck(e.currentTarget.checked);
  }
  return /*#__PURE__*/teact.createElement("label", {
    className: buildClassName(Switcher_module.container, className),
    title: label,
    "aria-label": label,
    onClick: shouldStopPropagation ? e => e.stopPropagation() : undefined,
    tabIndex: 0,
    role: "button"
  }, /*#__PURE__*/teact.createElement("input", {
    type: "checkbox",
    id: id,
    name: name,
    value: value,
    checked: checked,
    className: Switcher_module.input,
    onChange: handleChange
  }), /*#__PURE__*/teact.createElement("span", {
    className: Switcher_module.widget
  }));
}
/* harmony default export */ const ui_Switcher = (memo(Switcher));
;// ./src/components/settings/biometrics/Biometrics.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Biometrics_module = ({"modalDialog":"Biometrics-module__modalDialog","sticker":"Biometrics-module__sticker","stickerHuge":"Biometrics-module__stickerHuge","error":"Biometrics-module__error","step":"Biometrics-module__step"});
;// ./src/components/settings/biometrics/TurnOff.tsx


















const TurnOff_STICKER_SIZE = 180;
function TurnOff(_ref) {
  let {
    isOpen,
    isLoading,
    isInsideModal,
    state,
    error,
    onClose
  } = _ref;
  const {
    disableBiometrics
  } = getActions();
  const lang = hooks_useLang();
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const handleSubmit = useLastCallback((password, isPasswordNumeric) => {
    disableBiometrics({
      password,
      isPasswordNumeric
    });
  });
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case BiometricsState.TurnOffBiometricConfirmation:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Biometric Confirmation'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.holdTon,
          previewUrl: ANIMATED_STICKERS_PATHS.holdTonPreview,
          play: isActive,
          size: TurnOff_STICKER_SIZE,
          nonInteractive: true,
          noLoop: false,
          className: Biometrics_module.sticker
        }), error ? /*#__PURE__*/teact.createElement("div", {
          className: Biometrics_module.error
        }, lang(error)) : /*#__PURE__*/teact.createElement("div", {
          className: Biometrics_module.step
        }, lang('Please verify the operation.')), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          onClick: onClose,
          className: Modal_module.customSubmitButton
        }, lang('Cancel')))));
      case BiometricsState.TurnOffCreatePassword:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Create Password'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.guard,
          previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
          play: isActive,
          size: TurnOff_STICKER_SIZE,
          nonInteractive: true,
          noLoop: false,
          className: Biometrics_module.sticker
        }), /*#__PURE__*/teact.createElement(ui_CreatePasswordForm, {
          isActive: isActive,
          isLoading: isLoading,
          formId: "biometrics-create-password",
          onSubmit: handleSubmit,
          onCancel: onClose
        })));
      case BiometricsState.TurnOffComplete:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Biometrics Disabled'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.yeee,
          previewUrl: ANIMATED_STICKERS_PATHS.yeeePreview,
          play: isActive,
          size: src_config/* ANIMATED_STICKER_HUGE_SIZE_PX */.reE,
          nonInteractive: true,
          noLoop: false,
          className: buildClassName(Biometrics_module.sticker, Biometrics_module.stickerHuge)
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isPrimary: true,
          onClick: onClose,
          className: Modal_module.customSubmitButton
        }, lang('Done')))));
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen,
    dialogClassName: Biometrics_module.modalDialog,
    onClose: onClose
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: buildClassName(isInsideModal && Modal_module.transitionSlide),
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const biometrics_TurnOff = (memo(TurnOff));
;// ./src/components/settings/biometrics/TurnOffWarning.tsx







function TurnOffWaning(_ref) {
  let {
    isOpen,
    onClose
  } = _ref;
  const {
    openBiometricsTurnOff
  } = getActions();
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    isCompact: true,
    title: lang('Turn Off Biometrics'),
    onClose: onClose
  }, /*#__PURE__*/teact.createElement("p", {
    className: Modal_module.text
  }, lang('If you turn off biometric protection, you will need to create a password.')), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.buttons, Modal_module.buttonsNoExtraSpace)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Modal_module.button,
    onClick: onClose
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: Modal_module.button,
    onClick: openBiometricsTurnOff
  }, lang('Continue'))));
}
/* harmony default export */ const TurnOffWarning = (memo(TurnOffWaning));
;// ./src/components/settings/biometrics/TurnOn.tsx



















const TurnOn_STICKER_SIZE = 180;
function TurnOn(_ref) {
  let {
    isOpen,
    isLoading,
    isInsideModal,
    state,
    error,
    onClose
  } = _ref;
  const {
    enableBiometrics
  } = getActions();
  const lang = hooks_useLang();
  const [localError, setLocalError] = useState();
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const shouldDisablePasswordForm = Boolean(state !== BiometricsState.TurnOnPasswordConfirmation);
  teact_useEffect(() => {
    if (isOpen) {
      setLocalError('');
    }
  }, [isOpen]);
  const handleClearError = useLastCallback(() => {
    setLocalError(undefined);
  });
  const handleSubmit = useLastCallback(password => {
    if (shouldDisablePasswordForm) {
      return;
    }
    try {
      enableBiometrics({
        password
      });
    } catch (err) {
      setLocalError(err.message || 'Unknown error.');
    }
  });
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case BiometricsState.TurnOnPasswordConfirmation:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Turn On Biometrics'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
          isActive: isActive,
          isLoading: isLoading,
          error: error || localError,
          operationType: "turnOnBiometrics",
          help: lang('Enabling biometric confirmation will reset the password.'),
          submitLabel: lang('Continue'),
          onSubmit: handleSubmit,
          onCancel: onClose,
          onUpdate: handleClearError
        }));
      case BiometricsState.TurnOnRegistration:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Biometric Registration'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.holdTon,
          previewUrl: ANIMATED_STICKERS_PATHS.holdTonPreview,
          play: isActive,
          size: TurnOn_STICKER_SIZE,
          nonInteractive: true,
          noLoop: false,
          className: Biometrics_module.sticker
        }), /*#__PURE__*/teact.createElement("div", {
          className: Biometrics_module.step
        }, lang('Step 1 of 2. Registration')), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          onClick: onClose,
          className: Modal_module.customCancelButton
        }, lang('Cancel')))));
      case BiometricsState.TurnOnVerification:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Biometric Registration'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.holdTon,
          previewUrl: ANIMATED_STICKERS_PATHS.holdTonPreview,
          play: isActive,
          size: TurnOn_STICKER_SIZE,
          nonInteractive: true,
          noLoop: false,
          className: Biometrics_module.sticker
        }), /*#__PURE__*/teact.createElement("div", {
          className: Biometrics_module.step
        }, lang(windowEnvironment/* IS_ELECTRON */.cp ? 'Verification' : 'Step 2 of 2. Verification')), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          onClick: onClose,
          className: Modal_module.customCancelButton
        }, lang('Cancel')))));
      case BiometricsState.TurnOnComplete:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Biometrics Enabled'),
          onClose: onClose
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.transitionContent
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.yeee,
          previewUrl: ANIMATED_STICKERS_PATHS.yeeePreview,
          play: isActive,
          size: src_config/* ANIMATED_STICKER_HUGE_SIZE_PX */.reE,
          nonInteractive: true,
          noLoop: false,
          className: buildClassName(Biometrics_module.sticker, Biometrics_module.stickerHuge)
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isPrimary: true,
          onClick: onClose,
          className: Modal_module.customSubmitButton
        }, lang('Done')))));
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen,
    dialogClassName: Biometrics_module.modalDialog,
    onClose: onClose
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: buildClassName(isInsideModal && Modal_module.transitionSlide),
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const biometrics_TurnOn = (memo(TurnOn));
;// ./src/components/settings/biometrics/Biometrics.tsx






function Biometrics(_ref) {
  let {
    state,
    error,
    isLoading,
    isInsideModal
  } = _ref;
  const {
    closeBiometricSettings
  } = getActions();
  const isTurnOnBiometricsOpened = state === BiometricsState.TurnOnPasswordConfirmation || state === BiometricsState.TurnOnRegistration || state === BiometricsState.TurnOnVerification || state === BiometricsState.TurnOnComplete;
  const isTurnOffBiometricsOpened = state === BiometricsState.TurnOffBiometricConfirmation || state === BiometricsState.TurnOffCreatePassword || state === BiometricsState.TurnOffComplete;
  const isTurnOffBiometricsWarningOpened = state === BiometricsState.TurnOffWarning;
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(biometrics_TurnOn, {
    isOpen: isTurnOnBiometricsOpened,
    isLoading: isLoading,
    isInsideModal: isInsideModal,
    state: state,
    error: error,
    onClose: closeBiometricSettings
  }), /*#__PURE__*/teact.createElement(biometrics_TurnOff, {
    isOpen: isTurnOffBiometricsOpened,
    isLoading: isLoading,
    isInsideModal: isInsideModal,
    state: state,
    error: error,
    onClose: closeBiometricSettings
  }), /*#__PURE__*/teact.createElement(TurnOffWarning, {
    isOpen: isTurnOffBiometricsWarningOpened,
    onClose: closeBiometricSettings
  }));
}
/* harmony default export */ const biometrics_Biometrics = (memo(withGlobal(global => {
  const {
    biometrics: {
      state,
      error
    }
  } = global;
  return {
    state,
    error,
    isLoading: global.auth.isLoading
  };
})(Biometrics)));
;// ./src/components/settings/biometrics/NativeBiometricsTurnOn.tsx















function NativeBiometricsTurnOn(_ref) {
  let {
    isActive,
    isInsideModal,
    isPinAccepted,
    error,
    isNativeBiometricsEnabled,
    handleBackClick
  } = _ref;
  const {
    enableNativeBiometrics,
    clearNativeBiometricsError
  } = getActions();
  const lang = hooks_useLang();
  const {
    isSmallHeight
  } = useDeviceScreen();
  const [pin, setPin] = useState('');
  const pinPadType = pin.length !== src_config/* PIN_LENGTH */.NEx ? undefined : isPinAccepted ? 'success' : error ? 'error' : undefined;
  const pinTitle = isPinAccepted ? 'Correct' : error && pin.length === src_config/* PIN_LENGTH */.NEx ? error : 'Enter your code';
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  teact_useEffect(() => {
    if (!isActive) return;
    setPin('');
  }, [isActive]);
  hooks_useEffectWithPrevDeps(_ref2 => {
    let [prevIsEnabled] = _ref2;
    if (isNativeBiometricsEnabled && !prevIsEnabled) {
      handleBackClick();
    }
  }, [isNativeBiometricsEnabled, handleBackClick]);
  const handleSubmit = useLastCallback(password => {
    enableNativeBiometrics({
      password
    });
  });
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, Settings_module.contentFullSize)
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back')))), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.pinPadHeader
  }, !isInsideModal && /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.guard,
    previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
    noLoop: false,
    nonInteractive: true,
    className: Settings_module.stickerNativeBiometric
  }), !isSmallHeight && /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.pinPadTitle
  }, lang('Confirm Passcode'))), /*#__PURE__*/teact.createElement(ui_PinPad, {
    isActive: isActive,
    onClearError: clearNativeBiometricsError,
    title: lang(pinTitle),
    type: pinPadType,
    length: src_config/* PIN_LENGTH */.NEx,
    value: pin,
    onChange: setPin,
    onSubmit: handleSubmit
  })));
}
/* harmony default export */ const biometrics_NativeBiometricsTurnOn = (memo(withGlobal(global => {
  const {
    nativeBiometricsError,
    isPinAccepted
  } = global;
  return {
    isPinAccepted,
    error: nativeBiometricsError,
    isNativeBiometricsEnabled: selectIsNativeBiometricAuthEnabled(global)
  };
})(NativeBiometricsTurnOn)));
;// ./src/util/getAccentColorsFromNfts.ts




async function getAccentColorsFromNfts(nftAddresses, nftsByAddress) {
  try {
    const nftCards = (nftAddresses || []).reduce((result, nftAddress) => {
      const nft = nftsByAddress === null || nftsByAddress === void 0 ? void 0 : nftsByAddress[nftAddress];
      if ((nft === null || nft === void 0 ? void 0 : nft.collectionAddress) === src_config/* MTW_CARDS_COLLECTION */.qL) {
        result.push(nft);
      }
      return result;
    }, []);
    if (!nftCards.length) {
      return undefined;
    }
    const colors = await Promise.all(nftCards.map(nft => getAccentColorIndexFromNft(nft)));
    const nftsByColorIndex = colors.reduce((result, colorIndex, i) => {
      if (colorIndex !== undefined) {
        result[colorIndex] = nftCards[i];
      }
      return result;
    }, {});
    const availableAccentColorIds = (0,iteratees/* unique */.Am)((0,iteratees/* compact */.oE)(colors));
    return {
      availableAccentColorIds,
      nftsByColorIndex
    };
  } catch (err) {
    (0,logs/* logDebugError */.SJ)('[getAccentColorsFromNfts]: Error fetching accent colors', err);
    return undefined;
  }
}
;// ./src/assets/settings/settings_air.svg
const settings_air_namespaceObject = __webpack_require__.p + "settings_air.43ce12624d7cd516cd3f.svg";
;// ./src/assets/theme/theme_dark.png
const theme_dark_namespaceObject = __webpack_require__.p + "theme_dark.5de5fe78d9ef16d3bb16.png";
;// ./src/assets/theme/theme_light.png
const theme_light_namespaceObject = __webpack_require__.p + "theme_light.cf5d5bfba2109dad7231.png";
;// ./src/assets/theme/theme_system.png
const theme_system_namespaceObject = __webpack_require__.p + "theme_system.374b66ee35055adafec5.png";
;// ./src/components/settings/SettingsAppearance.tsx




























const SWITCH_THEME_DURATION_MS = 300;
const SWITCH_APPLICATION_DURATION_MS = 300;
const THEME_OPTIONS = [{
  value: 'light',
  name: 'Light',
  icon: theme_light_namespaceObject
}, {
  value: 'system',
  name: 'System',
  icon: theme_system_namespaceObject
}, {
  value: 'dark',
  name: 'Dark',
  icon: theme_dark_namespaceObject
}];
function SettingsAppearance(_ref) {
  let {
    isActive,
    theme,
    animationLevel,
    accentColorIndex,
    nftAddresses,
    nftsByAddress,
    isInsideModal,
    isViewMode,
    isTrayIconEnabled,
    isMintingCardsAvailable,
    isNftBuyingDisabled,
    onTrayIconEnabledToggle,
    handleBackClick
  } = _ref;
  const {
    setTheme,
    setAnimationLevel,
    openMintCardModal,
    installAccentColorFromNft,
    clearAccentColorFromNft,
    showNotification
  } = getActions();
  const lang = hooks_useLang();
  const [isAvailableAccentLoading, setIsAvailableAccentLoading] = useState(false);
  const [availableAccentColorIds, setAvailableAccentColorIds] = useState(MEMO_EMPTY_ARRAY);
  const [nftByColorIndexes, setNftsByColorIndex] = useState({});
  const [isAirVersionEnabled, setIsAirVersionEnabled] = useState(false);
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  const appTheme = hooks_useAppTheme(theme);
  teact_useEffect(() => {
    if (src_config/* IS_CORE_WALLET */.TI6) return;
    void (async () => {
      setIsAvailableAccentLoading(true);
      const result = await getAccentColorsFromNfts(nftAddresses, nftsByAddress);
      if (result) {
        setAvailableAccentColorIds(result.availableAccentColorIds);
        setNftsByColorIndex(result.nftsByColorIndex);
      } else {
        setAvailableAccentColorIds(MEMO_EMPTY_ARRAY);
        setNftsByColorIndex({});
      }
      setIsAvailableAccentLoading(false);
    })();
  }, [nftsByAddress, nftAddresses]);
  const sortedColors = teact_useMemo(() => {
    return ACCENT_COLORS[appTheme].map((color, index) => ({
      color,
      index
    })).sort((a, b) => {
      return Number(!availableAccentColorIds.includes(a.index)) - Number(!availableAccentColorIds.includes(b.index));
    });
  }, [appTheme, availableAccentColorIds]);
  const handleAirVersionSwitch = useLastCallback(async () => {
    setIsAirVersionEnabled(true);
    await (0,schedulers/* pause */.v7)(SWITCH_APPLICATION_DURATION_MS);
    switchToAir();
  });
  const handleThemeChange = useLastCallback(newTheme => {
    document.documentElement.classList.add('no-transitions');
    setTheme({
      theme: newTheme
    });
    switchTheme(newTheme, isInsideModal);
    setTimeout(() => {
      document.documentElement.classList.remove('no-transitions');
    }, SWITCH_THEME_DURATION_MS);
  });
  const handleAnimationLevelToggle = useLastCallback(() => {
    const level = animationLevel === src_config/* ANIMATION_LEVEL_MIN */.dnp ? src_config/* ANIMATION_LEVEL_MAX */.zP3 : src_config/* ANIMATION_LEVEL_MIN */.dnp;
    setAnimationLevel({
      level
    });
    switchAnimationLevel(level);
  });
  function handleAccentColorClick(colorIndex) {
    const isLocked = colorIndex !== undefined ? !availableAccentColorIds.includes(colorIndex) : false;
    if (isLocked) {
      showNotification({
        message: lang('Get a unique MyTonWallet Card to unlock new palettes.')
      });
    } else if (colorIndex === undefined) {
      clearAccentColorFromNft();
    } else {
      installAccentColorFromNft({
        nft: nftByColorIndexes[colorIndex]
      });
    }
  }
  const handleUnlockNewPalettesClick = useLastCallback(() => {
    if (!isViewMode && isMintingCardsAvailable) {
      openMintCardModal();
    } else {
      void openUrl(src_config/* MTW_CARDS_WEBSITE */.b2d);
    }
  });
  function renderAirSwitcher() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleAirVersionSwitch
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_air_namespaceObject,
      alt: "",
      "aria-hidden": true
    }), "MyTonWallet Air", /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: "MyTonWallet Air",
      checked: isAirVersionEnabled
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('$try_new_air_version')));
  }
  function renderThemes() {
    return THEME_OPTIONS.map(_ref2 => {
      let {
        name,
        value,
        icon
      } = _ref2;
      return /*#__PURE__*/teact.createElement("div", {
        key: value,
        className: buildClassName(Settings_module.theme, value === theme && Settings_module.theme_active),
        onClick: () => handleThemeChange(value)
      }, /*#__PURE__*/teact.createElement("div", {
        className: buildClassName(Settings_module.themeIcon, value === theme && Settings_module.themeIcon_active)
      }, /*#__PURE__*/teact.createElement("img", {
        src: icon,
        alt: "",
        className: Settings_module.themeImg,
        "aria-hidden": true
      })), /*#__PURE__*/teact.createElement("span", null, lang(name)));
    });
  }
  function renderColorButton(color, index) {
    const isSelected = accentColorIndex === index;
    const isLocked = index !== undefined ? !availableAccentColorIds.includes(index) : false;
    return /*#__PURE__*/teact.createElement("button", {
      key: color || 'default',
      type: "button",
      disabled: isSelected,
      style: color ? `--current-accent-color: ${color}` : undefined,
      className: buildClassName(Settings_module.colorButton, isSelected && Settings_module.colorButtonCurrent),
      "aria-label": lang('Change Palette'),
      onClick: () => handleAccentColorClick(index)
    }, isAvailableAccentLoading && isLocked && /*#__PURE__*/teact.createElement(ui_Spinner, {
      color: "white"
    }), !isAvailableAccentLoading && isLocked && /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconLock, 'icon-lock', color === '#FFFFFF' && Settings_module.iconLockInverted),
      "aria-hidden": true
    }));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Appearance'),
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Appearance'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll
  }, src_config/* IS_CAPACITOR */.UMQ && renderAirSwitcher(), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('Theme')), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.themeWrapper
  }, renderThemes())), !src_config/* IS_CORE_WALLET */.TI6 && !isNftBuyingDisabled && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('Palette')), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.colorList
  }, renderColorButton(), sortedColors.map(_ref3 => {
    let {
      color,
      index
    } = _ref3;
    return renderColorButton(color, index);
  })), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.subBlockAsButton,
    role: "button",
    tabIndex: 0,
    onClick: () => handleUnlockNewPalettesClick()
  }, lang('Unlock New Palettes'))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockDescription
  }, lang('Get a unique MyTonWallet Card to unlock new palettes.'))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('Other')), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleAnimationLevelToggle
  }, lang('Enable Animations'), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Enable Animations'),
    checked: animationLevel !== src_config/* ANIMATION_LEVEL_MIN */.dnp
  })), windowEnvironment/* IS_ELECTRON */.cp && windowEnvironment/* IS_WINDOWS */.H8 && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: onTrayIconEnabledToggle
  }, lang('Display Tray Icon'), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Display Tray Icon'),
    checked: isTrayIconEnabled
  })))));
}
/* harmony default export */ const settings_SettingsAppearance = (memo(withGlobal(global => {
  var _selectCurrentAccount, _selectCurrentAccount2;
  const {
    orderedAddresses: nftAddresses,
    byAddress: nftsByAddress
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) || {};
  const {
    config: {
      cardsInfo
    } = {}
  } = selectCurrentAccountState(global) || {};
  return {
    isViewMode: selectIsCurrentAccountViewMode(global),
    accentColorIndex: (_selectCurrentAccount2 = selectCurrentAccountSettings(global)) === null || _selectCurrentAccount2 === void 0 ? void 0 : _selectCurrentAccount2.accentColorIndex,
    nftAddresses,
    nftsByAddress,
    isMintingCardsAvailable: Boolean(cardsInfo),
    isNftBuyingDisabled: global.restrictions.isNftBuyingDisabled
  };
})(SettingsAppearance)));
;// ./src/components/main/modals/DeleteTokenModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const DeleteTokenModal_module = ({"content":"DeleteTokenModal-module__content","description":"DeleteTokenModal-module__description"});
;// ./src/components/main/modals/DeleteTokenModal.tsx









function DeleteTokenModal(_ref) {
  let {
    token
  } = _ref;
  const {
    deleteToken
  } = getActions();
  const [isOpen, setIsOpen] = useState(false);
  const lang = hooks_useLang();
  useSyncEffect(() => {
    if (token) {
      setIsOpen(true);
    }
  }, [token]);
  const handleClose = useLastCallback(() => {
    setIsOpen(false);
  });
  const handleDeleteToken = useLastCallback(() => {
    handleClose();
    deleteToken({
      slug: token.slug
    });
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    isCompact: true,
    onClose: handleClose,
    title: lang('Delete Token'),
    contentClassName: DeleteTokenModal_module.content
  }, /*#__PURE__*/teact.createElement("p", {
    className: DeleteTokenModal_module.description
  }, lang('Are you sure you want to delete?', {
    token: /*#__PURE__*/teact.createElement("strong", null, token === null || token === void 0 ? void 0 : token.name)
  })), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: handleClose,
    className: Modal_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    onClick: handleDeleteToken,
    className: Modal_module.button
  }, lang('Delete'))));
}
/* harmony default export */ const modals_DeleteTokenModal = (memo(DeleteTokenModal));
;// ./src/components/ui/Draggable.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Draggable_module = ({"container":"Draggable-module__container","isDragging":"Draggable-module__isDragging","knob":"Draggable-module__knob"});
;// ./src/components/ui/Draggable.tsx









const ZERO_POINT = {
  x: 0,
  y: 0
};
const DEFAULT_OFFSET = {
  top: 0,
  bottom: 0,
  left: 0,
  right: 0
};
const EDGE_THRESHOLD = 150;
function Draggable(_ref) {
  let {
    children,
    id,
    onDrag,
    onDragEnd,
    style: externalStyle,
    knobStyle,
    isDisabled,
    offset = DEFAULT_OFFSET,
    parentRef,
    scrollRef,
    className,
    onClick
  } = _ref;
  const lang = hooks_useLang();
  const ref = teact_useRef();
  const buttonRef = teact_useRef();
  const scrollIntervalId = teact_useRef();
  const [state, setState] = useState({
    isDragging: false,
    scrollTop: 0,
    origin: ZERO_POINT,
    translation: ZERO_POINT
  });
  const lastMousePosition = teact_useRef({
    x: 0,
    y: 0
  });
  const updateDraggablePosition = () => {
    if (!state.isDragging || !ref.current || !(parentRef !== null && parentRef !== void 0 && parentRef.current) || !(scrollRef !== null && scrollRef !== void 0 && scrollRef.current)) return;
    const translation = calculateConstrainedTranslation(state, lastMousePosition.current, scrollRef.current.scrollTop, ref.current, parentRef.current, offset);
    setState(current => ({
      ...current,
      translation
    }));
    onDrag(translation, id);
  };
  const stopContinuousScroll = () => {
    if (scrollIntervalId.current !== undefined) {
      cancelAnimationFrame(scrollIntervalId.current);
      scrollIntervalId.current = undefined;
    }
  };
  const startContinuousScroll = (scrollContainer, speed) => {
    const animateScroll = () => {
      scrollContainer.scrollBy(0, speed);
      updateDraggablePosition();
      scrollIntervalId.current = requestAnimationFrame(animateScroll);
    };
    stopContinuousScroll();
    animateScroll();
  };
  const setInitialState = e => {
    var _scrollRef$current, _ref$current, _ref$current2;
    const origin = getClientCoordinate(e);
    const scrollTop = (scrollRef === null || scrollRef === void 0 || (_scrollRef$current = scrollRef.current) === null || _scrollRef$current === void 0 ? void 0 : _scrollRef$current.scrollTop) ?? 0;
    setState({
      ...state,
      isDragging: true,
      origin,
      scrollTop,
      width: (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.offsetWidth,
      height: (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.offsetHeight
    });
  };
  const handleMouseDown = e => {
    setInitialState(e);
  };
  const handleTouchStart = useLastCallback(e => {
    e.stopPropagation();
    e.preventDefault();
    setInitialState(e);
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
      void esm_BottomSheet.clearScrollPatch();
    }
  });
  const handleMouseMove = useLastCallback(e => {
    if (!ref.current || !(parentRef !== null && parentRef !== void 0 && parentRef.current) || !(scrollRef !== null && scrollRef !== void 0 && scrollRef.current)) return;
    const {
      x,
      y
    } = getClientCoordinate(e);
    lastMousePosition.current = {
      x,
      y
    };
    const translation = calculateConstrainedTranslation(state, lastMousePosition.current, scrollRef.current.scrollTop, ref.current, parentRef.current, offset);
    const scrollRect = scrollRef.current.getBoundingClientRect();
    const distanceFromTop = y - scrollRect.top;
    const distanceFromBottom = scrollRect.bottom - y;
    if (distanceFromTop < EDGE_THRESHOLD) {
      startContinuousScroll(scrollRef.current, -scaledEase((EDGE_THRESHOLD - distanceFromTop) / EDGE_THRESHOLD));
    } else if (distanceFromBottom < EDGE_THRESHOLD) {
      startContinuousScroll(scrollRef.current, scaledEase((EDGE_THRESHOLD - distanceFromBottom) / EDGE_THRESHOLD));
    } else {
      stopContinuousScroll();
    }
    setState(current => ({
      ...current,
      translation
    }));
    onDrag(translation, id);
  });
  const handleMouseUp = useLastCallback(() => {
    setState(current => ({
      ...current,
      isDragging: false,
      width: undefined,
      height: undefined
    }));
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
      void esm_BottomSheet.applyScrollPatch();
    }
    onDragEnd();
  });
  const handleClick = useLastCallback(e => {
    if (state.isDragging) {
      return;
    }
    onClick(e);
  });
  teact_useEffect(() => {
    const dragButtonRef = buttonRef.current;
    if (dragButtonRef) {
      dragButtonRef.addEventListener('touchstart', handleTouchStart, {
        passive: false
      });
    }
    if (state.isDragging) {
      window.addEventListener('touchmove', handleMouseMove);
      window.addEventListener('mousemove', handleMouseMove);
      window.addEventListener('touchend', handleMouseUp);
      window.addEventListener('touchcancel', handleMouseUp);
      window.addEventListener('mouseup', handleMouseUp);
    } else {
      stopContinuousScroll();
      window.removeEventListener('touchmove', handleMouseMove);
      window.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('touchend', handleMouseUp);
      window.removeEventListener('touchcancel', handleMouseUp);
      window.removeEventListener('mouseup', handleMouseUp);
      setState(current => ({
        ...current,
        translation: ZERO_POINT
      }));
    }
    return () => {
      if (state.isDragging) {
        stopContinuousScroll();
        window.removeEventListener('touchmove', handleMouseMove);
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('touchend', handleMouseUp);
        window.removeEventListener('touchcancel', handleMouseUp);
        window.removeEventListener('mouseup', handleMouseUp);
        if (dragButtonRef) {
          dragButtonRef.removeEventListener('touchstart', handleTouchStart);
        }
      }
    };
  }, [handleMouseMove, handleMouseUp, handleTouchStart, state.isDragging, buttonRef, isDisabled]);
  const fullClassName = buildClassName(Draggable_module.container, className, state.isDragging && Draggable_module.isDragging);
  const cssStyles = teact_useMemo(() => {
    return buildStyle(state.isDragging && `transform: translate(${state.translation.x}px, ${state.translation.y}px)`, state.width ? `width: ${state.width}px` : undefined, state.height ? `height: ${state.height}px` : undefined, externalStyle);
  }, [externalStyle, state.height, state.isDragging, state.translation.x, state.translation.y, state.width]);
  return /*#__PURE__*/teact.createElement("div", {
    style: cssStyles,
    className: fullClassName,
    ref: ref,
    onClick: handleClick
  }, !isDisabled && /*#__PURE__*/teact.createElement("div", {
    ref: buttonRef,
    "aria-label": lang('i18n_dragToSort'),
    tabIndex: 0,
    role: "button",
    className: buildClassName(Draggable_module.knob, 'div-button', 'draggable-knob'),
    onMouseDown: handleMouseDown,
    style: knobStyle
  }, /*#__PURE__*/teact.createElement("i", {
    className: "icon icon-sort",
    "aria-hidden": true
  })), children);
}
/* harmony default export */ const ui_Draggable = (memo(Draggable));
function getClientCoordinate(e) {
  let x;
  let y;
  if ('touches' in e) {
    x = e.touches[0].clientX;
    y = e.touches[0].clientY;
  } else {
    x = e.clientX;
    y = e.clientY;
  }
  return {
    x,
    y
  };
}
function scaledEase(n) {
  return 5 * n ** 3 + 1;
}
function calculateConstrainedTranslation(state, lastMousePosition, lastScrollTop, draggableElement, parentElement, offset) {
  const translation = {
    x: lastMousePosition.x - state.origin.x,
    y: lastMousePosition.y - state.origin.y + lastScrollTop - state.scrollTop
  };
  const {
    top = 0,
    right = 0,
    bottom = 0,
    left = 0
  } = offset;
  const parentRect = parentElement.getBoundingClientRect();
  const draggableRect = draggableElement.getBoundingClientRect();
  const minX = -draggableElement.offsetLeft + left;
  const maxX = parentRect.width - draggableRect.width - draggableElement.offsetLeft + right;
  const minY = -draggableElement.offsetTop + top;
  const maxY = parentRect.height - draggableRect.height - draggableElement.offsetTop + bottom;
  return {
    x: clamp(translation.x, minX, maxX),
    y: clamp(translation.y, minY, maxY)
  };
}
;// ./src/components/settings/SettingsTokens.tsx



















const TOKEN_HEIGHT_PX = 64;
const TOP_OFFSET = 48;
function SettingsTokens(_ref) {
  let {
    parentContainer,
    tokens,
    orderedSlugs,
    isSortByValueEnabled,
    baseCurrency,
    withChainIcon,
    isSensitiveDataHidden
  } = _ref;
  const {
    openSettingsWithState,
    updateOrderedSlugs,
    rebuildOrderedSlugs,
    toggleTokenVisibility
  } = getActions();
  const lang = hooks_useLang();
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  const tokensRef = teact_useRef();
  const sortableContainerRef = teact_useRef();
  const [tokenToDelete, setTokenToDelete] = useState();
  const [state, setState] = useState({
    orderedTokenSlugs: orderedSlugs,
    dragOrderTokenSlugs: orderedSlugs,
    draggedIndex: undefined
  });
  hooks_useEffectOnce(() => {
    rebuildOrderedSlugs();
  });
  teact_useEffect(() => {
    if (!arraysAreEqual(orderedSlugs, state.orderedTokenSlugs)) {
      setState({
        orderedTokenSlugs: orderedSlugs,
        dragOrderTokenSlugs: orderedSlugs,
        draggedIndex: undefined
      });
    }
  }, [orderedSlugs, state.orderedTokenSlugs]);
  const handleOpenAddTokenPage = useLastCallback(() => {
    openSettingsWithState({
      state: SettingsState.SelectTokenList
    });
  });
  const handleDrag = useLastCallback((translation, id) => {
    var _state$orderedTokenSl, _state$orderedTokenSl2;
    const delta = Math.round(translation.y / TOKEN_HEIGHT_PX);
    const index = ((_state$orderedTokenSl = state.orderedTokenSlugs) === null || _state$orderedTokenSl === void 0 ? void 0 : _state$orderedTokenSl.indexOf(id)) ?? 0;
    const dragOrderTokenSlugs = (_state$orderedTokenSl2 = state.orderedTokenSlugs) === null || _state$orderedTokenSl2 === void 0 ? void 0 : _state$orderedTokenSl2.filter(tokenSlug => tokenSlug !== id);
    if (!dragOrderTokenSlugs || !isBetween(index + delta, 0, (orderedSlugs === null || orderedSlugs === void 0 ? void 0 : orderedSlugs.length) ?? 0)) {
      return;
    }
    dragOrderTokenSlugs.splice(index + delta, 0, id);
    setState(current => ({
      ...current,
      draggedIndex: index,
      dragOrderTokenSlugs
    }));
  });
  const handleDragEnd = useLastCallback(() => {
    setState(current => {
      updateOrderedSlugs({
        orderedSlugs: current.dragOrderTokenSlugs
      });
      return {
        ...current,
        orderedTokenSlugs: current.dragOrderTokenSlugs,
        draggedIndex: undefined
      };
    });
  });
  const handleTokenVisibility = useLastCallback((token, e) => {
    e.preventDefault();
    e.stopPropagation();
    toggleTokenVisibility({
      slug: token.slug,
      shouldShow: Boolean(token.isDisabled)
    });
  });
  const handleDeleteToken = useLastCallback((token, e) => {
    e.stopPropagation();
    setTokenToDelete(token);
  });
  function renderToken(token, index) {
    const {
      symbol,
      name,
      amount,
      price,
      slug,
      isDisabled
    } = token;
    const totalAmount = (0,bigint/* bigintMultiplyToNumber */.m1)(amount, price);
    const isDragged = state.draggedIndex === index;
    const draggedTop = isSortByValueEnabled ? getOffsetByIndex(index) : getOffsetBySlug(slug, state.orderedTokenSlugs);
    const top = isSortByValueEnabled ? getOffsetByIndex(index) : getOffsetBySlug(slug, state.dragOrderTokenSlugs);
    const style = `top: ${isDragged ? draggedTop : top}px;`;
    const knobStyle = 'left: 1rem;';
    const isDeleteButtonVisible = amount === 0n && !src_config/* DEFAULT_ENABLED_TOKEN_SLUGS */.Fgn.includes(slug);
    const isDragDisabled = isSortByValueEnabled || tokens.length <= 1;
    return /*#__PURE__*/teact.createElement(ui_Draggable, {
      key: slug,
      id: slug,
      onDrag: handleDrag,
      onDragEnd: handleDragEnd,
      style: style,
      knobStyle: knobStyle,
      isDisabled: isDragDisabled,
      className: buildClassName(Settings_module.item, Settings_module.item_token, !isSortByValueEnabled && Settings_module.draggable),
      offset: {
        top: TOP_OFFSET
      },
      parentRef: tokensRef,
      scrollRef: parentContainer,
      onClick: e => handleTokenVisibility(token, e)
    }, /*#__PURE__*/teact.createElement(common_TokenIcon, {
      token: token,
      withChainIcon: withChainIcon
    }), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.tokenInfo
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.tokenTitle
    }, name), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.tokenDescription
    }, /*#__PURE__*/teact.createElement(ui_SensitiveData, {
      isActive: isSensitiveDataHidden,
      cols: 4 + top % 6,
      rows: 2,
      cellSize: 8,
      contentClassName: Settings_module.tokenAmount
    }, /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency((0,util_decimals/* toDecimal */.nI)(totalAmount, token.decimals, true), shortBaseSymbol)
    }), /*#__PURE__*/teact.createElement("i", {
      className: Settings_module.dot,
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement(ui_AnimatedCounter, {
      text: formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, token.decimals), symbol)
    })), isDeleteButtonVisible && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("i", {
      className: Settings_module.dot,
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", {
      className: Settings_module.deleteText,
      onClick: e => handleDeleteToken(token, e)
    }, lang('Delete'))))), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      checked: !isDisabled
    }));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('My Tokens')), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.contentRelative,
    ref: sortableContainerRef
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.settingsBlock, Settings_module.sortableContainer),
    style: `height: ${((tokens === null || tokens === void 0 ? void 0 : tokens.length) ?? 0) * TOKEN_HEIGHT_PX + TOP_OFFSET}px`,
    ref: tokensRef
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleOpenAddTokenPage
  }, lang('Add Token'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })), tokens === null || tokens === void 0 ? void 0 : tokens.map(renderToken))), /*#__PURE__*/teact.createElement(modals_DeleteTokenModal, {
    token: tokenToDelete
  }));
}
function arraysAreEqual() {
  let arr1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let arr2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}
function getOffsetBySlug(slug) {
  let list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  const realIndex = list.indexOf(slug);
  const index = realIndex === -1 ? list.length : realIndex;
  return getOffsetByIndex(index);
}
function getOffsetByIndex(index) {
  return index * TOKEN_HEIGHT_PX + TOP_OFFSET;
}
/* harmony default export */ const settings_SettingsTokens = (memo(SettingsTokens));
;// ./src/components/settings/SettingsAssets.tsx


















function SettingsAssets(_ref) {
  let {
    isActive,
    isInsideModal,
    isInvestorViewEnabled,
    isSortByValueEnabled,
    isSensitiveDataHidden,
    areTinyTransfersHidden,
    areTokensWithNoCostHidden,
    baseCurrency,
    isMultichainAccount,
    tokens,
    orderedSlugs,
    nftsByAddress,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    onBack
  } = _ref;
  const {
    toggleTinyTransfersHidden,
    toggleInvestorView,
    toggleTokensWithNoCost,
    toggleSortByValue,
    changeBaseCurrency,
    setSettingsState
  } = getActions();
  const lang = hooks_useLang();
  const scrollContainerRef = teact_useRef();
  useHistoryBack({
    isActive,
    onBack
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  const currencyItems = teact_useMemo(() => Object.entries(src_config/* CURRENCIES */.yR2).map(_ref2 => {
    let [currency, {
      name
    }] = _ref2;
    return {
      value: currency,
      name
    };
  }), []);
  const handleTinyTransfersHiddenToggle = useLastCallback(() => {
    toggleTinyTransfersHidden({
      isEnabled: !areTinyTransfersHidden
    });
  });
  const handleInvestorViewToggle = useLastCallback(() => {
    toggleInvestorView({
      isEnabled: !isInvestorViewEnabled
    });
  });
  const handleOpenHiddenNfts = useLastCallback(() => {
    setSettingsState({
      state: SettingsState.HiddenNfts
    });
  });
  const handleTokensWithNoPriceToggle = useLastCallback(() => {
    toggleTokensWithNoCost({
      isEnabled: !areTokensWithNoCostHidden
    });
  });
  const handleSortByValueToggle = useLastCallback(() => {
    toggleSortByValue({
      isEnabled: !isSortByValueEnabled
    });
  });
  const [localBaseCurrency, setLocalBaseCurrency] = useState(baseCurrency);
  const handleBaseCurrencyChange = useLastCallback(currency => {
    setLocalBaseCurrency(currency);
    changeBaseCurrency({
      currency
    });
  });
  const {
    shouldRenderHiddenNftsSection,
    hiddenNftsCount
  } = teact_useMemo(() => {
    const nfts = Object.values(nftsByAddress || {});
    const blacklistedAddressesSet = new Set(blacklistedNftAddresses);
    const whitelistedAddressesSet = new Set(whitelistedNftAddresses);
    const shouldRender = nfts.some(nft => blacklistedAddressesSet.has(nft.address) || nft.isHidden);
    const hiddenNfts = nfts.filter(nft => !whitelistedAddressesSet.has(nft.address) && (blacklistedAddressesSet.has(nft.address) || nft.isHidden));
    return {
      shouldRenderHiddenNftsSection: shouldRender,
      hiddenNftsCount: hiddenNfts.length
    };
  }, [nftsByAddress, blacklistedNftAddresses, whitelistedNftAddresses]);
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Assets & Activity'),
    withNotch: isScrolled,
    onBackButtonClick: onBack,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: onBack,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Assets & Activity'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll,
    ref: scrollContainerRef
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement(ui_Dropdown, {
    label: lang('Base Currency'),
    items: currencyItems,
    selectedValue: baseCurrency ?? src_config/* DEFAULT_PRICE_CURRENCY */.wOb,
    theme: "light",
    shouldTranslateOptions: true,
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onChange: handleBaseCurrencyChange,
    isLoading: localBaseCurrency !== baseCurrency
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleInvestorViewToggle
  }, /*#__PURE__*/teact.createElement("div", null, lang('Investor View'), ' ', /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
    message: lang('Focus on asset value rather than current balance'),
    iconClassName: Settings_module.iconQuestion
  })), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Investor View'),
    checked: isInvestorViewEnabled
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleTinyTransfersHiddenToggle
  }, /*#__PURE__*/teact.createElement("div", null, lang('Hide Tiny Transfers'), ' ', /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
    message: lang('$tiny_transfers_help', {
      value: src_config/* TINY_TRANSFER_MAX_COST */.Wvq
    }),
    tooltipClassName: buildClassName(Settings_module.wideTooltip),
    iconClassName: Settings_module.iconQuestion
  })), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Hide Tiny Transfers'),
    checked: areTinyTransfersHidden
  }))), shouldRenderHiddenNftsSection && /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleOpenHiddenNfts
  }, lang('Hidden NFTs'), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.itemInfo
  }, hiddenNftsCount, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  })))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('Token Settings')), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleSortByValueToggle
  }, lang('Sort By Cost'), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Sort By Cost'),
    checked: isSortByValueEnabled
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleTokensWithNoPriceToggle
  }, /*#__PURE__*/teact.createElement("div", null, lang('Hide Tokens With No Cost'), ' ', /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
    message: lang('$hide_tokens_no_cost_help', {
      value: src_config/* TINY_TRANSFER_MAX_COST */.Wvq
    }),
    tooltipClassName: buildClassName(Settings_module.wideTooltip),
    iconClassName: Settings_module.iconQuestion
  })), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Hide Tokens With No Cost'),
    checked: areTokensWithNoCostHidden
  }))), /*#__PURE__*/teact.createElement(settings_SettingsTokens, {
    isSensitiveDataHidden: isSensitiveDataHidden,
    parentContainer: scrollContainerRef,
    tokens: tokens,
    orderedSlugs: orderedSlugs,
    isSortByValueEnabled: isSortByValueEnabled,
    baseCurrency: baseCurrency,
    withChainIcon: isMultichainAccount
  })));
}
/* harmony default export */ const settings_SettingsAssets = (memo(withGlobal(global => {
  const {
    isInvestorViewEnabled,
    isSortByValueEnabled,
    areTinyTransfersHidden,
    areTokensWithNoCostHidden,
    baseCurrency,
    isSensitiveDataHidden
  } = global.settings;
  const {
    orderedSlugs
  } = selectCurrentAccountSettings(global) ?? {};
  const {
    blacklistedNftAddresses = MEMO_EMPTY_ARRAY,
    whitelistedNftAddresses = MEMO_EMPTY_ARRAY,
    nfts: {
      byAddress: nftsByAddress
    } = {}
  } = selectCurrentAccountState(global) || {};
  return {
    isInvestorViewEnabled,
    isSortByValueEnabled,
    areTinyTransfersHidden,
    areTokensWithNoCostHidden,
    baseCurrency,
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId),
    tokens: selectCurrentAccountTokens(global),
    orderedSlugs,
    nftsByAddress,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    isSensitiveDataHidden
  };
})(SettingsAssets)));
;// ./src/components/main/modals/DisconnectDappModal.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const DisconnectDappModal_module = ({"content":"DisconnectDappModal-module__content","description":"DisconnectDappModal-module__description","buttons":"DisconnectDappModal-module__buttons","button":"DisconnectDappModal-module__button"});
;// ./src/components/main/modals/DisconnectDappModal.tsx








function DisconnectDappModal(_ref) {
  let {
    isOpen,
    dapp,
    onClose
  } = _ref;
  const {
    deleteAllDapps,
    deleteDapp
  } = getActions();
  const lang = hooks_useLang();
  const handleDeleteAllDapps = useLastCallback(() => {
    void deleteAllDapps();
    onClose();
  });
  const handleDeleteDapp = useLastCallback(() => {
    void deleteDapp({
      url: dapp.url,
      uniqueId: getDappConnectionUniqueId(dapp)
    });
    onClose();
  });
  const title = dapp ? lang('Disconnect Dapp') : lang('Disconnect Dapps');
  const description = dapp ? lang('Are you sure you want to disconnect?', {
    dappname: /*#__PURE__*/teact.createElement("strong", null, dapp.name)
  }) : lang('Are you sure you want to disconnect all websites?');
  const onDisconnect = dapp ? handleDeleteDapp : handleDeleteAllDapps;
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    isCompact: true,
    onClose: onClose,
    title: title,
    contentClassName: DisconnectDappModal_module.content
  }, /*#__PURE__*/teact.createElement("p", {
    className: DisconnectDappModal_module.description
  }, description), /*#__PURE__*/teact.createElement("div", {
    className: DisconnectDappModal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    className: DisconnectDappModal_module.button
  }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
    isDestructive: true,
    onClick: onDisconnect,
    className: DisconnectDappModal_module.button
  }, lang('Disconnect'))));
}
/* harmony default export */ const modals_DisconnectDappModal = (memo(DisconnectDappModal));
;// ./src/components/settings/SettingsDapps.tsx

















function SettingsDapps(_ref) {
  let {
    isActive,
    dapps,
    handleBackClick,
    isInsideModal
  } = _ref;
  const lang = hooks_useLang();
  const [isDisconnectModalOpen, openDisconnectModal, closeDisconnectModal] = hooks_useFlag();
  const [dappToDelete, setDappToDelete] = useState();
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  const handleDisconnectDapp = useLastCallback(url => {
    const dapp = dapps.find(d => d.url === url);
    setDappToDelete(dapp);
    openDisconnectModal();
  });
  const handleDisconnectAll = useLastCallback(() => {
    setDappToDelete(undefined);
    openDisconnectModal();
  });
  function renderDapps() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.dapps
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.disconnectAllBlock
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Settings_module.disconnectButton,
      isSimple: true,
      onClick: handleDisconnectAll
    }, lang('Disconnect All Dapps')), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('$dapps-description', {
      app_name: src_config/* APP_NAME */.C39
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockTitle
    }, lang('Logged in with %app_name%', {
      app_name: src_config/* APP_NAME */.C39
    })), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, dapps.map(dapp => /*#__PURE__*/teact.createElement(dapps_DappInfo, {
      key: `dapp-${dapp.url}-${getDappConnectionUniqueId(dapp)}`,
      dapp: dapp,
      className: Settings_module.dapp,
      onDisconnect: handleDisconnectDapp
    }))));
  }
  function renderEmptyDappsMessage(isPlaying) {
    return /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.emptyList
    }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: isPlaying,
      tgsUrl: ANIMATED_STICKERS_PATHS.noData,
      previewUrl: ANIMATED_STICKERS_PATHS.noDataPreview,
      size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
      noLoop: false,
      nonInteractive: true
    }), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.emptyListTitle
    }, lang('No active connections')));
  }
  const content = dapps.length === 0 ? renderEmptyDappsMessage(isActive) : renderDapps();
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Dapps'),
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Dapps'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    activeKey: dapps.length === 0 ? 0 : 1,
    name: "fade"
  }, content)), /*#__PURE__*/teact.createElement(modals_DisconnectDappModal, {
    isOpen: isDisconnectModalOpen,
    onClose: closeDisconnectModal,
    dapp: dappToDelete
  }));
}
/* harmony default export */ const settings_SettingsDapps = (memo(SettingsDapps));
;// ./src/util/getBuildPlatform.ts



function getBuildPlatform() {
  if (src_config/* IS_FIREFOX_EXTENSION */.v5B) return 'firefox-extension';
  if (src_config/* IS_OPERA_EXTENSION */.RTV) return 'opera-extension';
  if (src_config/* IS_EXTENSION */.hL1) return 'extension';
  if (src_config/* IS_CAPACITOR */.UMQ) {
    if (src_config/* IS_AIR_APP */.gmk) {
      if (windowEnvironment/* IS_IOS */.pz) return 'ios-air';
      if (src_config/* IS_ANDROID_DIRECT */.VL7) return 'android-air-direct';
      if (windowEnvironment/* IS_ANDROID */.Ni) return 'android-air';
    }
    if (src_config/* IS_ANDROID_DIRECT */.VL7) return 'android-direct';
    if (windowEnvironment/* IS_ANDROID */.Ni) return 'android';
    if (windowEnvironment/* IS_IOS */.pz) return 'ios';
  }
  if (src_config/* IS_TELEGRAM_APP */.tKX) {
    var _getTelegramApp;
    return ((_getTelegramApp = telegram_getTelegramApp()) === null || _getTelegramApp === void 0 ? void 0 : _getTelegramApp.platform) || 'telegram-unknown';
  }
  if (windowEnvironment/* IS_ELECTRON */.cp) return 'electron';
  return 'web';
}
function getFlagsValue() {
  return {
    IS_ANDROID_DIRECT: src_config/* IS_ANDROID_DIRECT */.VL7,
    IS_CAPACITOR: src_config/* IS_CAPACITOR */.UMQ,
    IS_TELEGRAM_APP: src_config/* IS_TELEGRAM_APP */.tKX,
    IS_EXTENSION: src_config/* IS_EXTENSION */.hL1,
    IS_FIREFOX_EXTENSION: src_config/* IS_FIREFOX_EXTENSION */.v5B,
    IS_PACKAGED_ELECTRON: src_config/* IS_PACKAGED_ELECTRON */.jht,
    IS_AIR_APP: src_config/* IS_AIR_APP */.gmk,
    IS_ELECTRON: windowEnvironment/* IS_ELECTRON */.cp,
    IS_OPERA_EXTENSION: src_config/* IS_OPERA_EXTENSION */.RTV
  };
}
// EXTERNAL MODULE: ./src/util/getPlatform.ts
var util_getPlatform = __webpack_require__(36791);
;// ./src/components/settings/SettingsDeveloperOptions.tsx



















const NETWORK_OPTIONS = [{
  value: 'mainnet',
  name: 'Mainnet'
}, {
  value: 'testnet',
  name: 'Testnet'
}];

// iOS allows downloading files even in TMA, however, in other platforms,
// downloading files from `blob:https://` schemes is limited by Telegram itself.
// Also, file downloading is limited in extensions.
const CAN_DOWNLOAD_LOGS = windowEnvironment/* IS_IOS */.pz || !(src_config/* IS_EXTENSION */.hL1 || src_config/* IS_TELEGRAM_APP */.tKX);
function SettingsDeveloperOptions(_ref) {
  let {
    isOpen,
    isTestnet,
    isCopyStorageEnabled,
    onShowAllWalletVersions,
    onClose,
    currentAccountId,
    accountsById,
    canViewAllWalletVersions
  } = _ref;
  const {
    startChangingNetwork,
    closeSettings,
    openAddAccountModal,
    copyStorageData,
    showNotification
  } = getActions();
  const lang = hooks_useLang();
  const currentNetwork = NETWORK_OPTIONS[isTestnet ? 1 : 0].value;
  const handleNetworkChange = useLastCallback(newNetwork => {
    startChangingNetwork({
      network: newNetwork
    });
    onClose();
  });
  const handleAddTonOnlyWallet = useLastCallback(() => {
    onClose();
    closeSettings();
    openAddAccountModal({
      forceAddingTonOnlyAccount: true
    });
  });
  const handleDownloadLogs = useLastCallback(async () => {
    const logsString = await getLogsString({
      currentAccountId,
      accountsById
    });
    if (!CAN_DOWNLOAD_LOGS) {
      await copyTextToClipboard(logsString);
      showNotification({
        message: lang('Logs were copied!'),
        icon: 'icon-copy'
      });
      onClose();
    } else {
      const filename = `${src_config/* IS_CORE_WALLET */.TI6 ? 'tonwallet' : 'mytonwallet'}_logs_${new Date().toISOString()}.json`;
      await shareFile(filename, logsString, 'application/json');
    }
  });
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    onClose: onClose,
    noBackdropClose: true,
    isCompact: true,
    title: lang('Developer Options')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement(ui_Dropdown, {
    label: lang('Network'),
    items: NETWORK_OPTIONS,
    selectedValue: currentNetwork,
    theme: "light",
    arrow: "chevron",
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onChange: handleNetworkChange
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleAddTonOnlyWallet
  }, lang('Create TON-Only Wallet'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-plus'),
    "aria-hidden": true
  })), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small, !canViewAllWalletVersions && Settings_module.item_disabled),
    onClick: onShowAllWalletVersions
  }, lang('All Wallet Versions'), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.itemInfo
  }, canViewAllWalletVersions ? /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  }) : /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.small
  }, lang('Multichain')), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-lock'),
    "aria-hidden": true
  }))))), isCopyStorageEnabled && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('Dangerous')), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: () => copyStorageData()
  }, lang('Copy Storage Data'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-copy'),
    "aria-hidden": true
  })))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.settingsBlock)
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleDownloadLogs
  }, !CAN_DOWNLOAD_LOGS ? /*#__PURE__*/teact.createElement(teact.Fragment, null, lang('Copy Logs'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-copy'),
    "aria-hidden": true
  })) : lang('Download Logs'))), /*#__PURE__*/teact.createElement(ui_Button, {
    className: Settings_module.developerCloseButton,
    onClick: onClose
  }, lang('Close')));
}
/* harmony default export */ const settings_SettingsDeveloperOptions = (memo(withGlobal(global => {
  var _global$accounts;
  const currentAccountId = global.currentAccountId;
  const accountsById = (_global$accounts = global.accounts) === null || _global$accounts === void 0 ? void 0 : _global$accounts.byId;
  const canViewAllWalletVersions = !selectIsMultichainAccount(global, currentAccountId);
  return {
    currentAccountId,
    accountsById,
    canViewAllWalletVersions
  };
})(SettingsDeveloperOptions)));
async function getLogsString(_ref2) {
  let {
    currentAccountId,
    accountsById
  } = _ref2;
  const accountsInfo = accountsById && Object.keys(accountsById).reduce((acc, accountId) => {
    const {
      addressByChain,
      type
    } = accountsById[accountId];
    acc[accountId] = {
      type,
      addressByChain
    };
    return acc;
  }, {});
  const [mainLogs, bottomSheetLogs, apiLogs = []] = await Promise.all([(0,logs/* getLogs */.ao)(), getLogsFromNative(), (0,api/* callApi */.p)('getLogs')]);
  const time = new Date();
  const timezoneOffset = -time.getTimezoneOffset();
  return JSON.stringify({
    time,
    timezone: `UTC${timezoneOffset < 0 ? '-' : '+'}${Math.abs(timezoneOffset) / 60}`,
    environment: src_config/* APP_ENV */.Guj,
    version: src_config/* APP_VERSION */.hl5,
    commit: src_config/* APP_COMMIT_HASH */.rFA,
    platform: (0,util_getPlatform/* getPlatform */.u)(),
    navigatorPlatform: navigator.platform,
    userAgent: navigator.userAgent,
    build: getBuildPlatform(),
    flags: getFlagsValue(),
    currentAccountId,
    accountsInfo,
    logs: [...mainLogs.map(log => ({
      ...log,
      context: 'main'
    })), ...bottomSheetLogs.map(log => ({
      ...log,
      context: 'bottomSheet'
    })), ...apiLogs.map(log => ({
      ...log,
      context: 'api'
    }))].sort((a, b) => a.time - b.time).map(log => ({
      ...log,
      time: new Date(log.time).toISOString()
    }))
  }, undefined, 2);
}
;// ./src/components/settings/SettingsDisclaimer.tsx












function SettingsDisclaimer(_ref) {
  let {
    isActive,
    handleBackClick,
    isInsideModal
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: "",
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back')))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, isInsideModal && 'custom-scroll', !isInsideModal && Settings_module.content_noScroll),
    onScroll: isInsideModal ? handleContentScroll : undefined
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.stickerAndTitle
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    tgsUrl: ANIMATED_STICKERS_PATHS.snitch,
    previewUrl: ANIMATED_STICKERS_PATHS.snitchPreview,
    noLoop: false,
    nonInteractive: true,
    size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW
  }), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.sideTitle
  }, lang('Use Responsibly'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.blockAbout, !isInsideModal && 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$auth_responsibly_description1', {
    app_name: src_config/* APP_NAME */.C39
  }))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$auth_responsibly_description2'))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$auth_responsibly_description3', {
    app_name: src_config/* APP_NAME */.C39
  }))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.text
  }, renderText(lang('$auth_responsibly_description4'))))));
}
/* harmony default export */ const settings_SettingsDisclaimer = (memo(SettingsDisclaimer));
;// ./src/components/settings/nfts/HiddenByUserNft.tsx












function HiddenByUserNft(_ref) {
  let {
    nft
  } = _ref;
  const {
    openMediaViewer,
    removeNftSpecialStatus
  } = getActions();
  const lang = hooks_useLang();
  const [isNftHidden,, unmarkNftHidden] = hooks_useFlag(true);
  const handleUnhide = useLastCallback(() => {
    removeNftSpecialStatus({
      address: nft.address
    });
  });
  const {
    ref
  } = useShowTransition({
    isOpen: isNftHidden,
    onCloseAnimationEnd: handleUnhide
  });
  const {
    isPortrait
  } = useDeviceScreen();
  const areSettingsInModal = !isPortrait || windowEnvironment/* IS_ELECTRON */.cp || windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA;
  function handleNftClick() {
    openMediaViewer({
      mediaId: nft.address,
      mediaType: MediaType.Nft,
      noGhostAnimation: areSettingsInModal,
      hiddenNfts: 'user'
    });
  }
  return /*#__PURE__*/teactn.createElement("div", {
    ref: ref,
    className: Settings_module.item,
    onClick: handleNftClick,
    key: nft.address,
    role: "button",
    tabIndex: 0,
    "data-nft-address": !areSettingsInModal && nft.address
  }, /*#__PURE__*/teactn.createElement("img", {
    className: Settings_module.nftImage,
    src: nft.image,
    alt: nft.name
  }), /*#__PURE__*/teactn.createElement("div", {
    className: Settings_module.nftPrimaryCell
  }, /*#__PURE__*/teactn.createElement("span", {
    className: Settings_module.nftName
  }, nft.name || lang('Untitled')), nft.collectionName && /*#__PURE__*/teactn.createElement("span", {
    className: Settings_module.nftCollection
  }, nft.collectionName)), /*#__PURE__*/teactn.createElement(ui_Button, {
    isSmall: true,
    isPrimary: true,
    isText: true,
    className: Settings_module.nftButtonUnhide,
    onClick: unmarkNftHidden,
    shouldStopPropagation: true
  }, lang('Unhide')));
}
/* harmony default export */ const nfts_HiddenByUserNft = (memo(HiddenByUserNft));
;// ./src/components/settings/nfts/ProbablyScamNft.tsx










function ProbablyScamNft(_ref) {
  let {
    nft,
    isWhitelisted
  } = _ref;
  const {
    openMediaViewer,
    removeNftSpecialStatus,
    openUnhideNftModal
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const areSettingsInModal = !isPortrait || windowEnvironment/* IS_ELECTRON */.cp || windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA;
  const handleNftClick = useLastCallback(() => {
    openMediaViewer({
      mediaId: nft.address,
      mediaType: MediaType.Nft,
      noGhostAnimation: areSettingsInModal,
      hiddenNfts: 'scam'
    });
  });
  const handleSwitcherClick = useLastCallback(e => {
    e.stopPropagation();
    if (isWhitelisted) {
      removeNftSpecialStatus({
        address: nft.address
      });
    } else {
      openUnhideNftModal({
        address: nft.address,
        name: nft.name
      });
    }
  });
  return /*#__PURE__*/teactn.createElement("div", {
    className: Settings_module.item,
    onClick: handleNftClick,
    key: nft.address,
    role: "button",
    tabIndex: 0,
    "data-nft-address": !areSettingsInModal && nft.address
  }, /*#__PURE__*/teactn.createElement("img", {
    className: Settings_module.nftImage,
    src: nft.image,
    alt: nft.name
  }), /*#__PURE__*/teactn.createElement("div", {
    className: Settings_module.nftPrimaryCell
  }, /*#__PURE__*/teactn.createElement("span", {
    className: Settings_module.nftName
  }, nft.name), nft.collectionName && /*#__PURE__*/teactn.createElement("span", {
    className: Settings_module.nftCollection
  }, nft.collectionName)), /*#__PURE__*/teactn.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Show'),
    checked: isWhitelisted,
    onChange: handleSwitcherClick,
    shouldStopPropagation: true
  }));
}
/* harmony default export */ const nfts_ProbablyScamNft = (memo(ProbablyScamNft));
;// ./src/components/settings/SettingsHiddenNfts.tsx














function SettingsHiddenNfts(_ref) {
  let {
    isActive,
    handleBackClick,
    isInsideModal,
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    orderedAddresses,
    byAddress
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    isScrolled,
    handleScroll: handleContentScroll
  } = useScrolledState();
  const nfts = teact_useMemo(() => {
    if (!orderedAddresses || !byAddress) {
      return undefined;
    }
    return orderedAddresses.map(address => byAddress[address]).filter(Boolean);
  }, [byAddress, orderedAddresses]);
  const hiddenByUserNfts = teact_useMemo(() => {
    const blacklistedNftAddressesSet = new Set(blacklistedNftAddresses);
    return nfts === null || nfts === void 0 ? void 0 : nfts.filter(nft => blacklistedNftAddressesSet.has(nft.address));
  }, [nfts, blacklistedNftAddresses]);
  const probablyScamNfts = teact_useMemo(() => {
    return nfts === null || nfts === void 0 ? void 0 : nfts.filter(nft => nft.isHidden);
  }, [nfts]);
  const whitelistedNftAddressesSet = teact_useMemo(() => {
    return new Set(whitelistedNftAddresses);
  }, [whitelistedNftAddresses]);
  const {
    isPortrait
  } = useDeviceScreen();
  const areSettingsInModal = !isPortrait || windowEnvironment/* IS_ELECTRON */.cp || windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI || windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA;
  function renderHiddenByUserNfts() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockTitle
    }, lang('Hidden By Me')), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, !areSettingsInModal && 'hidden-nfts-user')
    }, hiddenByUserNfts.map(nft => /*#__PURE__*/teact.createElement(nfts_HiddenByUserNft, {
      key: nft.address,
      nft: nft
    }))));
  }
  function renderProbablyScamNfts() {
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockTitle
    }, lang('Probably Scam')), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription, !areSettingsInModal && 'hidden-nfts-scam')
    }, probablyScamNfts.map(nft => /*#__PURE__*/teact.createElement(nfts_ProbablyScamNft, {
      key: nft.address,
      nft: nft,
      isWhitelisted: whitelistedNftAddressesSet.has(nft.address)
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('$settings_nft_probably_scam_description')));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Hidden NFTs'),
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Hidden NFTs'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll
  }, Boolean(hiddenByUserNfts === null || hiddenByUserNfts === void 0 ? void 0 : hiddenByUserNfts.length) && renderHiddenByUserNfts(), Boolean(probablyScamNfts === null || probablyScamNfts === void 0 ? void 0 : probablyScamNfts.length) && renderProbablyScamNfts()));
}
/* harmony default export */ const settings_SettingsHiddenNfts = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  const {
    blacklistedNftAddresses,
    whitelistedNftAddresses
  } = selectCurrentAccountState(global) ?? {};
  const {
    orderedAddresses,
    byAddress
  } = ((_selectCurrentAccount = selectCurrentAccountState(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.nfts) ?? {};
  return {
    blacklistedNftAddresses,
    whitelistedNftAddresses,
    orderedAddresses,
    byAddress
  };
})(SettingsHiddenNfts)));
;// ./src/assets/settings/settings_checkmark.svg
const settings_checkmark_namespaceObject = __webpack_require__.p + "settings_checkmark.4c62604cbc9fd263c110.svg";
;// ./src/components/settings/SettingsLanguage.tsx












function SettingsLanguage(_ref) {
  let {
    isActive,
    langCode,
    handleBackClick,
    isInsideModal
  } = _ref;
  const {
    changeLanguage
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const handleLanguageChange = useLastCallback(newLangCode => {
    void setLanguage(newLangCode, () => {
      changeLanguage({
        langCode: newLangCode
      });
    });
  });
  function renderLanguages() {
    return src_config/* LANG_LIST */.gSB.map(_ref2 => {
      let {
        name,
        nativeName,
        langCode: lc
      } = _ref2;
      return /*#__PURE__*/teact.createElement("div", {
        key: lc,
        className: buildClassName(Settings_module.item, Settings_module.item_lang),
        onClick: () => handleLanguageChange(lc)
      }, /*#__PURE__*/teact.createElement("div", {
        className: Settings_module.languageInfo
      }, /*#__PURE__*/teact.createElement("span", {
        className: Settings_module.languageMain
      }, name), /*#__PURE__*/teact.createElement("span", {
        className: Settings_module.languageNative
      }, nativeName)), langCode === lc && /*#__PURE__*/teact.createElement("img", {
        src: settings_checkmark_namespaceObject,
        alt: name
      }));
    });
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Language'),
    onBackButtonClick: handleBackClick,
    className: buildClassName(Settings_module.modalHeader, Settings_module.languageHeader)
  }) : /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Language'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.block
  }, renderLanguages())));
}
/* harmony default export */ const settings_SettingsLanguage = (memo(SettingsLanguage));
;// ./src/components/settings/SettingsPushNotifications.tsx

















function SettingsPushNotifications(_ref) {
  let {
    isActive,
    handleBackClick,
    accounts,
    canPlaySounds,
    pushNotifications: {
      enabledAccounts,
      isAvailable: arePushNotificationsAvailable
    },
    isInsideModal,
    settingsByAccountId
  } = _ref;
  const lang = hooks_useLang();
  const {
    toggleNotifications,
    toggleNotificationAccount,
    toggleCanPlaySounds
  } = getActions();
  const iterableAccounts = teact_useMemo(() => Object.entries(accounts || {}), [accounts]);
  const arePushNotificationsEnabled = Boolean(Object.keys(enabledAccounts).length);
  const headerTitle = arePushNotificationsAvailable ? lang('Notifications & Sounds') : lang('Sounds');
  const handlePushNotificationsToggle = useLastCallback(() => {
    toggleNotifications({
      isEnabled: !arePushNotificationsEnabled
    });
  });
  const handleCanPlaySoundToggle = useLastCallback(() => {
    toggleCanPlaySounds({
      isEnabled: !canPlaySounds
    });
  });
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  function renderAccount(accountId, addressByChain, accountType, title) {
    const onClick = !addressByChain.ton ? undefined : () => {
      toggleNotificationAccount({
        accountId
      });
    };
    const {
      cardBackgroundNft
    } = (settingsByAccountId === null || settingsByAccountId === void 0 ? void 0 : settingsByAccountId[accountId]) || {};
    const address = (0,util_account/* getMainAccountAddress */.LG)(addressByChain) ?? '';
    const isDisabled = enabledAccounts && !enabledAccounts[accountId] && isKeyCountGreater(enabledAccounts, src_config/* MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT */.vdF - 1);
    return /*#__PURE__*/teact.createElement(common_AccountButton, {
      className: buildClassName(Settings_module.account, isDisabled ? Settings_module.accountDisabled : undefined),
      key: accountId,
      accountId: accountId,
      address: address,
      title: title,
      ariaLabel: lang('Switch Account'),
      accountType: accountType,
      withCheckbox: true,
      isLoading: isDisabled,
      isActive: Boolean(enabledAccounts && enabledAccounts[accountId]),
      onClick: onClick,
      cardBackgroundNft: cardBackgroundNft
    });
  }
  function renderAccounts() {
    return /*#__PURE__*/teact.createElement(common_AccountButtonWrapper, {
      accountLength: iterableAccounts.length,
      className: Settings_module.settingsBlock
    }, iterableAccounts.map(_ref2 => {
      let [accountId, {
        title,
        addressByChain,
        type
      }] = _ref2;
      return renderAccount(accountId, addressByChain, type, title);
    }));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: headerTitle,
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, headerTitle)), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll
  }, arePushNotificationsAvailable && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handlePushNotificationsToggle
  }, lang('Push Notifications'), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Push Notifications'),
    checked: arePushNotificationsEnabled
  }))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockTitle
  }, lang('Select up to %count% wallets for notifications', {
    count: src_config/* MAX_PUSH_NOTIFICATIONS_ACCOUNT_COUNT */.vdF
  })), renderAccounts()), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.settingsBlock
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item, Settings_module.item_small),
    onClick: handleCanPlaySoundToggle
  }, lang('Play Sounds'), /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: lang('Play Sounds'),
    checked: canPlaySounds
  })))));
}
/* harmony default export */ const settings_SettingsPushNotifications = (memo(withGlobal(global => {
  const accounts = selectNetworkAccounts(global);
  return {
    accounts,
    canPlaySounds: global.settings.canPlaySounds,
    pushNotifications: global.pushNotifications,
    settingsByAccountId: global.settings.byAccountId
  };
})(SettingsPushNotifications)));
;// ./node_modules/capacitor-native-settings/dist/esm/definitions.js
var AndroidSettings;
(function (AndroidSettings) {
    /**
     * Show settings for accessibility modules
     */
    AndroidSettings["Accessibility"] = "accessibility";
    /**
     * Show add account screen for creating a new account
     */
    AndroidSettings["Account"] = "account";
    /**
     * Show settings to allow entering/exiting airplane mode
     */
    AndroidSettings["AirplaneMode"] = "airplane_mode";
    /**
     * Show settings to allow configuration of APNs
     */
    AndroidSettings["Apn"] = "apn";
    /**
     * Show screen of details about a particular application
     */
    AndroidSettings["ApplicationDetails"] = "application_details";
    /**
     * Show settings to allow configuration of application development-related settings
     */
    AndroidSettings["ApplicationDevelopment"] = "application_development";
    /**
     * Show settings to allow configuration of application-related settings
     */
    AndroidSettings["Application"] = "application";
    /**
     * Show settings to allow configuration of application-specific notifications
     */
    AndroidSettings["AppNotification"] = "app_notification";
    /**
     * Show screen for controlling which apps can ignore battery optimizations
     */
    AndroidSettings["BatteryOptimization"] = "battery_optimization";
    /**
     * Show settings to allow configuration of Bluetooth
     */
    AndroidSettings["Bluetooth"] = "bluetooth";
    /**
     * Show settings for video captioning
     */
    AndroidSettings["Captioning"] = "captioning";
    /**
     * Show settings to allow configuration of cast endpoints
     */
    AndroidSettings["Cast"] = "cast";
    /**
     * Show settings for selection of 2G/3G/4G
     */
    AndroidSettings["DataRoaming"] = "data_roaming";
    /**
     * Show settings to allow configuration of date and time
     */
    AndroidSettings["Date"] = "date";
    /**
     * Show settings to allow configuration of display
     */
    AndroidSettings["Display"] = "display";
    /**
     * Show Daydream settings
     */
    AndroidSettings["Dream"] = "dream";
    /**
     * Show Home selection settings
     */
    AndroidSettings["Home"] = "home";
    /**
     *    Show settings to configure input methods, in particular allowing the user to enable input methods
     */
    AndroidSettings["Keyboard"] = "keyboard";
    /**
     * Show settings to enable/disable input method subtypes
     */
    AndroidSettings["KeyboardSubType"] = "keyboard_subtype";
    /**
     * Show settings to allow configuration of locale
     */
    AndroidSettings["Locale"] = "locale";
    /**
     * Show settings to allow configuration of current location sources
     */
    AndroidSettings["Location"] = "location";
    /**
     *    Show settings to manage installed applications
     */
    AndroidSettings["ManageApplications"] = "manage_applications";
    /**
     * Show settings to manage all applications
     */
    AndroidSettings["ManageAllApplications"] = "manage_all_applications";
    /**
     * Show settings for memory card storage
     */
    AndroidSettings["MemoryCard"] = "memory_card";
    /**
     * Show settings for selecting the network operator
     */
    AndroidSettings["Network"] = "network";
    /**
     * Show NFC Sharing settings
     */
    AndroidSettings["NfcSharing"] = "nfcsharing";
    /**
     * Show NFC Tap & Pay settings
     */
    AndroidSettings["NfcPayment"] = "nfc_payment";
    /**
     * Show NFC settings
     */
    AndroidSettings["NfcSettings"] = "nfc_settings";
    /**
     * Show the top level print settings
     */
    AndroidSettings["Print"] = "print";
    /**
     * Show settings to allow configuration of privacy options
     */
    AndroidSettings["Privacy"] = "privacy";
    /**
     * Show settings to allow configuration of quick launch shortcuts
     */
    AndroidSettings["QuickLaunch"] = "quick_launch";
    /**
     * Show settings for global search
     */
    AndroidSettings["Search"] = "search";
    /**
     * Show settings to allow configuration of security and location privacy
     */
    AndroidSettings["Security"] = "security";
    /**
     * Show system settings
     */
    AndroidSettings["Settings"] = "settings";
    /**
     * Show the regulatory information screen for the device
     */
    AndroidSettings["ShowRegulatoryInfo"] = "show_regulatory_info";
    /**
     * Show settings to a llow configuration of sound and volume
     */
    AndroidSettings["Sound"] = "sound";
    /**
     * Show settings for internal storage
     */
    AndroidSettings["Storage"] = "storage";
    /**
     * Show settings to allow configuration of sync settings
     */
    AndroidSettings["Sync"] = "sync";
    /**
     * Show settings to control access to usage information
     */
    AndroidSettings["Usage"] = "usage";
    /**
     * Show settings to manage the user input dictionary
     */
    AndroidSettings["UserDictionary"] = "user_dictionary";
    /**
     * Show settings to configure input methods, in particular allowing the user to enable input methods
     */
    AndroidSettings["VoiceInput"] = "voice_input";
    /**
     * Show settings to allow configuration of Wi-Fi
     */
    AndroidSettings["Wifi"] = "wifi";
    /**
     * Show settings to allow configuration of a static IP address for Wi-Fi
     */
    AndroidSettings["WifiIp"] = "wifi_ip";
    /**
     * Show settings to allow configuration of wireless controls such as Wi-Fi, Bluetooth and Mobile networks
     */
    AndroidSettings["Wireless"] = "wireless";
    /**
     * Zen mode settings.
     */
    AndroidSettings["ZenMode"] = "zen_mode";
    /**
     * Zen mode priority settings.
     * Note that this may not work on every single device.
     * See: https://github.com/RaphaelWoude/capacitor-native-settings/pull/63
     */
    AndroidSettings["ZenModePriority"] = "zen_mode_priority";
    /**
     * Zen mode blocked effects settings.
     * Note that this may not work on every single device.
     * See: https://github.com/RaphaelWoude/capacitor-native-settings/pull/63
     */
    AndroidSettings["ZenModeBlockedEffects"] = "zen_mode_blocked_effects";
})(AndroidSettings || (AndroidSettings = {}));
var IOSSettings;
(function (IOSSettings) {
    /**
     * Settings > About page
     */
    IOSSettings["About"] = "about";
    /**
     * Opens your app-specific settings screen. Note that this is the only officially supported settings screen by Apple.
     */
    IOSSettings["App"] = "app";
    /**
     * Opens app-specific notification settings screen for iOS 15.4+; opens general app-specific settings for earlier versions."
     */
    IOSSettings["AppNotification"] = "appNotification";
    /**
     * Used to set if and when the screen should be automatically locked.
     */
    IOSSettings["AutoLock"] = "autoLock";
    /**
     * Bluetooth settings. Allows the users to enable/disable bluetooth and to search for devices.
     */
    IOSSettings["Bluetooth"] = "bluetooth";
    /**
     * Date and time settings.
     */
    IOSSettings["DateTime"] = "dateTime";
    /**
     * FaceTime settings.
     */
    IOSSettings["FaceTime"] = "facetime";
    /**
     * Opens iOS general settings screen.
     */
    IOSSettings["General"] = "general";
    /**
     * Keyboard settings.
     */
    IOSSettings["Keyboard"] = "keyboard";
    /**
     * iCloud settings.
     */
    IOSSettings["ICloud"] = "iCloud";
    /**
     * iCloud Storage and Backup settings.
     */
    IOSSettings["ICloudStorageBackup"] = "iCloudStorageBackup";
    /**
     * Language and region settings.
     */
    IOSSettings["International"] = "international";
    /**
     * Show settings to allow configuration of current location sources
     */
    IOSSettings["LocationServices"] = "locationServices";
    /**
     * Music settings.
     */
    IOSSettings["Music"] = "music";
    /**
     * Notes settings.
     */
    IOSSettings["Notes"] = "notes";
    /**
     * Notifications settings.
     */
    IOSSettings["Notifications"] = "notifications";
    /**
     * Phone settings.
     */
    IOSSettings["Phone"] = "phone";
    /**
     * Photos settings.
     */
    IOSSettings["Photos"] = "photos";
    /**
     * Allows the user to manage configuration profiles that are installed on the phone.
     */
    IOSSettings["ManagedConfigurationList"] = "managedConfigurationList";
    /**
     * Screen where the user can reset the phone to factory settings.
     */
    IOSSettings["Reset"] = "reset";
    /**
     * Ringtone settings.
     */
    IOSSettings["Ringtone"] = "ringtone";
    /**
     * Used to set phone volume, vibration settings, etc.
     */
    IOSSettings["Sounds"] = "sounds";
    /**
     * Software update screen.
     */
    IOSSettings["SoftwareUpdate"] = "softwareUpdate";
    /**
     * Store settings.
     */
    IOSSettings["Store"] = "store";
    /**
     * Tracking settings.
     */
    IOSSettings["Tracking"] = "tracking";
    /**
     * Wallpaper settings.
     */
    IOSSettings["Wallpaper"] = "wallpaper";
    /**
     * WiFi settings.
     */
    IOSSettings["WiFi"] = "wifi";
    /**
     * Tethering settings (used to create a hotspot with mobile data).
     */
    IOSSettings["Tethering"] = "tethering";
    /**
     * Do Not Disturb settings.
     */
    IOSSettings["DoNotDisturb"] = "doNotDisturb";
    /**
     * Touch id passcode settings.
     */
    IOSSettings["TouchIdPasscode"] = "touchIdPasscode";
    /**
     * Screen Time settings.
     */
    IOSSettings["ScreenTime"] = "screenTime";
    /**
     * Accessibility settings.
     */
    IOSSettings["Accessibility"] = "accessibility";
})(IOSSettings || (IOSSettings = {}));
//# sourceMappingURL=definitions.js.map
;// ./node_modules/capacitor-native-settings/dist/esm/index.js

const NativeSettings = (0,dist/* registerPlugin */.F3)('NativeSettings', {
    web: () => __webpack_require__.e(/* import() */ 988).then(__webpack_require__.bind(__webpack_require__, 91988)).then((m) => new m.NativeSettingsWeb()),
});


//# sourceMappingURL=index.js.map
;// ./src/assets/settings/settings_private-key.svg
const settings_private_key_namespaceObject = __webpack_require__.p + "settings_private-key.5db3564e144d742b44ca.svg";
;// ./src/assets/settings/settings_secret-words.svg
const settings_secret_words_namespaceObject = __webpack_require__.p + "settings_secret-words.594687182868e734ac8f.svg";
;// ./src/components/settings/backup/Backup.tsx










function Backup(_ref) {
  let {
    isActive,
    isInsideModal,
    isMultichainAccount,
    hasMnemonicWallet,
    onBackClick,
    onOpenSecretWordsSafetyRules,
    onOpenPrivateKeySafetyRules,
    openSettingsSlide
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    onBackButtonClick: openSettingsSlide,
    className: Settings_module.modalHeader,
    withNotch: isScrolled,
    title: lang('$back_up_security')
  }) : /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.header
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: openSettingsSlide,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('$back_up_security'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll
  }, hasMnemonicWallet && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item),
    onClick: onOpenSecretWordsSafetyRules
  }, /*#__PURE__*/teact.createElement("img", {
    className: Settings_module.menuIcon,
    src: settings_secret_words_namespaceObject,
    alt: lang('View Secret Words')
  }), lang('View Secret Words'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  }))), isMultichainAccount && /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockDescription
  }, lang('Can be imported to any multichain wallet supporting TON.'))), (isMultichainAccount || !hasMnemonicWallet) && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
  }, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.item),
    onClick: onOpenPrivateKeySafetyRules
  }, /*#__PURE__*/teact.createElement("img", {
    className: Settings_module.menuIcon,
    src: settings_private_key_namespaceObject,
    alt: lang('View TON Private Key')
  }), lang('View TON Private Key'), /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
    "aria-hidden": true
  }))), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockDescription
  }, lang('Can be imported to non-multichain wallets for TON.')))));
}
/* harmony default export */ const backup_Backup = (memo(Backup));
;// ./src/components/common/backup/PrivateKeyContent.tsx










function PrivateKeyContent_SecretWordsContent(_ref) {
  let {
    isActive,
    privateKey,
    onSubmit,
    buttonText
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview,
    size: src_config/* ANIMATED_STICKER_MIDDLE_SIZE_PX */.lWW,
    play: isActive,
    nonInteractive: true,
    noLoop: false,
    className: BackUpContent_module.modalSticker
  }), /*#__PURE__*/teact.createElement("p", {
    className: buildClassName(BackUpContent_module.info, BackUpContent_module.small)
  }, renderText(lang('$private_key_description'))), /*#__PURE__*/teact.createElement("p", {
    className: BackUpContent_module.warning
  }, renderText(lang('$mnemonic_warning'))), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
    noExplorer: true,
    text: privateKey,
    copyNotification: lang('Your private key was copied!')
  }), /*#__PURE__*/teact.createElement("div", {
    className: BackUpContent_module.buttonWrapper
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    className: BackUpContent_module.footerButton,
    onClick: onSubmit
  }, buttonText)));
}
/* harmony default export */ const PrivateKeyContent = (memo(PrivateKeyContent_SecretWordsContent));
;// ./src/components/settings/backup/Backup.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const Backup_module = ({"content":"Backup-module__content","buttonWrapper":"Backup-module__buttonWrapper","footerButton":"Backup-module__footerButton","modalSticker":"Backup-module__modalSticker"});
;// ./src/components/settings/backup/BackupPrivateKey.tsx











function BackupPrivateKey(_ref) {
  let {
    isActive,
    currentAccountId,
    enteredPassword,
    isBackupSlideActive,
    isInsideModal,
    onBackClick,
    onSubmit
  } = _ref;
  const lang = hooks_useLang();
  const [privateKey, setPrivateKey] = useState(undefined);
  teact_useEffect(() => {
    async function loadPrivateKey() {
      if (isBackupSlideActive && enteredPassword) {
        const privateKeyResult = await (0,api/* callApi */.p)('fetchPrivateKey', currentAccountId, enteredPassword);
        setPrivateKey(privateKeyResult);
      } else {
        setPrivateKey(undefined);
      }
    }
    void loadPrivateKey();
  }, [currentAccountId, enteredPassword, isBackupSlideActive]);
  useHistoryBack({
    isActive,
    onBack: onBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Private Key'),
    withNotch: isScrolled,
    onBackButtonClick: onBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: onBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Private Key'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, Backup_module.content),
    onScroll: handleContentScroll
  }, /*#__PURE__*/teact.createElement(PrivateKeyContent, {
    isActive: isActive,
    privateKey: privateKey,
    buttonText: lang('Close'),
    onSubmit: onSubmit
  })));
}
/* harmony default export */ const backup_BackupPrivateKey = (memo(BackupPrivateKey));
;// ./src/components/settings/backup/BackupSafetyRules.tsx











function BackupSafetyRules(_ref) {
  let {
    isActive,
    onBackClick,
    isInsideModal,
    onSubmit,
    backupType
  } = _ref;
  const lang = hooks_useLang();
  const [writedownAccepted, setWritedownAccepted] = useState(false);
  const [openWalletAccepted, setOpenWalletAccepted] = useState(false);
  const [canBeStolenAccepted, setCanBeStolenAccepted] = useState(false);
  const handleBackClick = useLastCallback(() => {
    setWritedownAccepted(false);
    setOpenWalletAccepted(false);
    setCanBeStolenAccepted(false);
    onBackClick();
  });
  useHistoryBack({
    isActive,
    onBack: onBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Safety Rules'),
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Safety Rules'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, Backup_module.content),
    onScroll: handleContentScroll
  }, /*#__PURE__*/teact.createElement(backup_SafetyRulesContent, {
    isActive: isActive,
    isFullSizeButton: true,
    textFirst: lang(backupType === 'key' ? '$safety_rules_private_key_one' : '$safety_rules_one'),
    textSecond: lang(backupType === 'key' ? '$safety_rules_private_key_two' : '$safety_rules_two'),
    textThird: lang(backupType === 'key' ? '$safety_rules_private_key_three' : '$safety_rules_three'),
    isFirstCheckboxSelected: writedownAccepted,
    onFirstCheckboxClick: setWritedownAccepted,
    isSecondCheckboxSelected: openWalletAccepted,
    onSecondCheckboxClick: setOpenWalletAccepted,
    isThirdCheckboxSelected: canBeStolenAccepted,
    onThirdCheckboxClick: setCanBeStolenAccepted,
    onSubmit: onSubmit
  })));
}
/* harmony default export */ const backup_BackupSafetyRules = (memo(BackupSafetyRules));
;// ./src/components/settings/backup/BackupSecretWords.tsx











function BackupSecretWords(_ref) {
  let {
    isActive,
    currentAccountId,
    enteredPassword,
    isBackupSlideActive,
    isInsideModal,
    onBackClick,
    onSubmit
  } = _ref;
  const lang = hooks_useLang();
  const [mnemonic, setMnemonic] = useState(undefined);
  const wordsCount = (mnemonic === null || mnemonic === void 0 ? void 0 : mnemonic.length) || 0;
  teact_useEffect(() => {
    async function loadMnemonic() {
      if (isBackupSlideActive && enteredPassword) {
        const mnemonicResult = await (0,api/* callApi */.p)('fetchMnemonic', currentAccountId, enteredPassword);
        setMnemonic(mnemonicResult);
      } else {
        setMnemonic(undefined);
      }
    }
    void loadMnemonic();
  }, [currentAccountId, enteredPassword, isBackupSlideActive]);
  useHistoryBack({
    isActive,
    onBack: onBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('%1$d Secret Words', wordsCount),
    withNotch: isScrolled,
    className: Settings_module.modalHeader,
    onBackButtonClick: onBackClick
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    className: Settings_module.headerBack,
    onClick: onBackClick
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('%1$d Secret Words', wordsCount))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, Backup_module.content),
    onScroll: handleContentScroll
  }, /*#__PURE__*/teact.createElement(backup_SecretWordsContent, {
    isActive: isActive,
    mnemonic: mnemonic,
    onSubmit: onSubmit,
    buttonText: lang('Close')
  })));
}
/* harmony default export */ const backup_BackupSecretWords = (memo(BackupSecretWords));
;// ./src/components/settings/biometrics/NativeBiometricsToggle.tsx




















function NativeBiometricsToggle(_ref) {
  let {
    isBiometricAuthEnabled,
    onEnable
  } = _ref;
  const {
    disableNativeBiometrics
  } = getActions();
  const isFaceId = getIsFaceIdAvailable() || !getIsNativeBiometricAuthSupported() && windowEnvironment/* IS_IOS */.pz;
  const isTouchId = getIsTouchIdAvailable();
  const lang = hooks_useLang();
  const [isWarningModalOpen, openWarningModal, closeWarningModal] = hooks_useFlag();
  const switcherTitle = isFaceId ? 'Face ID' : isTouchId ? 'Touch ID' : lang('Biometric Authentication');
  const warningTitle = isFaceId ? 'Turn Off Face ID' : isTouchId ? 'Turn Off Touch ID' : 'Turn Off Biometrics';
  const warningDescription = isFaceId ? 'Are you sure you want to disable Face ID?' : isTouchId ? 'Are you sure you want to disable Touch ID?' : 'Are you sure you want to disable biometrics?';
  const icon = isFaceId ? settings_face_id_namespaceObject : settings_biometrics_namespaceObject;
  const handleConfirmDisableBiometrics = useLastCallback(() => {
    closeWarningModal();
    disableNativeBiometrics();
  });
  useSyncEffect(() => {
    if (!windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return;
    if (isWarningModalOpen) {
      void Dialog.confirm({
        title: lang(warningTitle),
        message: lang(warningDescription),
        okButtonTitle: lang('Yes'),
        cancelButtonTitle: lang('Cancel')
      }).then(_ref2 => {
        let {
          value
        } = _ref2;
        if (value) {
          handleConfirmDisableBiometrics();
        }
      }).finally(closeWarningModal);
    }
  }, [handleConfirmDisableBiometrics, isWarningModalOpen, lang, warningDescription, warningTitle]);
  const handleBiometricAuthToggle = useLastCallback(() => {
    if (getIsTelegramBiometricsRestricted()) {
      var _getTelegramApp;
      (_getTelegramApp = telegram_getTelegramApp()) === null || _getTelegramApp === void 0 || _getTelegramApp.BiometricManager.openSettings();
      return;
    }
    if (isBiometricAuthEnabled) {
      openWarningModal();
    } else {
      onEnable();
    }
  });
  function renderDisableNativeBiometricsWarning() {
    if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) return undefined;
    return /*#__PURE__*/teact.createElement(ui_Modal, {
      isCompact: true,
      isOpen: isWarningModalOpen,
      title: lang(warningTitle),
      onClose: closeWarningModal,
      dialogClassName: Settings_module.stakingSafeDialog
    }, /*#__PURE__*/teact.createElement("p", {
      className: Modal_module.text
    }, renderText(lang(warningDescription))), /*#__PURE__*/teact.createElement("div", {
      className: Modal_module.buttons
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: closeWarningModal
    }, lang('Cancel')), /*#__PURE__*/teact.createElement(ui_Button, {
      onClick: handleConfirmDisableBiometrics
    }, lang('Yes'))));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.item,
    onClick: handleBiometricAuthToggle
  }, /*#__PURE__*/teact.createElement("img", {
    className: Settings_module.menuIcon,
    src: icon,
    alt: ""
  }), switcherTitle, /*#__PURE__*/teact.createElement(ui_Switcher, {
    className: Settings_module.menuSwitcher,
    label: switcherTitle,
    checked: isBiometricAuthEnabled
  })), renderDisableNativeBiometricsWarning()), /*#__PURE__*/teact.createElement("p", {
    className: Settings_module.blockDescription
  }, lang('To avoid entering the passcode every time, you can use biometrics.')));
}
/* harmony default export */ const biometrics_NativeBiometricsToggle = (memo(withGlobal(global => {
  return {
    isBiometricAuthEnabled: selectIsNativeBiometricAuthEnabled(global)
  };
})(NativeBiometricsToggle)));
;// ./src/assets/settings/settings_install-app.svg
const settings_install_app_namespaceObject = __webpack_require__.p + "settings_install-app.4e741ffc81f5e067f545.svg";
;// ./src/components/settings/SettingsSecurity.tsx










































let SettingsSecurity_SLIDES = /*#__PURE__*/function (SLIDES) {
  SLIDES[SLIDES["password"] = 0] = "password";
  SLIDES[SLIDES["settings"] = 1] = "settings";
  SLIDES[SLIDES["newPassword"] = 2] = "newPassword";
  SLIDES[SLIDES["createNewPin"] = 3] = "createNewPin";
  SLIDES[SLIDES["confirmNewPin"] = 4] = "confirmNewPin";
  SLIDES[SLIDES["passwordChanged"] = 5] = "passwordChanged";
  SLIDES[SLIDES["backup"] = 6] = "backup";
  SLIDES[SLIDES["safetyRules"] = 7] = "safetyRules";
  SLIDES[SLIDES["privateKey"] = 8] = "privateKey";
  SLIDES[SLIDES["secretWords"] = 9] = "secretWords";
  return SLIDES;
}({});
const SWITCH_CONFIRM_PASSCODE_PAUSE_MS = 500;
const CHANGE_PASSWORD_PAUSE_MS = 1500;
const INITIAL_CHANGE_PASSWORD_SLIDE = getDoesUsePinPad() ? SettingsSecurity_SLIDES.createNewPin : SettingsSecurity_SLIDES.newPassword;
function SettingsSecurity(_ref) {
  let {
    isActive,
    handleBackClick: navigateBackToSettings,
    isInsideModal,
    isBiometricAuthEnabled,
    isNativeBiometricAuthEnabled,
    isPasswordNumeric,
    isPasswordPresent,
    isMultichainAccount,
    isAppLockEnabled,
    autolockValue = src_config/* DEFAULT_AUTOLOCK_OPTION */.fPM,
    isAutoConfirmEnabled,
    isAllowSuspiciousActions,
    isAutoUpdateEnabled,
    currentAccountId,
    onSettingsClose,
    onAutoUpdateEnabledToggle,
    isLoading,
    shouldShowBackup
  } = _ref;
  const {
    setIsPinAccepted,
    clearIsPinAccepted,
    disableNativeBiometrics,
    enableNativeBiometrics,
    openBiometricsTurnOffWarning,
    openBiometricsTurnOn,
    setSettingsState,
    setAppLockValue,
    setIsAutoConfirmEnabled,
    setIsAllowSuspiciousActions,
    setIsAuthLoading,
    setInMemoryPassword
  } = getActions();
  const lang = hooks_useLang();
  const {
    isScrolled,
    handleScroll: handleContentScroll
  } = useScrolledState();
  const [currentSlide, setCurrentSlide] = useState(SettingsSecurity_SLIDES.password);
  const previousSlide = hooks_usePrevious(currentSlide);
  const [nextKey, setNextKey] = useState(SettingsSecurity_SLIDES.settings);
  const [passwordError, setPasswordError] = useState();
  const [password, setPassword] = useState();
  const [backupType, setBackupType] = useState(undefined);
  const [hasMnemonicWallet, setHasMnemonicWallet] = useState(false);

  // For Capacitor only
  const [pinValue, setPinValue] = useState('');
  const [confirmPinValue, setConfirmPinValue] = useState('');
  const clearPasswordError = useLastCallback(() => {
    setPasswordError(undefined);
  });
  const cleanup = useLastCallback(shouldKeepCurrentPassword => {
    if (!shouldKeepCurrentPassword) setPassword(undefined);
    setPinValue('');
    setConfirmPinValue('');
    clearPasswordError();
    clearIsPinAccepted();
  });
  const handleBackToSettingsClick = useLastCallback(() => {
    navigateBackToSettings();
    cleanup();
  });
  const openConfirmNewPinSlide = useLastCallback(() => {
    setCurrentSlide(SettingsSecurity_SLIDES.confirmNewPin);
    setNextKey(SettingsSecurity_SLIDES.settings);
  });
  const openSettingsSlide = useLastCallback(() => {
    setCurrentSlide(SettingsSecurity_SLIDES.settings);
    setNextKey(undefined);
    cleanup(true);
  });
  const openBackupPage = useLastCallback(() => {
    if (!isMultichainAccount) {
      openSettingsSlide();
      return;
    }
    setCurrentSlide(SettingsSecurity_SLIDES.backup);
    setNextKey(SettingsSecurity_SLIDES.safetyRules);
  });
  const openNewPasswordSlide = useLastCallback(() => {
    setCurrentSlide(INITIAL_CHANGE_PASSWORD_SLIDE);
    setNextKey(SettingsSecurity_SLIDES.settings);
  });
  const openPasswordChangedSlide = useLastCallback(() => {
    setCurrentSlide(SettingsSecurity_SLIDES.passwordChanged);
    setNextKey(SettingsSecurity_SLIDES.settings);
  });
  useLayoutEffect(() => {
    if (password === undefined && isActive) setCurrentSlide(SettingsSecurity_SLIDES.password);else if (!isActive) cleanup();
  }, [password, isActive]);
  useHistoryBack({
    isActive,
    onBack: handleBackToSettingsClick
  });
  const handlePasswordSubmit = useLastCallback(async enteredPassword => {
    const result = await (0,api/* callApi */.p)('verifyPassword', enteredPassword);
    if (!result) {
      setPasswordError('Wrong password, please try again.');
      return;
    }
    if (getDoesUsePinPad()) {
      setIsPinAccepted();
      await vibrateOnSuccess(true);
    }
    openSettingsSlide();
    setPassword(enteredPassword);
  });
  const handleNewPasswordSubmit = useLastCallback(async enteredPassword => {
    await (0,api/* callApi */.p)('changePassword', password, enteredPassword);
    setIsAuthLoading({
      isLoading: true
    });
    setPassword(enteredPassword);
    setInMemoryPassword({
      password: enteredPassword
    });
    if (isNativeBiometricAuthEnabled) {
      disableNativeBiometrics();
      enableNativeBiometrics({
        password: enteredPassword
      });
    }
    if (getDoesUsePinPad()) {
      openSettingsSlide();
    } else {
      openPasswordChangedSlide();
    }
    setIsAuthLoading({
      isLoading: undefined
    });
  });
  const handlePinSubmit = useLastCallback(async enteredPassword => {
    setPinValue(enteredPassword);
    await vibrateOnSuccess(true);
    await (0,schedulers/* pause */.v7)(SWITCH_CONFIRM_PASSCODE_PAUSE_MS);
    openConfirmNewPinSlide();
  });
  const handleConfirmPinSubmit = useLastCallback(async enteredPassword => {
    if (enteredPassword === pinValue) {
      setPasswordError(lang('New code set successfully'));
      await (0,schedulers/* pause */.v7)(CHANGE_PASSWORD_PAUSE_MS);
      await handleNewPasswordSubmit(enteredPassword);
    } else {
      setPasswordError(lang('Codes donâ€™t match'));
      await (0,schedulers/* pause */.v7)(CHANGE_PASSWORD_PAUSE_MS);
      cleanup(true);
      setCurrentSlide(SettingsSecurity_SLIDES.createNewPin);
    }
  });
  const handleChangePasswordClick = useLastCallback(() => {
    setNextKey(INITIAL_CHANGE_PASSWORD_SLIDE);
    openNewPasswordSlide();
  });
  const handleOpenPrivateKeySafetyRules = useLastCallback(() => {
    setBackupType('key');
    setCurrentSlide(SettingsSecurity_SLIDES.safetyRules);
    setNextKey(SettingsSecurity_SLIDES.privateKey);
  });
  const handleOpenSecretWordsSafetyRules = useLastCallback(() => {
    setBackupType('words');
    setCurrentSlide(SettingsSecurity_SLIDES.safetyRules);
    setNextKey(SettingsSecurity_SLIDES.secretWords);
  });
  const handleOpenBackupWallet = useLastCallback(() => {
    if (!isMultichainAccount) {
      if (hasMnemonicWallet) handleOpenSecretWordsSafetyRules();else handleOpenPrivateKeySafetyRules();
      return;
    }
    setCurrentSlide(SettingsSecurity_SLIDES.backup);
    // Resetting next key to undefined unmounts and destroys components with mnemonic and private key
    setNextKey(undefined);
  });
  const handleOpenPrivateKey = useLastCallback(() => {
    setCurrentSlide(SettingsSecurity_SLIDES.privateKey);
    setNextKey(SettingsSecurity_SLIDES.backup);
  });
  const handleOpenSecretWords = useLastCallback(() => {
    setCurrentSlide(SettingsSecurity_SLIDES.secretWords);
    setNextKey(SettingsSecurity_SLIDES.backup);
  });
  const handleAppLockToggle = useLastCallback(() => {
    setAppLockValue({
      value: autolockValue,
      isEnabled: !isAppLockEnabled
    });
  });
  const handleAutolockChange = useLastCallback(value => {
    setAppLockValue({
      value,
      isEnabled: true
    });
  });
  const handleAutoConfirmToggle = useLastCallback(() => {
    setIsAutoConfirmEnabled({
      isEnabled: !isAutoConfirmEnabled
    });
  });
  const handleAllowSuspiciousActionsToggle = useLastCallback(() => {
    setIsAllowSuspiciousActions({
      isEnabled: !isAllowSuspiciousActions
    });
  });

  // Biometrics
  const handleBiometricAuthToggle = useLastCallback(() => {
    if (isBiometricAuthEnabled) {
      openBiometricsTurnOffWarning();
    } else {
      openBiometricsTurnOn();
    }
  });
  const handleNativeBiometricsTurnOnOpen = useLastCallback(async () => {
    if (getIsNativeBiometricAuthSupported()) {
      setSettingsState({
        state: SettingsState.NativeBiometricsTurnOn
      });
      return;
    }
    const warningDescription = windowEnvironment/* IS_IOS */.pz ? 'To use this feature, first enable Face ID in your phone settings.' : 'To use this feature, first enable biometrics in your phone settings.';
    const {
      value
    } = await Dialog.confirm({
      title: lang('Warning!'),
      message: lang(warningDescription),
      okButtonTitle: lang('Open Settings'),
      cancelButtonTitle: lang('Cancel')
    });
    if (value) {
      await NativeSettings.open({
        optionAndroid: AndroidSettings.ApplicationDetails,
        optionIOS: IOSSettings.App
      });
    }
  });
  teact_useEffect(() => {
    if (!password) return;
    void (0,api/* callApi */.p)('fetchMnemonic', currentAccountId, password).then(mnemonic => {
      setHasMnemonicWallet(Boolean(mnemonic && !isMnemonicPrivateKey(mnemonic)));
    });
  }, [hasMnemonicWallet, currentAccountId, password]);

  // The `getIsTelegramBiometricsRestricted` case is required to display a toggle switch.
  // When activated, it will show a warning to the user indicating that they need to grant
  // the appropriate permissions for biometric authentication to function properly.
  const shouldRenderNativeBiometrics = isPasswordPresent && (getIsNativeBiometricAuthSupported() || windowEnvironment/* IS_IOS_APP */.ZH || getIsTelegramBiometricsRestricted());
  const shouldRenderMinifiedPinPad = isInsideModal && getDoesUsePinPad();
  const isAutoConfirmAvailable = !isBiometricAuthEnabled;
  function renderSettings() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.slide
    }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Security'),
      withNotch: isScrolled,
      onBackButtonClick: handleBackToSettingsClick,
      className: Settings_module.modalHeader
    }) : /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      isText: true,
      onClick: handleBackToSettingsClick,
      className: Settings_module.headerBack
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
      className: Settings_module.headerTitle
    }, lang('Security'))), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.content, 'custom-scroll'),
      onScroll: handleContentScroll
    }, shouldShowBackup && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.settingsBlock
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.item),
      onClick: handleOpenBackupWallet
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_install_app_namespaceObject,
      alt: lang('$back_up_security')
    }), lang('$back_up_security'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), shouldRenderNativeBiometrics && /*#__PURE__*/teact.createElement(biometrics_NativeBiometricsToggle, {
      onEnable: handleNativeBiometricsTurnOnOpen
    }), isPasswordPresent && windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleBiometricAuthToggle
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_biometrics_namespaceObject,
      alt: lang('Biometric Authentication')
    }), lang('Biometric Authentication'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Biometric Authentication'),
      checked: isBiometricAuthEnabled
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('To avoid entering the passcode every time, you can use biometrics.'))), !(isBiometricAuthEnabled && !isNativeBiometricAuthEnabled) && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      className: Settings_module.changePasswordButton,
      isSimple: true,
      onClick: handleChangePasswordClick
    }, isPasswordNumeric ? lang('Change Passcode') : lang('Change Password'))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('The passcode will be changed for all your wallets.'))), isPasswordPresent && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.item, Settings_module.itemSmall),
      onClick: handleAppLockToggle
    }, lang('App Lock'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Allow App Lock'),
      checked: isAppLockEnabled
    })), /*#__PURE__*/teact.createElement(ui_Collapsible, {
      isShown: !!isAppLockEnabled
    }, /*#__PURE__*/teact.createElement(ui_Dropdown, {
      label: lang('Auto-Lock'),
      items: src_config/* AUTOLOCK_OPTIONS_LIST */.zTb,
      selectedValue: autolockValue,
      theme: "light",
      shouldTranslateOptions: true,
      className: buildClassName(Settings_module.item, Settings_module.item_small, Settings_module.itemAutoLock),
      onChange: handleAutolockChange
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('$app_lock_description', {
      app_name: src_config/* APP_NAME */.C39
    }))), isPasswordPresent && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.item, Settings_module.itemSmall, !isAutoConfirmAvailable && Settings_module.itemDisabled),
      onClick: isAutoConfirmAvailable ? handleAutoConfirmToggle : undefined
    }, isPasswordNumeric ? lang('Remember Passcode') : lang('Remember Password'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: isPasswordNumeric ? lang('Remember Passcode') : lang('Remember Password'),
      checked: isAutoConfirmAvailable && isAutoConfirmEnabled
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('App will not ask for signature for %1$d minutes after last entry.', src_config/* AUTO_CONFIRM_DURATION_MINUTES */.gbw), !isAutoConfirmAvailable && ` ${lang('Not available with biometrics.')}`)), windowEnvironment/* IS_ELECTRON */.cp && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.item, Settings_module.item_small),
      onClick: onAutoUpdateEnabledToggle
    }, lang('Auto-Updates'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Auto-Updates'),
      checked: isAutoUpdateEnabled
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('Turn this off so you can manually download updates and verify signatures.'))), /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.block, Settings_module.settingsBlockWithDescription)
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.item, Settings_module.itemSmall),
      onClick: handleAllowSuspiciousActionsToggle
    }, lang('Allow Suspicious Actions'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Allow Suspicious Actions'),
      checked: isAllowSuspiciousActions
    }))), /*#__PURE__*/teact.createElement("p", {
      className: Settings_module.blockDescription
    }, lang('$allow_suspicious_actions_description')))));
  }
  function renderContent(isSlideActive, isFrom, currentKey) {
    switch (currentKey) {
      case SettingsSecurity_SLIDES.settings:
        return renderSettings();
      case SettingsSecurity_SLIDES.password:
        if (getHasInMemoryPassword()) {
          setCurrentSlide(SettingsSecurity_SLIDES.settings);
          void getInMemoryPassword().then(memoizedPassword => setPassword(memoizedPassword));
          return undefined;
        }
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: isPasswordNumeric ? lang('Confirm Passcode') : lang('Confirm Password'),
          onBackButtonClick: handleBackToSettingsClick,
          className: Settings_module.modalHeader
        }) : /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.header
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isSimple: true,
          isText: true,
          onClick: handleBackToSettingsClick,
          className: Settings_module.headerBack
        }, /*#__PURE__*/teact.createElement("i", {
          className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
          "aria-hidden": true
        }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
          className: Settings_module.headerTitle
        }, lang('Enter Password'))), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
          isActive: isSlideActive && isActive,
          error: passwordError,
          containerClassName: src_config/* IS_CAPACITOR */.UMQ ? Settings_module.passwordFormContent : Settings_module.passwordFormContentInModal,
          forceBiometricsInMain: !isInsideModal,
          placeholder: lang('Enter your current password'),
          submitLabel: lang('Continue'),
          onCancel: handleBackToSettingsClick,
          onSubmit: handlePasswordSubmit,
          onUpdate: clearPasswordError
        }));
      case SettingsSecurity_SLIDES.newPassword:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Change Password'),
          onBackButtonClick: openSettingsSlide,
          className: Settings_module.modalHeader
        }) : /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.header
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isSimple: true,
          isText: true,
          onClick: openSettingsSlide,
          className: Settings_module.headerBack
        }, /*#__PURE__*/teact.createElement("i", {
          className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
          "aria-hidden": true
        }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
          className: Settings_module.headerTitle
        }, lang('Change Password'))), /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Modal_module.transitionContent, Settings_module.content, isInsideModal && Settings_module.contentInModal)
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.guard,
          previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
          play: isSlideActive,
          size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk,
          nonInteractive: true,
          noLoop: false,
          className: Settings_module.sticker
        }), /*#__PURE__*/teact.createElement(ui_CreatePasswordForm, {
          isActive: isSlideActive,
          isLoading: isLoading,
          onSubmit: handleNewPasswordSubmit,
          onCancel: openSettingsSlide,
          formId: "auth-create-password"
        })));
      case SettingsSecurity_SLIDES.createNewPin:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          onBackButtonClick: openSettingsSlide,
          className: Settings_module.modalHeader,
          title: shouldRenderMinifiedPinPad && lang('Change Passcode')
        }) : /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.header
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isSimple: true,
          isText: true,
          onClick: openSettingsSlide,
          className: Settings_module.headerBack
        }, /*#__PURE__*/teact.createElement("i", {
          className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
          "aria-hidden": true
        }), /*#__PURE__*/teact.createElement("span", null, lang('Back')))), /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Settings_module.pinPadHeader, shouldRenderMinifiedPinPad && Settings_module.pinPadHeaderMinified)
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          play: isActive,
          tgsUrl: ANIMATED_STICKERS_PATHS.guard,
          previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
          noLoop: false,
          size: shouldRenderMinifiedPinPad ? src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp : src_config/* ANIMATED_STICKER_HUGE_SIZE_PX */.reE,
          nonInteractive: true
        }), !shouldRenderMinifiedPinPad && /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.pinPadTitle
        }, lang('Change Passcode'))), /*#__PURE__*/teact.createElement(ui_PinPad, {
          isActive: isActive,
          title: lang('Enter your new code'),
          length: src_config/* PIN_LENGTH */.NEx,
          value: pinValue,
          onChange: setPinValue,
          onSubmit: handlePinSubmit,
          isMinified: shouldRenderMinifiedPinPad
        }));
      case SettingsSecurity_SLIDES.confirmNewPin:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          onBackButtonClick: openSettingsSlide,
          className: Settings_module.modalHeader,
          title: shouldRenderMinifiedPinPad && (passwordError && pinValue === confirmPinValue ? lang('Passcode Changed!') : lang('Change Passcode'))
        }) : /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.header
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isSimple: true,
          isText: true,
          onClick: openSettingsSlide,
          className: Settings_module.headerBack
        }, /*#__PURE__*/teact.createElement("i", {
          className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
          "aria-hidden": true
        }), /*#__PURE__*/teact.createElement("span", null, lang('Back')))), /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Settings_module.pinPadHeader, shouldRenderMinifiedPinPad && Settings_module.pinPadHeaderMinified)
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          play: isActive,
          tgsUrl: ANIMATED_STICKERS_PATHS.guard,
          previewUrl: ANIMATED_STICKERS_PATHS.guardPreview,
          noLoop: false,
          size: shouldRenderMinifiedPinPad ? src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp : src_config/* ANIMATED_STICKER_HUGE_SIZE_PX */.reE,
          nonInteractive: true
        }), !shouldRenderMinifiedPinPad && /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.pinPadTitle
        }, passwordError && pinValue === confirmPinValue ? lang('Passcode Changed!') : lang('Change Passcode'))), /*#__PURE__*/teact.createElement(ui_PinPad, {
          isActive: isActive,
          title: !passwordError ? lang('Re-enter your new code') : passwordError,
          type: passwordError ? pinValue === confirmPinValue ? 'success' : 'error' : undefined,
          length: src_config/* PIN_LENGTH */.NEx,
          value: confirmPinValue,
          onChange: setConfirmPinValue,
          onSubmit: handleConfirmPinSubmit,
          isMinified: shouldRenderMinifiedPinPad
        }));
      case SettingsSecurity_SLIDES.passwordChanged:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('Password Changed!'),
          className: Settings_module.modalHeader
        }) : /*#__PURE__*/teact.createElement("div", {
          className: buildClassName(Settings_module.header, Settings_module.onlyTextHeader)
        }, /*#__PURE__*/teact.createElement("span", {
          className: Settings_module.headerTitle
        }, lang('Password Changed!'))), /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.content
        }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
          tgsUrl: ANIMATED_STICKERS_PATHS.yeee,
          previewUrl: ANIMATED_STICKERS_PATHS.yeeePreview,
          play: isActive,
          size: src_config/* ANIMATED_STICKER_HUGE_SIZE_PX */.reE,
          nonInteractive: true,
          noLoop: false,
          className: buildClassName(Settings_module.sticker, Settings_module.stickerHuge)
        }), /*#__PURE__*/teact.createElement("div", {
          className: Modal_module.buttons
        }, /*#__PURE__*/teact.createElement(ui_Button, {
          isPrimary: true,
          onClick: openSettingsSlide,
          className: Modal_module.customSubmitButton
        }, lang('Done')))));
      case SettingsSecurity_SLIDES.backup:
        return /*#__PURE__*/teact.createElement(backup_Backup, {
          isActive: isActive && isSlideActive,
          isMultichainAccount: isMultichainAccount,
          openSettingsSlide: openSettingsSlide,
          isInsideModal: isInsideModal,
          onOpenPrivateKeySafetyRules: handleOpenPrivateKeySafetyRules,
          onOpenSecretWordsSafetyRules: handleOpenSecretWordsSafetyRules,
          onBackClick: handleBackToSettingsClick,
          hasMnemonicWallet: hasMnemonicWallet
        });
      case SettingsSecurity_SLIDES.safetyRules:
        return /*#__PURE__*/teact.createElement(backup_BackupSafetyRules, {
          isActive: isActive && isSlideActive,
          isInsideModal: isInsideModal,
          backupType: backupType,
          onBackClick: openBackupPage,
          onSubmit: backupType === 'key' ? handleOpenPrivateKey : handleOpenSecretWords
        });
      case SettingsSecurity_SLIDES.secretWords:
        return /*#__PURE__*/teact.createElement(backup_BackupSecretWords, {
          isActive: isActive && isSlideActive,
          isBackupSlideActive: currentKey === SettingsSecurity_SLIDES.secretWords || currentKey === SettingsSecurity_SLIDES.safetyRules,
          isInsideModal: isInsideModal,
          enteredPassword: password,
          currentAccountId: currentAccountId,
          onBackClick: openBackupPage,
          onSubmit: onSettingsClose
        });
      case SettingsSecurity_SLIDES.privateKey:
        return /*#__PURE__*/teact.createElement(backup_BackupPrivateKey, {
          isActive: isActive && isSlideActive,
          isBackupSlideActive: currentKey === SettingsSecurity_SLIDES.privateKey || currentKey === SettingsSecurity_SLIDES.safetyRules,
          isInsideModal: isInsideModal,
          enteredPassword: password,
          currentAccountId: currentAccountId,
          onBackClick: openBackupPage,
          onSubmit: onSettingsClose
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Transition, {
    direction: previousSlide === SettingsSecurity_SLIDES.password && currentSlide === SettingsSecurity_SLIDES.settings ? 1 : 'auto',
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: buildClassName(Settings_module.slide, isInsideModal && Modal_module.transitionSlide),
    activeKey: currentSlide,
    nextKey: nextKey,
    shouldCleanup: true
  }, renderContent);
}
/* harmony default export */ const settings_SettingsSecurity = (memo(withGlobal(global => {
  const {
    isPasswordNumeric,
    autolockValue,
    isAppLockEnabled,
    isAutoConfirmEnabled
  } = global.settings;
  const isBiometricAuthEnabled = selectIsBiometricAuthEnabled(global);
  const isNativeBiometricAuthEnabled = selectIsNativeBiometricAuthEnabled(global);
  const isPasswordPresent = selectIsPasswordPresent(global);
  const isAllowSuspiciousActions = selectIsAllowSuspiciousActions(global, global.currentAccountId);
  const isMultichainAccount = selectIsMultichainAccount(global, global.currentAccountId);
  const isMnemonicAccount = selectIsMnemonicAccount(global);
  return {
    isBiometricAuthEnabled,
    isNativeBiometricAuthEnabled,
    isMultichainAccount,
    isPasswordNumeric,
    isPasswordPresent,
    isAppLockEnabled,
    autolockValue,
    isAutoConfirmEnabled,
    isAllowSuspiciousActions,
    shouldShowBackup: isMnemonicAccount,
    isLoading: global.auth.isLoading,
    currentAccountId: global.currentAccountId
  };
})(SettingsSecurity)));
;// ./src/components/settings/SettingsTokenList.tsx









function SettingsTokenList(_ref) {
  let {
    isActive,
    isInsideModal,
    handleBackClick
  } = _ref;
  const {
    addToken
  } = getActions();
  const lang = hooks_useLang();
  const handleTokenSelect = useLastCallback(token => {
    addToken({
      token: token
    });
  });
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  function renderHeader() {
    return /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.header, isInsideModal && Settings_module.headerInsideModal)
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      isText: true,
      className: buildClassName(Settings_module.headerBack, isInsideModal && Settings_module.isInsideModal),
      onClick: handleBackClick
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
      className: Settings_module.headerTitle
    }, lang('Select Token')));
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.slide, Settings_module.withTopSpace)
  }, /*#__PURE__*/teact.createElement(common_TokenSelector, {
    isActive: isActive,
    shouldHideMyTokens: true,
    shouldHideNotSupportedTokens: true,
    header: renderHeader(),
    onTokenSelect: handleTokenSelect,
    onBack: handleBackClick,
    onClose: handleBackClick
  }));
}
/* harmony default export */ const settings_SettingsTokenList = (memo(SettingsTokenList));
;// ./src/components/settings/SettingsWalletVersion.tsx











function SettingsWalletVersion(_ref) {
  let {
    isActive,
    handleBackClick,
    isInsideModal,
    currentVersion,
    wallets
  } = _ref;
  const {
    closeSettings,
    importAccountByVersion
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: handleBackClick
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  const handleAddWallet = useLastCallback(version => {
    closeSettings();
    importAccountByVersion({
      version
    });
  });
  function renderWallets() {
    return wallets === null || wallets === void 0 ? void 0 : wallets.map(v => {
      return /*#__PURE__*/teact.createElement("div", {
        key: v.address,
        className: buildClassName(Settings_module.item, Settings_module.item_wallet_version),
        onClick: () => handleAddWallet(v.version)
      }, /*#__PURE__*/teact.createElement("div", {
        className: Settings_module.walletVersionInfo
      }, /*#__PURE__*/teact.createElement("span", {
        className: Settings_module.walletVersionTitle
      }, v.version), /*#__PURE__*/teact.createElement("span", {
        className: Settings_module.walletVersionAddress
      }, (0,shortenAddress/* shortenAddress */.W)(v.address))), /*#__PURE__*/teact.createElement("div", {
        className: Settings_module.walletVersionInfoRight
      }, /*#__PURE__*/teact.createElement("span", {
        className: Settings_module.walletVersionTokens
      }, v.tokens.join(', ')), /*#__PURE__*/teact.createElement("span", {
        className: Settings_module.walletVersionAmount
      }, "\u2248\u2009", v.totalBalance)), /*#__PURE__*/teact.createElement("i", {
        className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
        "aria-hidden": true
      }));
    });
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.slide
  }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Wallet Versions'),
    withNotch: isScrolled,
    onBackButtonClick: handleBackClick,
    className: Settings_module.modalHeader
  }) : /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isSimple: true,
    isText: true,
    onClick: handleBackClick,
    className: Settings_module.headerBack
  }, /*#__PURE__*/teact.createElement("i", {
    className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
    "aria-hidden": true
  }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
    className: Settings_module.headerTitle
  }, lang('Wallet Versions'))), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Settings_module.content, 'custom-scroll'),
    onScroll: handleContentScroll
  }, /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.blockWalletVersionText
  }, /*#__PURE__*/teact.createElement("span", null, lang('$current_wallet_version', {
    version: /*#__PURE__*/teact.createElement("strong", null, currentVersion)
  })), /*#__PURE__*/teact.createElement("span", null, lang('You have tokens on other versions of your wallet. You can import them from here.'))), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.block
  }, renderWallets()), /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.blockWalletVersionReadMore
  }, lang('$read_more_about_wallet_version', {
    ton_link: /*#__PURE__*/teact.createElement("a", {
      href: "https://docs.ton.org/participate/wallets/contracts",
      target: "_blank",
      rel: "noreferrer"
    }, "ton.org")
  }))));
}
/* harmony default export */ const settings_SettingsWalletVersion = (memo(SettingsWalletVersion));
;// ./src/assets/settings/settings_about.svg
const settings_about_namespaceObject = __webpack_require__.p + "settings_about.595108a2131c96b2a073.svg";
;// ./src/assets/settings/settings_appearance.svg
const settings_appearance_namespaceObject = __webpack_require__.p + "settings_appearance.2b14c893329172079cde.svg";
;// ./src/assets/settings/settings_assets-activity.svg
const settings_assets_activity_namespaceObject = __webpack_require__.p + "settings_assets-activity.1ad5da85234bf09fece1.svg";
;// ./src/assets/settings/settings_connected-dapps.svg
const settings_connected_dapps_namespaceObject = __webpack_require__.p + "settings_connected-dapps.2040e629b6b7c8322782.svg";
;// ./src/assets/settings/settings_disclaimer.svg
const settings_disclaimer_namespaceObject = __webpack_require__.p + "settings_disclaimer.253b4de147ec357601d1.svg";
;// ./src/assets/settings/settings_exit.svg
const settings_exit_namespaceObject = __webpack_require__.p + "settings_exit.32a8c2a0aa15b32cbe18.svg";
;// ./src/assets/settings/settings_helpcenter.svg
const settings_helpcenter_namespaceObject = __webpack_require__.p + "settings_helpcenter.c1b63b9a0edfbe3ca57a.svg";
;// ./src/assets/settings/settings_install-desktop.svg
const settings_install_desktop_namespaceObject = __webpack_require__.p + "settings_install-desktop.f9ff2be3a8a645314652.svg";
;// ./src/assets/settings/settings_install-mobile.svg
const settings_install_mobile_namespaceObject = __webpack_require__.p + "settings_install-mobile.9a3f10a7012a857e2ba2.svg";
;// ./src/assets/settings/settings_language.svg
const settings_language_namespaceObject = __webpack_require__.p + "settings_language.5082638742f18ab7aea8.svg";
;// ./src/assets/settings/settings_ledger.svg
const settings_ledger_namespaceObject = __webpack_require__.p + "settings_ledger.d4d0de11ad8edd55b0ca.svg";
;// ./src/assets/settings/settings_mtw-cards.svg
const settings_mtw_cards_namespaceObject = __webpack_require__.p + "settings_mtw-cards.aa09d8a35d4b36e090c8.svg";
;// ./src/assets/settings/settings_mytonwallet.svg
const settings_mytonwallet_namespaceObject = __webpack_require__.p + "settings_mytonwallet.0bfa3bfd3fb936194997.svg";
;// ./src/assets/settings/settings_notifications.svg
const settings_notifications_namespaceObject = __webpack_require__.p + "settings_notifications.20cf46edde7f154d46e3.svg";
;// ./src/assets/settings/settings_security.svg
const settings_security_namespaceObject = __webpack_require__.p + "settings_security.4e873ae439b7ec0b15a9.svg";
;// ./src/assets/settings/settings_support.svg
const settings_support_namespaceObject = __webpack_require__.p + "settings_support.de2a6e66d58407937014.svg";
;// ./src/assets/settings/settings_telegram-menu.svg
const settings_telegram_menu_namespaceObject = __webpack_require__.p + "settings_telegram-menu.48b7177fffab504e301c.svg";
;// ./src/assets/settings/settings_tips.svg
const settings_tips_namespaceObject = __webpack_require__.p + "settings_tips.4f95b86d29d530790adb.svg";
;// ./src/assets/settings/settings_ton-links.svg
const settings_ton_links_namespaceObject = __webpack_require__.p + "settings_ton-links.d9f0da8222e4a54c9332.svg";
;// ./src/assets/settings/settings_ton-magic.svg
const settings_ton_magic_namespaceObject = __webpack_require__.p + "settings_ton-magic.bc2fb1d30938a1154b6c.svg";
;// ./src/assets/settings/settings_ton-proxy.svg
const settings_ton_proxy_namespaceObject = __webpack_require__.p + "settings_ton-proxy.21c95b346710c5a73217.svg";
;// ./src/assets/settings/settings_wallet-version.svg
const settings_wallet_version_namespaceObject = __webpack_require__.p + "settings_wallet-version.651cf56eff6ca7827bf6.svg";
;// ./src/components/settings/Settings.tsx










































































const AMOUNT_OF_CLICKS_FOR_DEVELOPERS_MODE = 5;
const SUPPORT_ACCOUNTS_COUNT_DEFAULT = 1;
function Settings(_ref) {
  let {
    settings: {
      state,
      theme,
      animationLevel,
      isTestnet,
      langCode,
      isTonProxyEnabled,
      isTonMagicEnabled,
      isDeeplinkHookEnabled,
      baseCurrency
    },
    dapps,
    isActive,
    isOpen = false,
    tokens,
    isInsideModal,
    isPasswordPresent,
    currentVersion,
    versions,
    isCopyStorageEnabled,
    supportAccountsCount = SUPPORT_ACCOUNTS_COUNT_DEFAULT,
    accounts,
    hardwareWallets,
    arePushNotificationsAvailable,
    isNftBuyingDisabled,
    isViewMode
  } = _ref;
  const {
    setSettingsState,
    openSettingsHardwareWallet,
    closeSettings,
    toggleDeeplinkHook,
    toggleTonProxy,
    toggleTonMagic,
    getDapps,
    clearIsPinAccepted,
    afterSelectHardwareWallets
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const transitionRef = teact_useRef();
  const {
    renderingKey
  } = useModalTransitionKeys(state, isOpen);
  const {
    disableSwipeToClose,
    enableSwipeToClose
  } = useTelegramMiniAppSwipeToClose(isOpen);
  const [clicksAmount, setClicksAmount] = useState(isTestnet ? AMOUNT_OF_CLICKS_FOR_DEVELOPERS_MODE : 0);
  const prevRenderingKeyRef = useStateRef(usePrevious2(renderingKey));
  const [isDeveloperModalOpen, openDeveloperModal, closeDeveloperModal] = hooks_useFlag();
  const [withAllWalletVersions, markWithAllWalletVersions] = hooks_useFlag();
  const [isLogOutModalOpened, openLogOutModal, closeLogOutModal] = hooks_useFlag();
  // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
  const isInitialScreen = renderingKey === SettingsState.Initial;
  const activeLang = teact_useMemo(() => src_config/* LANG_LIST */.gSB.find(l => l.langCode === langCode), [langCode]);
  const shortBaseSymbol = getShortCurrencySymbol(baseCurrency);
  const tonToken = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(_ref2 => {
    let {
      slug
    } = _ref2;
    return slug === src_config/* TONCOIN */.Tu9.slug;
  }), [tokens]);
  const wallets = teact_useMemo(() => {
    var _versions$filter;
    return (versions === null || versions === void 0 || (_versions$filter = versions.filter(v => v.lastTxId || v.version === 'W5' || withAllWalletVersions)) === null || _versions$filter === void 0 ? void 0 : _versions$filter.map(v => {
      const tonBalance = formatCurrency((0,util_decimals/* toDecimal */.nI)(v.balance), (tonToken === null || tonToken === void 0 ? void 0 : tonToken.symbol) ?? '');
      const balanceInCurrency = formatCurrency((0,util_decimals/* toBig */.CF)(v.balance).mul((tonToken === null || tonToken === void 0 ? void 0 : tonToken.price) ?? 0).round(tonToken === null || tonToken === void 0 ? void 0 : tonToken.decimals), shortBaseSymbol);
      const accountTokens = [tonBalance];
      return {
        address: v.address,
        version: v.version,
        totalBalance: balanceInCurrency,
        tokens: accountTokens
      };
    })) ?? [];
  }, [shortBaseSymbol, tonToken, versions, withAllWalletVersions]);
  const {
    shouldRender: isTelegramLinkRendered,
    ref: telegramLinkRef
  } = useShowTransition({
    isOpen: isTonMagicEnabled,
    withShouldRender: true
  });
  const {
    handleScroll: handleContentScroll,
    isScrolled
  } = useScrolledState();
  const handleSlideAnimationStop = useLastCallback(() => {
    if (prevRenderingKeyRef.current === SettingsState.NativeBiometricsTurnOn) {
      clearIsPinAccepted();
    }
  });
  const handleCloseSettings = useLastCallback(() => {
    closeSettings(undefined, {
      forceOnHeavyAnimation: true
    });
    setSettingsState({
      state: SettingsState.Initial
    });
  });
  useHistoryBack({
    isActive: isActive && isInitialScreen,
    onBack: handleCloseSettings,
    shouldIgnoreForTelegram: isInsideModal
  });
  useHideBottomBar(isOpen && !isInitialScreen);
  const handlCloseDeveloperModal = useLastCallback(() => {
    closeDeveloperModal();
    if (src_config/* IS_CORE_WALLET */.TI6) {
      handleCloseSettings();
    }
  });
  const handleConnectedDappsOpen = useLastCallback(() => {
    getDapps();
    setSettingsState({
      state: SettingsState.Dapps
    });
  });
  function handleAppearanceOpen() {
    setSettingsState({
      state: SettingsState.Appearance
    });
  }
  function handlePushNotificationsOpen() {
    setSettingsState({
      state: SettingsState.PushNotifications
    });
  }
  function handleSecurityOpen() {
    setSettingsState({
      state: SettingsState.Security
    });
  }
  function handleAssetsOpen() {
    setSettingsState({
      state: SettingsState.Assets
    });
  }
  function handleLanguageOpen() {
    setSettingsState({
      state: SettingsState.Language
    });
  }
  function handleAboutOpen() {
    setSettingsState({
      state: SettingsState.About
    });
  }
  function handleDisclaimerOpen() {
    setSettingsState({
      state: SettingsState.Disclaimer
    });
  }
  const handleBackClick = useLastCallback(() => {
    switch (renderingKey) {
      case SettingsState.HiddenNfts:
      case SettingsState.SelectTokenList:
        setSettingsState({
          state: SettingsState.Assets
        });
        break;
      default:
        setSettingsState({
          state: SettingsState.Initial
        });
    }
  });
  const handleBackClickToAssets = useLastCallback(() => {
    setSettingsState({
      state: SettingsState.Assets
    });
  });
  const handleOpenWalletVersion = useLastCallback(() => {
    setSettingsState({
      state: SettingsState.WalletVersion
    });
  });
  const handleDeeplinkHookToggle = useLastCallback(() => {
    toggleDeeplinkHook({
      isEnabled: !isDeeplinkHookEnabled
    });
  });
  const handleTonProxyToggle = useLastCallback(() => {
    toggleTonProxy({
      isEnabled: !isTonProxyEnabled
    });
  });
  const handleTonMagicToggle = useLastCallback(() => {
    toggleTonMagic({
      isEnabled: !isTonMagicEnabled
    });
  });
  function handleClickInstallApp() {
    void openUrl('https://mytonwallet.io/get', {
      isExternal: true
    });
  }
  function handleClickInstallOnDesktop() {
    void openUrl('https://mytonwallet.io/get/desktop', {
      isExternal: true
    });
  }
  function handleClickInstallOnMobile() {
    void openUrl('https://mytonwallet.io/get/mobile', {
      isExternal: true
    });
  }
  const handleAddLedgerWallet = useLastCallback(() => {
    afterSelectHardwareWallets({
      hardwareSelectedIndices: [hardwareWallets[0].index]
    });
    handleCloseSettings();
  });
  const handleLedgerConnected = useLastCallback(isSingleWallet => {
    if (isSingleWallet) {
      handleAddLedgerWallet();
      return;
    }
    setSettingsState({
      state: SettingsState.LedgerSelectWallets
    });
  });
  const [isTrayIconEnabled, setIsTrayIconEnabled] = useState(false);
  teact_useEffect(() => {
    var _window$electron;
    void ((_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.getIsTrayIconEnabled().then(setIsTrayIconEnabled));
  }, []);
  const handleTrayIconEnabledToggle = useLastCallback(() => {
    var _window$electron2;
    setIsTrayIconEnabled(!isTrayIconEnabled);
    void ((_window$electron2 = window.electron) === null || _window$electron2 === void 0 ? void 0 : _window$electron2.setIsTrayIconEnabled(!isTrayIconEnabled));
  });
  const [isAutoUpdateEnabled, setIsAutoUpdateEnabled] = useState(false);
  teact_useEffect(() => {
    var _window$electron3;
    void ((_window$electron3 = window.electron) === null || _window$electron3 === void 0 ? void 0 : _window$electron3.getIsAutoUpdateEnabled().then(setIsAutoUpdateEnabled));
  }, []);
  const handleAutoUpdateEnabledToggle = useLastCallback(() => {
    var _window$electron4;
    setIsAutoUpdateEnabled(!isAutoUpdateEnabled);
    void ((_window$electron4 = window.electron) === null || _window$electron4 === void 0 ? void 0 : _window$electron4.setIsAutoUpdateEnabled(!isAutoUpdateEnabled));
  });
  const handleBackOrCloseAction = useLastCallback(() => {
    if (isInitialScreen) {
      if (isInsideModal) handleCloseSettings();
    } else {
      handleBackClick();
    }
  });
  const handleCloseLogOutModal = useLastCallback(shouldCloseSettings => {
    closeLogOutModal();
    if (shouldCloseSettings) {
      handleCloseSettings();
    }
  });
  function handleOpenHardwareModal() {
    openSettingsHardwareWallet();
  }
  const handleMultipleClick = () => {
    if (clicksAmount + 1 >= AMOUNT_OF_CLICKS_FOR_DEVELOPERS_MODE) {
      openDeveloperModal();
    } else {
      setClicksAmount(clicksAmount + 1);
    }
  };
  const handleShowAllWalletVersions = useLastCallback(() => {
    markWithAllWalletVersions();
    handlCloseDeveloperModal();
    handleOpenWalletVersion();
  });
  teact_useEffect(() => captureEscKeyListener(isInsideModal ? handleBackOrCloseAction : handleBackClick), [isInsideModal]);
  teact_useEffect(() => {
    if (!windowEnvironment/* IS_TOUCH_ENV */.TF) {
      return undefined;
    }
    return captureControlledSwipe(transitionRef.current, {
      onSwipeRightStart: () => {
        if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
          handleBackClick();
        } else {
          handleBackOrCloseAction();
        }
        disableSwipeToClose();
      },
      onCancel: () => {
        setSettingsState({
          state: prevRenderingKeyRef.current
        });
        enableSwipeToClose();
      }
    });
  }, [disableSwipeToClose, enableSwipeToClose, prevRenderingKeyRef]);
  function renderHandleDeeplinkButton() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleDeeplinkHookToggle
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_ton_links_namespaceObject,
      alt: lang('Handle ton:// links')
    }), lang('Handle ton:// links'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Handle ton:// links'),
      checked: isDeeplinkHookEnabled
    }));
  }
  function renderSettings() {
    return /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.slide
    }, isInsideModal ? /*#__PURE__*/teact.createElement(ui_ModalHeader, {
      title: lang('Settings'),
      withNotch: isScrolled,
      onClose: !isPortrait ? handleCloseSettings : undefined,
      className: Settings_module.modalHeader
    }) : /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.header, 'with-notch-on-scroll', isScrolled && 'is-scrolled')
    }, /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      isText: true,
      onClick: handleCloseSettings,
      className: buildClassName(Settings_module.headerBack, isPortrait && Settings_module.hidden)
    }, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevron, 'icon-chevron-left'),
      "aria-hidden": true
    }), /*#__PURE__*/teact.createElement("span", null, lang('Back'))), /*#__PURE__*/teact.createElement("span", {
      className: Settings_module.headerTitle
    }, lang('Settings'))), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.content, 'custom-scroll', Settings_module.withBottomSpace),
      onScroll: handleContentScroll
    }, src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleClickInstallApp
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_mytonwallet_namespaceObject,
      alt: lang('Upgrade to MyTonWallet')
    }), lang('Upgrade to MyTonWallet'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), !src_config/* IS_CORE_WALLET */.TI6 && windowEnvironment/* IS_WEB */.u2 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleClickInstallApp
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_install_app_namespaceObject,
      alt: lang('Install App')
    }), lang('Install App'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), src_config/* IS_EXTENSION */.hL1 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, src_config/* PROXY_HOSTS */.hnd && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleTonProxyToggle
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_ton_proxy_namespaceObject,
      alt: lang('TON Proxy')
    }), lang('TON Proxy'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Toggle TON Proxy'),
      checked: isTonProxyEnabled
    })), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleTonMagicToggle
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_ton_magic_namespaceObject,
      alt: lang('TON Magic')
    }), lang('TON Magic'), /*#__PURE__*/teact.createElement(ui_Switcher, {
      className: Settings_module.menuSwitcher,
      label: lang('Toggle TON Magic'),
      checked: isTonMagicEnabled
    })), isTelegramLinkRendered && /*#__PURE__*/teact.createElement("div", {
      ref: telegramLinkRef,
      className: Settings_module.item,
      onClick: handleOpenTelegramWeb
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_telegram_menu_namespaceObject,
      alt: lang('Open Telegram Web')
    }), lang('Open Telegram Web'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), renderHandleDeeplinkButton()), windowEnvironment/* IS_ELECTRON */.cp && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, renderHandleDeeplinkButton()), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handlePushNotificationsOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_notifications_namespaceObject,
      alt: arePushNotificationsAvailable ? lang('Notifications & Sounds') : lang('Sounds')
    }), arePushNotificationsAvailable ? lang('Notifications & Sounds') : lang('Sounds'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleAppearanceOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_appearance_namespaceObject,
      alt: lang('Appearance')
    }), lang('Appearance'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), !src_config/* SHOULD_SHOW_ALL_ASSETS_AND_ACTIVITY */.K_I && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleAssetsOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_assets_activity_namespaceObject,
      alt: lang('Assets & Activity')
    }), lang('Assets & Activity'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), isPasswordPresent && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleSecurityOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_security_namespaceObject,
      alt: lang('Security')
    }), lang('Security'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), windowEnvironment/* IS_DAPP_SUPPORTED */.ED && !isViewMode && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleConnectedDappsOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_connected_dapps_namespaceObject,
      alt: lang('Connected Dapps')
    }), lang('Connected Dapps'), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.itemInfo
    }, dapps.length ? dapps.length : '', /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleLanguageOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_language_namespaceObject,
      alt: lang('Language')
    }), lang('Language'), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.itemInfo
    }, activeLang === null || activeLang === void 0 ? void 0 : activeLang.name, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })))), (!!(versions !== null && versions !== void 0 && versions.length) || windowEnvironment/* IS_LEDGER_SUPPORTED */.sC) && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, !!(versions !== null && versions !== void 0 && versions.length) && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleOpenWalletVersion
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_wallet_version_namespaceObject,
      alt: lang('Wallet Versions')
    }), lang('Wallet Versions'), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.itemInfo
    }, currentVersion, /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), windowEnvironment/* IS_LEDGER_SUPPORTED */.sC && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleOpenHardwareModal
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_ledger_namespaceObject,
      alt: lang('Connect Ledger')
    }), lang('Connect Ledger'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement(teact.Fragment, null, !isNftBuyingDisabled && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("a", {
      href: src_config/* MTW_CARDS_WEBSITE */.b2d,
      target: "_blank",
      rel: "noopener noreferrer",
      className: Settings_module.item
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_mtw_cards_namespaceObject,
      alt: lang('MyTonWallet Cards NFT')
    }), lang('MyTonWallet Cards NFT'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("a", {
      href: `https://t.me/${src_config/* MTW_TIPS_CHANNEL_NAME */.AIK[langCode] ?? src_config/* MTW_TIPS_CHANNEL_NAME */.AIK.en}`,
      target: "_blank",
      rel: "noopener noreferrer",
      className: Settings_module.item
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_tips_namespaceObject,
      alt: lang('MyTonWallet Tips')
    }), lang('MyTonWallet Tips'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), /*#__PURE__*/teact.createElement("a", {
      href: getHelpCenterUrl(langCode, 'home'),
      target: "_blank",
      rel: "noopener noreferrer",
      className: Settings_module.item
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_helpcenter_namespaceObject,
      alt: lang('Help Center')
    }), lang('Help Center'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), supportAccountsCount > 0 && /*#__PURE__*/teact.createElement("a", {
      href: `https://t.me/${src_config/* SUPPORT_USERNAME */.Fkn}`,
      target: "_blank",
      rel: "noopener noreferrer",
      className: Settings_module.item
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_support_namespaceObject,
      alt: lang('Get Support')
    }), lang('Get Support'), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.itemInfo
    }, /*#__PURE__*/teact.createElement("span", {
      className: Settings_module.small
    }, "@", src_config/* SUPPORT_USERNAME */.Fkn), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))))), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleDisclaimerOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_disclaimer_namespaceObject,
      alt: lang('Use Responsibly')
    }), lang('Use Responsibly'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), !src_config/* IS_CORE_WALLET */.TI6 && src_config/* IS_CAPACITOR */.UMQ && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleClickInstallOnDesktop
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_install_desktop_namespaceObject,
      alt: lang('Install on Desktop')
    }), lang('Install on Desktop'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), !src_config/* IS_CORE_WALLET */.TI6 && windowEnvironment/* IS_ELECTRON */.cp && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleClickInstallOnMobile
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_install_mobile_namespaceObject,
      alt: lang('Install on Mobile')
    }), lang('Install on Mobile'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, !src_config/* IS_CORE_WALLET */.TI6 && src_config/* IS_EXTENSION */.hL1 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleClickInstallApp
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_install_app_namespaceObject,
      alt: lang('Install App')
    }), lang('Install App'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    })), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.item,
      onClick: handleAboutOpen
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_about_namespaceObject,
      alt: ""
    }), lang('About %app_name%', {
      app_name: src_config/* APP_NAME */.C39
    }), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.block
    }, /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Settings_module.item, Settings_module.item_red),
      onClick: openLogOutModal
    }, /*#__PURE__*/teact.createElement("img", {
      className: Settings_module.menuIcon,
      src: settings_exit_namespaceObject,
      alt: lang('Exit')
    }), lang('Exit'), /*#__PURE__*/teact.createElement("i", {
      className: buildClassName(Settings_module.iconChevronRight, 'icon-chevron-right'),
      "aria-hidden": true
    }))), /*#__PURE__*/teact.createElement("div", {
      className: Settings_module.version,
      onClick: handleMultipleClick
    }, src_config/* APP_NAME */.C39, " ", src_config/* APP_VERSION */.hl5, " ", src_config/* APP_ENV_MARKER */.vOV)));
  }
  function renderContent(isSlideActive, isFrom, currentKey) {
    switch (currentKey) {
      case SettingsState.Initial:
        return renderSettings();
      case SettingsState.PushNotifications:
        return /*#__PURE__*/teact.createElement(settings_SettingsPushNotifications, {
          isActive: isActive && isSlideActive,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal
        });
      case SettingsState.Appearance:
        return /*#__PURE__*/teact.createElement(settings_SettingsAppearance, {
          isActive: isActive && isSlideActive,
          theme: theme,
          animationLevel: animationLevel,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal,
          isTrayIconEnabled: isTrayIconEnabled,
          onTrayIconEnabledToggle: handleTrayIconEnabledToggle
        });
      case SettingsState.Assets:
        return /*#__PURE__*/teact.createElement(settings_SettingsAssets, {
          isActive: isActive && isSlideActive,
          isInsideModal: isInsideModal,
          onBack: handleBackClick
        });
      case SettingsState.Security:
        return /*#__PURE__*/teact.createElement(settings_SettingsSecurity, {
          isActive: isActive && isSlideActive,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal,
          isAutoUpdateEnabled: isAutoUpdateEnabled,
          onAutoUpdateEnabledToggle: handleAutoUpdateEnabledToggle,
          onSettingsClose: handleCloseSettings
        });
      case SettingsState.Dapps:
        return /*#__PURE__*/teact.createElement(settings_SettingsDapps, {
          isActive: isActive && isSlideActive,
          dapps: dapps,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal
        });
      case SettingsState.Language:
        return /*#__PURE__*/teact.createElement(settings_SettingsLanguage, {
          isActive: isActive && isSlideActive,
          langCode: langCode,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal
        });
      case SettingsState.About:
        return /*#__PURE__*/teact.createElement(settings_SettingsAbout, {
          isActive: isActive && isSlideActive,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal,
          theme: theme
        });
      case SettingsState.Disclaimer:
        return /*#__PURE__*/teact.createElement(settings_SettingsDisclaimer, {
          isActive: isActive && isSlideActive,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal
        });
      case SettingsState.NativeBiometricsTurnOn:
        return /*#__PURE__*/teact.createElement(biometrics_NativeBiometricsTurnOn, {
          isActive: isActive && isSlideActive,
          isInsideModal: isInsideModal,
          handleBackClick: handleBackClick
        });
      case SettingsState.SelectTokenList:
        return /*#__PURE__*/teact.createElement(settings_SettingsTokenList, {
          isActive: isActive && isSlideActive,
          isInsideModal: isInsideModal,
          handleBackClick: handleBackClickToAssets
        });
      case SettingsState.WalletVersion:
        return /*#__PURE__*/teact.createElement(settings_SettingsWalletVersion, {
          isActive: isActive && isSlideActive,
          currentVersion: currentVersion,
          handleBackClick: handleBackClick,
          isInsideModal: isInsideModal,
          wallets: wallets
        });
      case SettingsState.LedgerConnectHardware:
        return /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.slide
        }, /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive && isSlideActive,
          isStatic: !isInsideModal,
          className: Settings_module.nestedTransition,
          onBackButtonClick: handleBackClick,
          onConnected: handleLedgerConnected,
          onClose: handleBackOrCloseAction
        }));
      case SettingsState.LedgerSelectWallets:
        return /*#__PURE__*/teact.createElement("div", {
          className: Settings_module.slide
        }, /*#__PURE__*/teact.createElement(ledger_LedgerSelectWallets, {
          isActive: isActive && isSlideActive,
          isStatic: !isInsideModal,
          accounts: accounts,
          hardwareWallets: hardwareWallets,
          onBackButtonClick: handleBackClick,
          onClose: handleBackOrCloseAction
        }));
      case SettingsState.HiddenNfts:
        return /*#__PURE__*/teact.createElement(settings_SettingsHiddenNfts, {
          isActive: isActive && isSlideActive,
          handleBackClick: handleBackClickToAssets,
          isInsideModal: isInsideModal
        });
    }
  }
  return /*#__PURE__*/teact.createElement("div", {
    className: Settings_module.wrapper
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    ref: transitionRef,
    name: resolveSlideTransitionName(),
    className: buildClassName(isInsideModal ? Modal_module.transition : Settings_module.transitionContainer, 'custom-scroll'),
    activeKey: renderingKey,
    slideClassName: buildClassName(isInsideModal && Modal_module.transitionSlide),
    withSwipeControl: true,
    onStop: getDoesUsePinPad() ? handleSlideAnimationStop : undefined
  }, renderContent), /*#__PURE__*/teact.createElement(settings_SettingsDeveloperOptions, {
    isOpen: isDeveloperModalOpen,
    isTestnet: isTestnet,
    isCopyStorageEnabled: isCopyStorageEnabled,
    onShowAllWalletVersions: handleShowAllWalletVersions,
    onClose: handlCloseDeveloperModal
  }), /*#__PURE__*/teact.createElement(modals_LogOutModal, {
    isOpen: isLogOutModalOpened,
    onClose: handleCloseLogOutModal
  }), windowEnvironment/* IS_BIOMETRIC_AUTH_SUPPORTED */.uh && /*#__PURE__*/teact.createElement(biometrics_Biometrics, {
    isInsideModal: isInsideModal
  }));
}
/* harmony default export */ const settings_Settings = (memo(withGlobal(global => {
  const isPasswordPresent = selectIsPasswordPresent(global);
  const accounts = selectNetworkAccounts(global);
  const {
    isCopyStorageEnabled,
    supportAccountsCount = 1,
    isNftBuyingDisabled
  } = global.restrictions;
  const {
    currentVersion,
    byId: versionsById
  } = global.walletVersions ?? {};
  const versions = versionsById === null || versionsById === void 0 ? void 0 : versionsById[global.currentAccountId];
  const {
    dapps = MEMO_EMPTY_ARRAY
  } = selectCurrentAccountState(global) || {};
  const {
    hardwareWallets
  } = global.hardware;
  return {
    settings: global.settings,
    dapps,
    isOpen: global.areSettingsOpen,
    tokens: selectCurrentAccountTokens(global),
    isPasswordPresent,
    currentVersion,
    versions,
    isCopyStorageEnabled,
    supportAccountsCount,
    hardwareWallets,
    accounts,
    isNftBuyingDisabled,
    arePushNotificationsAvailable: global.pushNotifications.isAvailable,
    isViewMode: selectIsCurrentAccountViewMode(global)
  };
})(Settings)));
function handleOpenTelegramWeb() {
  window.open(src_config/* TELEGRAM_WEB_URL */.h4K, '_blank', 'noopener');
}
;// ./src/components/settings/SettingsModal.tsx







function SettingsModal(_ref) {
  let {
    children,
    isOpen,
    onClose,
    isMediaViewerOpen
  } = _ref;
  const fullDialogClassName = buildClassName(Settings_module.modalDialog, !(windowEnvironment/* IS_ELECTRON */.cp || src_config/* IS_EXTENSION */.hL1) && Settings_module.modalDialogWeb);
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    hasCloseButton: true,
    isOpen: isOpen && !isMediaViewerOpen,
    dialogClassName: fullDialogClassName,
    contentClassName: Settings_module.modalContent,
    nativeBottomSheetKey: "settings",
    forceFullNative: true,
    onClose: onClose
  }, children);
}
/* harmony default export */ const settings_SettingsModal = (memo(withGlobal(global => {
  return {
    isMediaViewerOpen: Boolean(global.mediaViewer.mediaId)
  };
})(SettingsModal)));
;// ./src/components/swap/SwapBlockchain.tsx

























const SwapBlockchain_SHORT_ADDRESS_SHIFT = 14;
const SwapBlockchain_MIN_ADDRESS_LENGTH_TO_SHORTEN = SwapBlockchain_SHORT_ADDRESS_SHIFT * 2;
function SwapBlockchain(_ref) {
  let {
    isActive,
    swapType,
    toAddress = '',
    tokenIn,
    tokenOut
  } = _ref;
  const {
    cancelSwap,
    setSwapCexAddress,
    showNotification,
    setSwapScreen,
    requestOpenQrScanner
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const toAddressRef = teact_useRef();
  const [shouldRenderPasteButton, setShouldRenderPasteButton] = useState(windowEnvironment/* IS_CLIPBOARDS_SUPPORTED */.Et);
  const [isAddressFocused, markAddressFocused, unmarkAddressFocused] = hooks_useFlag();
  const [hasToAddressError, setHasToAddressError] = useState(false);
  const [canContinue, setCanContinue] = useState(swapType !== SwapType.CrosschainFromWallet);
  const isQrScannerSupported = useQrScannerSupport();
  const withPasteButton = shouldRenderPasteButton && toAddress === '';
  const toAddressShort = toAddress.length > SwapBlockchain_MIN_ADDRESS_LENGTH_TO_SHORTEN ? (0,shortenAddress/* shortenAddress */.W)(toAddress, SwapBlockchain_SHORT_ADDRESS_SHIFT) || '' : toAddress;
  const handleCancelClick = useLastCallback(() => {
    setHasToAddressError(false);
    setCanContinue(false);
    setSwapScreen({
      state: isPortrait ? SwapState.Initial : SwapState.None
    });
  });
  useHistoryBack({
    isActive,
    onBack: handleCancelClick
  });
  const handleAddressFocus = useLastCallback(() => {
    const el = toAddressRef.current;

    // `selectionStart` is only updated in the next frame after `focus` event
    requestAnimationFrame(() => {
      const caretPosition = el.selectionStart;
      markAddressFocused();

      // Restore caret position after input field value has been focused and expanded
      requestAnimationFrame(() => {
        const newCaretPosition = caretPosition <= SwapBlockchain_SHORT_ADDRESS_SHIFT + 3 ? caretPosition : Math.max(0, el.value.length - (toAddressShort.length - caretPosition));
        el.setSelectionRange(newCaretPosition, newCaretPosition);
        if (newCaretPosition > SwapBlockchain_SHORT_ADDRESS_SHIFT * 2) {
          el.scrollLeft = el.scrollWidth - el.clientWidth;
        }
      });
    });
  });
  const validateToAddress = useLastCallback(async address => {
    if (!address.length) {
      setHasToAddressError(false);
      setCanContinue(false);
      return;
    }
    const response = await (0,api/* callApi */.p)('swapCexValidateAddress', {
      slug: tokenOut.slug,
      address
    });
    if (!response) {
      setHasToAddressError(false);
      setCanContinue(false);
      return;
    }
    setHasToAddressError(!response.result);
    setCanContinue(response.result);
  });
  const handleAddressBlur = useLastCallback(() => {
    unmarkAddressFocused();
  });
  const handleAddressInput = useLastCallback(newToAddress => {
    setSwapCexAddress({
      toAddress: newToAddress.trim()
    });
  });
  const handlePasteClick = useLastCallback(async () => {
    try {
      const {
        type,
        text
      } = await readClipboardContent();
      if (type === 'text/plain') {
        setSwapCexAddress({
          toAddress: text.trim()
        });
        await validateToAddress(text.trim());
      }
    } catch (error) {
      showNotification({
        message: lang('Error reading clipboard')
      });
      setShouldRenderPasteButton(false);
    }
  });
  teact_useEffect(() => {
    void validateToAddress(toAddress);
  }, [toAddress, validateToAddress]);
  const submitPassword = useLastCallback(() => {
    void vibrate();
    setSwapScreen({
      state: SwapState.Password
    });
  });
  const handleQrScanClick = useLastCallback(() => {
    if (windowEnvironment/* IS_IOS */.pz && (0,windowEnvironment/* getIsMobileTelegramApp */.v3)()) {
      alert('Scanning is temporarily not available');
      return;
    }
    requestOpenQrScanner();
    cancelSwap();
  });
  function renderInfo() {
    const text = hasToAddressError ? lang('Incorrect address.') : lang('Please provide an address of your wallet in %blockchain% blockchain to receive bought tokens.', {
      blockchain: getChainNetworkName(tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.chain)
    });
    return /*#__PURE__*/teact.createElement(ui_Transition, {
      name: "fade",
      activeKey: hasToAddressError ? 0 : 1,
      slideClassName: Swap_module.blockchainHintWrapper
    }, /*#__PURE__*/teact.createElement("span", {
      className: buildClassName(Swap_module.blockchainHintText, hasToAddressError && Swap_module.blockchainHintTextError)
    }, text));
  }
  function renderInputAddress() {
    if (swapType !== SwapType.CrosschainFromWallet) return undefined;
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.inputAddress
    }, /*#__PURE__*/teact.createElement(ui_Input, {
      ref: toAddressRef,
      isRequired: true,
      placeholder: lang('Your address on another blockchain'),
      value: isAddressFocused ? toAddress : toAddressShort,
      onInput: handleAddressInput,
      onFocus: handleAddressFocus,
      onBlur: handleAddressBlur,
      wrapperClassName: Swap_module.inputAddressWrapper
    }, isQrScannerSupported && /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      className: buildClassName(Swap_module.inputButton, withPasteButton && Swap_module.inputButtonShifted),
      onClick: handleQrScanClick,
      ariaLabel: lang('Scan QR Code')
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-qr-scanner-alt",
      "aria-hidden": true
    })), withPasteButton && /*#__PURE__*/teact.createElement(ui_Button, {
      isSimple: true,
      className: Swap_module.inputButton,
      onClick: handlePasteClick,
      ariaLabel: lang('Paste')
    }, /*#__PURE__*/teact.createElement("i", {
      className: "icon-paste",
      "aria-hidden": true
    })))), renderInfo());
  }
  const title = lang('$swap_from_to', {
    from: tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol,
    icon: /*#__PURE__*/teact.createElement("i", {
      className: buildClassName('icon-chevron-right', Swap_module.swapArrowIcon),
      "aria-hidden": true
    }),
    to: tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.symbol
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: title,
    onClose: cancelSwap
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Swap_module.scrollContent, Swap_module.selectBlockchainBlock, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    noLoop: false,
    nonInteractive: true,
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview,
    size: src_config/* ANIMATED_STICKER_BIG_SIZE_PX */.igk
  }), renderInputAddress(), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Swap_module.blockchainButtons, Modal_module.footerButtons)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: handleCancelClick,
    className: Modal_module.buttonHalfWidth
  }, lang('Close')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isDisabled: !canContinue,
    className: Modal_module.buttonHalfWidth,
    onClick: submitPassword
  }, lang('Continue')))));
}
/* harmony default export */ const swap_SwapBlockchain = (memo(SwapBlockchain));
;// ./src/components/common/SwapResult.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const SwapResult_module = ({"sticker":"SwapResult-module__sticker","buttons":"SwapResult-module__buttons","button":"SwapResult-module__button","changellyInfoBlock":"SwapResult-module__changellyInfoBlock","changellyDescription":"SwapResult-module__changellyDescription","changellyDescriptionBold":"SwapResult-module__changellyDescriptionBold","changellyTextField":"SwapResult-module__changellyTextField"});
;// ./src/components/common/SwapResult.tsx













function SwapResult(_ref) {
  let {
    tokenIn,
    tokenOut,
    amountIn,
    amountOut,
    playAnimation,
    firstButtonText,
    secondButtonText,
    swapType,
    toAddress = '',
    addressByChain,
    isSensitiveDataHidden,
    onFirstButtonClick,
    onSecondButtonClick,
    isFirstButtonDisabled
  } = _ref;
  const lang = hooks_useLang();
  const isInternalSwap = getIsInternalSwap({
    from: tokenIn,
    to: tokenOut,
    toAddress,
    addressByChain
  });
  const isToAddressInCurrentWallet = teact_useMemo(() => {
    return Boolean(toAddress && Object.values(addressByChain ?? {}).some(address => address === toAddress));
  }, [addressByChain, toAddress]);
  function renderButtons() {
    if (!firstButtonText && !secondButtonText) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement("div", {
      className: SwapResult_module.buttons
    }, firstButtonText && /*#__PURE__*/teact.createElement(ui_Button, {
      className: SwapResult_module.button,
      onClick: onFirstButtonClick,
      isDisabled: isFirstButtonDisabled
    }, firstButtonText), secondButtonText && /*#__PURE__*/teact.createElement(ui_Button, {
      className: SwapResult_module.button,
      onClick: onSecondButtonClick
    }, secondButtonText));
  }
  function renderSticker() {
    if (swapType === SwapType.CrosschainFromWallet && !isInternalSwap) return undefined;
    return /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
      play: playAnimation,
      noLoop: false,
      nonInteractive: true,
      className: SwapResult_module.sticker,
      tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
      previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
    });
  }
  function renderTimeWarning() {
    return /*#__PURE__*/teact.createElement("div", {
      className: SwapResult_module.changellyInfoBlock
    }, /*#__PURE__*/teact.createElement("span", {
      className: SwapResult_module.changellyDescription
    }, lang('Please note that it may take up to a few hours for tokens to appear in your wallet.')));
  }
  function renderChangellyInfo() {
    if (swapType !== SwapType.CrosschainFromWallet || isToAddressInCurrentWallet) {
      return undefined;
    }
    const chain = getIsSupportedChain(tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.chain) ? tokenOut.chain : undefined;
    return /*#__PURE__*/teact.createElement("div", {
      className: SwapResult_module.changellyInfoBlock
    }, /*#__PURE__*/teact.createElement("span", {
      className: SwapResult_module.changellyDescription
    }, lang('$swap_changelly_from_ton_description', {
      blockchain: /*#__PURE__*/teact.createElement("span", {
        className: SwapResult_module.changellyDescriptionBold
      }, getChainNetworkName(tokenOut === null || tokenOut === void 0 ? void 0 : tokenOut.chain))
    })), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      chain: chain,
      address: toAddress,
      copyNotification: lang('Address was copied!'),
      noSavedAddress: true,
      noExplorer: true,
      className: SwapResult_module.changellyTextField
    }));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, renderSticker(), /*#__PURE__*/teact.createElement(common_SwapTokensInfo, {
    isSensitiveDataHidden: isSensitiveDataHidden,
    tokenIn: tokenIn,
    amountIn: amountIn,
    tokenOut: tokenOut,
    amountOut: amountOut
  }), swapType !== SwapType.OnChain && renderTimeWarning(), renderChangellyInfo(), renderButtons());
}
/* harmony default export */ const common_SwapResult = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  return {
    addressByChain: (_selectCurrentAccount = selectCurrentAccount(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.addressByChain,
    isSensitiveDataHidden: global.settings.isSensitiveDataHidden
  };
})(SwapResult)));
;// ./src/components/swap/SwapComplete.tsx









function SwapComplete(_ref) {
  let {
    isActive,
    tokenIn,
    tokenOut,
    amountIn,
    amountOut,
    swapType,
    toAddress,
    onInfoClick,
    onStartSwap,
    onClose,
    isDetailsDisabled
  } = _ref;
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Swap Placed'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Swap_module.scrollContent, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(common_SwapResult, {
    tokenIn: tokenIn,
    amountIn: amountIn,
    tokenOut: tokenOut,
    amountOut: amountOut,
    swapType: swapType,
    toAddress: toAddress,
    playAnimation: isActive,
    firstButtonText: lang('Details'),
    secondButtonText: lang('Repeat'),
    onFirstButtonClick: onInfoClick,
    onSecondButtonClick: onStartSwap,
    isFirstButtonDisabled: isDetailsDisabled
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    isPrimary: true
  }, lang('Close')))));
}
/* harmony default export */ const swap_SwapComplete = (memo(SwapComplete));
;// ./src/components/swap/SwapPassword.tsx








function SwapPassword(_ref) {
  let {
    isActive,
    isLoading,
    error,
    children,
    onSubmit,
    onBack
  } = _ref;
  const {
    cancelSwap,
    clearSwapError
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Confirm Swap'),
    onClose: cancelSwap
  }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
    isActive: isActive,
    isLoading: isLoading,
    withCloseButton: src_config/* IS_CAPACITOR */.UMQ,
    error: error,
    operationType: "swap",
    submitLabel: lang('Swap'),
    cancelLabel: lang('Back'),
    onSubmit: onSubmit,
    onCancel: onBack,
    onUpdate: clearSwapError,
    skipAuthScreen: true
  }, children));
}
/* harmony default export */ const swap_SwapPassword = (memo(SwapPassword));
;// ./src/components/swap/SwapWaitTokens.tsx


















function SwapWaitTokens(_ref) {
  let {
    isActive,
    tokenIn,
    tokenOut,
    amountIn,
    amountOut,
    payinAddress,
    payoutAddress,
    payinExtraId,
    activity,
    addressByChain,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const [isExpired, setIsExpired] = useState(false);
  const timestamp = teact_useMemo(() => Date.now(), []);
  const {
    qrCodeRef,
    isInitialized
  } = useQrCode({
    address: payinAddress,
    isActive,
    hiddenClassName: Swap_module.qrCodeHidden,
    hideLogo: true
  });
  const shouldShowQrCode = !payinExtraId;
  const isInternalSwap = getIsInternalSwap({
    from: tokenIn,
    to: tokenOut,
    toAddress: payoutAddress,
    addressByChain
  });
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  const handleTimeout = useLastCallback(() => {
    setIsExpired(true);
  });
  function renderMemo() {
    if (!payinExtraId) return undefined;
    return /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.textFieldWrapperFullWidth
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.textFieldLabel
    }, lang('Memo')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      chain: "ton",
      address: payinExtraId,
      copyNotification: lang('Memo was copied!'),
      noSavedAddress: true,
      noExplorer: true,
      className: Swap_module.changellyTextField
    }));
  }
  function renderInfo() {
    if (isExpired) {
      var _activity$cex;
      const cexTransactionId = activity && 'cex' in activity ? (_activity$cex = activity.cex) === null || _activity$cex === void 0 ? void 0 : _activity$cex.transactionId : undefined;
      return /*#__PURE__*/teact.createElement("div", {
        className: Swap_module.changellyInfoBlock
      }, /*#__PURE__*/teact.createElement("span", {
        className: Swap_module.changellyImportantRed
      }, lang('The time for sending coins is over.')), /*#__PURE__*/teact.createElement("span", {
        className: Swap_module.changellyDescription
      }, lang('$swap_changelly_support', {
        livechat: /*#__PURE__*/teact.createElement("a", {
          href: src_config/* CHANGELLY_LIVE_CHAT_URL */.o$d,
          target: "_blank",
          rel: "noreferrer",
          className: Swap_module.changellyDescriptionBold
        }, lang('Changelly Live Chat')),
        email: /*#__PURE__*/teact.createElement("span", {
          className: Swap_module.changellyDescriptionBold
        }, src_config/* CHANGELLY_SUPPORT_EMAIL */.HWN)
      })), cexTransactionId && /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
        text: cexTransactionId,
        copyNotification: lang('Transaction ID was copied!'),
        noSavedAddress: true,
        noExplorer: true,
        className: Swap_module.changellyTextField
      }));
    }
    if (isInternalSwap) {
      return /*#__PURE__*/teact.createElement("div", {
        className: Swap_module.changellyInfoBlock
      }, /*#__PURE__*/teact.createElement("span", {
        className: Swap_module.changellyDescription
      }, lang('Please note that it may take up to a few hours for tokens to appear in your wallet.')));
    }
    const chain = getIsSupportedChain(tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.chain) ? tokenIn.chain : undefined;
    return /*#__PURE__*/teact.createElement("div", {
      className: Swap_module.changellyInfoBlock
    }, /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.changellyDescription
    }, lang('$swap_changelly_to_ton_description1', {
      value: /*#__PURE__*/teact.createElement("span", {
        className: Swap_module.changellyDescriptionBold
      }, formatCurrencyExtended(Number(amountIn), (tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.symbol) ?? '', true)),
      blockchain: /*#__PURE__*/teact.createElement("span", {
        className: Swap_module.changellyDescriptionBold
      }, getChainNetworkName(tokenIn === null || tokenIn === void 0 ? void 0 : tokenIn.chain)),
      time: /*#__PURE__*/teact.createElement(common_Countdown, {
        timestamp: timestamp,
        deadline: src_config/* CHANGELLY_WAITING_DEADLINE */.JWy,
        onCompleted: handleTimeout
      })
    })), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
      chain: chain,
      address: payinAddress,
      copyNotification: lang('Address was copied!'),
      noSavedAddress: true,
      noExplorer: true,
      noDimming: true,
      className: Swap_module.changellyTextField
    }), renderMemo(), shouldShowQrCode && /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Swap_module.qrCode, !isInitialized && Swap_module.qrCodeHidden),
      ref: qrCodeRef
    }), /*#__PURE__*/teact.createElement("span", {
      className: Swap_module.changellyDescription
    }, lang('Please note that it may take up to a few hours for tokens to appear in your wallet.')));
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang(isExpired ? 'Swap Expired' : isInternalSwap ? 'Swapping' : 'Waiting for Payment'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Swap_module.scrollContent, Swap_module.selectBlockchainBlock, 'custom-scroll')
  }, /*#__PURE__*/teact.createElement(common_SwapTokensInfo, {
    tokenIn: tokenIn,
    amountIn: amountIn,
    tokenOut: tokenOut,
    amountOut: amountOut
  }), /*#__PURE__*/teact.createElement(ui_Transition, {
    name: "fade",
    activeKey: isExpired ? 1 : 0
  }, renderInfo()), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    onClick: onClose
  }, lang('Close')))));
}
/* harmony default export */ const swap_SwapWaitTokens = (memo(SwapWaitTokens));
;// ./src/components/swap/SwapModal.tsx
























const SwapModal_FULL_SIZE_NBS_STATES = [SwapState.Password, SwapState.SelectTokenFrom, SwapState.SelectTokenTo];
function SwapModal(_ref) {
  let {
    currentSwap: {
      state,
      tokenInSlug,
      tokenOutSlug,
      amountIn = '0',
      amountOut = '0',
      isLoading,
      error,
      activityId,
      toAddress,
      payinAddress,
      payoutAddress,
      payinExtraId,
      shouldResetOnClose
    },
    swapType,
    swapTokens,
    activityById,
    addressByChain
  } = _ref;
  const {
    startSwap,
    cancelSwap,
    setSwapScreen,
    submitSwap,
    showActivityInfo,
    submitSwapCex,
    addSwapToken,
    setSwapTokenIn,
    setSwapTokenOut
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const isOpen = state !== SwapState.None;
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  const tokenIn = teact_useMemo(() => swapTokens === null || swapTokens === void 0 ? void 0 : swapTokens.find(token => token.slug === tokenInSlug), [tokenInSlug, swapTokens]);
  const tokenOut = teact_useMemo(() => swapTokens === null || swapTokens === void 0 ? void 0 : swapTokens.find(token => token.slug === tokenOutSlug), [swapTokens, tokenOutSlug]);
  const [renderedSwapType, setRenderedSwapType] = useState(swapType);
  const [renderedTransactionAmountIn, setRenderedTransactionAmountIn] = useState(amountIn);
  const [renderedTransactionAmountOut, setRenderedTransactionAmountOut] = useState(amountOut);
  const [renderedTransactionTokenIn, setRenderedTransactionTokenIn] = useState(tokenIn);
  const [renderedTransactionTokenOut, setRenderedTransactionTokenOut] = useState(tokenOut);
  const [renderedActivity, setRenderedActivity] = useState();
  teact_useEffect(() => {
    if (!isOpen || !activityId || !(activityById !== null && activityById !== void 0 && activityById[activityId])) {
      setRenderedActivity(undefined);
      return;
    }
    const activity = activityById[activityId];
    setRenderedActivity(activity);
    if (activity.kind === 'swap' && swapType === SwapType.CrosschainToWallet) {
      var _activity$cex;
      const status = (_activity$cex = activity.cex) === null || _activity$cex === void 0 ? void 0 : _activity$cex.status;
      if (status === 'exchanging' || status === 'confirming') {
        setSwapScreen({
          state: SwapState.Complete
        });
      }
    }
  }, [activityById, activityId, isOpen, swapType]);
  const handleTransferSubmit = useLastCallback(password => {
    setRenderedTransactionAmountIn(amountIn);
    setRenderedTransactionAmountOut(amountOut);
    setRenderedTransactionTokenIn(tokenIn);
    setRenderedTransactionTokenOut(tokenOut);
    setRenderedSwapType(swapType);
    if (swapType === SwapType.OnChain) {
      submitSwap({
        password
      });
      return;
    }
    submitSwapCex({
      password
    });
  });
  const handleBackClick = useLastCallback(() => {
    if (state === SwapState.Password) {
      if (swapType === SwapType.CrosschainFromWallet) {
        setSwapScreen({
          state: SwapState.Blockchain
        });
      } else {
        setSwapScreen({
          state: isPortrait ? SwapState.Initial : SwapState.None
        });
      }
      return;
    }
    if (state === SwapState.SelectTokenTo || state === SwapState.SelectTokenFrom) {
      setSwapScreen({
        state: isPortrait ? SwapState.Initial : SwapState.None
      });
    }
    if (state === SwapState.Blockchain) {
      setSwapScreen({
        state: isPortrait ? SwapState.Initial : SwapState.None
      });
    }
  });
  const handleTransactionInfoClick = useLastCallback(() => {
    if (!activityId) return;
    cancelSwap({
      shouldReset: true
    });
    showActivityInfo({
      id: activityId
    });
  });
  const handleModalClose = useLastCallback(() => {
    cancelSwap({
      shouldReset: isPortrait || shouldResetOnClose
    });
    updateNextKey();
  });
  const handleModalCloseWithReset = useLastCallback(() => {
    cancelSwap({
      shouldReset: true
    });
  });
  const handleTokenSelect = useLastCallback(token => {
    addSwapToken({
      token: token
    });
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    const setToken = renderingKey === SwapState.SelectTokenTo ? setSwapTokenOut : setSwapTokenIn;
    setToken({
      tokenSlug: token.slug
    });
  });
  const handleStartSwap = useLastCallback(() => {
    startSwap({
      amountIn: renderedTransactionAmountIn,
      tokenInSlug: renderedTransactionTokenIn === null || renderedTransactionTokenIn === void 0 ? void 0 : renderedTransactionTokenIn.slug,
      tokenOutSlug: renderedTransactionTokenOut === null || renderedTransactionTokenOut === void 0 ? void 0 : renderedTransactionTokenOut.slug
    });
  });
  function renderSwapShortInfo() {
    if (!tokenIn || !tokenOut || !amountIn || !amountOut) return undefined;
    return /*#__PURE__*/teact.createElement(common_TransactionBanner, {
      tokenIn: tokenIn,
      withChainIcon: true,
      tokenOut: tokenOut,
      text: formatCurrencyExtended(amountIn, tokenIn.symbol ?? '', true),
      secondText: formatCurrencyExtended(amountOut, tokenOut.symbol ?? '', true),
      className: !getDoesUsePinPad() ? Swap_module.transactionBanner : undefined
    });
  }
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case SwapState.Initial:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang('$swap_action'),
          onClose: cancelSwap
        }), /*#__PURE__*/teact.createElement(swap_SwapInitial, {
          isActive: isActive
        }));
      case SwapState.Blockchain:
        return /*#__PURE__*/teact.createElement(swap_SwapBlockchain, {
          isActive: isActive,
          toAddress: toAddress,
          tokenIn: tokenIn,
          tokenOut: tokenOut,
          swapType: swapType
        });
      case SwapState.WaitTokens:
        return /*#__PURE__*/teact.createElement(swap_SwapWaitTokens, {
          isActive: isActive,
          tokenIn: renderedTransactionTokenIn,
          tokenOut: renderedTransactionTokenOut,
          amountIn: renderedTransactionAmountIn,
          amountOut: renderedTransactionAmountOut,
          payinAddress: payinAddress,
          payoutAddress: payoutAddress,
          payinExtraId: payinExtraId,
          addressByChain: addressByChain,
          activity: renderedActivity,
          onClose: handleModalCloseWithReset
        });
      case SwapState.Password:
        return /*#__PURE__*/teact.createElement(swap_SwapPassword, {
          isActive: isActive,
          isLoading: isLoading,
          error: error,
          onSubmit: handleTransferSubmit,
          onBack: handleBackClick
        }, renderSwapShortInfo());
      case SwapState.Complete:
        {
          return /*#__PURE__*/teact.createElement(swap_SwapComplete, {
            isActive: isActive,
            tokenIn: renderedTransactionTokenIn,
            tokenOut: renderedTransactionTokenOut,
            amountIn: renderedTransactionAmountIn,
            amountOut: renderedTransactionAmountOut,
            swapType: renderedSwapType,
            toAddress: toAddress,
            onClose: handleModalCloseWithReset,
            onInfoClick: handleTransactionInfoClick,
            onStartSwap: handleStartSwap,
            isDetailsDisabled: !activityId
          });
        }
      case SwapState.SelectTokenFrom:
      case SwapState.SelectTokenTo:
        return /*#__PURE__*/teact.createElement(common_TokenSelector, {
          isActive: isActive,
          shouldUseSwapTokens: true,
          shouldFilter: currentKey === SwapState.SelectTokenTo,
          onTokenSelect: handleTokenSelect,
          onBack: handleBackClick,
          onClose: handleModalCloseWithReset
        });
    }
  }
  const forceFullNative = SwapModal_FULL_SIZE_NBS_STATES.includes(renderingKey)
  // Crosschain exchanges have additional information that may cause the height of the modal to be insufficient
  // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
  || renderingKey === SwapState.Complete && renderedSwapType !== SwapType.OnChain;
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen,
    onClose: cancelSwap,
    noBackdropClose: true,
    dialogClassName: Swap_module.modalDialog,
    nativeBottomSheetKey: "swap",
    forceFullNative: forceFullNative,
    hasCloseButton: true,
    onCloseAnimationEnd: handleModalClose
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const swap_SwapModal = (memo(withGlobal(global => {
  var _accountState$activit;
  const accountState = selectCurrentAccountState(global);
  const account = selectCurrentAccount(global);
  const activityById = accountState === null || accountState === void 0 || (_accountState$activit = accountState.activities) === null || _accountState$activit === void 0 ? void 0 : _accountState$activit.byId;
  return {
    currentSwap: global.currentSwap,
    swapType: selectSwapType(global),
    swapTokens: selectSwapTokens(global),
    activityById,
    addressByChain: account === null || account === void 0 ? void 0 : account.addressByChain
  };
})(SwapModal)));
;// ./src/components/transfer/TransferComplete.tsx

















function TransferComplete(_ref) {
  let {
    isActive,
    amount,
    symbol,
    txId,
    tokenSlug,
    toAddress,
    comment,
    decimals,
    nfts,
    onInfoClick,
    onClose
  } = _ref;
  const {
    startTransfer
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const isNftTransfer = Boolean(nfts === null || nfts === void 0 ? void 0 : nfts.length);
  useHistoryBack({
    isActive,
    onBack: onClose
  });
  teact_useEffect(() => {
    return isActive ? captureKeyboardListeners({
      onEnter: onClose
    }) : undefined;
  }, [isActive, onClose]);
  const handleTransactionRepeatClick = useLastCallback(() => {
    startTransfer({
      isPortrait,
      tokenSlug,
      toAddress,
      amount,
      comment
    });
  });
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang(isNftTransfer ? 'NFT has been sent!' : 'Coins have been sent!'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContent
  }, isNftTransfer ? /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    play: isActive,
    noLoop: false,
    nonInteractive: true,
    className: TransferResult_module.sticker,
    tgsUrl: ANIMATED_STICKERS_PATHS.thumbUp,
    previewUrl: ANIMATED_STICKERS_PATHS.thumbUpPreview
  }), nfts.length === 1 ? /*#__PURE__*/teact.createElement(transfer_NftInfo, {
    nft: nfts[0]
  }) : /*#__PURE__*/teact.createElement(transfer_NftChips, {
    nfts: nfts
  }), Boolean(txId) && /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(TransferResult_module.buttons, TransferResult_module.buttonsAfterNft)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: TransferResult_module.button,
    onClick: onInfoClick
  }, lang('Details')))) : /*#__PURE__*/teact.createElement(common_TransferResult, {
    playAnimation: isActive,
    amount: amount ? -amount : undefined,
    tokenSymbol: symbol,
    firstButtonText: txId ? lang('Details') : undefined,
    secondButtonText: lang('Repeat'),
    onFirstButtonClick: onInfoClick,
    onSecondButtonClick: handleTransactionRepeatClick,
    decimals: decimals
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    isPrimary: true
  }, lang('Close')))));
}
/* harmony default export */ const transfer_TransferComplete = (memo(TransferComplete));
;// ./src/components/ui/AmountWithFeeTextField.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const AmountWithFeeTextField_module = ({"root":"AmountWithFeeTextField-module__root","suffix":"AmountWithFeeTextField-module__suffix","label":"AmountWithFeeTextField-module__label","feeLabel":"AmountWithFeeTextField-module__feeLabel","feeConfirm":"AmountWithFeeTextField-module__feeConfirm"});
;// ./src/components/ui/AmountWithFeeTextField.tsx





function AmountWithFeeTextField(_ref) {
  let {
    amount,
    label,
    currency = '',
    symbol,
    fractionDigits,
    feeText,
    className,
    labelClassName
  } = _ref;
  const lang = hooks_useLang();
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(AmountWithFeeTextField_module.label, labelClassName)
  }, label), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(AmountWithFeeTextField_module.root, className)
  }, formatCurrencyExtended(amount, currency, true, fractionDigits), symbol && /*#__PURE__*/teact.createElement("span", {
    className: AmountWithFeeTextField_module.suffix
  }, symbol), Boolean(feeText) && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
    className: AmountWithFeeTextField_module.feeLabel
  }, lang('Fee')), /*#__PURE__*/teact.createElement("span", {
    className: AmountWithFeeTextField_module.feeConfirm
  }, feeText))));
}
/* harmony default export */ const ui_AmountWithFeeTextField = (memo(AmountWithFeeTextField));
;// ./src/components/transfer/TransferConfirm.tsx


























function TransferConfirm(_ref) {
  let {
    currentTransfer: {
      tokenSlug,
      amount,
      toAddress,
      resolvedAddress,
      fee,
      realFee,
      comment,
      shouldEncrypt,
      promiseId,
      isLoading,
      toAddressName,
      isToNewAddress,
      isScam,
      binPayload,
      nfts,
      isGaslessWithStars,
      diesel,
      stateInit
    },
    token,
    currentAccountId,
    accounts,
    isActive,
    savedAddresses,
    onBack,
    onClose
  } = _ref;
  const {
    submitTransferConfirm
  } = getActions();
  const lang = hooks_useLang();
  const isNftTransfer = Boolean(nfts === null || nfts === void 0 ? void 0 : nfts.length);
  if (isNftTransfer) {
    tokenSlug = src_config/* TONCOIN */.Tu9.slug;
  }
  const chain = getChainBySlug(tokenSlug);
  const localAddressName = teact_useMemo(() => getLocalAddressName({
    address: toAddress,
    chain,
    currentAccountId,
    accounts: accounts,
    savedAddresses
  }), [accounts, chain, currentAccountId, savedAddresses, toAddress]);
  const addressName = localAddressName || toAddressName;
  const isBurning = resolvedAddress === src_config/* BURN_ADDRESS */.pV9;
  const isNotcoinBurning = resolvedAddress === src_config/* NOTCOIN_EXCHANGERS */.WVU[0];
  const explainedFee = explainApiTransferFee({
    fee,
    realFee,
    diesel,
    tokenSlug
  });
  useHistoryBack({
    isActive,
    onBack
  });
  const handleConfirm = useLastCallback(() => {
    void vibrate();
    submitTransferConfirm();
  });
  function renderNfts() {
    if (nfts.length === 1) {
      return /*#__PURE__*/teact.createElement(transfer_NftInfo, {
        nft: nfts[0],
        withMediaViewer: true
      });
    }
    return /*#__PURE__*/teact.createElement(transfer_NftChips, {
      nfts: nfts
    });
  }
  function renderAmountWithFee() {
    if (!explainedFee.realFee || !token) {
      return undefined;
    }
    const feeText = /*#__PURE__*/teact.createElement(ui_Fee, {
      terms: explainedFee.realFee.terms,
      precision: explainedFee.realFee.precision,
      token: token,
      symbolClassName: Transfer_module.currencySymbol
    });
    return isNftTransfer ? /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, lang('Fee')), /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.inputReadOnly
    }, feeText)) : /*#__PURE__*/teact.createElement(ui_AmountWithFeeTextField, {
      label: lang('Amount'),
      amount: (0,util_decimals/* toDecimal */.nI)(amount ?? 0n, token === null || token === void 0 ? void 0 : token.decimals),
      symbol: (token === null || token === void 0 ? void 0 : token.symbol) ?? '',
      feeText: feeText,
      fractionDigits: token === null || token === void 0 ? void 0 : token.decimals
    });
  }
  function renderComment() {
    if (binPayload || stateInit) {
      return /*#__PURE__*/teact.createElement(teact.Fragment, null, binPayload && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
        className: Transfer_module.label
      }, lang('Signing Data')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
        text: binPayload,
        copyNotification: lang('Data was copied!'),
        className: Transfer_module.addressWidget
      })), stateInit && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
        className: Transfer_module.label
      }, lang('Contract Initialization Data')), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
        text: stateInit,
        copyNotification: lang('Data was copied!'),
        className: Transfer_module.addressWidget
      })), /*#__PURE__*/teact.createElement("div", {
        className: Transfer_module.error
      }, renderText(lang('$signature_warning'))));
    }
    if (!comment) {
      return undefined;
    }
    return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement("div", {
      className: Transfer_module.label
    }, shouldEncrypt ? lang('Encrypted Message') : lang('Comment or Memo')), /*#__PURE__*/teact.createElement("div", {
      className: buildClassName(Transfer_module.inputReadOnly, Transfer_module.inputReadOnly_words, Transfer_module.commentInputWrapper)
    }, comment));
  }
  const burningDurationMin = nfts !== null && nfts !== void 0 && nfts.length ? Math.ceil(nfts.length / src_config/* NFT_BATCH_SIZE */.gR8) * src_config/* BURN_CHUNK_DURATION_APPROX_SEC */.WHY / 60 : undefined;
  const submitBtnText = lang(isBurning || isNotcoinBurning ? isNftTransfer ? 'Burn NFT' : 'Burn' : isGaslessWithStars ? 'Pay fee with %stars_symbol%' : 'Confirm', isGaslessWithStars ? {
    stars_symbol: src_config/* STARS_SYMBOL */.xFF
  } : undefined);
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang('Is it all ok?'),
    onClose: onClose
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContent
  }, isNftTransfer ? renderNfts() : /*#__PURE__*/teact.createElement(ui_AnimatedIconWithPreview, {
    size: src_config/* ANIMATED_STICKER_SMALL_SIZE_PX */.jzp,
    play: isActive,
    noLoop: false,
    nonInteractive: true,
    className: buildClassName(Transfer_module.sticker, Transfer_module.sticker_sizeSmall),
    tgsUrl: ANIMATED_STICKERS_PATHS.bill,
    previewUrl: ANIMATED_STICKERS_PATHS.billPreview
  }), /*#__PURE__*/teact.createElement("div", {
    className: Transfer_module.label
  }, lang('Receiving Address'), ' ', isToNewAddress && /*#__PURE__*/teact.createElement(ui_IconWithTooltip, {
    emoji: "\u26A0\uFE0F",
    size: "small",
    message: lang('This address is new and never received transfers before.'),
    tooltipClassName: Transfer_module.warningTooltipContainer
  })), /*#__PURE__*/teact.createElement(ui_InteractiveTextField, {
    chain: chain,
    address: resolvedAddress,
    addressName: addressName,
    isScam: isScam,
    copyNotification: lang('Address was copied!'),
    className: Transfer_module.addressWidget
  }), renderAmountWithFee(), renderComment(), nfts && (isBurning || isNotcoinBurning && (nfts === null || nfts === void 0 ? void 0 : nfts.length) > 1) && /*#__PURE__*/teact.createElement("div", {
    className: Transfer_module.burnWarning
  }, (nfts === null || nfts === void 0 ? void 0 : nfts.length) === 1 ? renderText(lang('Are you sure you want to burn this NFT? It will be lost forever.')) : [renderText(lang('$multi_burn_nft_warning', {
    amount: nfts.length
  })), ' ', renderText(lang('$multi_send_nft_warning', {
    duration: burningDurationMin
  }))]), /*#__PURE__*/teact.createElement("div", {
    className: buildClassName(Modal_module.buttons, Modal_module.buttonsInsideContentWithScroll)
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    className: Modal_module.button,
    onClick: promiseId ? onClose : onBack
  }, promiseId ? lang('Cancel') : lang('Edit')), /*#__PURE__*/teact.createElement(ui_Button, {
    isPrimary: true,
    isLoading: isLoading,
    isDestructive: isBurning || isScam,
    className: Modal_module.button,
    onClick: handleConfirm
  }, submitBtnText))));
}
/* harmony default export */ const transfer_TransferConfirm = (memo(withGlobal(global => {
  return {
    currentAccountId: global.currentAccountId,
    currentTransfer: global.currentTransfer,
    accounts: selectNetworkAccounts(global)
  };
})(TransferConfirm)));
;// ./src/components/transfer/TransferMultiNftProcess.tsx










function TransferMultiNftProcess(_ref) {
  let {
    nfts,
    sentNftsCount = 0,
    toAddress,
    onClose
  } = _ref;
  const lang = hooks_useLang();
  const isInProgress = sentNftsCount < nfts.length;
  const isBurning = toAddress === src_config/* BURN_ADDRESS */.pV9;
  const isNotcoinBurning = toAddress === src_config/* NOTCOIN_EXCHANGERS */.WVU[0];
  const title = isInProgress ? lang(`${isBurning || isNotcoinBurning ? 'Burning' : 'Sending'}: %n% of %m% NFTs...`, {
    n: sentNftsCount,
    m: nfts.length
  }) : lang('Sent');
  const duration = Math.ceil(nfts.length / src_config/* NFT_BATCH_SIZE */.gR8) * src_config/* BURN_CHUNK_DURATION_APPROX_SEC */.WHY / 60;
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: title
  }), /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.transitionContent
  }, isInProgress && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_Spinner, {
    className: Transfer_module.spinner
  }), /*#__PURE__*/teact.createElement("div", {
    className: Transfer_module.infoBox
  }, lang('$multi_send_nft_warning', {
    duration
  }))), nfts.length === 1 ? /*#__PURE__*/teact.createElement(transfer_NftInfo, {
    nft: nfts[0]
  }) : /*#__PURE__*/teact.createElement(transfer_NftChips, {
    nfts: nfts
  }), !isInProgress && /*#__PURE__*/teact.createElement("div", {
    className: Modal_module.buttons
  }, /*#__PURE__*/teact.createElement(ui_Button, {
    onClick: onClose,
    isPrimary: true
  }, lang('Close')))));
}
/* harmony default export */ const transfer_TransferMultiNftProcess = (memo(TransferMultiNftProcess));
;// ./src/components/transfer/TransferPassword.tsx








function TransferPassword(_ref) {
  let {
    isActive,
    isLoading,
    isBurning,
    error,
    children,
    onSubmit,
    onCancel,
    isGaslessWithStars
  } = _ref;
  const {
    cancelTransfer,
    clearTransferError
  } = getActions();
  const lang = hooks_useLang();
  useHistoryBack({
    isActive,
    onBack: onCancel
  });
  const title = isBurning ? 'Confirm Burning' : 'Confirm Sending';
  const submitLabel = isGaslessWithStars ? lang('Pay fee with %stars_symbol%', {
    stars_symbol: src_config/* STARS_SYMBOL */.xFF
  }) : lang('Send');
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, !getDoesUsePinPad() && /*#__PURE__*/teact.createElement(ui_ModalHeader, {
    title: lang(title),
    onClose: cancelTransfer
  }), /*#__PURE__*/teact.createElement(ui_PasswordForm, {
    isActive: isActive,
    isLoading: isLoading,
    withCloseButton: Boolean(children),
    operationType: "transfer",
    error: error,
    submitLabel: submitLabel,
    cancelLabel: lang('Back'),
    onSubmit: onSubmit,
    onCancel: onCancel,
    onUpdate: clearTransferError
  }, children));
}
/* harmony default export */ const transfer_TransferPassword = (memo(TransferPassword));
;// ./src/components/transfer/TransferModal.tsx































const SCREEN_HEIGHT_FOR_FORCE_FULLSIZE_NBS = 762; // Computed empirically

function TransferModal(_ref) {
  let {
    currentTransfer: {
      state,
      amount,
      toAddress,
      comment,
      error,
      isLoading,
      txId,
      tokenSlug,
      nfts,
      sentNftsCount,
      diesel
    },
    tokens,
    savedAddresses,
    isMediaViewerOpen,
    isMultichainAccount
  } = _ref;
  const {
    submitTransferConfirm,
    submitTransfer,
    setTransferScreen,
    cancelTransfer,
    showActivityInfo
  } = getActions();
  const lang = hooks_useLang();
  const {
    isPortrait
  } = useDeviceScreen();
  const isOpen = state !== TransferState.None;
  const {
    screenHeight
  } = useWindowSize();
  const selectedToken = teact_useMemo(() => tokens === null || tokens === void 0 ? void 0 : tokens.find(token => token.slug === tokenSlug), [tokenSlug, tokens]);
  const decimals = selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.decimals;
  const renderedTransactionAmount = hooks_usePrevious(amount, true);
  const symbol = (selectedToken === null || selectedToken === void 0 ? void 0 : selectedToken.symbol) || '';
  const isNftTransfer = Boolean(nfts === null || nfts === void 0 ? void 0 : nfts.length);
  const isBurning = toAddress === src_config/* BURN_ADDRESS */.pV9;
  const {
    renderingKey,
    nextKey,
    updateNextKey
  } = useModalTransitionKeys(state, isOpen);
  teact_useEffect(() => state === TransferState.Confirm ? captureKeyboardListeners({
    onEnter: () => submitTransferConfirm()
  }) : undefined, [state, submitTransferConfirm]);
  const handleTransferSubmit = useLastCallback(password => {
    submitTransfer({
      password
    });
  });
  const handleBackClick = useLastCallback(() => {
    if (state === TransferState.Confirm) {
      setTransferScreen({
        state: TransferState.Initial
      });
    }
    if (state === TransferState.Password) {
      setTransferScreen({
        state: TransferState.Confirm
      });
    }
  });
  const handleTransactionInfoClick = useLastCallback(() => {
    cancelTransfer({
      shouldReset: true
    });
    showActivityInfo({
      id: txId
    });
  });
  const handleModalClose = useLastCallback(() => {
    cancelTransfer({
      shouldReset: isPortrait
    });
    updateNextKey();
  });
  const handleModalCloseWithReset = useLastCallback(() => {
    cancelTransfer({
      shouldReset: true
    });
  });
  const handleLedgerConnect = useLastCallback(() => {
    submitTransfer();
  });
  function renderContent(isActive, isFrom, currentKey) {
    var _nfts$, _nfts$2;
    switch (currentKey) {
      case TransferState.Initial:
        return /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(ui_ModalHeader, {
          title: lang(isNftTransfer ? 'Send NFT' : 'Send'),
          onClose: handleModalCloseWithReset
        }), /*#__PURE__*/teact.createElement(transfer_TransferInitial, null));
      case TransferState.Confirm:
        return /*#__PURE__*/teact.createElement(transfer_TransferConfirm, {
          isActive: isActive,
          token: selectedToken,
          savedAddresses: savedAddresses,
          onBack: isPortrait ? handleBackClick : handleModalClose,
          onClose: handleModalCloseWithReset
        });
      case TransferState.Password:
        return /*#__PURE__*/teact.createElement(transfer_TransferPassword, {
          isActive: isActive,
          isLoading: isLoading,
          isBurning: isBurning,
          error: error,
          onSubmit: handleTransferSubmit,
          onCancel: handleModalCloseWithReset,
          isGaslessWithStars: (diesel === null || diesel === void 0 ? void 0 : diesel.status) === 'stars-fee'
        }, /*#__PURE__*/teact.createElement(common_TransactionBanner, {
          tokenIn: selectedToken,
          imageUrl: nfts === null || nfts === void 0 || (_nfts$ = nfts[0]) === null || _nfts$ === void 0 ? void 0 : _nfts$.thumbnail,
          withChainIcon: isMultichainAccount,
          text: isNftTransfer ? nfts.length > 1 ? lang('%amount% NFTs', {
            amount: nfts.length
          }) : ((_nfts$2 = nfts[0]) === null || _nfts$2 === void 0 ? void 0 : _nfts$2.name) || 'NFT' : formatCurrency((0,util_decimals/* toDecimal */.nI)(amount, decimals), symbol),
          className: !getDoesUsePinPad() ? Transfer_module.transactionBanner : undefined,
          secondText: (0,shortenAddress/* shortenAddress */.W)(toAddress)
        }));
      case TransferState.ConnectHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConnect, {
          isActive: isActive,
          onConnected: handleLedgerConnect,
          onClose: handleModalCloseWithReset
        });
      case TransferState.ConfirmHardware:
        return /*#__PURE__*/teact.createElement(ledger_LedgerConfirmOperation, {
          text: lang('Please confirm transaction on your Ledger'),
          error: error,
          onClose: handleModalCloseWithReset,
          onTryAgain: handleLedgerConnect
        });
      case TransferState.Complete:
        return ((nfts === null || nfts === void 0 ? void 0 : nfts.length) || 0) <= src_config/* NFT_BATCH_SIZE */.gR8 ? /*#__PURE__*/teact.createElement(transfer_TransferComplete, {
          isActive: isActive,
          nfts: nfts,
          amount: renderedTransactionAmount,
          symbol: symbol,
          txId: txId,
          tokenSlug: tokenSlug,
          toAddress: toAddress,
          comment: comment,
          onInfoClick: handleTransactionInfoClick,
          onClose: handleModalCloseWithReset,
          decimals: decimals
        }) : /*#__PURE__*/teact.createElement(transfer_TransferMultiNftProcess, {
          nfts: nfts,
          sentNftsCount: sentNftsCount,
          toAddress: toAddress,
          onClose: handleModalCloseWithReset
        });
    }
  }
  return /*#__PURE__*/teact.createElement(ui_Modal, {
    isOpen: isOpen && !isMediaViewerOpen,
    noBackdropClose: true,
    dialogClassName: Transfer_module.modalDialog,
    nativeBottomSheetKey: "transfer"
    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison
    ,
    forceFullNative: screenHeight <= SCREEN_HEIGHT_FOR_FORCE_FULLSIZE_NBS || renderingKey === TransferState.Password,
    onClose: handleModalCloseWithReset,
    onCloseAnimationEnd: handleModalClose
  }, /*#__PURE__*/teact.createElement(ui_Transition, {
    name: resolveSlideTransitionName(),
    className: buildClassName(Modal_module.transition, 'custom-scroll'),
    slideClassName: Modal_module.transitionSlide,
    activeKey: renderingKey,
    nextKey: nextKey,
    onStop: updateNextKey
  }, renderContent));
}
/* harmony default export */ const transfer_TransferModal = (memo(withGlobal(global => {
  const accountState = selectCurrentAccountState(global);
  return {
    currentTransfer: global.currentTransfer,
    tokens: selectCurrentAccountTokens(global),
    savedAddresses: accountState === null || accountState === void 0 ? void 0 : accountState.savedAddresses,
    isMediaViewerOpen: Boolean(global.mediaViewer.mediaId),
    isMultichainAccount: selectIsMultichainAccount(global, global.currentAccountId)
  };
})(TransferModal)));
;// ./src/components/ui/ConfettiContainer.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const ConfettiContainer_module = ({"root":"ConfettiContainer-module__root"});
;// ./src/components/ui/ConfettiContainer.tsx









const CONFETTI_FADEOUT_TIMEOUT = 10000;
const DEFAULT_CONFETTI_SIZE = 10;
const CONFETTI_COLORS = ['#E8BC2C', '#D0049E', '#02CBFE', '#5723FD', '#FE8C27', '#6CB859'];
function ConfettiContainer(_ref) {
  let {
    lastRequestedAt
  } = _ref;
  const canvasRef = teact_useRef();
  const confettiRef = teact_useRef([]);
  const isRafStartedRef = teact_useRef(false);
  const windowSize = useWindowSize();
  const forceUpdate = hooks_useForceUpdate();
  const {
    isPortrait
  } = useDeviceScreen();
  const defaultConfettiAmount = isPortrait ? 50 : 100;
  const invokeGenerateConfetti = useLastCallback((w, h) => {
    generateConfetti(confettiRef, w, h, defaultConfettiAmount);
  });
  const updateCanvas = useLastCallback(() => {
    if (!canvasRef.current || !isRafStartedRef.current) {
      return;
    }
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
      return;
    }
    const {
      width: canvasWidth,
      height: canvasHeight
    } = canvas;
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    const confettiToRemove = new Set([]);
    confettiRef.current.forEach((c, i) => {
      const {
        pos,
        velocity,
        size,
        color,
        flicker,
        flickerFrequency,
        rotation,
        lastDrawnAt,
        frameCount
      } = c;
      const diff = (Date.now() - lastDrawnAt) / 1000;
      const newPos = {
        x: pos.x + velocity.x * diff,
        y: pos.y + velocity.y * diff
      };
      const newVelocity = {
        x: velocity.x * 0.98,
        // Air Resistance
        y: velocity.y += diff * 1000 // Gravity
      };
      const newFlicker = size * Math.abs(Math.sin(frameCount * flickerFrequency));
      const newRotation = 5 * frameCount * flickerFrequency * (Math.PI / 180);
      const newFrameCount = frameCount + 1;
      const newLastDrawnAt = Date.now();
      const shouldRemove = newPos.y > canvasHeight + c.size;
      if (shouldRemove) {
        confettiToRemove.add(c);
        return;
      }
      confettiRef.current[i] = {
        ...c,
        pos: newPos,
        velocity: newVelocity,
        flicker: newFlicker,
        rotation: newRotation,
        lastDrawnAt: newLastDrawnAt,
        frameCount: newFrameCount
      };
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y, size, flicker, rotation, 0, 2 * Math.PI);
      ctx.fill();
    });
    confettiRef.current = confettiRef.current.filter(c => !confettiToRemove.has(c));
    if (confettiRef.current.length) {
      (0,fasterdom/* requestMeasure */.YS)(updateCanvas);
    } else {
      isRafStartedRef.current = false;
    }
  });
  useSyncEffect(_ref2 => {
    let [prevConfettiTime] = _ref2;
    let hideTimeout;
    if (lastRequestedAt && prevConfettiTime !== lastRequestedAt) {
      invokeGenerateConfetti(windowSize.width, windowSize.height);
      hideTimeout = window.setTimeout(forceUpdate, CONFETTI_FADEOUT_TIMEOUT);
      if (!isRafStartedRef.current) {
        isRafStartedRef.current = true;
        (0,fasterdom/* requestMeasure */.YS)(updateCanvas);
      }
    }
    return () => {
      window.clearTimeout(hideTimeout);
    };
    // eslint-disable-next-line react-hooks-static-deps/exhaustive-deps -- Old timeout should be cleared only if new confetti is generated
  }, [lastRequestedAt, forceUpdate, updateCanvas]);
  if (!lastRequestedAt || Date.now() - lastRequestedAt > CONFETTI_FADEOUT_TIMEOUT) {
    return undefined;
  }
  return /*#__PURE__*/teact.createElement("div", {
    id: "Confetti",
    className: ConfettiContainer_module.root
  }, /*#__PURE__*/teact.createElement("canvas", {
    ref: canvasRef,
    width: windowSize.width,
    height: windowSize.height
  }));
}
/* harmony default export */ const ui_ConfettiContainer = (memo(withGlobal(global => {
  return {
    lastRequestedAt: global.confettiRequestedAt
  };
})(ConfettiContainer)));
function generateConfetti(confettiRef, width, height, amount) {
  for (let i = 0; i < amount; i++) {
    const leftSide = i % 2;
    const pos = {
      x: width * (leftSide ? -0.1 : 1.1),
      y: height * 0.75
    };
    const randomX = Math.random() * width * 1.5;
    const randomY = -height / 2 - Math.random() * height;
    const velocity = {
      x: leftSide ? randomX : randomX * -1,
      y: randomY
    };
    const randomColor = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
    const size = DEFAULT_CONFETTI_SIZE;
    confettiRef.current.push({
      pos,
      size,
      color: randomColor,
      velocity,
      flicker: size,
      flickerFrequency: Math.random() * 0.2,
      rotation: 0,
      lastDrawnAt: Date.now(),
      frameCount: 0
    });
  }
}
;// ./src/components/ui/LoadingOverlay.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const LoadingOverlay_module = ({"root":"LoadingOverlay-module__root","button":"LoadingOverlay-module__button","spinner":"LoadingOverlay-module__spinner","shown":"LoadingOverlay-module__shown"});
;// ./src/components/ui/LoadingOverlay.tsx












const CLOSE_BUTTON_DELAY_MS = 7000;
function LoadingOverlay(_ref) {
  let {
    isOpen
  } = _ref;
  const {
    closeLoadingOverlay
  } = getActions();
  const lang = hooks_useLang();
  const [shouldShowCloseButton, showCloseButton, hideCloseButton] = hooks_useFlag(false);
  const {
    shouldRender,
    ref
  } = useShowTransition({
    isOpen,
    withShouldRender: true
  });
  teact_useEffect(() => {
    if (!shouldRender) hideCloseButton();
  }, [shouldRender]);
  hooks_useTimeout(showCloseButton, shouldRender ? CLOSE_BUTTON_DELAY_MS : undefined, [shouldRender]);
  if (!shouldRender) return undefined;
  return /*#__PURE__*/teact.createElement(ui_Portal, null, /*#__PURE__*/teact.createElement("div", {
    ref: ref,
    className: LoadingOverlay_module.root,
    onClick: () => closeLoadingOverlay()
  }, /*#__PURE__*/teact.createElement(ui_Spinner, {
    color: "white",
    className: LoadingOverlay_module.spinner
  }), /*#__PURE__*/teact.createElement(ui_Button, {
    shouldStopPropagation: true,
    className: buildClassName(LoadingOverlay_module.button, shouldShowCloseButton && LoadingOverlay_module.shown),
    onClick: closeLoadingOverlay
  }, lang('Close'))));
}
/* harmony default export */ const ui_LoadingOverlay = (memo(withGlobal(global => {
  var _global$dappConnectRe;
  const isDpppModalOpen = ((_global$dappConnectRe = global.dappConnectRequest) === null || _global$dappConnectRe === void 0 ? void 0 : _global$dappConnectRe.state) !== undefined || global.currentDappTransfer.state !== TransferState.None;
  return {
    isOpen: global.isLoadingOverlayOpen && !isDpppModalOpen
  };
})(LoadingOverlay)));
;// ./src/components/App.module.scss
// extracted by mini-css-extract-plugin
/* harmony default export */ const App_module = ({"containerInner":"App-module__containerInner","appSlide":"App-module__appSlide","appSlide_fastTransition":"App-module__appSlide_fastTransition","appSlideFastTransition":"App-module__appSlide_fastTransition","appSlideTransparent":"App-module__appSlideTransparent","appSlideContent":"App-module__appSlideContent","transitionContainer":"App-module__transitionContainer","loading":"App-module__loading"});
;// ./src/components/App.tsx

























































// import Test from './components/test/TestNoRedundancy';

const APP_STATES_WITH_BOTTOM_BAR = new Set([AppState.Main, AppState.Settings, AppState.Explore]);
const APP_UPDATE_INTERVAL = windowEnvironment/* IS_ELECTRON */.cp && !windowEnvironment/* IS_LINUX */.ig || src_config/* IS_ANDROID_DIRECT */.VL7 ? 5 * dateFormat/* MINUTE */.pY : undefined;
const PRERENDER_MAIN_DELAY = 1200;
let mainKey = 0;
const APP_STATE_RENDER_COUNT = Object.keys(AppState).length / 2;
function App_App(_ref) {
  let {
    appState,
    accountId,
    isBackupWalletModalOpen,
    isHardwareModalOpen,
    isQrScannerOpen,
    isExploreOpen,
    isFullscreen,
    areSettingsOpen,
    theme,
    accentColorIndex
  } = _ref;
  const {
    closeBackupWalletModal,
    closeHardwareWalletModal,
    closeSettings,
    cancelCaching,
    closeQrScanner,
    checkAppVersion
  } = getActions();
  const {
    isPortrait
  } = useDeviceScreen();
  const areSettingsInModal = !isPortrait;
  const [isInactive, markInactive] = hooks_useFlag(false);
  const [canPrerenderMain, prerenderMain] = hooks_useFlag();
  const renderingKey = isInactive ? AppState.Inactive : areSettingsOpen && !areSettingsInModal ? AppState.Settings : isExploreOpen && isPortrait ? AppState.Explore : appState;
  const withBottomBar = isPortrait && APP_STATES_WITH_BOTTOM_BAR.has(renderingKey);
  const transitionName = withBottomBar ? 'semiFade' : isPortrait ? windowEnvironment/* IS_ANDROID */.Ni ? 'slideFadeAndroid' : windowEnvironment/* IS_IOS */.pz ? 'slideLayers' : 'slideFade' : 'semiFade';
  hooks_useTimeout(prerenderMain, renderingKey === AppState.Auth && !canPrerenderMain ? PRERENDER_MAIN_DELAY : undefined);
  hooks_useInterval(checkAppVersion, src_config/* IS_CORE_WALLET */.TI6 ? undefined : APP_UPDATE_INTERVAL);
  teact_useEffect(() => {
    document.documentElement.classList.toggle('with-bottombar', withBottomBar);
  }, [withBottomBar]);
  teact_useEffect(() => {
    updateSizes();
    setActiveTabChangeListener(() => {
      document.title = `${src_config/* APP_NAME */.C39} ${src_config/* INACTIVE_MARKER */.LaL}`;
      markInactive();
      closeSettings();
      cancelCaching();
    });
  }, [markInactive]);
  useBackgroundMode(() => {
    void (0,api/* callApi */.p)('setIsAppFocused', false);
  }, () => {
    void (0,api/* callApi */.p)('setIsAppFocused', true);
  }, windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe);
  useLayoutEffect(() => {
    document.documentElement.classList.add('is-rendered');
    resolveRender();
  }, []);
  useLayoutEffect(() => {
    document.documentElement.classList.toggle('is-fullscreen', isFullscreen);
    requestAnimationFrame(updateSizes);
  }, [isFullscreen]);
  useSyncEffect(() => {
    if (accountId) {
      mainKey += 1;
    }
  }, [accountId]);
  const appTheme = hooks_useAppTheme(theme);
  useAccentColor('body', appTheme, accentColorIndex);
  useAppIntersectionObserver();
  function renderContent(isActive, isFrom, currentKey) {
    switch (currentKey) {
      case AppState.Auth:
        return /*#__PURE__*/teact.createElement(auth_Auth, null);
      case AppState.Main:
        {
          const slideFullClassName = buildClassName(App_module.appSlide, App_module.appSlideContent, 'custom-scroll', 'app-slide-content');
          return /*#__PURE__*/teact.createElement(ui_Transition, {
            name: "semiFade",
            activeKey: mainKey,
            shouldCleanup: true,
            nextKey: renderingKey === AppState.Auth && canPrerenderMain ? mainKey + 1 : undefined,
            slideClassName: slideFullClassName
          }, /*#__PURE__*/teact.createElement(main_Main, {
            key: mainKey,
            isActive: isActive
          }));
        }
      case AppState.Explore:
        return /*#__PURE__*/teact.createElement(explore_Explore, {
          isActive: isActive
        });
      case AppState.Settings:
        return /*#__PURE__*/teact.createElement(settings_Settings, {
          isActive: isActive
        });
      case AppState.Ledger:
        return /*#__PURE__*/teact.createElement(ledger_LedgerModal, {
          isOpen: true,
          noBackdropClose: true,
          onClose: tab/* closeThisTab */.ks
        });
      case AppState.Inactive:
        return /*#__PURE__*/teact.createElement(components_AppInactive, null);
    }
  }
  return /*#__PURE__*/teact.createElement(teact.Fragment, null, windowEnvironment/* IS_ELECTRON */.cp && !windowEnvironment/* IS_LINUX */.ig && /*#__PURE__*/teact.createElement(electron_ElectronHeader, {
    withTitle: true
  }), /*#__PURE__*/teact.createElement(ui_Transition, {
    name: transitionName,
    activeKey: renderingKey,
    renderCount: APP_STATE_RENDER_COUNT,
    shouldCleanup: !withBottomBar,
    className: App_module.transitionContainer,
    slideClassName: buildClassName(App_module.appSlide, withBottomBar && App_module.appSlide_fastTransition, 'custom-scroll')
  }, renderContent), areSettingsInModal && /*#__PURE__*/teact.createElement(settings_SettingsModal, {
    isOpen: areSettingsOpen,
    onClose: closeSettings
  }, /*#__PURE__*/teact.createElement(settings_Settings, {
    isActive: !!areSettingsOpen,
    isInsideModal: true
  })), /*#__PURE__*/teact.createElement(appLocked_AppLocked, null), /*#__PURE__*/teact.createElement(mediaViewer_MediaViewer, null), !isInactive && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(auth_AuthImportWalletModal, null), /*#__PURE__*/teact.createElement(ledger_LedgerModal, {
    isOpen: isHardwareModalOpen,
    onClose: closeHardwareWalletModal
  }), /*#__PURE__*/teact.createElement(modals_BackupModal, {
    isOpen: isBackupWalletModalOpen,
    onClose: closeBackupWalletModal
  }), /*#__PURE__*/teact.createElement(transfer_TransferModal, null), !src_config/* IS_CORE_WALLET */.TI6 && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(swap_SwapModal, null), /*#__PURE__*/teact.createElement(mintCard_MintCardModal, null)), /*#__PURE__*/teact.createElement(modals_SignatureModal, null), /*#__PURE__*/teact.createElement(modals_TransactionModal, null), /*#__PURE__*/teact.createElement(modals_SwapActivityModal, null), /*#__PURE__*/teact.createElement(dapps_DappConnectModal, null), /*#__PURE__*/teact.createElement(dapps_DappSignDataModal, null), /*#__PURE__*/teact.createElement(dapps_DappTransferModal, null), /*#__PURE__*/teact.createElement(modals_AddAccountModal, null), /*#__PURE__*/teact.createElement(modals_OnRampWidgetModal, null), /*#__PURE__*/teact.createElement(modals_UnhideNftModal, null), /*#__PURE__*/teact.createElement(modals_NftAttributesModal, null), src_config/* IS_CAPACITOR */.UMQ && /*#__PURE__*/teact.createElement(modals_QrScannerModal, {
    isOpen: isQrScannerOpen,
    onClose: closeQrScanner
  }), !windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA && /*#__PURE__*/teact.createElement(teact.Fragment, null, /*#__PURE__*/teact.createElement(main_Notifications, null), /*#__PURE__*/teact.createElement(components_Dialogs, null), /*#__PURE__*/teact.createElement(ui_ConfettiContainer, null), src_config/* IS_CAPACITOR */.UMQ ? /*#__PURE__*/teact.createElement(ui_InAppBrowser, null) : /*#__PURE__*/teact.createElement(ui_IFrameBrowser, null), /*#__PURE__*/teact.createElement(ui_LoadingOverlay, null))), withBottomBar && /*#__PURE__*/teact.createElement(Actions_BottomBar, null));
}
/* harmony default export */ const components_App = (memo(withGlobal(global => {
  var _selectCurrentAccount;
  return {
    appState: global.appState,
    accountId: global.currentAccountId,
    isBackupWalletModalOpen: global.isBackupWalletModalOpen,
    isHardwareModalOpen: global.isHardwareModalOpen,
    isExploreOpen: global.isExploreOpen,
    areSettingsOpen: global.areSettingsOpen,
    isQrScannerOpen: global.isQrScannerOpen,
    isFullscreen: Boolean(global.isFullscreen),
    theme: global.settings.theme,
    accentColorIndex: (_selectCurrentAccount = selectCurrentAccountSettings(global)) === null || _selectCurrentAccount === void 0 ? void 0 : _selectCurrentAccount.accentColorIndex
  };
})(App_App)));
;// ./src/index.tsx





















if (src_config/* DEBUG */.Oig) {
  // eslint-disable-next-line no-console
  console.log('>>> INIT');
}
if (src_config/* STRICTERDOM_ENABLED */.rkj) {
  (0,stricterdom/* enableStrict */.Z3)();
}
if (src_config/* IS_CAPACITOR */.UMQ) {
  void initCapacitor();
}
if (windowEnvironment/* IS_ELECTRON */.cp) {
  void initElectron();
}
if (src_config/* IS_TELEGRAM_APP */.tKX) {
  void initTelegramApp();
}
if (windowEnvironment/* IS_DELEGATING_BOTTOM_SHEET */.KI) {
  initMultitab({
    noPubGlobal: true
  });
} else if (windowEnvironment/* IS_DELEGATED_BOTTOM_SHEET */.bA) {
  initMultitab();
}
initFocusScrollController();
void (async _window$electron => {
  if (windowEnvironment/* IS_IOS_APP */.ZH) {
    await fixIosAppStorage();
  }
  await ((_window$electron = window.electron) === null || _window$electron === void 0 ? void 0 : _window$electron.restoreStorage());
  getActions().init();

  // Connecting to the API from remote tabs creates excessive polling in the API.
  // The remote tab doesn't need the API anyway.
  if (!windowEnvironment/* IS_LEDGER_EXTENSION_TAB */.Fe) {
    getActions().initApi();
  } else {
    (0,logs/* logDebug */.MD)('API was not initialized because it was connected from a detached tab');
  }
  if (src_config/* IS_CAPACITOR */.UMQ) {
    await processCapacitorLaunchDeeplink();
  }
  if (src_config/* DEBUG */.Oig) {
    // eslint-disable-next-line no-console
    console.log('>>> START INITIAL RENDER');
  }
  (0,fasterdom/* requestMutation */.RK)(() => {
    teact_dom.render(/*#__PURE__*/teact.createElement(components_App, null), document.getElementById('root'));
    forceLoadFonts();
    betterView();
  });
  if (src_config/* DEBUG */.Oig) {
    // eslint-disable-next-line no-console
    console.log('>>> FINISH INITIAL RENDER');
  }
  document.addEventListener('dblclick', () => {
    // eslint-disable-next-line no-console
    console.warn('GLOBAL STATE', getGlobal());
  });
  if (window.top === window) {
    (0,logs/* logSelfXssWarnings */.ef)();
  }
})();
})();

/******/ })()
;
//# sourceMappingURL=main.1ae9d068f144b4f1a46b.js.map