{"version":3,"file":"909.a7bb8f6eb0374ee347af.js","mappings":";;;;;;AAAa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,+BAA+B;AACvD,gBAAgB,mBAAO,CAAC,KAAS;AACjC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;;;;;;;;;;;;;;;AC1CA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACkC;AACiG;AACtF;AACqC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB,IAAI;AACzC;AACA;AACA;AACA,2BAA2B,+CAAY;AACvC;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,QAAQ;AAC3B,mBAAmB,eAAe;AAClC,mBAAmB,QAAQ;AAC3B;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA,gKAAgK,MAAM,yBAAyB,yDAAW,QAAQ,iBAAiB,IAAI;AACvO,4DAA4D,kBAAkB;AAC9E;AACA,uEAAuE,yBAAyB;AAChG,0BAA0B,4DAAc;AACxC;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA,YAAY,MAAM,SAAS,MAAM,2BAA2B,MAAM,gCAAgC,gBAAgB;AAClH;AACA;AACA;AACA,0BAA0B,kEAAoB;AAC9C;AACA;AACA,SAAS;AACT;AACA,0BAA0B,uDAAW;AACrC;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA,sBAAsB,kCAAkC,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,kBAAkB;AACjC,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAW;AAC1C,8BAA8B,kEAAoB;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mCAAmC,4DAAc;AACjD;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,+BAA+B,4DAAc;AAC7C,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,oEAAsB;AAChD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,0CAA0C,4DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;AACzB;;;;;;;AC5Sa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,aAAa;AACpC;AACA;AACA;AACA,KAAK;AACL;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;;;;;;;AC9Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;;;;;;;;AC/Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,oBAAoB,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,oBAAoB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,mBAAmB;AACzM,eAAe,mBAAO,CAAC,IAAW;AAClC;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA,mBAAmB;AACnB;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,uBAAuB;;;;;;;;AC1DV;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB;AACtB,kBAAkB,mBAAO,CAAC,IAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;;;;;;AC5Da;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,oBAAoB,GAAG,aAAa,GAAG,+BAA+B,GAAG,qBAAqB,GAAG,8BAA8B,GAAG,gCAAgC,GAAG,aAAa,GAAG,iBAAiB,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,2BAA2B;AACxS,4BAA4B,mBAAO,CAAC,KAAgC;AACpE,uDAAsD,EAAE,qCAAqC,qDAAqD,EAAC;AACnJ,kBAAkB,mBAAO,CAAC,KAAkB;AAC5C,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,uBAAuB,mBAAO,CAAC,KAAuB;AACtD,kDAAiD,EAAE,qCAAqC,2CAA2C,EAAC;AACpI,kBAAkB,mBAAO,CAAC,KAAkB;AAC5C,6CAA4C,EAAE,qCAAqC,iCAAiC,EAAC;AACrH,cAAc,mBAAO,CAAC,KAAc;AACpC,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,wBAAwB,mBAAO,CAAC,KAAwB;AACxD,4DAA2D,EAAE,qCAAqC,sDAAsD,EAAC;AACzJ,0DAAyD,EAAE,qCAAqC,oDAAoD,EAAC;AACrJ,gBAAgB,mBAAO,CAAC,IAAiB;AACzC,iDAAgD,EAAE,qCAAqC,mCAAmC,EAAC;AAC3H,2DAA0D,EAAE,qCAAqC,6CAA6C,EAAC;AAC/I,cAAc,mBAAO,CAAC,KAAe;AACrC,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,gDAA+C,EAAE,qCAAqC,gCAAgC,EAAC;AACvH,qBAAqB,mBAAO,CAAC,KAAsB;AACnD,gDAA+C,EAAE,qCAAqC,uCAAuC,EAAC;AAC9H;;;;;;;ACxBa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;AClDa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;ACzDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,eAAe,mBAAO,CAAC,IAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;ACdF;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,yBAAyB,mBAAO,CAAC,KAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;AChCa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;;;;;;ACjEa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,8BAA8B,GAAG,gCAAgC;AACjE,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;;;;;;;ACtEa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oBAAoB,GAAG,oBAAoB,GAAG,qBAAqB;AACnE,eAAe,mBAAO,CAAC,IAAW;AAClC,iBAAiB,mBAAO,CAAC,KAAa;AACtC,mBAAmB,mBAAO,CAAC,KAAU;AACrC,uBAAuB,mBAAO,CAAC,KAAsB;AACrD,kBAAkB,mBAAO,CAAC,KAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,kBAAkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gDAAgD,MAAM;AACtD,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,gBAAgB,MAAM;AACtB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,MAAM;AAC1E;AACA,kBAAkB,MAAM,GAAG,MAAM,GAAG,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,4BAA4B,MAAM;AAClC;AACA,4BAA4B,MAAM;AAClC;AACA,0BAA0B,MAAM;AAChC,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA,qBAAqB;AACrB;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,MAAM;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA","sources":["webpack://mytonwallet/./node_modules/teslabot/dist/timer/backoff.js","webpack://mytonwallet/./node_modules/@ledgerhq/hw-transport/lib-es/Transport.js","webpack://mytonwallet/./node_modules/teslabot/dist/timer/delay.js","webpack://mytonwallet/./node_modules/teslabot/dist/timer/asyncTimeout.js","webpack://mytonwallet/./node_modules/@ton-community/ton-ledger/dist/utils/ledgerWriter.js","webpack://mytonwallet/./node_modules/teslabot/dist/sync/InvalidateSync.js","webpack://mytonwallet/./node_modules/teslabot/dist/index.js","webpack://mytonwallet/./node_modules/teslabot/dist/sync/Queue.js","webpack://mytonwallet/./node_modules/teslabot/dist/sync/AsyncLock.js","webpack://mytonwallet/./node_modules/@ton-community/ton-ledger/dist/utils/getInit.js","webpack://mytonwallet/./node_modules/teslabot/dist/sync/SyncValue.js","webpack://mytonwallet/./node_modules/teslabot/dist/iterator/createAsyncIterator.js","webpack://mytonwallet/./node_modules/teslabot/dist/sync/ConcurrencyPool.js","webpack://mytonwallet/./node_modules/@ton-community/ton-ledger/dist/TonTransport.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createBackoff = exports.exponentialBackoffDelay = void 0;\nconst delay_1 = require(\"./delay\");\nfunction exponentialBackoffDelay(currentFailureCount, minDelay, maxDelay, maxFailureCount) {\n    let maxDelayRet = minDelay + ((maxDelay - minDelay) / maxFailureCount) * Math.max(currentFailureCount, maxFailureCount);\n    return Math.round(Math.random() * maxDelayRet);\n}\nexports.exponentialBackoffDelay = exponentialBackoffDelay;\nfunction createBackoff(opts) {\n    return (callback) => __awaiter(this, void 0, void 0, function* () {\n        let currentFailureCount = 0;\n        const minDelay = opts && opts.minDelay !== undefined ? opts.minDelay : 250;\n        const maxDelay = opts && opts.maxDelay !== undefined ? opts.maxDelay : 1000;\n        const maxFailureCount = opts && opts.maxFailureCount !== undefined ? opts.maxFailureCount : 50;\n        while (true) {\n            try {\n                return yield callback();\n            }\n            catch (e) {\n                if (currentFailureCount < maxFailureCount) {\n                    currentFailureCount++;\n                }\n                if (opts && opts.onError) {\n                    opts.onError(e, currentFailureCount);\n                }\n                let waitForRequest = exponentialBackoffDelay(currentFailureCount, minDelay, maxDelay, maxFailureCount);\n                yield (0, delay_1.delay)(waitForRequest);\n            }\n        }\n    });\n}\nexports.createBackoff = createBackoff;\n//# sourceMappingURL=backoff.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError, } from \"@ledgerhq/errors\";\nimport { LocalTracer } from \"@ledgerhq/logs\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\nconst DEFAULT_LOG_TYPE = \"transport\";\n/**\n * The Transport class defines a generic interface for communicating with a Ledger hardware wallet.\n * There are different kind of transports based on the technology (channels like U2F, HID, Bluetooth, Webusb) and environment (Node, Web,...).\n * It is an abstract class that needs to be implemented.\n */\nclass Transport {\n    constructor({ context, logType } = {}) {\n        this.exchangeTimeout = 30000;\n        this.unresponsiveTimeout = 15000;\n        this.deviceModel = null;\n        this._events = new EventEmitter();\n        /**\n         * Send data to the device using the higher level API.\n         *\n         * @param {number} cla - The instruction class for the command.\n         * @param {number} ins - The instruction code for the command.\n         * @param {number} p1 - The first parameter for the instruction.\n         * @param {number} p2 - The second parameter for the instruction.\n         * @param {Buffer} data - The data to be sent. Defaults to an empty buffer.\n         * @param {Array<number>} statusList - A list of acceptable status codes for the response. Defaults to [StatusCodes.OK].\n         * @param {Object} options - Contains optional options for the exchange function\n         *  - abortTimeoutMs: stop the send after a given timeout. Another timeout exists\n         *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n         * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n         */\n        this.send = (cla_1, ins_1, p1_1, p2_1, ...args_1) => __awaiter(this, [cla_1, ins_1, p1_1, p2_1, ...args_1], void 0, function* (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK], { abortTimeoutMs } = {}) {\n            const tracer = this.tracer.withUpdatedContext({ function: \"send\" });\n            if (data.length >= 256) {\n                tracer.trace(\"data.length exceeded 256 bytes limit\", { dataLength: data.length });\n                throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n            }\n            tracer.trace(\"Starting an exchange\", { abortTimeoutMs });\n            const response = yield this.exchange(\n            // The size of the data is added in 1 byte just before `data`\n            Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]), { abortTimeoutMs });\n            tracer.trace(\"Received response from exchange\");\n            const sw = response.readUInt16BE(response.length - 2);\n            if (!statusList.some(s => s === sw)) {\n                throw new TransportStatusError(sw);\n            }\n            return response;\n        });\n        this._appAPIlock = null;\n        this.tracer = new LocalTracer(logType !== null && logType !== void 0 ? logType : DEFAULT_LOG_TYPE, context);\n    }\n    /**\n     * Send data to the device using a low level API.\n     * It's recommended to use the \"send\" method for a higher level API.\n     * @param {Buffer} apdu - The data to send.\n     * @param {Object} options - Contains optional options for the exchange function\n     *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n     *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n     * @returns {Promise<Buffer>} A promise that resolves with the response data from the device.\n     */\n    exchange(_apdu, { abortTimeoutMs: _abortTimeoutMs } = {}) {\n        throw new Error(\"exchange not implemented\");\n    }\n    /**\n     * Send apdus in batch to the device using a low level API.\n     * The default implementation is to call exchange for each apdu.\n     * @param {Array<Buffer>} apdus - array of apdus to send.\n     * @param {Observer<Buffer>} observer - an observer that will receive the response of each apdu.\n     * @returns {Subscription} A Subscription object on which you can call \".unsubscribe()\" to stop sending apdus.\n     */\n    exchangeBulk(apdus, observer) {\n        let unsubscribed = false;\n        const unsubscribe = () => {\n            unsubscribed = true;\n        };\n        const main = () => __awaiter(this, void 0, void 0, function* () {\n            if (unsubscribed)\n                return;\n            for (const apdu of apdus) {\n                const r = yield this.exchange(apdu);\n                if (unsubscribed)\n                    return;\n                const status = r.readUInt16BE(r.length - 2);\n                if (status !== StatusCodes.OK) {\n                    throw new TransportStatusError(status);\n                }\n                observer.next(r);\n            }\n        });\n        main().then(() => !unsubscribed && observer.complete(), e => !unsubscribed && observer.error(e));\n        return { unsubscribe };\n    }\n    /**\n     * Set the \"scramble key\" for the next data exchanges with the device.\n     * Each app can have a different scramble key and it is set internally during instantiation.\n     * @param {string} key - The scramble key to set.\n     * deprecated This method is no longer needed for modern transports and should be migrated away from.\n     * no @ before deprecated as it breaks documentationjs on version 14.0.2\n     * https://github.com/documentationjs/documentation/issues/1596\n     */\n    setScrambleKey(_key) { }\n    /**\n     * Close the connection with the device.\n     *\n     * Note: for certain transports (hw-transport-node-hid-singleton for ex), once the promise resolved,\n     * the transport instance is actually still cached, and the device is disconnected only after a defined timeout.\n     * But for the consumer of the Transport, this does not matter and it can consider the transport to be closed.\n     *\n     * @returns {Promise<void>} A promise that resolves when the transport is closed.\n     */\n    close() {\n        return Promise.resolve();\n    }\n    /**\n     * Listen for an event on the transport instance.\n     * Transport implementations may have specific events. Common events include:\n     * \"disconnect\" : triggered when the transport is disconnected.\n     * @param {string} eventName - The name of the event to listen for.\n     * @param {(...args: Array<any>) => any} cb - The callback function to be invoked when the event occurs.\n     */\n    on(eventName, cb) {\n        this._events.on(eventName, cb);\n    }\n    /**\n     * Stop listening to an event on an instance of transport.\n     */\n    off(eventName, cb) {\n        this._events.removeListener(eventName, cb);\n    }\n    emit(event, ...args) {\n        this._events.emit(event, ...args);\n    }\n    /**\n     * Enable or not logs of the binary exchange\n     */\n    setDebugMode() {\n        console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n    }\n    /**\n     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n     */\n    setExchangeTimeout(exchangeTimeout) {\n        this.exchangeTimeout = exchangeTimeout;\n    }\n    /**\n     * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n     */\n    setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n        this.unresponsiveTimeout = unresponsiveTimeout;\n    }\n    /**\n     * create() allows to open the first descriptor available or\n     * throw if there is none or if timeout is reached.\n     * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n     * @example\n    TransportFoo.create().then(transport => ...)\n     */\n    static create(openTimeout = 3000, listenTimeout) {\n        return new Promise((resolve, reject) => {\n            let found = false;\n            const sub = this.listen({\n                next: e => {\n                    found = true;\n                    if (sub)\n                        sub.unsubscribe();\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    this.open(e.descriptor, openTimeout).then(resolve, reject);\n                },\n                error: e => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    reject(e);\n                },\n                complete: () => {\n                    if (listenTimeoutId)\n                        clearTimeout(listenTimeoutId);\n                    if (!found) {\n                        reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n                    }\n                },\n            });\n            const listenTimeoutId = listenTimeout\n                ? setTimeout(() => {\n                    sub.unsubscribe();\n                    reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n                }, listenTimeout)\n                : null;\n        });\n    }\n    /**\n     * Wrapper to make an exchange \"atomic\" (blocking any other exchange)\n     *\n     * It also handles \"unresponsiveness\" by emitting \"unresponsive\" and \"responsive\" events.\n     *\n     * @param f The exchange job, using the transport to run\n     * @returns a Promise resolving with the output of the given job\n     */\n    exchangeAtomicImpl(f) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tracer = this.tracer.withUpdatedContext({\n                function: \"exchangeAtomicImpl\",\n                unresponsiveTimeout: this.unresponsiveTimeout,\n            });\n            if (this.exchangeBusyPromise) {\n                tracer.trace(\"Atomic exchange is already busy\");\n                throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n            }\n            // Sets the atomic guard\n            let resolveBusy;\n            const busyPromise = new Promise(r => {\n                resolveBusy = r;\n            });\n            this.exchangeBusyPromise = busyPromise;\n            // The device unresponsiveness handler\n            let unresponsiveReached = false;\n            const timeout = setTimeout(() => {\n                tracer.trace(`Timeout reached, emitting Transport event \"unresponsive\"`, {\n                    unresponsiveTimeout: this.unresponsiveTimeout,\n                });\n                unresponsiveReached = true;\n                this.emit(\"unresponsive\");\n            }, this.unresponsiveTimeout);\n            try {\n                const res = yield f();\n                if (unresponsiveReached) {\n                    tracer.trace(\"Device was unresponsive, emitting responsive\");\n                    this.emit(\"responsive\");\n                }\n                return res;\n            }\n            finally {\n                tracer.trace(\"Finalize, clearing busy guard\");\n                clearTimeout(timeout);\n                if (resolveBusy)\n                    resolveBusy();\n                this.exchangeBusyPromise = null;\n            }\n        });\n    }\n    decorateAppAPIMethods(self, methods, scrambleKey) {\n        for (const methodName of methods) {\n            self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n        }\n    }\n    decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n        return (...args) => __awaiter(this, void 0, void 0, function* () {\n            const { _appAPIlock } = this;\n            if (_appAPIlock) {\n                return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n            }\n            try {\n                this._appAPIlock = methodName;\n                this.setScrambleKey(scrambleKey);\n                return yield f.apply(ctx, args);\n            }\n            finally {\n                this._appAPIlock = null;\n            }\n        });\n    }\n    /**\n     * Sets the context used by the logging/tracing mechanism\n     *\n     * Useful when re-using (cached) the same Transport instance,\n     * but with a new tracing context.\n     *\n     * @param context A TraceContext, that can undefined to reset the context\n     */\n    setTraceContext(context) {\n        this.tracer = this.tracer.withContext(context);\n    }\n    /**\n     * Updates the context used by the logging/tracing mechanism\n     *\n     * The update only overrides the key-value that are already defined in the current context.\n     *\n     * @param contextToAdd A TraceContext that will be added to the current context\n     */\n    updateTraceContext(contextToAdd) {\n        this.tracer.updateContext(contextToAdd);\n    }\n    /**\n     * Gets the tracing context of the transport instance\n     */\n    getTraceContext() {\n        return this.tracer.getContext();\n    }\n}\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\nexport default Transport;\n//# sourceMappingURL=Transport.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.minimumDelay = exports.delay = void 0;\nfunction delay(ms) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    });\n}\nexports.delay = delay;\nfunction minimumDelay(ms, src) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let start = Date.now();\n        let r = yield src;\n        let d = ms - (Date.now() - start);\n        if (d > 0) {\n            yield delay(d);\n        }\n        return r;\n    });\n}\nexports.minimumDelay = minimumDelay;\n//# sourceMappingURL=delay.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asyncTimeout = void 0;\nfunction asyncTimeout(src, timeout) {\n    return new Promise((resolve, reject) => {\n        // Callbacks\n        let timer = null;\n        function abort(err) {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            reject(err);\n        }\n        function complete(value) {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve(value);\n        }\n        // Timeout\n        timer = setTimeout(() => {\n            abort(new Error('Request timeout'));\n        }, timeout);\n        // Source\n        src.then(complete);\n        src.catch(abort);\n    });\n}\nexports.asyncTimeout = asyncTimeout;\n//# sourceMappingURL=asyncTimeout.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeCellInline = exports.writeCellRef = exports.writeAddress = exports.writeUint8 = exports.writeVarUInt = exports.writeUint64 = exports.writeUint48 = exports.writeUint16 = exports.writeUint32 = void 0;\nconst core_1 = require(\"@ton/core\");\nfunction writeUint32(value) {\n    let b = Buffer.alloc(4);\n    b.writeUint32BE(value, 0);\n    return b;\n}\nexports.writeUint32 = writeUint32;\nfunction writeUint16(value) {\n    let b = Buffer.alloc(2);\n    b.writeUint16BE(value, 0);\n    return b;\n}\nexports.writeUint16 = writeUint16;\nfunction writeUint48(value) {\n    let b = Buffer.alloc(6);\n    b.writeUint16BE(value >> 32, 0);\n    b.writeUint32BE(value & ((1 << 32) - 1), 2);\n    return b;\n}\nexports.writeUint48 = writeUint48;\nfunction writeUint64(value) {\n    return (0, core_1.beginCell)().storeUint(value, 64).endCell().beginParse().loadBuffer(8);\n}\nexports.writeUint64 = writeUint64;\nfunction writeVarUInt(value) {\n    const sizeBytes = value === 0n ? 0 : Math.ceil((value.toString(2).length) / 8);\n    return (0, core_1.beginCell)().storeUint(sizeBytes, 8).storeUint(value, sizeBytes * 8).endCell().beginParse().loadBuffer(1 + sizeBytes);\n}\nexports.writeVarUInt = writeVarUInt;\nfunction writeUint8(value) {\n    let b = Buffer.alloc(1);\n    b[0] = value;\n    return b;\n}\nexports.writeUint8 = writeUint8;\nfunction writeAddress(address) {\n    return Buffer.concat([\n        writeUint8(address.workChain === -1 ? 0xff : address.workChain),\n        address.hash\n    ]);\n}\nexports.writeAddress = writeAddress;\nfunction writeCellRef(ref) {\n    return Buffer.concat([\n        writeUint16(ref.depth()),\n        ref.hash()\n    ]);\n}\nexports.writeCellRef = writeCellRef;\nfunction writeCellInline(bytes) {\n    return Buffer.concat([\n        writeUint8(bytes.length),\n        bytes,\n    ]);\n}\nexports.writeCellInline = writeCellInline;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InvalidateSync = void 0;\nconst backoff_1 = require(\"../timer/backoff\");\nclass InvalidateSync {\n    constructor(command, opts) {\n        this._invalidated = false;\n        this._invalidatedDouble = false;\n        this._stopped = false;\n        this._doSync = () => __awaiter(this, void 0, void 0, function* () {\n            yield this._backoff(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._stopped) {\n                    return;\n                }\n                yield this._command();\n            }));\n            if (this._stopped) {\n                return;\n            }\n            if (this._invalidatedDouble) {\n                this._invalidatedDouble = false;\n                this._doSync();\n            }\n            else {\n                this._invalidated = false;\n            }\n        });\n        this._backoff = opts && opts.backoff ? opts.backoff : (0, backoff_1.createBackoff)();\n        this._command = command;\n    }\n    invalidate() {\n        if (this._stopped) {\n            return;\n        }\n        if (!this._invalidated) {\n            this._invalidated = true;\n            this._invalidatedDouble = false;\n            this._doSync();\n        }\n        if (!this._invalidatedDouble) {\n            this._invalidatedDouble = true;\n        }\n    }\n    stop() {\n        if (this._stopped) {\n            return;\n        }\n        this._stopped = true;\n    }\n}\nexports.InvalidateSync = InvalidateSync;\n//# sourceMappingURL=InvalidateSync.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.asyncTimeout = exports.minimumDelay = exports.delay = exports.exponentialBackoffDelay = exports.createBackoff = exports.BoundedConcurrencyPool = exports.UnboundedConcurrencyPool = exports.Queue = exports.SyncValue = exports.InvalidateSync = exports.AsyncLock = exports.createAsyncIterator = void 0;\nvar createAsyncIterator_1 = require(\"./iterator/createAsyncIterator\");\nObject.defineProperty(exports, \"createAsyncIterator\", { enumerable: true, get: function () { return createAsyncIterator_1.createAsyncIterator; } });\nvar AsyncLock_1 = require(\"./sync/AsyncLock\");\nObject.defineProperty(exports, \"AsyncLock\", { enumerable: true, get: function () { return AsyncLock_1.AsyncLock; } });\nvar InvalidateSync_1 = require(\"./sync/InvalidateSync\");\nObject.defineProperty(exports, \"InvalidateSync\", { enumerable: true, get: function () { return InvalidateSync_1.InvalidateSync; } });\nvar SyncValue_1 = require(\"./sync/SyncValue\");\nObject.defineProperty(exports, \"SyncValue\", { enumerable: true, get: function () { return SyncValue_1.SyncValue; } });\nvar Queue_1 = require(\"./sync/Queue\");\nObject.defineProperty(exports, \"Queue\", { enumerable: true, get: function () { return Queue_1.Queue; } });\nvar ConcurrencyPool_1 = require(\"./sync/ConcurrencyPool\");\nObject.defineProperty(exports, \"UnboundedConcurrencyPool\", { enumerable: true, get: function () { return ConcurrencyPool_1.UnboundedConcurrencyPool; } });\nObject.defineProperty(exports, \"BoundedConcurrencyPool\", { enumerable: true, get: function () { return ConcurrencyPool_1.BoundedConcurrencyPool; } });\nvar backoff_1 = require(\"./timer/backoff\");\nObject.defineProperty(exports, \"createBackoff\", { enumerable: true, get: function () { return backoff_1.createBackoff; } });\nObject.defineProperty(exports, \"exponentialBackoffDelay\", { enumerable: true, get: function () { return backoff_1.exponentialBackoffDelay; } });\nvar delay_1 = require(\"./timer/delay\");\nObject.defineProperty(exports, \"delay\", { enumerable: true, get: function () { return delay_1.delay; } });\nObject.defineProperty(exports, \"minimumDelay\", { enumerable: true, get: function () { return delay_1.minimumDelay; } });\nvar asyncTimeout_1 = require(\"./timer/asyncTimeout\");\nObject.defineProperty(exports, \"asyncTimeout\", { enumerable: true, get: function () { return asyncTimeout_1.asyncTimeout; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Queue = void 0;\nclass Queue {\n    constructor() {\n        this.q = [];\n        this.awaiters = [];\n        this.push = (item) => {\n            // If queue is not empty\n            if (this.q.length > 0) {\n                this.q.push(item);\n                return;\n            }\n            // If queue is empty and there are awaiters\n            if (this.awaiters.length > 0) {\n                this.awaiters.shift()(item);\n                return;\n            }\n            // No awaiters and not empty queue\n            this.q.push(item);\n        };\n        this.get = () => __awaiter(this, void 0, void 0, function* () {\n            if (this.q.length > 0) {\n                return this.q.shift();\n            }\n            return yield new Promise((resolver) => this.awaiters.push(resolver));\n        });\n        this.getOptional = () => {\n            if (this.q.length > 0) {\n                return this.q.shift();\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    get isEmpty() {\n        return this.q.length === 0;\n    }\n}\nexports.Queue = Queue;\n//# sourceMappingURL=Queue.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncLock = void 0;\nclass AsyncLock {\n    constructor() {\n        this.permits = 1;\n        this.promiseResolverQueue = [];\n    }\n    inLock(func) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.lock();\n                return yield func();\n            }\n            finally {\n                this.unlock();\n            }\n        });\n    }\n    lock() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.permits > 0) {\n                this.permits = this.permits - 1;\n                return;\n            }\n            yield new Promise(resolve => this.promiseResolverQueue.push(resolve));\n        });\n    }\n    unlock() {\n        this.permits += 1;\n        if (this.permits > 1 && this.promiseResolverQueue.length > 0) {\n            throw new Error('this.permits should never be > 0 when there is someone waiting.');\n        }\n        else if (this.permits === 1 && this.promiseResolverQueue.length > 0) {\n            // If there is someone else waiting, immediately consume the permit that was released\n            // at the beginning of this function and let the waiting function resume.\n            this.permits -= 1;\n            const nextResolver = this.promiseResolverQueue.shift();\n            // Resolve on the next tick\n            if (nextResolver) {\n                setTimeout(() => {\n                    nextResolver(true);\n                }, 0);\n            }\n        }\n    }\n}\nexports.AsyncLock = AsyncLock;\n//# sourceMappingURL=AsyncLock.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInit = void 0;\nconst core_1 = require(\"@ton/core\");\nfunction getInit(publicKey, subwalletId, isV3R2) {\n    let data = (0, core_1.beginCell)()\n        .storeUint(0, 32) // Seqno\n        .storeUint(subwalletId, 32)\n        .storeBuffer(publicKey);\n    return {\n        code: isV3R2 ? core_1.Cell.fromBase64('te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=') : core_1.Cell.fromBase64('te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA=='),\n        data: isV3R2 ? data.endCell() : data.storeBit(0).endCell(),\n    };\n}\nexports.getInit = getInit;\n","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncValue = void 0;\nconst InvalidateSync_1 = require(\"./InvalidateSync\");\nclass SyncValue {\n    constructor(initial, updater, opts) {\n        this._value = initial;\n        this._updater = updater;\n        this._sync = new InvalidateSync_1.InvalidateSync(() => __awaiter(this, void 0, void 0, function* () {\n            yield this._updater(this._value);\n        }), opts);\n    }\n    get value() {\n        return this._value;\n    }\n    set value(v) {\n        if (!Object.is(v, this._value)) {\n            this._value = v;\n            this._sync.invalidate();\n        }\n    }\n}\nexports.SyncValue = SyncValue;\n//# sourceMappingURL=SyncValue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createAsyncIterator = void 0;\nfunction createAsyncIterator(onExit) {\n    let events = [];\n    let resolvers = [];\n    const getValue = () => {\n        return new Promise((resolve => {\n            if (events.length > 0) {\n                let val = events.shift();\n                if (val === null) {\n                    resolve({ value: undefined, done: true });\n                }\n                else {\n                    resolve({ value: val, done: false });\n                }\n            }\n            else {\n                resolvers.push(resolve);\n            }\n        }));\n    };\n    let onReturn = () => {\n        events = [];\n        resolvers = [];\n        onExit();\n        return Promise.resolve({ value: undefined, done: true });\n    };\n    return {\n        [Symbol.asyncIterator]() {\n            return {\n                next() {\n                    return getValue();\n                },\n                return: onReturn,\n                throw(error) {\n                    return Promise.reject(error);\n                }\n            };\n        },\n        push(data) {\n            if (resolvers.length > 0) {\n                resolvers.shift()({\n                    value: data,\n                    done: false\n                });\n            }\n            else {\n                events.push(data);\n            }\n        },\n        complete() {\n            if (resolvers.length > 0) {\n                resolvers.shift()({\n                    value: null,\n                    done: true\n                });\n            }\n            else {\n                events.push(null);\n            }\n        }\n    };\n}\nexports.createAsyncIterator = createAsyncIterator;\n//# sourceMappingURL=createAsyncIterator.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _BoundedConcurrencyPool_inFlight;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BoundedConcurrencyPool = exports.UnboundedConcurrencyPool = void 0;\nexports.UnboundedConcurrencyPool = {\n    run: (src) => {\n        return src();\n    }\n};\nclass BoundedConcurrencyPool {\n    constructor(concurrencyFactor) {\n        this.pending = [];\n        _BoundedConcurrencyPool_inFlight.set(this, 0);\n        if (typeof concurrencyFactor === 'number') {\n            this.concurrencyFactor = () => concurrencyFactor;\n        }\n        else {\n            this.concurrencyFactor = concurrencyFactor;\n        }\n    }\n    run(src) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (__classPrivateFieldGet(this, _BoundedConcurrencyPool_inFlight, \"f\") >= this.concurrencyFactor()) {\n                yield new Promise((resolve) => this.pending.push(resolve));\n            }\n            __classPrivateFieldSet(this, _BoundedConcurrencyPool_inFlight, (_a = __classPrivateFieldGet(this, _BoundedConcurrencyPool_inFlight, \"f\"), _a++, _a), \"f\");\n            try {\n                let res = yield src();\n                return res;\n            }\n            finally {\n                __classPrivateFieldSet(this, _BoundedConcurrencyPool_inFlight, (_b = __classPrivateFieldGet(this, _BoundedConcurrencyPool_inFlight, \"f\"), _b--, _b), \"f\");\n                if (this.pending.length > 0) {\n                    let p = this.pending[0];\n                    this.pending.shift();\n                    p();\n                }\n            }\n        });\n    }\n    get inFlight() {\n        return __classPrivateFieldGet(this, _BoundedConcurrencyPool_inFlight, \"f\");\n    }\n    get inQueue() {\n        return this.pending.length;\n    }\n}\nexports.BoundedConcurrencyPool = BoundedConcurrencyPool;\n_BoundedConcurrencyPool_inFlight = new WeakMap();\n//# sourceMappingURL=ConcurrencyPool.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TonTransport = exports.parseMessage = exports.KNOWN_JETTONS = void 0;\nconst core_1 = require(\"@ton/core\");\nconst crypto_1 = require(\"@ton/crypto\");\nconst teslabot_1 = require(\"teslabot\");\nconst ledgerWriter_1 = require(\"./utils/ledgerWriter\");\nconst getInit_1 = require(\"./utils/getInit\");\nconst LEDGER_SYSTEM = 0xB0;\nconst LEDGER_CLA = 0xe0;\nconst INS_VERSION = 0x03;\nconst INS_ADDRESS = 0x05;\nconst INS_SIGN_TX = 0x06;\nconst INS_PROOF = 0x08;\nconst INS_SIGN_DATA = 0x09;\nconst INS_SETTINGS = 0x0A;\nconst DEFAULT_SUBWALLET_ID = 698983191;\nexports.KNOWN_JETTONS = [\n    {\n        symbol: 'USDT',\n        masterAddress: core_1.Address.parse('EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs'),\n    },\n    {\n        symbol: 'NOT',\n        masterAddress: core_1.Address.parse('EQAvlWFDxGF2lXm67y4yzC17wYKD9A0guwPkMs1gOsM__NOT'),\n    },\n    {\n        symbol: 'tsTON',\n        masterAddress: core_1.Address.parse('EQC98_qAmNEptUtPc7W6xdHh_ZHrBUFpw5Ft_IzNU20QAJav'),\n    },\n    {\n        symbol: 'wsTON',\n        masterAddress: core_1.Address.parse('EQB0SoxuGDx5qjVt0P_bPICFeWdFLBmVopHhjgfs0q-wsTON'),\n    },\n    {\n        symbol: 'hTON',\n        masterAddress: core_1.Address.parse('EQDPdq8xjAhytYqfGSX8KcFWIReCufsB9Wdg0pLlYSO_h76w'),\n    },\n    {\n        symbol: 'stTON',\n        masterAddress: core_1.Address.parse('EQDNhy-nxYFgUqzfUzImBEP67JqsyMIcyk2S5_RwNNEYku0k'),\n    },\n    {\n        symbol: 'STAKED',\n        masterAddress: core_1.Address.parse('EQCqC6EhRJ_tpWngKxL6dV0k6DSnRUrs9GSVkLbfdCqsj6TE'),\n    },\n];\nconst dnsWalletKey = Buffer.from([0xe8, 0xd4, 0x40, 0x50, 0x87, 0x3d, 0xba, 0x86, 0x5a, 0xa7, 0xc1, 0x70, 0xab, 0x4c, 0xce, 0x64,\n    0xd9, 0x08, 0x39, 0xa3, 0x4d, 0xcf, 0xd6, 0xcf, 0x71, 0xd1, 0x4e, 0x02, 0x05, 0x44, 0x3b, 0x1b]);\nfunction normalizeQueryId(qid) {\n    return qid === 0n ? null : qid;\n}\nfunction parseMessage(cell, opts) {\n    const params = {\n        disallowUnsafe: false,\n        disallowModification: false,\n        encodeJettonBurnEthAddressAsHex: true,\n        ...opts,\n    };\n    if (cell.hash().equals(new core_1.Cell().hash())) {\n        return undefined;\n    }\n    let s = cell.beginParse();\n    try {\n        const op = s.loadUint(32);\n        switch (op) {\n            case 0: {\n                const str = s.loadStringTail();\n                s.endParse();\n                if (str.length > 120) {\n                    throw new Error('Comment must be at most 120 ASCII characters long');\n                }\n                for (const c of str) {\n                    if (c.charCodeAt(0) < 0x20 || c.charCodeAt(0) >= 0x7f) {\n                        throw new Error('Comment must only contain printable ASCII characters');\n                    }\n                }\n                return {\n                    type: 'comment',\n                    text: str,\n                };\n            }\n            case 0x0f8a7ea5: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const amount = s.loadCoins();\n                const destination = s.loadAddress();\n                const responseDestination = s.loadAddress();\n                const customPayload = s.loadMaybeRef();\n                const forwardAmount = s.loadCoins();\n                let forwardPayload = null;\n                if (s.loadBit()) {\n                    forwardPayload = s.loadRef();\n                }\n                else {\n                    const p = s.asCell();\n                    s = new core_1.Cell().beginParse(); // clear the slice\n                    if (!p.hash().equals(new core_1.Cell().hash())) {\n                        if (params.disallowModification) {\n                            throw new Error('Jetton transfer message would be modified');\n                        }\n                        forwardPayload = p;\n                    }\n                }\n                s.endParse();\n                return {\n                    type: 'jetton-transfer',\n                    queryId,\n                    amount,\n                    destination,\n                    responseDestination,\n                    customPayload,\n                    forwardAmount,\n                    forwardPayload,\n                    knownJetton: null,\n                };\n            }\n            case 0x5fcc3d14: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const newOwner = s.loadAddress();\n                const responseDestination = s.loadAddress();\n                const customPayload = s.loadMaybeRef();\n                const forwardAmount = s.loadCoins();\n                let forwardPayload = null;\n                if (s.loadBit()) {\n                    forwardPayload = s.loadRef();\n                }\n                else {\n                    const p = s.asCell();\n                    s = new core_1.Cell().beginParse(); // clear the slice\n                    if (!p.hash().equals(new core_1.Cell().hash())) {\n                        if (params.disallowModification) {\n                            throw new Error('Jetton transfer message would be modified');\n                        }\n                        forwardPayload = p;\n                    }\n                }\n                s.endParse();\n                return {\n                    type: 'nft-transfer',\n                    queryId,\n                    newOwner,\n                    responseDestination,\n                    customPayload,\n                    forwardAmount,\n                    forwardPayload,\n                };\n            }\n            case 0x595f07bc: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const amount = s.loadCoins();\n                const responseDestination = s.loadAddress();\n                let customPayload = s.loadMaybeRef();\n                s.endParse();\n                if (params.encodeJettonBurnEthAddressAsHex && customPayload !== null && customPayload.bits.length === 160 && customPayload.refs.length === 0) {\n                    const cs = customPayload.beginParse();\n                    customPayload = cs.loadBuffer(20);\n                    cs.endParse();\n                }\n                return {\n                    type: 'jetton-burn',\n                    queryId,\n                    amount,\n                    responseDestination,\n                    customPayload,\n                };\n            }\n            case 0x7258a69b: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const address = s.loadAddress();\n                s.endParse();\n                return {\n                    type: 'add-whitelist',\n                    queryId,\n                    address,\n                };\n            }\n            case 0x1000: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const amount = s.loadCoins();\n                s.endParse();\n                return {\n                    type: 'single-nominator-withdraw',\n                    queryId,\n                    amount,\n                };\n            }\n            case 0x1001: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const address = s.loadAddress();\n                s.endParse();\n                return {\n                    type: 'single-nominator-change-validator',\n                    queryId,\n                    address,\n                };\n            }\n            case 0x47d54391: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                let appId = null;\n                if (s.remainingBits > 0) {\n                    appId = s.loadUintBig(64);\n                }\n                s.endParse();\n                return {\n                    type: 'tonstakers-deposit',\n                    queryId,\n                    appId,\n                };\n            }\n            case 0x69fb306c: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const votingAddress = s.loadAddress();\n                const expirationDate = s.loadUint(48);\n                const vote = s.loadBit();\n                const needConfirmation = s.loadBit();\n                s.endParse();\n                return {\n                    type: 'vote-for-proposal',\n                    queryId,\n                    votingAddress,\n                    expirationDate,\n                    vote,\n                    needConfirmation,\n                };\n            }\n            case 0x4eb1f0f9: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const key = s.loadBuffer(32);\n                if (key.equals(dnsWalletKey)) {\n                    if (s.remainingRefs > 0) {\n                        const vs = s.loadRef().beginParse();\n                        if (s.remainingBits > 0 && !params.disallowModification) {\n                            // tolerate the Maybe bit\n                            if (!s.loadBit())\n                                throw new Error('Incorrect change DNS record message');\n                        }\n                        s.endParse();\n                        const type = vs.loadUint(16);\n                        if (type !== 0x9fd3) {\n                            throw new Error('Wrong DNS record type');\n                        }\n                        const address = vs.loadAddress();\n                        const flags = vs.loadUint(8);\n                        if (flags > 1) {\n                            throw new Error('DNS wallet record must have flags 0 or 1');\n                        }\n                        let capabilities = (flags & 1) > 0 ? { isWallet: false } : null;\n                        if (capabilities !== null) {\n                            while (vs.loadBit()) {\n                                const cap = vs.loadUint(16);\n                                if (cap === 0x2177) {\n                                    if (capabilities.isWallet && params.disallowModification) {\n                                        throw new Error('DNS change record message would be modified');\n                                    }\n                                    capabilities.isWallet = true;\n                                }\n                                else {\n                                    throw new Error('Unknown DNS wallet record capability');\n                                }\n                            }\n                        }\n                        return {\n                            type: 'change-dns-record',\n                            queryId,\n                            record: {\n                                type: 'wallet',\n                                value: {\n                                    address,\n                                    capabilities,\n                                },\n                            },\n                        };\n                    }\n                    else {\n                        if (s.remainingBits > 0 && !params.disallowModification) {\n                            // tolerate the Maybe bit\n                            if (s.loadBit())\n                                throw new Error('Incorrect change DNS record message');\n                        }\n                        s.endParse();\n                        return {\n                            type: 'change-dns-record',\n                            queryId,\n                            record: {\n                                type: 'wallet',\n                                value: null,\n                            },\n                        };\n                    }\n                }\n                else {\n                    if (s.remainingRefs > 0) {\n                        const value = s.loadRef();\n                        if (s.remainingBits > 0 && !params.disallowModification) {\n                            // tolerate the Maybe bit\n                            if (!s.loadBit())\n                                throw new Error('Incorrect change DNS record message');\n                        }\n                        s.endParse();\n                        return {\n                            type: 'change-dns-record',\n                            queryId,\n                            record: {\n                                type: 'unknown',\n                                key,\n                                value,\n                            },\n                        };\n                    }\n                    else {\n                        if (s.remainingBits > 0 && !params.disallowModification) {\n                            // tolerate the Maybe bit\n                            if (s.loadBit())\n                                throw new Error('Incorrect change DNS record message');\n                        }\n                        s.endParse();\n                        return {\n                            type: 'change-dns-record',\n                            queryId,\n                            record: {\n                                type: 'unknown',\n                                key,\n                                value: null,\n                            },\n                        };\n                    }\n                }\n            }\n            case 0x8: {\n                const queryId = normalizeQueryId(s.loadUintBig(64));\n                const swapId = s.loadBuffer(32);\n                s.endParse();\n                return {\n                    type: 'token-bridge-pay-swap',\n                    queryId,\n                    swapId,\n                };\n            }\n        }\n        throw new Error('Unknown op: ' + op);\n    }\n    catch (e) {\n        if (params.disallowUnsafe) {\n            throw e;\n        }\n    }\n    return {\n        type: 'unsafe',\n        message: cell,\n    };\n}\nexports.parseMessage = parseMessage;\nfunction chunks(buf, n) {\n    const nc = Math.ceil(buf.length / n);\n    const cs = [];\n    for (let i = 0; i < nc; i++) {\n        cs.push(buf.subarray(i * n, (i + 1) * n));\n    }\n    return cs;\n}\nfunction processAddressFlags(opts) {\n    const bounceable = opts?.bounceable ?? true;\n    const testOnly = opts?.testOnly ?? false;\n    const chain = opts?.chain ?? 0;\n    const subwalletId = opts?.subwalletId ?? 698983191;\n    const walletVersion = opts?.walletVersion ?? 'v4';\n    let specifiers = undefined;\n    let flags = 0x00;\n    if (testOnly) {\n        flags |= 0x01;\n    }\n    if (chain === -1) {\n        flags |= 0x02;\n    }\n    if (subwalletId !== 698983191 || walletVersion !== 'v4') {\n        flags |= 0x04;\n        specifiers = {\n            subwalletId,\n            isV3R2: walletVersion === 'v3r2',\n        };\n    }\n    return { bounceable, testOnly, chain, flags, specifiers };\n}\nfunction convertPayload(input) {\n    let payload = null;\n    let hints = Buffer.concat([(0, ledgerWriter_1.writeUint8)(0)]);\n    if (input === undefined) {\n        return {\n            payload,\n            hints,\n        };\n    }\n    switch (input.type) {\n        case 'unsafe': {\n            payload = input.message;\n            break;\n        }\n        case 'comment': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x00),\n                (0, ledgerWriter_1.writeUint16)(Buffer.from(input.text).length),\n                Buffer.from(input.text)\n            ]);\n            payload = (0, core_1.beginCell)()\n                .storeUint(0, 32)\n                .storeBuffer(Buffer.from(input.text))\n                .endCell();\n            break;\n        }\n        case 'jetton-transfer':\n        case 'nft-transfer': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(input.type === 'jetton-transfer' ? 0x01 : 0x02)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(input.type === 'jetton-transfer' ? 0x0f8a7ea5 : 0x5fcc3d14, 32);\n            let d = Buffer.alloc(0);\n            let flags = 0;\n            if (input.queryId !== null) {\n                flags |= 1;\n            }\n            if (input.type === 'jetton-transfer' && input.knownJetton !== null) {\n                flags |= 2;\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(flags)]);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                b = b.storeUint(0, 64);\n            }\n            if (input.type === 'jetton-transfer') {\n                if (input.knownJetton !== null) {\n                    d = Buffer.concat([d, (0, ledgerWriter_1.writeUint16)(input.knownJetton.jettonId), (0, ledgerWriter_1.writeUint8)(input.knownJetton.workchain)]);\n                }\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeVarUInt)(input.amount)]);\n                b = b.storeCoins(input.amount);\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.destination)]);\n                b = b.storeAddress(input.destination);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.newOwner)]);\n                b = b.storeAddress(input.newOwner);\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.responseDestination)]);\n            b = b.storeAddress(input.responseDestination);\n            if (input.customPayload !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeCellRef)(input.customPayload)]);\n                b = b.storeMaybeRef(input.customPayload);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeMaybeRef(input.customPayload);\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeVarUInt)(input.forwardAmount)]);\n            b = b.storeCoins(input.forwardAmount);\n            if (input.forwardPayload !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeCellRef)(input.forwardPayload)]);\n                b = b.storeMaybeRef(input.forwardPayload);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeMaybeRef(input.forwardPayload);\n            }\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'jetton-burn': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x03)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(0x595f07bc, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeVarUInt)(input.amount)]);\n            b = b.storeCoins(input.amount);\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.responseDestination)]);\n            b = b.storeAddress(input.responseDestination);\n            if (input.customPayload === null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeMaybeRef(input.customPayload);\n            }\n            else if (input.customPayload instanceof core_1.Cell) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeCellRef)(input.customPayload)]);\n                b = b.storeMaybeRef(input.customPayload);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(2), (0, ledgerWriter_1.writeCellInline)(input.customPayload)]);\n                b = b.storeMaybeRef((0, core_1.beginCell)().storeBuffer(input.customPayload).endCell());\n            }\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'add-whitelist':\n        case 'single-nominator-change-validator': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(input.type === 'add-whitelist' ? 0x04 : 0x06)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(input.type === 'add-whitelist' ? 0x7258a69b : 0x1001, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.address)]);\n            b = b.storeAddress(input.address);\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'single-nominator-withdraw': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x05)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(0x1000, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeVarUInt)(input.amount)]);\n            b = b.storeCoins(input.amount);\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'tonstakers-deposit': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x07)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(0x47d54391, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            if (input.appId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.appId)]);\n                b = b.storeUint(input.appId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n            }\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'vote-for-proposal': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x08)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(0x69fb306c, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.votingAddress)]);\n            b = b.storeAddress(input.votingAddress);\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeUint48)(input.expirationDate)]);\n            b = b.storeUint(input.expirationDate, 48);\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(input.vote ? 1 : 0), (0, ledgerWriter_1.writeUint8)(input.needConfirmation ? 1 : 0)]);\n            b = b.storeBit(input.vote).storeBit(input.needConfirmation);\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'change-dns-record': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x09)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(0x4eb1f0f9, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            if (input.record.type === 'unknown' && input.record.key.length !== 32) {\n                throw new Error('DNS record key length must be 32 bytes long');\n            }\n            b = b.storeBuffer(input.record.type === 'wallet' ? (0, crypto_1.sha256_sync)('wallet') : input.record.key);\n            d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(input.record.value === null ? 0 : 1), (0, ledgerWriter_1.writeUint8)(input.record.type === 'wallet' ? 0 : 1)]);\n            if (input.record.type === 'wallet') {\n                if (input.record.value !== null) {\n                    d = Buffer.concat([d, (0, ledgerWriter_1.writeAddress)(input.record.value.address), (0, ledgerWriter_1.writeUint8)(input.record.value.capabilities === null ? 0 : 1)]);\n                    let rb = (0, core_1.beginCell)().storeUint(0x9fd3, 16).storeAddress(input.record.value.address).storeUint(input.record.value.capabilities === null ? 0 : 1, 8);\n                    if (input.record.value.capabilities !== null) {\n                        d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(input.record.value.capabilities.isWallet ? 1 : 0)]);\n                        if (input.record.value.capabilities.isWallet) {\n                            rb = rb.storeBit(true).storeUint(0x2177, 16);\n                        }\n                        rb = rb.storeBit(false);\n                    }\n                    b = b.storeRef(rb);\n                }\n            }\n            else {\n                d = Buffer.concat([d, input.record.key]);\n                if (input.record.value !== null) {\n                    d = Buffer.concat([d, (0, ledgerWriter_1.writeCellRef)(input.record.value)]);\n                    b = b.storeRef(input.record.value);\n                }\n            }\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        case 'token-bridge-pay-swap': {\n            hints = Buffer.concat([\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint32)(0x0A)\n            ]);\n            let b = (0, core_1.beginCell)()\n                .storeUint(8, 32);\n            let d = Buffer.alloc(0);\n            if (input.queryId !== null) {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint64)(input.queryId)]);\n                b = b.storeUint(input.queryId, 64);\n            }\n            else {\n                d = Buffer.concat([d, (0, ledgerWriter_1.writeUint8)(0)]);\n                b = b.storeUint(0, 64);\n            }\n            if (input.swapId.length !== 32) {\n                throw new Error('Token bridge swap ID must be 32 bytes long');\n            }\n            d = Buffer.concat([d, input.swapId]);\n            b = b.storeBuffer(input.swapId);\n            payload = b.endCell();\n            hints = Buffer.concat([\n                hints,\n                (0, ledgerWriter_1.writeUint16)(d.length),\n                d\n            ]);\n            break;\n        }\n        default: {\n            throw new Error('Unknown payload type: ' + input.type);\n        }\n    }\n    return {\n        payload,\n        hints,\n    };\n}\nclass TonTransport {\n    transport;\n    #lock = new teslabot_1.AsyncLock();\n    constructor(transport) {\n        this.transport = transport;\n    }\n    //\n    // Apps\n    //\n    async #getCurrentApp() {\n        return this.#lock.inLock(async () => {\n            let r = await this.transport.send(LEDGER_SYSTEM, 0x01, 0x00, 0x00, undefined, [0x9000]);\n            let data = r.slice(0, r.length - 2);\n            if (data[0] !== 0x01) {\n                throw Error('Invalid response');\n            }\n            let nameLength = data[1];\n            let name = data.slice(2, 2 + nameLength).toString();\n            let versionLength = data[2 + nameLength];\n            let version = data.slice(3 + nameLength, 3 + nameLength + versionLength).toString();\n            return { name, version };\n        });\n    }\n    async isAppOpen() {\n        return (await this.#getCurrentApp()).name === 'TON';\n    }\n    async getVersion() {\n        let loaded = await this.#doRequest(INS_VERSION, 0x00, 0x00, Buffer.alloc(0));\n        const [major, minor, patch] = loaded;\n        return `${major}.${minor}.${patch}`;\n    }\n    //\n    // Operations\n    //\n    async getAddress(path, opts) {\n        // Check path\n        validatePath(path);\n        // Resolve flags\n        const { bounceable, testOnly, chain, specifiers } = processAddressFlags(opts);\n        // Get public key\n        let response = await this.#doRequest(INS_ADDRESS, 0x00, 0x00, pathElementsToBuffer(path.map((v) => v + 0x80000000)));\n        if (response.length !== 32) {\n            throw Error('Invalid response');\n        }\n        // Contract\n        const contract = (0, getInit_1.getInit)(response, specifiers?.subwalletId ?? 698983191, specifiers?.isV3R2 ?? false);\n        const address = (0, core_1.contractAddress)(chain, contract);\n        return { address: address.toString({ bounceable, testOnly }), publicKey: response };\n    }\n    async validateAddress(path, opts) {\n        // Check path\n        validatePath(path);\n        // Resolve flags\n        const { bounceable, testOnly, chain, flags, specifiers } = processAddressFlags(opts);\n        let r = pathElementsToBuffer(path.map((v) => v + 0x80000000));\n        if (specifiers !== undefined) {\n            r = Buffer.concat([r, (0, ledgerWriter_1.writeUint8)(specifiers.isV3R2 ? 1 : 0), (0, ledgerWriter_1.writeUint32)(specifiers.subwalletId)]);\n        }\n        // Get public key\n        let response = await this.#doRequest(INS_ADDRESS, 0x01, flags, r);\n        if (response.length !== 32) {\n            throw Error('Invalid response');\n        }\n        // Contract\n        const contract = (0, getInit_1.getInit)(response, specifiers?.subwalletId ?? 698983191, specifiers?.isV3R2 ?? false);\n        const address = (0, core_1.contractAddress)(chain, contract);\n        return { address: address.toString({ bounceable, testOnly }), publicKey: response };\n    }\n    async getAddressProof(path, params, opts) {\n        // Check path\n        validatePath(path);\n        let publicKey = (await this.getAddress(path)).publicKey;\n        // Resolve flags\n        const { flags, specifiers } = processAddressFlags(opts);\n        let specifiersBuf = Buffer.alloc(0);\n        if (specifiers !== undefined) {\n            specifiersBuf = Buffer.concat([(0, ledgerWriter_1.writeUint8)(specifiers.isV3R2 ? 1 : 0), (0, ledgerWriter_1.writeUint32)(specifiers.subwalletId)]);\n        }\n        const domainBuf = Buffer.from(params.domain, 'utf-8');\n        const reqBuf = Buffer.concat([\n            pathElementsToBuffer(path.map((v) => v + 0x80000000)),\n            specifiersBuf,\n            (0, ledgerWriter_1.writeUint8)(domainBuf.length),\n            domainBuf,\n            (0, ledgerWriter_1.writeUint64)(BigInt(params.timestamp)),\n            params.payload,\n        ]);\n        // Get public key\n        let res = await this.#doRequest(INS_PROOF, 0x01, flags, reqBuf);\n        let signature = res.slice(1, 1 + 64);\n        let hash = res.slice(2 + 64, 2 + 64 + 32);\n        if (!(0, crypto_1.signVerify)(hash, signature, publicKey)) {\n            throw Error('Received signature is invalid');\n        }\n        return { signature, hash };\n    }\n    async signData(path, req, opts) {\n        validatePath(path);\n        const publicKey = (await this.getAddress(path)).publicKey;\n        const timestamp = opts?.timestamp ?? Math.floor(Date.now() / 1000);\n        let schema;\n        let data;\n        let cell;\n        switch (req.type) {\n            case 'plaintext': {\n                schema = 0x754bf91b;\n                data = Buffer.from(req.text, 'ascii');\n                cell = (0, core_1.beginCell)().storeStringTail(req.text).endCell();\n                break;\n            }\n            case 'app-data': {\n                if (req.address === undefined && req.domain === undefined) {\n                    throw new Error('At least one of `address` and `domain` must be set when using \\'app-data\\' request');\n                }\n                schema = 0x54b58535;\n                let b = (0, core_1.beginCell)();\n                let dp = [];\n                if (req.address !== undefined) {\n                    b.storeBit(1);\n                    b.storeAddress(req.address);\n                    dp.push((0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeAddress)(req.address));\n                }\n                else {\n                    b.storeBit(0);\n                    dp.push((0, ledgerWriter_1.writeUint8)(0));\n                }\n                if (req.domain !== undefined) {\n                    b.storeBit(1);\n                    let inner = (0, core_1.beginCell)();\n                    req.domain.split('.').reverse().forEach(p => {\n                        inner.storeBuffer(Buffer.from(p, 'ascii'));\n                        inner.storeUint(0, 8);\n                    });\n                    b.storeRef(inner);\n                    const db = Buffer.from(req.domain, 'ascii');\n                    dp.push((0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeUint8)(db.length), db);\n                }\n                else {\n                    b.storeBit(0);\n                    dp.push((0, ledgerWriter_1.writeUint8)(0));\n                }\n                b.storeRef(req.data);\n                dp.push((0, ledgerWriter_1.writeCellRef)(req.data));\n                if (req.ext !== undefined) {\n                    b.storeBit(1);\n                    b.storeRef(req.ext);\n                    dp.push((0, ledgerWriter_1.writeUint8)(1), (0, ledgerWriter_1.writeCellRef)(req.ext));\n                }\n                else {\n                    b.storeBit(0);\n                    dp.push((0, ledgerWriter_1.writeUint8)(0));\n                }\n                data = Buffer.concat(dp);\n                cell = b.endCell();\n                break;\n            }\n            default: {\n                throw new Error(`Sign data request type '${req.type}' not supported`);\n            }\n        }\n        const commonPart = Buffer.concat([\n            (0, ledgerWriter_1.writeUint32)(schema),\n            (0, ledgerWriter_1.writeUint64)(BigInt(timestamp)),\n        ]);\n        const pkg = Buffer.concat([\n            commonPart,\n            data,\n        ]);\n        await this.#doRequest(INS_SIGN_DATA, 0x00, 0x03, pathElementsToBuffer(path.map((v) => v + 0x80000000)));\n        const pkgCs = chunks(pkg, 255);\n        for (let i = 0; i < pkgCs.length - 1; i++) {\n            await this.#doRequest(INS_SIGN_DATA, 0x00, 0x02, pkgCs[i]);\n        }\n        const res = await this.#doRequest(INS_SIGN_DATA, 0x00, 0x00, pkgCs[pkgCs.length - 1]);\n        let signature = res.subarray(1, 1 + 64);\n        let hash = res.subarray(2 + 64, 2 + 64 + 32);\n        if (!hash.equals(cell.hash())) {\n            throw Error('Hash mismatch. Expected: ' + cell.hash().toString('hex') + ', got: ' + hash.toString('hex'));\n        }\n        if (!(0, crypto_1.signVerify)(Buffer.concat([commonPart, hash]), signature, publicKey)) {\n            throw Error('Received signature is invalid');\n        }\n        return {\n            signature,\n            cell,\n            timestamp,\n        };\n    }\n    signTransaction = async (path, transaction) => {\n        // Check path\n        validatePath(path);\n        //\n        // Fetch key\n        //\n        let publicKey = (await this.getAddress(path)).publicKey;\n        //\n        // Create package\n        //\n        let pkg = Buffer.concat([\n            (0, ledgerWriter_1.writeUint8)(transaction.walletSpecifiers === undefined ? 0 : 1), // tag\n        ]);\n        if (transaction.walletSpecifiers !== undefined) {\n            pkg = Buffer.concat([\n                pkg,\n                (0, ledgerWriter_1.writeUint32)(transaction.walletSpecifiers.subwalletId ?? DEFAULT_SUBWALLET_ID),\n                (0, ledgerWriter_1.writeUint8)(transaction.walletSpecifiers.includeWalletOp ? 1 : 0),\n            ]);\n        }\n        pkg = Buffer.concat([\n            pkg,\n            (0, ledgerWriter_1.writeUint32)(transaction.seqno),\n            (0, ledgerWriter_1.writeUint32)(transaction.timeout),\n            (0, ledgerWriter_1.writeVarUInt)(transaction.amount),\n            (0, ledgerWriter_1.writeAddress)(transaction.to),\n            (0, ledgerWriter_1.writeUint8)(transaction.bounce ? 1 : 0),\n            (0, ledgerWriter_1.writeUint8)(transaction.sendMode),\n        ]);\n        //\n        // State init\n        //\n        let stateInit = null;\n        if (transaction.stateInit) {\n            stateInit = (0, core_1.beginCell)()\n                .store((0, core_1.storeStateInit)(transaction.stateInit))\n                .endCell();\n            pkg = Buffer.concat([\n                pkg,\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint16)(stateInit.depth()),\n                stateInit.hash()\n            ]);\n        }\n        else {\n            pkg = Buffer.concat([\n                pkg,\n                (0, ledgerWriter_1.writeUint8)(0)\n            ]);\n        }\n        //\n        // Payload\n        //\n        const { payload, hints } = convertPayload(transaction.payload);\n        if (payload) {\n            pkg = Buffer.concat([\n                pkg,\n                (0, ledgerWriter_1.writeUint8)(1),\n                (0, ledgerWriter_1.writeUint16)(payload.depth()),\n                payload.hash(),\n                hints\n            ]);\n        }\n        else {\n            pkg = Buffer.concat([\n                pkg,\n                (0, ledgerWriter_1.writeUint8)(0),\n                (0, ledgerWriter_1.writeUint8)(0)\n            ]);\n        }\n        //\n        // Send package\n        //\n        await this.#doRequest(INS_SIGN_TX, 0x00, 0x03, pathElementsToBuffer(path.map((v) => v + 0x80000000)));\n        const pkgCs = chunks(pkg, 255);\n        for (let i = 0; i < pkgCs.length - 1; i++) {\n            await this.#doRequest(INS_SIGN_TX, 0x00, 0x02, pkgCs[i]);\n        }\n        let res = await this.#doRequest(INS_SIGN_TX, 0x00, 0x00, pkgCs[pkgCs.length - 1]);\n        //\n        // Parse response\n        //\n        let orderBuilder = (0, core_1.beginCell)()\n            .storeBit(0)\n            .storeBit(true)\n            .storeBit(transaction.bounce)\n            .storeBit(false)\n            .storeAddress(null)\n            .storeAddress(transaction.to)\n            .storeCoins(transaction.amount)\n            .storeBit(false)\n            .storeCoins(0)\n            .storeCoins(0)\n            .storeUint(0, 64)\n            .storeUint(0, 32);\n        // State Init\n        if (stateInit) {\n            orderBuilder = orderBuilder\n                .storeBit(true)\n                .storeBit(true) // Always in reference\n                .storeRef(stateInit);\n        }\n        else {\n            orderBuilder = orderBuilder\n                .storeBit(false);\n        }\n        // Payload\n        if (payload) {\n            orderBuilder = orderBuilder\n                .storeBit(true) // Always in reference\n                .storeRef(payload);\n        }\n        else {\n            orderBuilder = orderBuilder\n                .storeBit(false);\n        }\n        // Transfer message\n        let transferB = (0, core_1.beginCell)()\n            .storeUint(transaction.walletSpecifiers?.subwalletId ?? DEFAULT_SUBWALLET_ID, 32)\n            .storeUint(transaction.timeout, 32)\n            .storeUint(transaction.seqno, 32);\n        if (transaction.walletSpecifiers?.includeWalletOp ?? true) {\n            transferB = transferB.storeUint(0, 8);\n        }\n        let transfer = transferB.storeUint(transaction.sendMode, 8)\n            .storeRef(orderBuilder.endCell())\n            .endCell();\n        // Parse result\n        let signature = res.slice(1, 1 + 64);\n        let hash = res.slice(2 + 64, 2 + 64 + 32);\n        if (!hash.equals(transfer.hash())) {\n            throw Error('Hash mismatch. Expected: ' + transfer.hash().toString('hex') + ', got: ' + hash.toString('hex'));\n        }\n        if (!(0, crypto_1.signVerify)(hash, signature, publicKey)) {\n            throw Error('Received signature is invalid');\n        }\n        // Build a message\n        return (0, core_1.beginCell)()\n            .storeBuffer(signature)\n            .storeSlice(transfer.beginParse())\n            .endCell();\n    };\n    async getSettings() {\n        let loaded = await this.#doRequest(INS_SETTINGS, 0x00, 0x00, Buffer.alloc(0));\n        return {\n            blindSigningEnabled: (loaded[0] & 0x01) > 0,\n            expertMode: (loaded[0] & 0x02) > 0,\n        };\n    }\n    #doRequest = async (ins, p1, p2, data) => {\n        return this.#lock.inLock(async () => {\n            let r = await this.transport.send(LEDGER_CLA, ins, p1, p2, data);\n            return r.slice(0, r.length - 2);\n        });\n    };\n}\nexports.TonTransport = TonTransport;\n//\n// Utils\n//\nfunction validatePath(path) {\n    if (path.length < 6) {\n        throw Error('Path is too short');\n    }\n    if (path[0] !== 44) {\n        throw Error('First element of a path must be 44');\n    }\n    if (path[1] !== 607) {\n        throw Error('Second element of a path must be 607');\n    }\n    for (let p of path) {\n        if (p >= 0x80000000) {\n            throw Error('All path elements must be under 0x80000000');\n        }\n    }\n}\nfunction pathElementsToBuffer(paths) {\n    const buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n        buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return buffer;\n}\n"],"names":[],"sourceRoot":""}