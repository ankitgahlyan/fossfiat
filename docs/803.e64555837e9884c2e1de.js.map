{"version":3,"file":"803.e64555837e9884c2e1de.js","mappings":"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","sources":["webpack://mytonwallet/./src/util/ledger/constants.ts","webpack://mytonwallet/./src/api/errors.ts","webpack://mytonwallet/./src/util/ledger/index.ts"],"sourcesContent":["export type PossibleWalletVersion = 'v3R2' | 'v4R2';\n\nexport enum LedgerWalletVersion {\n  v3R2 = 'v3r2',\n  v4R2 = 'v4',\n}\n\nexport const INTERNAL_WORKCHAIN = 0; // workchain === -1 ? 255 : 0;\nexport const DEFAULT_WALLET_VERSION: PossibleWalletVersion = 'v4R2';\n\nexport const DEVICE_DETECT_ATTEMPTS = 3;\nexport const PAUSE = 125;\nexport const ATTEMPTS = 10;\nexport const IS_BOUNCEABLE = false;\n","import type { ApiAnyDisplayError } from './types';\nimport { ApiCommonError } from './types';\n\nexport class ApiBaseError extends Error {\n  constructor(message?: string, public displayError?: ApiAnyDisplayError) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class ApiUserRejectsError extends ApiBaseError {\n  constructor(message: string = 'Canceled by the user') {\n    super(message);\n  }\n}\n\nexport class ApiServerError extends ApiBaseError {\n  constructor(message: string, public statusCode?: number) {\n    super(message, ApiCommonError.ServerError);\n  }\n}\n\nexport class AbortOperationError extends ApiBaseError {\n  constructor(message: string = 'Abort operation') {\n    super(message);\n  }\n}\n\nexport class NotImplemented extends ApiBaseError {\n  constructor(message: string = 'Not implemented') {\n    super(message);\n  }\n}\n\nexport function maybeApiErrors(fn: AnyAsyncFunction) {\n  return async (...args: any) => {\n    try {\n      return await fn(...args);\n    } catch (err) {\n      return handleServerError(err);\n    }\n  };\n}\n\nexport function handleServerError(err: any) {\n  if (err instanceof ApiServerError) {\n    return { error: err.displayError! };\n  }\n  throw err;\n}\n","import type Transport from '@ledgerhq/hw-transport';\nimport TransportWebHID from '@ledgerhq/hw-transport-webhid';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport type { HIDTransport } from '@mytonwallet/capacitor-usb-hid';\nimport { TonTransport } from '@ton-community/ton-ledger';\nimport type { ICapacitorUSBDevice } from '@mytonwallet/capacitor-usb-hid/dist/esm/definitions';\n\nimport type { ApiNetwork } from '../../api/types';\nimport type BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\nimport type { PossibleWalletVersion } from './constants';\nimport type { LedgerTransport, LedgerWalletInfo } from './types';\n\nimport { IS_CAPACITOR } from '../../config';\nimport { callApi } from '../../api';\nimport { WALLET_IS_BOUNCEABLE } from '../../api/chains/ton/constants';\nimport { handleServerError } from '../../api/errors';\nimport { parseAccountId } from '../account';\nimport { logDebug, logDebugError } from '../logs';\nimport { pause } from '../schedulers';\nimport { IS_ANDROID_APP } from '../windowEnvironment';\nimport {\n  ATTEMPTS,\n  DEFAULT_WALLET_VERSION,\n  DEVICE_DETECT_ATTEMPTS,\n  INTERNAL_WORKCHAIN,\n  IS_BOUNCEABLE,\n  PAUSE,\n} from './constants';\nimport { LedgerWalletVersion } from './constants';\nimport { getLedgerAccountPathByIndex, getLedgerAccountPathByWallet, isLedgerConnectionBroken } from './utils';\n\ntype BleConnectorClass = typeof import('./bleConnector').BleConnector;\ntype HIDTransportClass = typeof import('@mytonwallet/capacitor-usb-hid/dist/esm').HIDTransport;\ntype ListLedgerDevicesFunction = typeof import('@mytonwallet/capacitor-usb-hid/dist/esm').listLedgerDevices;\n\nlet transport: TransportWebHID | TransportWebUSB | BleTransport | HIDTransport | undefined;\nlet tonTransport: TonTransport | undefined;\nlet transportSupport: {\n  hid: boolean;\n  webUsb: boolean;\n  bluetooth: boolean;\n} | undefined;\nlet currentLedgerTransport: LedgerTransport | undefined;\n\nlet hidImportPromise: Promise<{\n  transport: HIDTransportClass;\n  listLedgerDevices: ListLedgerDevicesFunction;\n}> | undefined;\nlet bleImportPromise: Promise<BleConnectorClass> | undefined;\nlet BleConnector: BleConnectorClass;\nlet MtwHidTransport: HIDTransportClass;\nlet listLedgerDevices: ListLedgerDevicesFunction;\n\nasync function ensureBleConnector() {\n  if (!IS_CAPACITOR) return undefined;\n\n  if (!bleImportPromise) {\n    bleImportPromise = import('./bleConnector').then((module) => {\n      return module.BleConnector;\n    });\n    BleConnector = await bleImportPromise;\n  }\n\n  return bleImportPromise;\n}\n\nasync function ensureHidTransport() {\n  if (!IS_ANDROID_APP) return undefined;\n\n  if (!hidImportPromise) {\n    hidImportPromise = import('@mytonwallet/capacitor-usb-hid/dist/esm').then((module) => {\n      return {\n        transport: module.HIDTransport,\n        listLedgerDevices: module.listLedgerDevices,\n      };\n    });\n    const result = await hidImportPromise;\n    MtwHidTransport = result.transport;\n    listLedgerDevices = result.listLedgerDevices;\n  }\n\n  return hidImportPromise;\n}\n\nvoid ensureBleConnector();\nvoid ensureHidTransport();\n\nexport async function detectAvailableTransports() {\n  await ensureBleConnector();\n  await ensureHidTransport();\n  const [hid, bluetooth, webUsb] = await Promise.all([\n    IS_ANDROID_APP ? MtwHidTransport.isSupported() : TransportWebHID.isSupported(),\n    BleConnector ? BleConnector.isSupported() : false,\n    TransportWebUSB.isSupported(),\n  ]);\n\n  logDebug('LEDGER TRANSPORTS', { hid, bluetooth, webUsb });\n\n  transportSupport = { hid, bluetooth, webUsb };\n\n  return {\n    isUsbAvailable: hid || webUsb,\n    isBluetoothAvailable: bluetooth,\n  };\n}\n\nexport async function hasUsbDevice() {\n  const support = await getTransportSupport();\n\n  if (support.hid) {\n    return IS_ANDROID_APP\n      ? await hasCapacitorHIDDevice()\n      : await hasWebHIDDevice();\n  }\n\n  if (support.webUsb) {\n    return await hasWebUsbDevice();\n  }\n\n  return false;\n}\n\nfunction getInternalWalletVersion(version: PossibleWalletVersion) {\n  return LedgerWalletVersion[version];\n}\n\nexport async function importLedgerWallet(network: ApiNetwork, accountIndex: number) {\n  const walletInfo = await getLedgerWalletInfo(network, accountIndex);\n  return callApi('importLedgerWallet', network, walletInfo);\n}\n\nexport function openSystemBluetoothSettings() {\n  if (!BleConnector) return;\n  void BleConnector.openSettings();\n}\n\nexport async function reconnectLedger() {\n  try {\n    if (await tonTransport?.isAppOpen()) {\n      return true;\n    }\n  } catch {\n    // Do nothing\n  }\n\n  const isLedgerConnected = await connectLedger();\n  if (!isLedgerConnected) return false;\n\n  try {\n    return await waitLedgerTonApp();\n  } catch (err: any) {\n    if (isLedgerConnectionBroken(err.name)) {\n      return reconnectLedger();\n    }\n\n    throw err;\n  }\n}\n\nexport async function connectLedger(preferredTransport?: LedgerTransport) {\n  const support = await getTransportSupport();\n\n  if (preferredTransport) currentLedgerTransport = preferredTransport;\n\n  try {\n    switch (currentLedgerTransport) {\n      case 'bluetooth':\n        transport = await connectBLE();\n        break;\n\n      case 'usb':\n      default:\n        if (support.hid) {\n          transport = await connectHID();\n        } else if (support.webUsb) {\n          transport = await connectWebUsb();\n        }\n        break;\n    }\n\n    if (!transport) {\n      logDebugError('connectLedger: BLE and/or HID are not supported');\n      return false;\n    }\n\n    tonTransport = new TonTransport(transport);\n    return true;\n  } catch (err) {\n    logDebugError('connectLedger', err);\n    return false;\n  }\n}\n\nasync function waitLedgerTonAppDeadline(): Promise<boolean> {\n  await pause(PAUSE * ATTEMPTS);\n  return false;\n}\n\nasync function checkTonApp() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    try {\n      const isTonOpen = await tonTransport?.isAppOpen();\n\n      if (isTonOpen) {\n        if (transport?.deviceModel?.id.startsWith('nanoS')) {\n          // Workaround for Ledger Nano S or Nano S Plus, this is a way to check if it is unlocked.\n          // There will be an error with code 0x530c.\n          await tonTransport?.getAddress(getLedgerAccountPathByIndex(0, false), {\n            walletVersion: LedgerWalletVersion[DEFAULT_WALLET_VERSION],\n          });\n        }\n\n        return true;\n      }\n    } catch (err: any) {\n      if (isLedgerConnectionBroken(err.name)) {\n        tonTransport = undefined;\n        throw err;\n      }\n      if (!err?.message.includes('0x530c')) {\n        logDebugError('waitLedgerTonApp', err);\n      }\n    }\n\n    await pause(PAUSE);\n  }\n\n  return false;\n}\n\nexport function waitLedgerTonApp() {\n  return Promise.race([\n    checkTonApp(),\n    waitLedgerTonAppDeadline(),\n  ]);\n}\n\nfunction connectHID() {\n  if (IS_ANDROID_APP) {\n    return connectCapacitorHID();\n  }\n\n  return connectWebHID();\n}\n\nasync function connectWebHID() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await TransportWebHID.list();\n\n    if (!device) {\n      await TransportWebHID.create();\n      await pause(PAUSE);\n      continue;\n    }\n\n    if (device.opened) {\n      return new TransportWebHID(device);\n    } else {\n      return TransportWebHID.open(device);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectWebUsb() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await TransportWebUSB.list();\n\n    if (!device) {\n      await TransportWebUSB.create();\n      await pause(PAUSE);\n      continue;\n    }\n\n    if (device.opened) {\n      return (await TransportWebUSB.openConnected()) ?? (await TransportWebUSB.request());\n    } else {\n      return TransportWebUSB.open(device);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectCapacitorHID(): Promise<HIDTransport> {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await listLedgerDevices();\n\n    if (!device) {\n      await pause(PAUSE);\n      continue;\n    }\n\n    try {\n      return await Promise.race([\n        MtwHidTransport.open(device),\n        new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error()), 1000);\n        }),\n      ]);\n    } catch (error) {\n      await pause(PAUSE);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectBLE(): Promise<BleTransport> {\n  if (!BleConnector) {\n    throw new Error('BLE is not supported on this device.');\n  }\n\n  const connection = await BleConnector.connect();\n  return connection.bleTransport;\n}\n\nexport async function getNextLedgerWallets(\n  network: ApiNetwork,\n  lastExistingIndex = -1,\n  alreadyImportedAddresses: string[] = [],\n) {\n  const result: LedgerWalletInfo[] = [];\n  let index = lastExistingIndex + 1;\n\n  try {\n    while (true) {\n      const walletInfo = await getLedgerWalletInfo(network, index);\n\n      if (alreadyImportedAddresses.includes(walletInfo.address)) {\n        index += 1;\n        continue;\n      }\n\n      if (walletInfo.balance !== 0n) {\n        result.push(walletInfo);\n        index += 1;\n        continue;\n      }\n\n      if (!result.length) {\n        result.push(walletInfo);\n      }\n\n      return result;\n    }\n  } catch (err) {\n    return handleServerError(err);\n  }\n}\n\nasync function getLedgerWalletInfo(network: ApiNetwork, accountIndex: number): Promise<LedgerWalletInfo> {\n  const isTestnet = network === 'testnet';\n  const { address, publicKey } = await getLedgerWalletAddress(accountIndex, isTestnet);\n  const balance = (await callApi('getWalletBalance', 'ton', network, address))!;\n\n  return {\n    index: accountIndex,\n    address,\n    publicKey: publicKey.toString('hex'),\n    balance,\n    version: DEFAULT_WALLET_VERSION,\n    driver: 'HID',\n    deviceId: transport!.deviceModel?.id,\n    deviceName: transport!.deviceModel?.productName,\n  };\n}\n\nfunction getLedgerWalletAddress(index: number, isTestnet: boolean) {\n  const path = getLedgerAccountPathByIndex(index, isTestnet);\n\n  return tonTransport!.getAddress(path, {\n    testOnly: isTestnet,\n    chain: INTERNAL_WORKCHAIN,\n    bounceable: WALLET_IS_BOUNCEABLE,\n    walletVersion: LedgerWalletVersion[DEFAULT_WALLET_VERSION],\n  });\n}\n\nexport async function verifyAddress(accountId: string) {\n  const account = await callApi('fetchLedgerAccount', accountId);\n  const path = getLedgerAccountPathByWallet(parseAccountId(accountId).network, account!.ton);\n\n  await tonTransport!.validateAddress(path, {\n    bounceable: IS_BOUNCEABLE,\n    walletVersion: getInternalWalletVersion(account!.ton.version as PossibleWalletVersion),\n  });\n}\n\nasync function tryDetectDevice(\n  listDeviceFn: () => Promise<ICapacitorUSBDevice[]>,\n  createTransportFn?: () => Promise<unknown> | void,\n) {\n  try {\n    for (let i = 0; i < DEVICE_DETECT_ATTEMPTS; i++) {\n      const [device] = await listDeviceFn();\n      if (!device) {\n        if (createTransportFn) await createTransportFn();\n        await pause(PAUSE);\n        continue;\n      }\n\n      return true;\n    }\n  } catch (err: any) {\n    logDebugError('tryDetectDevice', err);\n  }\n\n  return false;\n}\n\nfunction hasWebHIDDevice() {\n  return tryDetectDevice(() => TransportWebHID.list(), () => TransportWebHID.create());\n}\nfunction hasWebUsbDevice() {\n  return tryDetectDevice(() => TransportWebUSB.list(), () => TransportWebUSB.create());\n}\nfunction hasCapacitorHIDDevice() {\n  return tryDetectDevice(listLedgerDevices);\n}\n\nasync function getTransportSupport() {\n  // Ensure transports support is detected lazily if missing\n  if (!transportSupport) {\n    await detectAvailableTransports();\n  }\n\n  return transportSupport!;\n}\n\nexport function getTransport(): Transport | undefined {\n  return transport;\n}\n"],"names":["LedgerWalletVersion","INTERNAL_WORKCHAIN","DEFAULT_WALLET_VERSION","DEVICE_DETECT_ATTEMPTS","PAUSE","ATTEMPTS","IS_BOUNCEABLE","ApiBaseError","Error","constructor","message","displayError","super","this","name","ApiServerError","statusCode","ApiCommonError","ServerError","transport","tonTransport","transportSupport","currentLedgerTransport","hidImportPromise","bleImportPromise","BleConnector","MtwHidTransport","listLedgerDevices","async","ensureBleConnector","IS_CAPACITOR","then","module","ensureHidTransport","IS_ANDROID_APP","HIDTransport","result","detectAvailableTransports","hid","bluetooth","webUsb","Promise","all","isSupported","TransportWebHID","TransportWebUSB","logDebug","isUsbAvailable","isBluetoothAvailable","hasUsbDevice","support","getTransportSupport","tryDetectDevice","list","create","importLedgerWallet","network","accountIndex","walletInfo","getLedgerWalletInfo","callApi","openSystemBluetoothSettings","openSettings","reconnectLedger","_tonTransport","isAppOpen","connectLedger","waitLedgerTonApp","err","isLedgerConnectionBroken","preferredTransport","connect","bleTransport","connectBLE","i","device","race","open","_","reject","setTimeout","error","pause","connectCapacitorHID","opened","connectWebHID","openConnected","request","connectWebUsb","TonTransport","logDebugError","waitLedgerTonAppDeadline","checkTonApp","_tonTransport2","_transport","_tonTransport3","deviceModel","id","startsWith","getAddress","getLedgerAccountPathByIndex","walletVersion","undefined","includes","getNextLedgerWallets","alreadyImportedAddresses","arguments","length","index","address","balance","push","handleServerError","_deviceModel","_deviceModel2","isTestnet","publicKey","path","testOnly","chain","bounceable","WALLET_IS_BOUNCEABLE","getLedgerWalletAddress","toString","version","driver","deviceId","deviceName","productName","verifyAddress","accountId","account","getLedgerAccountPathByWallet","parseAccountId","ton","validateAddress","listDeviceFn","createTransportFn","getTransport"],"sourceRoot":""}